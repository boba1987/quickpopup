(function(f){typeof define==='function'&&define.amd?define(f):f();}(function(){'use strict';function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

var REGEX_LEN_VAL = /^\d+(?:[a-z]|\%)+$/i;
var REGEX_DIGITS = /\d+$/;
var REGEX_SPACE = /\s/;
var REGEX_KEBAB = /([A-Z])+/g;
var IMPORTANT = 'important';
var POSSIBLE_PREFIXES = ['webkit', 'moz', 'ms', 'o'];
var REQUIRES_UNIT_VALUE = ['background-position-x', 'background-position-y', 'block-size', 'border-width', 'columnRule-width', 'cx', 'cy', 'font-size', 'grid-column-gap', 'grid-row-gap', 'height', 'inline-size', 'line-height', 'minBlock-size', 'min-height', 'min-inline-size', 'min-width', 'max-height', 'max-width', 'outline-offset', 'outline-width', 'perspective', 'shape-margin', 'stroke-dashoffset', 'stroke-width', 'text-indent', 'width', 'word-spacing', 'top', 'bottom', 'left', 'right', 'x', 'y'];
var QUAD_SHORTHANDS = ['margin', 'padding', 'border', 'border-radius'];
var DIRECTIONS = ['top', 'bottom', 'left', 'right'];
QUAD_SHORTHANDS.forEach(function (property) {
  var direction, i, len;
  REQUIRES_UNIT_VALUE.push(property);

  for (i = 0, len = DIRECTIONS.length; i < len; i++) {
    direction = DIRECTIONS[i];
    REQUIRES_UNIT_VALUE.push(property + '-' + direction);
  }
});
var SAMPLE_STYLE, styleConfig;
SAMPLE_STYLE = document.createElement('div').style;

var includes = function includes(target, item) {
  return target && target.indexOf(item) !== -1;
};

var isIterable = function isIterable(target) {
  return target && _typeof(target) === 'object' && typeof target.length === 'number' && !target.nodeType;
};

var toKebabCase = function toKebabCase(string) {
  return string.replace(REGEX_KEBAB, function (e, letter) {
    return "-".concat(letter.toLowerCase());
  });
};

var isPropSupported = function isPropSupported(property) {
  return typeof SAMPLE_STYLE[property] !== 'undefined';
};

var isValueSupported = function isValueSupported(property, value) {
  if (window.CSS && window.CSS.supports) {
    return window.CSS.supports(property, value);
  } else {
    SAMPLE_STYLE[property] = value;
    return SAMPLE_STYLE[property] === '' + value;
  }
};

var getPrefix = function getPrefix(property, skipInitialCheck) {
  var j, len1, prefix;

  if (skipInitialCheck || !isPropSupported(property)) {
    for (j = 0, len1 = POSSIBLE_PREFIXES.length; j < len1; j++) {
      prefix = POSSIBLE_PREFIXES[j];

      if (isPropSupported("-".concat(prefix, "-").concat(property))) {
        /* istanbul ignore next */
        return "-".concat(prefix, "-");
      }
    }
  }

  return '';
};

var normalizeProperty = function normalizeProperty(property) {
  property = toKebabCase(property);

  if (isPropSupported(property)) {
    return property;
  } else {
    return "".concat(getPrefix(property, true)).concat(property);
  }
};

var normalizeValue = function normalizeValue(property, value) {
  if (includes(REQUIRES_UNIT_VALUE, property) && value !== null) {
    value = '' + value;

    if (REGEX_DIGITS.test(value) && !REGEX_LEN_VAL.test(value) && !REGEX_SPACE.test(value)) {
      value += property === 'line-height' ? 'em' : 'px';
    }
  }

  return value;
};

var sort = function sort(array) {
  var great, i, len, less, pivot;

  if (array.length < 2) {
    return array;
  } else {
    pivot = array[0];
    less = [];
    great = [];
    len = array.length;
    i = 0;

    while (++i !== len) {
      if (array[i] <= pivot) {
        less.push(array[i]);
      } else {
        great.push(array[i]);
      }
    }

    return sort(less).concat(pivot, sort(great));
  }
};

var hash = function hash(string) {
  var hsh, i, length;
  hsh = 5381;
  i = -1;
  length = string.length;

  while (++i !== string.length) {
    hsh = (hsh << 5) - hsh + string.charCodeAt(i);
    hsh |= 0;
  }

  return '_' + (hsh < 0 ? hsh * -2 : hsh);
};

var ruleToString = function ruleToString(rule, important) {
  var j, len1, output, prop, property, props, value;
  output = '';
  props = sort(Object.keys(rule));

  for (j = 0, len1 = props.length; j < len1; j++) {
    prop = props[j];

    if (typeof rule[prop] === 'string' || typeof rule[prop] === 'number') {
      property = normalizeProperty(prop);
      value = normalizeValue(property, rule[prop]);

      if (important) {
        value += " !important";
      }

      output += "".concat(property, ":").concat(value, ";");
    }
  }

  return output;
};

var inlineStyleConfig = styleConfig = Object.create(null);

var inlineStyle = function inlineStyle(rule, valueToStore, level) {
  var config, styleEl;

  if (!(config = styleConfig[level])) {
    styleEl = document.createElement('style');
    styleEl.id = "quickcss".concat(level || '');
    document.head.appendChild(styleEl);
    styleConfig[level] = config = {
      el: styleEl,
      content: '',
      cache: Object.create(null)
    };
  }

  if (!config.cache[rule]) {
    config.cache[rule] = valueToStore || true;
    config.el.textContent = config.content += rule;
  }
};

var clearInlineStyle = function clearInlineStyle(level) {
  var config, j, key, keys, len1;

  if (config = styleConfig[level]) {
    if (!config.content) {
      return;
    }

    config.el.textContent = config.content = '';
    keys = Object.keys(config.cache);

    for (j = 0, len1 = keys.length; j < len1; j++) {
      key = keys[j];
      config.cache[key] = null;
    }
  }
};

var version = "1.4.2";

var _quickcss;

var index = _quickcss = function quickcss(targetEl, property, value, important) {
  var computedStyle, i, len, subEl, subProperty, subValue;

  switch (false) {
    case !isIterable(targetEl):
      for (i = 0, len = targetEl.length; i < len; i++) {
        subEl = targetEl[i];

        _quickcss(subEl, property, value);
      }

      break;

    case _typeof(property) !== 'object':
      // Passed a style map
      for (subProperty in property) {
        subValue = property[subProperty];

        _quickcss(targetEl, subProperty, subValue);
      }

      break;

    default:
      property = normalizeProperty(property);

      if (typeof value === 'undefined') {
        computedStyle = targetEl._computedStyle || (targetEl._computedStyle = getComputedStyle(targetEl));
        return computedStyle[property];
      } else if (property) {
        targetEl.style.setProperty(property, normalizeValue(property, value), important ? IMPORTANT : void 0);
      }

  }
};

_quickcss.animation = function (name$$1, frames) {
  var frame, generated, prefix, rules;

  if (name$$1 && typeof name$$1 === 'string' && frames && _typeof(frames) === 'object') {
    prefix = getPrefix('animation');
    generated = '';

    for (frame in frames) {
      rules = frames[frame];
      generated += "".concat(frame, " {").concat(ruleToString(rules), "}");
    }

    generated = "@".concat(prefix, "keyframes ").concat(name$$1, " {").concat(generated, "}");
    return inlineStyle(generated, true, 0);
  }
};

_quickcss.register = function (rule, level, important) {
  var className, ref, style;

  if (rule && _typeof(rule) === 'object') {
    level || (level = 0);
    rule = ruleToString(rule, important);

    if (!(className = (ref = inlineStyleConfig[level]) != null ? ref[rule] : void 0)) {
      className = hash(rule);
      style = ".".concat(className, " {").concat(rule, "}");
      inlineStyle(style, className, level);
    }

    return className;
  }
};

_quickcss.clearRegistered = function (level) {
  return clearInlineStyle(level || 0);
};
/* istanbul ignore next */


_quickcss.UNSET = function () {
  switch (false) {
    case !isValueSupported('display', 'unset'):
      return 'unset';

    case !isValueSupported('display', 'initial'):
      return 'initial';

    case !isValueSupported('display', 'inherit'):
      return 'inherit';
  }
}();

_quickcss.supports = isValueSupported;
_quickcss.supportsProperty = isPropSupported;
_quickcss.normalizeProperty = normalizeProperty;
_quickcss.normalizeValue = normalizeValue;
_quickcss.version = version;

function _typeof$1(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof$1 = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof$1(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _typeof$2(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$2 = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof$2 = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof$2(obj);
}

var _extend, isArray, isObject, _shouldDeepExtend;

isArray = function isArray(target) {
  return Array.isArray(target);
};

isObject = function isObject(target) {
  return target && Object.prototype.toString.call(target) === '[object Object]' || isArray(target);
};

_shouldDeepExtend = function shouldDeepExtend(options, target, parentKey) {
  if (options.deep) {
    if (options.notDeep) {
      return !options.notDeep[target];
    } else {
      return true;
    }
  } else if (options.deepOnly) {
    return options.deepOnly[target] || parentKey && _shouldDeepExtend(options, parentKey);
  }
}; // else false


var extend = _extend = function extend(options, target, sources, parentKey) {
  var i, key, len, source, sourceValue, subTarget, targetValue;

  if (!target || _typeof$2(target) !== 'object' && typeof target !== 'function') {
    target = {};
  }

  for (i = 0, len = sources.length; i < len; i++) {
    source = sources[i];

    if (source != null) {
      for (key in source) {
        sourceValue = source[key];
        targetValue = target[key];

        if (sourceValue === target || sourceValue === void 0 || sourceValue === null && !options.allowNull && !options.nullDeletes || options.keys && !options.keys[key] || options.notKeys && options.notKeys[key] || options.own && !source.hasOwnProperty(key) || options.globalFilter && !options.globalFilter(sourceValue, key, source) || options.filters && options.filters[key] && !options.filters[key](sourceValue, key, source)) {
          continue;
        }

        if (sourceValue === null && options.nullDeletes) {
          delete target[key];
          continue;
        }

        if (options.globalTransform) {
          sourceValue = options.globalTransform(sourceValue, key, source);
        }

        if (options.transforms && options.transforms[key]) {
          sourceValue = options.transforms[key](sourceValue, key, source);
        }

        switch (false) {
          case !(options.concat && isArray(sourceValue) && isArray(targetValue)):
            target[key] = targetValue.concat(sourceValue);
            break;

          case !(_shouldDeepExtend(options, key, parentKey) && isObject(sourceValue)):
            subTarget = isObject(targetValue) ? targetValue : isArray(sourceValue) ? [] : {};
            target[key] = _extend(options, subTarget, [sourceValue], key);
            break;

          default:
            target[key] = sourceValue;
        }
      }
    }
  }

  return target;
};

var version$1 = "1.7.4";
var modifiers, newBuilder, normalizeKeys, primaryBuilder;

normalizeKeys = function normalizeKeys(keys) {
  var i, key, len, output;

  if (keys) {
    output = {};

    if (_typeof$2(keys) !== 'object') {
      output[keys] = true;
    } else {
      if (!Array.isArray(keys)) {
        keys = Object.keys(keys);
      }

      for (i = 0, len = keys.length; i < len; i++) {
        key = keys[i];
        output[key] = true;
      }
    }

    return output;
  }
};

newBuilder = function newBuilder(isBase) {
  var _builder;

  _builder = function builder(target) {
    var theTarget;
    var $_len = arguments.length,
        $_i = -1,
        sources = new Array($_len);

    while (++$_i < $_len) sources[$_i] = arguments[$_i];

    if (_builder.options.target) {
      theTarget = _builder.options.target;
    } else {
      theTarget = target;
      sources.shift();
    }

    return extend(_builder.options, theTarget, sources);
  };

  if (isBase) {
    _builder.isBase = true;
  }

  _builder.options = {};
  Object.defineProperties(_builder, modifiers);
  return _builder;
};

modifiers = {
  'deep': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      _.options.deep = true;
      return _;
    }
  },
  'own': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      _.options.own = true;
      return _;
    }
  },
  'allowNull': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      _.options.allowNull = true;
      return _;
    }
  },
  'nullDeletes': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      _.options.nullDeletes = true;
      return _;
    }
  },
  'concat': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      _.options.concat = true;
      return _;
    }
  },
  'clone': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      _.options.target = {};
      return _;
    }
  },
  'notDeep': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      return function (keys) {
        _.options.notDeep = normalizeKeys(keys);
        return _;
      };
    }
  },
  'deepOnly': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      return function (keys) {
        _.options.deepOnly = normalizeKeys(keys);
        return _;
      };
    }
  },
  'keys': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      return function (keys) {
        _.options.keys = normalizeKeys(keys);
        return _;
      };
    }
  },
  'notKeys': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      return function (keys) {
        _.options.notKeys = normalizeKeys(keys);
        return _;
      };
    }
  },
  'transform': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      return function (transform) {
        if (typeof transform === 'function') {
          _.options.globalTransform = transform;
        } else if (transform && _typeof$2(transform) === 'object') {
          _.options.transforms = transform;
        }

        return _;
      };
    }
  },
  'filter': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder() : this;
      return function (filter) {
        if (typeof filter === 'function') {
          _.options.globalFilter = filter;
        } else if (filter && _typeof$2(filter) === 'object') {
          _.options.filters = filter;
        }

        return _;
      };
    }
  }
};
primaryBuilder = newBuilder(true);
primaryBuilder.version = version$1;
var primaryBuilder$1 = primaryBuilder;
var template = ['id', 'name', 'type', 'href', 'selected', 'checked', 'className']; // To copy from DOM Elements

var element = ['id', 'ref', 'type', 'name', 'text', 'style', 'class', 'className', 'url', 'href', 'selected', 'checked', 'props', 'attrs', 'passStateToChildren', 'stateTriggers', 'unpassableStates']; // Used in QuickElement::toJSON
// 'relatedInstance'

function _typeof$3(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$3 = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof$3 = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof$3(obj);
}

function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$1(Constructor, staticProps);
  return Constructor;
}

var defined = function defined(subject) {
  return subject !== void 0;
};

var array = function array(subject) {
  return subject instanceof Array;
};

var object = function object(subject) {
  return _typeof$3(subject) === 'object' && subject; // 2nd check is to test against 'null' values
};

var objectPlain = function objectPlain(subject) {
  return object(subject) && Object.prototype.toString.call(subject) === '[object Object]' && subject.constructor === Object;
};

var string = function string(subject) {
  return typeof subject === 'string';
};

var number = function number(subject) {
  return typeof subject === 'number' && !isNaN(subject);
};

var numberLoose = function numberLoose(subject) {
  return number(subject) || string(subject) && number(Number(subject));
};

var iterable = function iterable(subject) {
  return object(subject) && number(subject.length);
};

var function_ = function function_(subject) {
  return typeof subject === 'function';
};

var natives =
/*#__PURE__*/
Object.freeze({
  defined: defined,
  array: array,
  object: object,
  objectPlain: objectPlain,
  string: string,
  number: number,
  numberLoose: numberLoose,
  iterable: iterable,
  function_: function_
});

var domDoc = function domDoc(subject) {
  return subject && subject.nodeType === 9;
};

var domEl = function domEl(subject) {
  return subject && subject.nodeType === 1;
};

var domText = function domText(subject) {
  return subject && subject.nodeType === 3;
};

var domNode = function domNode(subject) {
  return domEl(subject) || domText(subject);
};

var domTextarea = function domTextarea(subject) {
  return subject && subject.nodeName === 'TEXTAREA';
};

var domInput = function domInput(subject) {
  return subject && subject.nodeName === 'INPUT';
};

var domSelect = function domSelect(subject) {
  return subject && subject.nodeName === 'SELECT';
};

var domField = function domField(subject) {
  return domInput(subject) || domTextarea(subject) || domSelect(subject);
};

var dom =
/*#__PURE__*/
Object.freeze({
  domDoc: domDoc,
  domEl: domEl,
  domText: domText,
  domNode: domNode,
  domTextarea: domTextarea,
  domInput: domInput,
  domSelect: domSelect,
  domField: domField
});
var AVAIL_SETS, Checks;
AVAIL_SETS = {
  natives: natives,
  dom: dom
};

Checks =
/*#__PURE__*/
function () {
  _createClass$1(Checks, [{
    key: "create",
    value: function create() {
      var args;

      if (arguments.length) {
        args = Array.prototype.slice.call(arguments);
      }

      return new Checks(args);
    }
  }]);

  function Checks(sets) {
    _classCallCheck$1(this, Checks);

    var i, len, set;

    if (sets == null) {
      sets = ['natives'];
    }

    for (i = 0, len = sets.length; i < len; i++) {
      set = sets[i];

      if (AVAIL_SETS[set]) {
        this.load(AVAIL_SETS[set]);
      }
    }
  }

  _createClass$1(Checks, [{
    key: "load",
    value: function load(set) {
      var key, value;

      if (AVAIL_SETS.natives.string(set)) {
        set = AVAIL_SETS[set];
      }

      if (!AVAIL_SETS.natives.objectPlain(set)) {
        return;
      }

      for (key in set) {
        value = set[key];

        if (key === 'function_') {
          key = 'function';
        }

        this[key] = value;
      }
    }
  }]);

  return Checks;
}();

var index$1 = Checks.prototype.create();
var IS;
IS = index$1.create('natives', 'dom');
IS.load({
  quickDomEl: function quickDomEl(subject) {
    return subject && subject.constructor.name === 'QuickElement';
  },
  template: function template(subject) {
    return subject && subject.constructor.name === 'QuickTemplate';
  }
}); // batch: (subject)-> subject and subject.constructor.name is 'QuickBatch'

var IS$1 = IS;

var QuickElement, QuickWindow, _quickdom;

QuickElement = null;
QuickWindow = null;

_quickdom = function quickdom() {
  var arg, args, element, i, j, len, prevCount;
  args = new Array(arguments.length);

  for (i = j = 0, len = arguments.length; j < len; i = ++j) {
    arg = arguments[i];
    args[i] = arg;
  }

  prevCount = QuickElement.count;
  element = _quickdom.create(args);

  if (element && element._postCreation && QuickElement.count !== prevCount) {
    element._postCreation();
  }

  return element;
};

_quickdom.create = function (args) {
  var argsLength, child, children, element, i, j, len, options, type;

  switch (false) {
    case !IS$1.array(args[0]):
      return _quickdom.apply(void 0, _toConsumableArray(args[0]));

    case !IS$1.template(args[0]):
      return args[0].spawn();

    case !IS$1.quickDomEl(args[0]):
      if (args[1]) {
        return args[0].updateOptions(args[1]);
      } else {
        return args[0];
      }

    case !(IS$1.domNode(args[0]) || IS$1.domDoc(args[0])):
      if (args[0]._quickElement) {
        return args[0]._quickElement;
      }

      type = args[0].nodeName.toLowerCase().replace('#', '');
      options = args[1] || {};
      options.existing = args[0];
      return new QuickElement(type, options);

    case args[0] !== window:
      return QuickWindow;

    case !IS$1.string(args[0]):
      type = args[0].toLowerCase();

      if (type === 'text') {
        options = IS$1.object(args[1]) ? args[1] : {
          text: args[1] || ''
        };
      } else {
        options = IS$1.object(args[1]) ? args[1] : {};
      }

      element = new QuickElement(type, options);

      if (args.length > 2) {
        children = new Array(argsLength = args.length);
        i = 1;

        while (++i < argsLength) {
          children[i + 1] = args[i];
        }

        for (j = 0, len = children.length; j < len; j++) {
          child = children[j];

          if (IS$1.string(child)) {
            child = _quickdom.text(child);
          }

          if (IS$1.array(child)) {
            child = _quickdom.apply(void 0, _toConsumableArray(child));
          }

          if (IS$1.quickDomEl(child)) {
            element.append(child);
          }
        }
      }

      return element;

    case !(args[0] && (IS$1.domNode(args[0][0]) || IS$1.domDoc(args[0][0]))):
      return _quickdom(args[0][0]);
  }
};

_quickdom.html = function (innerHTML) {
  var children, container;
  container = document.createElement('div');
  container.innerHTML = innerHTML;
  children = Array.prototype.slice.call(container.childNodes);
  return _quickdom.batch(children);
};

_quickdom.isQuickEl = function (target) {
  return IS$1.quickDomEl(target);
};

_quickdom.isEl = function (target) {
  return IS$1.domEl(target);
};

var init = function init(QuickElement_, QuickWindow_) {
  QuickElement = QuickElement_;
  QuickWindow = QuickWindow_;
  return _quickdom;
};

var includes$1 = function includes(target, item) {
  return target && target.indexOf(item) !== -1;
};

var removeItem = function removeItem(target, item) {
  var itemIndex;
  itemIndex = target.indexOf(item);

  if (itemIndex !== -1) {
    target.splice(itemIndex, 1);
  }

  return target;
};

var normalizeElementArg = function normalizeElementArg(targetEl) {
  switch (false) {
    case !IS$1.string(targetEl):
      return quickdom.text(targetEl);

    case !IS$1.domNode(targetEl):
      return quickdom(targetEl);

    case !IS$1.template(targetEl):
      return targetEl.spawn();

    default:
      return targetEl;
  }
};

var isStateStyle = function isStateStyle(string) {
  return string[0] === '$' || string[0] === '@';
};

var registerStyle = function registerStyle(rule, level, important) {
  var cached, i, len, output, prop, props;
  level || (level = 0);
  cached = styleCache.get(rule, level);

  if (cached) {
    return cached;
  }

  output = {
    className: [index.register(rule, level, important)],
    fns: [],
    rule: rule
  };
  props = Object.keys(rule);

  for (i = 0, len = props.length; i < len; i++) {
    prop = props[i];

    if (typeof rule[prop] === 'function') {
      output.fns.push([prop, rule[prop]]);
    }
  }

  return styleCache.set(rule, output, level);
};

var styleCache = new (
/*#__PURE__*/
function () {
  function _class() {
    _classCallCheck(this, _class);

    this.keys = Object.create(null);
    this.values = Object.create(null);
  }

  _createClass(_class, [{
    key: "get",
    value: function get(key, level) {
      var index$$1;

      if (this.keys[level]) {
        index$$1 = this.keys[level].indexOf(key);

        if (index$$1 !== -1) {
          return this.values[level][index$$1];
        }
      }
    }
  }, {
    key: "set",
    value: function set(key, value, level) {
      if (!this.keys[level]) {
        this.keys[level] = [];
        this.values[level] = [];
      }

      this.keys[level].push(key);
      this.values[level].push(value);
      return value;
    }
  }]);

  return _class;
}())();
var REGEX_WHITESPACE;
REGEX_WHITESPACE = /\s+/;

var on_ = function on_(eventNames, callback, useCapture, isPrivate) {
  var _this = this;

  var callbackRef, split;

  if (this._eventCallbacks == null) {
    this._eventCallbacks = {
      __refs: {}
    };
  }

  if (IS$1.string(eventNames) && IS$1.function(callback)) {
    split = eventNames.split('.');
    callbackRef = split[1];
    eventNames = split[0];

    if (eventNames === 'inserted' && this._inserted) {
      callback.call(this, this._parent);
      return this;
    }

    eventNames.split(REGEX_WHITESPACE).forEach(function (eventName) {
      var base;

      if (!_this._eventCallbacks[eventName]) {
        _this._eventCallbacks[eventName] = [];

        if (!isPrivate) {
          _this._listenTo(eventName, function (event) {
            return _this._invokeHandlers(eventName, event);
          }, useCapture);
        }
      }

      if (callbackRef) {
        if ((base = _this._eventCallbacks.__refs)[eventName] == null) {
          base[eventName] = {};
        }

        _this._eventCallbacks.__refs[eventName][callbackRef] = callback;
      }

      return _this._eventCallbacks[eventName].push(callback);
    });
  }

  return this;
};

var once = function once(eventNames, callback) {
  var _this2 = this;

  var _onceCallback;

  if (IS$1.string(eventNames) && IS$1.function(callback)) {
    this.on(eventNames, _onceCallback = function onceCallback(event) {
      _this2.off(eventNames, _onceCallback);

      return callback.call(_this2, event);
    });
  }

  return this;
};

var off_ = function off_(eventNames, callback) {
  var _this3 = this;

  var callbackRef, eventName, split;

  if (this._eventCallbacks == null) {
    this._eventCallbacks = {
      __refs: {}
    };
  }

  if (!IS$1.string(eventNames)) {
    for (eventName in this._eventCallbacks) {
      this.off(eventName);
    }
  } else {
    split = eventNames.split('.');
    callbackRef = split[1];
    eventNames = split[0];
    eventNames.split(REGEX_WHITESPACE).forEach(function (eventName) {
      var ref;

      if (_this3._eventCallbacks[eventName]) {
        if (callback == null) {
          callback = (ref = _this3._eventCallbacks.__refs[eventName]) != null ? ref[callbackRef] : void 0;
        }

        if (IS$1.function(callback)) {
          return removeItem(_this3._eventCallbacks[eventName], callback);
        } else if (!callbackRef) {
          return _this3._eventCallbacks[eventName].length = 0;
        }
      }
    });
  }

  return this;
};

var emit = function emit(eventName) {
  var bubbles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var cancelable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var data = arguments.length > 3 ? arguments[3] : undefined;
  var event;

  if (eventName && IS$1.string(eventName)) {
    event = document.createEvent('Event');
    event.initEvent(eventName, bubbles, cancelable);

    if (data && _typeof$1(data) === 'object') {
      primaryBuilder$1(event, data);
    }

    this.el.dispatchEvent(event);
  }

  return this;
};

var emitPrivate = function emitPrivate(eventName, arg) {
  var ref;

  if (eventName && IS$1.string(eventName) && ((ref = this._eventCallbacks) != null ? ref[eventName] : void 0)) {
    this._invokeHandlers(eventName, arg);
  }

  return this;
};

var _invokeHandlers = function _invokeHandlers(eventName, arg) {
  var callbacks, cb, i, len;
  callbacks = this._eventCallbacks[eventName].slice();

  for (i = 0, len = callbacks.length; i < len; i++) {
    cb = callbacks[i];
    cb.call(this, arg);
  }
};
/* istanbul ignore next */


var _listenTo = function _listenTo(eventName, callback, useCapture) {
  var eventNameToListenFor, listenMethod;
  listenMethod = this.el.addEventListener ? 'addEventListener' : 'attachEvent';
  eventNameToListenFor = this.el.addEventListener ? eventName : "on".concat(eventName);
  this.el[listenMethod](eventNameToListenFor, callback, useCapture);
  return this;
};

function events(QuickElement) {
  QuickElement.prototype.on = on_;
  QuickElement.prototype.once = once;
  QuickElement.prototype.off = off_;
  QuickElement.prototype.emit = emit;
  QuickElement.prototype.emitPrivate = emitPrivate;
  QuickElement.prototype._invokeHandlers = _invokeHandlers;
  return QuickElement.prototype._listenTo = _listenTo;
}
/**
* Sets/gets the value of a style property. In getter mode the computed property of
* the style will be returned unless the element is not inserted into the DOM. In
* webkit browsers all computed properties of a detached node are always an empty
* string but in gecko they reflect on the actual computed value, hence we need
* to "normalize" this behavior and make sure that even on gecko an empty string
* is returned
* @return {[type]} [description]
*/


var style = function style(property) {
  var _this = this;

  var args, i, key, keys, result, value;

  if (this.type === 'text') {
    return;
  }

  args = arguments;

  if (IS$1.string(property)) {
    value = typeof args[1] === 'function' ? args[1].call(this, this.related) : args[1];

    if (args[1] === null && IS$1.defined(this.currentStateStyle(property)) && !IS$1.function(this.currentStateStyle(property))) {
      value = index.UNSET;
    }

    if (value && typeof value.then === 'function') {
      value.then(function (value) {
        return index(_this.el, property, value, _this.options.forceStyle);
      });
    } else {
      result = index(this.el, property, value, this.options.forceStyle);
    }

    if (args.length === 1) {
      /* istanbul ignore next */
      if (this._inserted) {
        return result;
      } else if (!result) {
        return result;
      } else {
        return '';
      }
    }
  } else if (IS$1.object(property)) {
    keys = Object.keys(property);
    i = -1;

    while (key = keys[++i]) {
      this.style(key, property[key]);
    }
  }

  return this;
};
/**
* Attempts to resolve the value for a given property in the following order if each one isn't a valid value:
* 1. from computed style (for dom-inserted els)
* 2. from DOMElement.style object (for non-inserted els; if options.styleAfterInsert, will only have state styles)
* 3. from provided style options
* (for non-inserted els; checking only $base since state styles will always be applied to the style object even for non-inserted)
 */


var styleSafe = function styleSafe(property, skipComputed) {
  var computed, result, sample;

  if (this.type === 'text') {
    return;
  }

  sample = this.el.style[property];

  if (IS$1.string(sample) || IS$1.number(sample)) {
    computed = skipComputed ? 0 : this.style(property);
    result = computed || this.el.style[property] || this.currentStateStyle(property) || '';

    if (typeof result === 'function') {
      return result.call(this, this.related);
    } else {
      return result;
    }
  }

  return this;
};

var styleParsed = function styleParsed(property, skipComputed) {
  return parseFloat(this.styleSafe(property, skipComputed));
};

var recalcStyle = function recalcStyle(recalcChildren) {
  var child, j, len, ref, targetStyles;
  targetStyles = this._resolveFnStyles(this._getActiveStates(), true);
  this.style(targetStyles);

  if (recalcChildren) {
    ref = this._children;

    for (j = 0, len = ref.length; j < len; j++) {
      child = ref[j];
      child.recalcStyle();
    }
  }

  return this;
};

var currentStateStyle = function currentStateStyle(property) {
  var i, state, states;

  if (property) {
    if (this._state.length) {
      states = this._state.slice();

      if (this._stateShared && this._stateShared.length) {
        var _states;

        (_states = states).push.apply(_states, _toConsumableArray(this._stateShared));
      }

      i = states.length;

      while (state = states[--i]) {
        if (this._styles[state] && IS$1.defined(this._styles[state].rule[property])) {
          return this._styles[state].rule[property];
        }
      }
    }

    if (this._styles.base) {
      return this._styles.base.rule[property];
    }
  }
};

var hide = function hide() {
  return this.style('display', 'none');
};

var show = function show(display) {
  var ref;

  if (!display) {
    display = this.currentStateStyle('display');

    if (display === 'none' || !display) {
      display = 'block';
    }
  }

  if (display == null) {
    display = ((ref = this._styles.base) != null ? ref.display : void 0) || 'block';
  }

  return this.style('display', display);
};

var orientationGetter = {
  get: function get() {
    if (this.width > this.height) {
      return 'landscape';
    } else {
      return 'portrait';
    }
  }
};
var aspectRatioGetter = {
  get: function get() {
    return this.width / this.height;
  }
};

function style$1(QuickElement) {
  Object.defineProperties(QuickElement.prototype, {
    'orientation': orientationGetter,
    'aspectRatio': aspectRatioGetter,
    'rect': {
      get: function get() {
        return this.el.getBoundingClientRect();
      }
    },
    'width': {
      get: function get() {
        return parseFloat(this.style('width'));
      },
      set: function set(value) {
        return this.style('width', value);
      }
    },
    'height': {
      get: function get() {
        return parseFloat(this.style('height'));
      },
      set: function set(value) {
        return this.style('height', value);
      }
    }
  });
  QuickElement.prototype.style = style;
  QuickElement.prototype.styleSafe = styleSafe;
  QuickElement.prototype.styleParsed = styleParsed;
  QuickElement.prototype.recalcStyle = recalcStyle;
  QuickElement.prototype.currentStateStyle = currentStateStyle;
  QuickElement.prototype.hide = hide;
  return QuickElement.prototype.show = show;
}

var QuickWindow$1;
var QuickWindow$2 = QuickWindow$1 = {
  type: 'window',
  el: window,
  raw: window,
  _eventCallbacks: {
    __refs: {}
  }
};
QuickWindow$1.on = on_;
QuickWindow$1.off = off_;
QuickWindow$1.emit = emit;
QuickWindow$1.emitPrivate = emitPrivate;
QuickWindow$1._listenTo = _listenTo;
QuickWindow$1._invokeHandlers = _invokeHandlers;
Object.defineProperties(QuickWindow$1, {
  'width': {
    get: function get() {
      return window.innerWidth;
    }
  },
  'height': {
    get: function get() {
      return window.innerHeight;
    }
  },
  'orientation': orientationGetter,
  'aspectRatio': aspectRatioGetter
});
var MediaQuery, RULE_DEILIMITER;
RULE_DEILIMITER = /,\s*/;
var MediaQuery$1 = MediaQuery = new function () {
  var callbacks, testRule;
  callbacks = [];
  window.addEventListener('resize', function () {
    var callback, i, len;

    for (i = 0, len = callbacks.length; i < len; i++) {
      callback = callbacks[i];
      callback();
    }
  });

  this.parseQuery = function (target, queryString) {
    var querySplit, rules, source;
    querySplit = queryString.split('(');
    source = querySplit[0];

    source = function () {
      switch (source) {
        case 'window':
          return QuickWindow$2;

        case 'parent':
          return target.parent;

        case 'self':
          return target;

        default:
          return target.parentMatching(function (parent) {
            return parent.ref === source.slice(1);
          });
      }
    }();

    rules = querySplit[1].slice(0, -1).split(RULE_DEILIMITER).map(function (rule) {
      var getter, key, keyPrefix, max, min, split, value;
      split = rule.split(':');
      value = parseFloat(split[1]);

      if (isNaN(value)) {
        value = split[1];
      }

      key = split[0];
      keyPrefix = key.slice(0, 4);
      max = keyPrefix === 'max-';
      min = !max && keyPrefix === 'min-';

      if (max || min) {
        key = key.slice(4);
      }

      getter = function () {
        switch (key) {
          case 'orientation':
            return function () {
              return source.orientation;
            };

          case 'aspect-ratio':
            return function () {
              return source.aspectRatio;
            };

          case 'width':
          case 'height':
            return function () {
              return source[key];
            };

          default:
            return function () {
              var parsedValue, stringValue;
              stringValue = source.style(key);
              parsedValue = parseFloat(stringValue);

              if (isNaN(parsedValue)) {
                return stringValue;
              } else {
                return parsedValue;
              }
            };
        }
      }();

      return {
        key: key,
        value: value,
        min: min,
        max: max,
        getter: getter
      };
    });
    return {
      source: source,
      rules: rules
    };
  };

  this.register = function (target, queryString) {
    var callback, query;
    query = this.parseQuery(target, queryString);

    if (query.source) {
      callbacks.push(callback = function callback() {
        return testRule(target, query, queryString);
      });
      callback();
    }

    return query;
  };

  testRule = function testRule(target, query, queryString) {
    var currentValue, i, len, passed, ref, rule;
    passed = true;
    ref = query.rules;

    for (i = 0, len = ref.length; i < len; i++) {
      rule = ref[i];
      currentValue = rule.getter();

      passed = function () {
        switch (false) {
          case !rule.min:
            return currentValue >= rule.value;

          case !rule.max:
            return currentValue <= rule.value;

          default:
            return currentValue === rule.value;
        }
      }();

      if (!passed) {
        break;
      }
    }

    return target.state(queryString, passed);
  };

  return this;
}();
var StateChain;

var StateChain$1 = StateChain =
/*#__PURE__*/
function () {
  function StateChain(states) {
    _classCallCheck(this, StateChain);

    this.string = states.join('+');
    this.array = states.slice();
    this.length = states.length;
  }

  _createClass(StateChain, [{
    key: "includes",
    value: function includes(target) {
      var i, len, ref, state;
      ref = this.array;

      for (i = 0, len = ref.length; i < len; i++) {
        state = ref[i];

        if (state === target) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "without",
    value: function without(target) {
      return this.array.filter(function (state) {
        return state !== target;
      }).join('+');
    }
  }, {
    key: "isApplicable",
    value: function isApplicable(target, otherActive) {
      var active;
      active = this.array.filter(function (state) {
        return state === target || otherActive.indexOf(state) !== -1;
      });
      return active.length === this.array.length;
    }
  }]);

  return StateChain;
}();

var BASE_STATE_TRIGGERS, CACHED_FN_INSERTED;
BASE_STATE_TRIGGERS = {
  'hover': {
    on: 'mouseenter',
    off: 'mouseleave',
    bubbles: true
  },
  'focus': {
    on: 'focus',
    off: 'blur',
    bubbles: true
  }
};

var _normalizeOptions = function _normalizeOptions() {
  var base1, base2, base3, base4, base5;

  if (this.options.relatedInstance) {
    (base1 = this.options).related || (base1.related = this.options.relatedInstance);
    this.options.relatedInstance = null;
  }

  this.related = (base2 = this.options).related != null ? base2.related : base2.related = this;

  if (this.options.class) {
    this.options.className = this.options.class;
  }

  if (this.options.url) {
    this.options.href = this.options.url;
  }

  if ((base3 = this.options).unpassableStates == null) {
    base3.unpassableStates = [];
  }

  if ((base4 = this.options).passStateToChildren == null) {
    base4.passStateToChildren = true;
  }

  if ((base5 = this.options).passDataToChildren == null) {
    base5.passDataToChildren = true;
  }

  this.options.stateTriggers = this.options.stateTriggers ? primaryBuilder$1.clone.deep(BASE_STATE_TRIGGERS, this.options.stateTriggers) : BASE_STATE_TRIGGERS;

  if (this.type === 'text') {
    primaryBuilder$1(this, this._parseTexts(this.options.text, this._texts));
  } else {
    primaryBuilder$1(this, this._parseStyles(this.options.style, this._styles));
  }
};

var _parseStyles = function _parseStyles(styles, store) {
  var _mediaStates, _providedStates, _providedStatesShared, _stateShared, _styles, base, _flattenNestedStates, forceStyle, i, keys, len, specialStates, state, stateStyles, state_, states;

  if (!IS$1.objectPlain(styles)) {
    return;
  }

  keys = Object.keys(styles);
  states = keys.filter(function (key) {
    return isStateStyle(key);
  });
  specialStates = removeItem(states.slice(), '$base');
  _mediaStates = states.filter(function (key) {
    return key[0] === '@';
  }).map(function (state) {
    return state.slice(1);
  });
  _providedStates = states.map(function (state) {
    return state.slice(1); // Remove '$' prefix
  });
  _styles = store || {};
  _stateShared = _providedStatesShared = void 0;
  base = !includes$1(states, '$base') ? styles : styles.$base;
  _styles.base = registerStyle(base, 0, forceStyle = this.options.forceStyle);

  if (specialStates.length) {
    _flattenNestedStates = function flattenNestedStates(styleObject, chain, level) {
      var hasNonStateProps, i, len, output, state, stateChain, state_, styleKeys;
      styleKeys = Object.keys(styleObject);
      output = {};
      hasNonStateProps = false;

      for (i = 0, len = styleKeys.length; i < len; i++) {
        state = styleKeys[i];

        if (!isStateStyle(state)) {
          hasNonStateProps = true;
          output[state] = styleObject[state];
        } else {
          chain.push(state_ = state.slice(1));
          stateChain = new StateChain$1(chain);

          if (_stateShared == null) {
            _stateShared = [];
          }

          if (_providedStatesShared == null) {
            _providedStatesShared = [];
          }

          _providedStatesShared.push(stateChain);

          if (state[0] === '@') {
            _mediaStates.push(state_);
          }

          _styles[stateChain.string] = registerStyle(_flattenNestedStates(styleObject[state], chain, level + 1), level + 1, forceStyle);
        }
      }

      if (hasNonStateProps) {
        return output;
      }
    };

    for (i = 0, len = specialStates.length; i < len; i++) {
      state = specialStates[i];
      state_ = state.slice(1);
      stateStyles = _flattenNestedStates(styles[state], [state_], 1);

      if (stateStyles) {
        _styles[state_] = registerStyle(stateStyles, 1);
      }
    }
  }

  return {
    _styles: _styles,
    _mediaStates: _mediaStates,
    _stateShared: _stateShared,
    _providedStates: _providedStates,
    _providedStatesShared: _providedStatesShared
  };
};

var _parseTexts = function _parseTexts(texts, store) {
  var _providedStates, _texts, i, len, state, states;

  if (!IS$1.objectPlain(texts)) {
    return;
  }

  states = Object.keys(texts).map(function (state) {
    return state.slice(1);
  });
  _providedStates = states.filter(function (state) {
    return state !== 'base';
  });
  _texts = store || {};
  _texts = {
    base: ''
  };

  for (i = 0, len = states.length; i < len; i++) {
    state = states[i];
    _texts[state] = texts['$' + state];
  }

  return {
    _texts: _texts,
    _providedStates: _providedStates
  };
};

var _applyOptions = function _applyOptions() {
  var _this = this;

  var event, handler, method, ref, ref1, ref2, value;

  if (ref = this.options.id || this.options.ref) {
    this.attr('data-ref', this.ref = ref);
  }

  if (this.options.id) {
    this.el.id = this.options.id;
  }

  if (this.options.className) {
    this.el.className = this.options.className;
  }

  if (this.options.src) {
    this.el.src = this.options.src;
  }

  if (this.options.href) {
    this.el.href = this.options.href;
  }

  if (this.options.type) {
    this.el.type = this.options.type;
  }

  if (this.options.name) {
    this.el.name = this.options.name;
  }

  if (this.options.value) {
    this.el.value = this.options.value;
  }

  if (this.options.selected) {
    this.el.selected = this.options.selected;
  }

  if (this.options.checked) {
    this.el.checked = this.options.checked;
  }

  if (this.options.props) {
    this.prop(this.options.props);
  }

  if (this.options.attrs) {
    this.attr(this.options.attrs);
  }

  this._applyRegisteredStyle(this._styles.base, null, null, this.options.styleAfterInsert);

  if (this._texts) {
    this.text = this._texts.base;
  }

  this.on('inserted', CACHED_FN_INSERTED, false, true);

  if (this.options.invokeComputersOnce) {
    this._invokedComputers = {};
  }

  if (this.options.recalcOnResize) {
    window.addEventListener('resize', function () {
      return _this.recalcStyle();
    });
  }

  if (this.options.events) {
    ref1 = this.options.events;

    for (event in ref1) {
      handler = ref1[event];
      this.on(event, handler);
    }
  }

  if (this.options.methods) {
    ref2 = this.options.methods;

    for (method in ref2) {
      value = ref2[method];

      if (!this[method]) {
        if (IS$1.function(value)) {
          this[method] = value;
        } else if (IS$1.object(value)) {
          Object.defineProperty(this, method, {
            configurable: true,
            get: value.get,
            set: value.set
          });
        }
      }
    }
  }

  if (this.type !== 'text' && IS$1.object(this.options.text)) {
    this.append(_quickdom('text', {
      text: this.options.text
    }));
  }
};

var _postCreation = function _postCreation(data) {
  if (this.options.computers) {
    if (data && this.options.data) {
      data = primaryBuilder$1.clone(this.options.data, data);
    }

    data || (data = this.options.data);
    this.applyData(data, false);

    if (this.options.computers._init) {
      this._runComputer('_init', data);
    }
  }

  if (this.options.state) {
    this.state(this.options.state);
  }
};

var _attachStateEvents = function _attachStateEvents(force) {
  var _this2 = this;

  var states;
  states = Object.keys(this.options.stateTriggers);
  states.forEach(function (state) {
    var disabler, enabler, trigger;
    trigger = _this2.options.stateTriggers[state];

    if (!includes$1(_this2._providedStates, state) && !force && !trigger.force) {
      return;
    }

    enabler = IS$1.string(trigger) ? trigger : trigger.on;

    if (IS$1.object(trigger)) {
      disabler = trigger.off;
    }

    _this2._listenTo(enabler, function () {
      return _this2.state(state, true, trigger.bubbles);
    });

    if (disabler) {
      return _this2._listenTo(disabler, function () {
        return _this2.state(state, false, trigger.bubbles);
      });
    }
  });
};

var _proxyParent = function _proxyParent() {
  var parent;
  parent = void 0;
  return Object.defineProperty(this, '_parent', {
    get: function get() {
      return parent;
    },
    set: function set(newParent) {
      var _this3 = this;

      var lastParent;

      if (parent = newParent) {
        lastParent = this.parents.slice(-1)[0];

        if (lastParent.raw === document.documentElement) {
          this._unproxyParent(newParent);
        } else {
          parent.on('inserted', function () {
            if (parent === newParent) {
              return _this3._unproxyParent(newParent);
            }
          });
        }
      }
    }
  });
};

var _unproxyParent = function _unproxyParent(newParent) {
  delete this._parent;
  this._parent = newParent;
  this.emitPrivate('inserted', newParent);
};

CACHED_FN_INSERTED = function CACHED_FN_INSERTED() {
  var i, len, mediaStates, queryString, results;
  this._inserted = this;

  if (this.options.styleAfterInsert) {
    this.recalcStyle();
  }

  if ((mediaStates = this._mediaStates) && this._mediaStates.length) {
    this._mediaStates = Object.create(null);
    results = [];

    for (i = 0, len = mediaStates.length; i < len; i++) {
      queryString = mediaStates[i];
      results.push(this._mediaStates[queryString] = MediaQuery$1.register(this, queryString));
    }

    return results;
  }
};

function init$1(QuickElement) {
  QuickElement.prototype._normalizeOptions = _normalizeOptions;
  QuickElement.prototype._parseStyles = _parseStyles;
  QuickElement.prototype._parseTexts = _parseTexts;
  QuickElement.prototype._applyOptions = _applyOptions;
  QuickElement.prototype._postCreation = _postCreation;
  QuickElement.prototype._attachStateEvents = _attachStateEvents;
  QuickElement.prototype._proxyParent = _proxyParent;
  return QuickElement.prototype._unproxyParent = _unproxyParent;
}

function aliases(QuickElement) {
  return Object.defineProperties(QuickElement.prototype, {
    'raw': {
      get: function get() {
        return this.el;
      }
    },
    '0': {
      get: function get() {
        return this.el;
      }
    },
    'css': {
      get: function get() {
        return this.style;
      }
    },
    'replaceWith': {
      get: function get() {
        return this.replace;
      }
    },
    'removeListener': {
      get: function get() {
        return this.off;
      }
    }
  });
}

var parentsUntil = function parentsUntil(filter) {
  return _getParents(this, filter);
};

var parentMatching = function parentMatching(filter) {
  var isRef, nextParent;

  if (IS$1.function(filter) || (isRef = IS$1.string(filter))) {
    nextParent = this.parent;

    while (nextParent) {
      if (isRef) {
        if (nextParent.ref === filter) {
          return nextParent;
        }
      } else {
        if (filter(nextParent)) {
          return nextParent;
        }
      }

      nextParent = nextParent.parent;
    }
  }
};

var query = function query(selector) {
  return _quickdom(this.raw.querySelector(selector));
};

var queryAll = function queryAll(selector) {
  var i, item, len, output, result;
  result = this.raw.querySelectorAll(selector);
  output = [];

  for (i = 0, len = result.length; i < len; i++) {
    item = result[i];
    output.push(item);
  }

  return _quickdom.batch(output);
};

var _getParents = function _getParents(targetEl, filter) {
  var isRef, nextParent, parents;

  if (!IS$1.function(filter) && !(isRef = IS$1.string(filter))) {
    filter = void 0;
  }

  parents = [];
  nextParent = targetEl.parent;

  while (nextParent) {
    parents.push(nextParent);
    nextParent = nextParent.parent;

    if (isRef) {
      if (nextParent && nextParent.ref === filter) {
        nextParent = null;
      }
    } else if (filter) {
      if (filter(nextParent)) {
        nextParent = null;
      }
    }
  }

  return parents;
};

var _getChildRefs = function _getChildRefs(target, freshCopy) {
  var child, childRefs, children, el, i, len, ref, refs;

  if (freshCopy || !target._childRefs) {
    target._childRefs = {};
  }

  refs = target._childRefs;

  if (target.ref) {
    refs[target.ref] = target;
  }

  children = target.children;

  if (children.length) {
    for (i = 0, len = children.length; i < len; i++) {
      child = children[i];
      childRefs = _getChildRefs(child, freshCopy);

      for (ref in childRefs) {
        el = childRefs[ref];
        refs[ref] || (refs[ref] = el);
      }
    }
  }

  return refs;
};

var _getIndexByProp = function _getIndexByProp(main, prop) {
  var parent;

  if (!(parent = main.parent)) {
    return null;
  } else {
    return parent.children.filter(function (child) {
      return child[prop] === main[prop];
    }).indexOf(main);
  }
};

var _filterElements = function _filterElements(array) {
  var i, item, len, output;

  if (!array.length) {
    return array;
  } else {
    output = [];

    for (i = 0, len = array.length; i < len; i++) {
      item = array[i];

      if (item.type !== 'text') {
        output.push(item);
      }
    }

    return output;
  }
};

function traversing(QuickElement) {
  QuickElement.prototype.parentsUntil = parentsUntil;
  QuickElement.prototype.parentMatching = parentMatching;
  QuickElement.prototype.query = query;
  QuickElement.prototype.queryAll = queryAll;
  return Object.defineProperties(QuickElement.prototype, {
    'children': {
      get: function get() {
        var child, i, len, ref1;

        if (this.el.childNodes.length !== this._children.length) {
          // Re-collect children	
          this._children.length = 0; // Empty out children array

          ref1 = this.el.childNodes;

          for (i = 0, len = ref1.length; i < len; i++) {
            child = ref1[i];

            if (child.nodeType < 4) {
              this._children.push(_quickdom(child));
            }
          }
        }

        return this._children;
      }
    },
    'elementChildren': {
      get: function get() {
        return _filterElements(this.children);
      }
    },
    'parent': {
      get: function get() {
        if ((!this._parent || this._parent.el !== this.el.parentNode) && !IS$1.domDoc(this.el.parentNode)) {
          this._parent = _quickdom(this.el.parentNode);
        }

        return this._parent;
      }
    },
    'parents': {
      get: function get() {
        return _getParents(this);
      }
    },
    'next': {
      get: function get() {
        return _quickdom(this.el.nextSibling);
      }
    },
    'nextEl': {
      get: function get() {
        return _quickdom(this.el.nextElementSibling);
      }
    },
    'nextElAll': {
      get: function get() {
        return _filterElements(this.nextAll);
      }
    },
    'nextAll': {
      get: function get() {
        var nextSibling, siblings;
        siblings = [];
        nextSibling = _quickdom(this.el.nextSibling);

        while (nextSibling) {
          siblings.push(nextSibling);
          nextSibling = nextSibling.next;
        }

        return siblings;
      }
    },
    'prev': {
      get: function get() {
        return _quickdom(this.el.previousSibling);
      }
    },
    'prevEl': {
      get: function get() {
        return _quickdom(this.el.previousElementSibling);
      }
    },
    'prevElAll': {
      get: function get() {
        return _filterElements(this.prevAll);
      }
    },
    'prevAll': {
      get: function get() {
        var prevSibling, siblings;
        siblings = [];
        prevSibling = _quickdom(this.el.previousSibling);

        while (prevSibling) {
          siblings.push(prevSibling);
          prevSibling = prevSibling.prev;
        }

        return siblings;
      }
    },
    'siblings': {
      get: function get() {
        return this.prevAll.reverse().concat(this.nextAll);
      }
    },
    'elementSiblings': {
      get: function get() {
        return _filterElements(this.siblings);
      }
    },
    'child': {
      get: function get() {
        return this._childRefs || _getChildRefs(this);
      }
    },
    'childf': {
      get: function get() {
        return _getChildRefs(this, true);
      }
    },
    'firstChild': {
      get: function get() {
        return this.children[0];
      }
    },
    'lastChild': {
      get: function get() {
        var children;
        children = this.children;
        return children[children.length - 1];
      }
    },
    'index': {
      get: function get() {
        var parent;

        if (!(parent = this.parent)) {
          return null;
        } else {
          return parent.children.indexOf(this);
        }
      }
    },
    'indexType': {
      get: function get() {
        return _getIndexByProp(this, 'type');
      }
    },
    'indexRef': {
      get: function get() {
        return _getIndexByProp(this, 'ref');
      }
    }
  });
}

_quickdom.query = function (target) {
  return _quickdom(document).query(target);
};

_quickdom.queryAll = function (target) {
  return _quickdom(document).queryAll(target);
};

var DUMMY_ARRAY;
DUMMY_ARRAY = [];

var state = function state(targetState, value, bubbles, source) {
  var activeStates, child, desiredValue, i, j, key, keys, len, prop, ref, toggle;

  if (arguments.length === 0) {
    return this._state.slice();
  }

  if (arguments.length === 1) {
    if (IS$1.string(targetState)) {
      return includes$1(this._state, targetState);
    } else if (IS$1.object(targetState)) {
      keys = Object.keys(targetState);
      i = -1;

      while (key = keys[++i]) {
        this.state(key, targetState[key]);
      }

      return this;
    }
  } else if (this._statePipeTarget && source !== this) {
    this._statePipeTarget.state(targetState, value, bubbles, this);

    return this;
  } else if (IS$1.string(targetState)) {
    if (targetState[0] === '$') {
      targetState = targetState.slice(1);
    }

    if (targetState === 'base') {
      return this;
    }

    desiredValue = !!value; // Convert the value to a boolean

    activeStates = this._getActiveStates(targetState, false); // ==== Toggle styles for this state =================================================================================

    if (this.state(targetState) !== desiredValue) {
      prop = this.type === 'text' ? 'Text' : 'Style';

      if (desiredValue) {
        //is on
        this._state.push(targetState);

        toggle = 'ON';
      } else {
        removeItem(this._state, targetState);
        toggle = 'OFF';
      }

      this['_turn' + prop + toggle](targetState, activeStates);
      this.emitPrivate("stateChange:".concat(targetState), desiredValue);
    } // ==== Pass state to parent/children =================================================================================


    if (!includes$1(this.options.unpassableStates, targetState)) {
      if (bubbles) {
        if (this.parent) {
          this._parent.state(targetState, value, true, source || this);
        }
      } else if (this.options.passStateToChildren) {
        ref = this._children;

        for (j = 0, len = ref.length; j < len; j++) {
          child = ref[j];
          child.state(targetState, value, false, source || this);
        }
      }
    }

    return this;
  }
};

var toggleState = function toggleState(targetState) {
  return this.state(targetState, !this.state(targetState));
};

var resetState = function resetState() {
  var activeState, j, len, ref;
  ref = this._state.slice();

  for (j = 0, len = ref.length; j < len; j++) {
    activeState = ref[j];
    this.state(activeState, false);
  }

  return this;
};

var pipeState = function pipeState(targetEl) {
  var activeState, j, len, ref;

  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl) && targetEl !== this) {
      this._statePipeTarget = targetEl;
      ref = this._state;

      for (j = 0, len = ref.length; j < len; j++) {
        activeState = ref[j];
        targetEl.state(activeState, true);
      }
    }
  } else if (targetEl === false) {
    delete this._statePipeTarget;
  }

  return this;
};

var _applyRegisteredStyle = function _applyRegisteredStyle(targetStyle, superiorStates, includeBase, skipFns) {
  var className, entry, j, k, len, len1, ref, ref1, superiorStyles;

  if (targetStyle) {
    ref = targetStyle.className;

    for (j = 0, len = ref.length; j < len; j++) {
      className = ref[j];
      this.addClass(className);
    }

    if (targetStyle.fns.length && !skipFns) {
      if (superiorStates) {
        superiorStyles = this._resolveFnStyles(superiorStates, includeBase);
      }

      ref1 = targetStyle.fns;

      for (k = 0, len1 = ref1.length; k < len1; k++) {
        entry = ref1[k];

        if (!(superiorStyles && superiorStyles[entry[0]])) {
          this.style(entry[0], entry[1]);
        }
      }
    }
  }
};

var _removeRegisteredStyle = function _removeRegisteredStyle(targetStyle, superiorStates, includeBase) {
  var className, entry, j, k, len, len1, ref, ref1, resetValue, superiorStyles;
  ref = targetStyle.className;

  for (j = 0, len = ref.length; j < len; j++) {
    className = ref[j];
    this.removeClass(className);
  }

  if (targetStyle.fns.length) {
    if (superiorStates) {
      superiorStyles = this._resolveFnStyles(superiorStates, includeBase);
    }

    ref1 = targetStyle.fns;

    for (k = 0, len1 = ref1.length; k < len1; k++) {
      entry = ref1[k];
      resetValue = superiorStyles && superiorStyles[entry[0]] || null;
      this.style(entry[0], resetValue);
    }
  }
};

var _turnStyleON = function _turnStyleON(targetState, activeStates) {
  var j, len, sharedStates, skipFns, stateChain;
  skipFns = this.options.styleAfterInsert && !this._inserted;

  if (this._styles[targetState]) {
    this._applyRegisteredStyle(this._styles[targetState], this._getSuperiorStates(targetState, activeStates), false, skipFns);
  }

  if (this._providedStatesShared) {
    sharedStates = this._getSharedStates(targetState);

    for (j = 0, len = sharedStates.length; j < len; j++) {
      stateChain = sharedStates[j];

      if (!includes$1(this._stateShared, stateChain.string)) {
        this._stateShared.push(stateChain.string);
      }

      this._applyRegisteredStyle(this._styles[stateChain.string], null, null, skipFns);
    }
  }
};

var _turnStyleOFF = function _turnStyleOFF(targetState, activeStates) {
  var activeSharedStates, j, len, sharedStates, stateChain, targetStyle;

  if (this._styles[targetState]) {
    this._removeRegisteredStyle(this._styles[targetState], activeStates, true);
  }

  if (this._providedStatesShared) {
    sharedStates = this._getSharedStates(targetState);

    if (sharedStates.length === 0) {
      return;
    }

    for (j = 0, len = sharedStates.length; j < len; j++) {
      stateChain = sharedStates[j];
      removeItem(this._stateShared, stateChain.string);
      targetStyle = this._styles[stateChain.string];

      if (targetStyle.fns.length && this._stateShared.length && !activeSharedStates) {
        activeSharedStates = this._stateShared.filter(function (state) {
          return !includes$1(state, targetState);
        });
        activeStates = activeStates.concat(activeSharedStates);
      }

      this._removeRegisteredStyle(targetStyle, activeStates, true);
    }
  }
};

var _turnTextON = function _turnTextON(targetState, activeStates) {
  var superiorStates, targetText;

  if (this._texts && IS$1.string(targetText = this._texts[targetState])) {
    superiorStates = this._getSuperiorStates(targetState, activeStates);

    if (!superiorStates.length) {
      this.text = targetText;
    }
  }
};

var _turnTextOFF = function _turnTextOFF(targetState, activeStates) {
  var targetText;

  if (this._texts && IS$1.string(targetText = this._texts[targetState])) {
    activeStates = activeStates.filter(function (state) {
      return state !== targetState;
    });
    targetText = this._texts[activeStates[activeStates.length - 1]];

    if (targetText == null) {
      targetText = this._texts.base;
    }

    this.text = targetText;
  }
};

var _getActiveStates = function _getActiveStates(stateToExclude) {
  var includeSharedStates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var activeStates, j, len, plainStates;

  if (!this._providedStates) {
    return DUMMY_ARRAY;
  }

  activeStates = plainStates = this._state;

  if (stateToExclude) {
    plainStates = [];

    for (j = 0, len = activeStates.length; j < len; j++) {
      state = activeStates[j];

      if (state !== stateToExclude) {
        plainStates.push(state);
      }
    }
  }

  if (!includeSharedStates || !this._providedStatesShared) {
    return plainStates;
  } else {
    return plainStates.concat(this._stateShared);
  }
};

var _getSuperiorStates = function _getSuperiorStates(targetState, activeStates) {
  var candidate, j, len, superior, targetStateIndex;
  targetStateIndex = this._providedStates.indexOf(targetState);

  if (targetStateIndex === this._providedStates.length - 1) {
    return DUMMY_ARRAY;
  }

  superior = [];

  for (j = 0, len = activeStates.length; j < len; j++) {
    candidate = activeStates[j];

    if (this._providedStates.indexOf(candidate) > targetStateIndex) {
      superior.push(candidate);
    }
  }

  return superior;
};

var _getSharedStates = function _getSharedStates(targetState) {
  var activeStates, j, len, ref, sharedStates, stateChain;
  activeStates = this._state;
  sharedStates = [];
  ref = this._providedStatesShared;

  for (j = 0, len = ref.length; j < len; j++) {
    stateChain = ref[j];

    if (stateChain.includes(targetState) && stateChain.isApplicable(targetState, activeStates)) {
      sharedStates.push(stateChain);
    }
  }

  return sharedStates;
};

var _resolveFnStyles = function _resolveFnStyles(states, includeBase) {
  var entry, j, k, len, len1, output, ref;

  if (includeBase) {
    states = ['base'].concat(states);
  }

  output = {};

  for (j = 0, len = states.length; j < len; j++) {
    state = states[j];

    if (this._styles[state] && this._styles[state].fns.length) {
      ref = this._styles[state].fns;

      for (k = 0, len1 = ref.length; k < len1; k++) {
        entry = ref[k];
        output[entry[0]] = entry[1];
      }
    }
  }

  return output;
};

function state$1(QuickElement) {
  QuickElement.prototype.state = state;
  QuickElement.prototype.toggleState = toggleState;
  QuickElement.prototype.resetState = resetState;
  QuickElement.prototype.pipeState = pipeState;
  QuickElement.prototype._applyRegisteredStyle = _applyRegisteredStyle;
  QuickElement.prototype._removeRegisteredStyle = _removeRegisteredStyle;
  QuickElement.prototype._turnStyleON = _turnStyleON;
  QuickElement.prototype._turnStyleOFF = _turnStyleOFF;
  QuickElement.prototype._turnTextON = _turnTextON;
  QuickElement.prototype._turnTextOFF = _turnTextOFF;
  QuickElement.prototype._getActiveStates = _getActiveStates;
  QuickElement.prototype._getSuperiorStates = _getSuperiorStates;
  QuickElement.prototype._getSharedStates = _getSharedStates;
  return QuickElement.prototype._resolveFnStyles = _resolveFnStyles;
}

var toTemplate = function toTemplate() {
  return _quickdom.template(this);
};

var clone = function clone() {
  var activeState, callback, callbacks, child, elClone, eventName, i, j, k, len, len1, len2, newEl, options, ref, ref1, ref2;
  elClone = this.el.cloneNode(false);
  options = primaryBuilder$1.clone(this.options, {
    existing: elClone
  });
  newEl = new this.constructor(this.type, options);
  ref = this._state;

  for (i = 0, len = ref.length; i < len; i++) {
    activeState = ref[i];
    newEl.state(activeState, true);
  }

  ref1 = this.children;

  for (j = 0, len1 = ref1.length; j < len1; j++) {
    child = ref1[j];
    newEl.append(child.clone());
  }

  ref2 = this._eventCallbacks;

  for (eventName in ref2) {
    callbacks = ref2[eventName];

    for (k = 0, len2 = callbacks.length; k < len2; k++) {
      callback = callbacks[k];
      newEl.on(eventName, callback);
    }
  }

  return newEl;
};

var append = function append(targetEl) {
  var prevParent;

  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      prevParent = targetEl.parent;

      if (prevParent) {
        prevParent._removeChild(targetEl);
      }

      this._children.push(targetEl);

      this.el.appendChild(targetEl.el);

      targetEl._refreshParent(); // Force re-fresh targetEl._parent value to trigger inserted callback

    }
  }

  return this;
};

var appendTo = function appendTo(targetEl) {
  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      targetEl.append(this);
    }
  }

  return this;
};

var prepend = function prepend(targetEl) {
  var prevParent;

  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      prevParent = targetEl.parent;

      if (prevParent) {
        prevParent._removeChild(targetEl);
      }

      this._children.unshift(targetEl);

      this.el.insertBefore(targetEl.el, this.el.firstChild);

      targetEl._refreshParent(); // Force re-fresh targetEl._parent value to trigger inserted callback

    }
  }

  return this;
};

var prependTo = function prependTo(targetEl) {
  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      targetEl.prepend(this);
    }
  }

  return this;
};

var after = function after(targetEl) {
  var myIndex;

  if (targetEl && this.parent) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      myIndex = this.parent._children.indexOf(this);

      this.parent._children.splice(myIndex + 1, 0, targetEl);

      this.el.parentNode.insertBefore(targetEl.el, this.el.nextSibling);

      targetEl._refreshParent(); // Force re-fresh targetEl._parent value to trigger inserted callback

    }
  }

  return this;
};

var insertAfter = function insertAfter(targetEl) {
  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      targetEl.after(this);
    }
  }

  return this;
};

var before = function before(targetEl) {
  var myIndex;

  if (targetEl && this.parent) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      myIndex = this.parent._children.indexOf(this);

      this.parent._children.splice(myIndex, 0, targetEl);

      this.el.parentNode.insertBefore(targetEl.el, this.el);

      targetEl._refreshParent(); // Force re-fresh targetEl._parent value to trigger inserted callback

    }
  }

  return this;
};

var insertBefore = function insertBefore(targetEl) {
  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl)) {
      targetEl.before(this);
    }
  }

  return this;
};

var detach = function detach() {
  var ref;

  if ((ref = this.parent) != null) {
    ref._removeChild(this);
  }

  return this;
};

var remove = function remove() {
  var eventName;
  this.detach();
  this.resetState();

  if (this._eventCallbacks) {
    for (eventName in this._eventCallbacks) {
      this._eventCallbacks[eventName].length = 0;
    }
  }

  return this;
};

var empty = function empty() {
  var child, i, len, ref;
  ref = this.children.slice();

  for (i = 0, len = ref.length; i < len; i++) {
    child = ref[i];

    this._removeChild(child);
  }

  return this;
};

var wrap = function wrap(targetEl) {
  var currentParent;

  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);
    currentParent = this.parent;

    if (IS$1.quickDomEl(targetEl) && targetEl !== this && targetEl !== this.parent) {
      if (currentParent) {
        currentParent._removeChild(this, !targetEl.parent ? targetEl : void 0);
      }

      targetEl.append(this);
    }
  }

  return this;
};

var unwrap = function unwrap() {
  var grandParent, parent, parentChildren, parentSibling;
  parent = this.parent;

  if (parent) {
    parentChildren = _quickdom.batch(parent.children);
    parentSibling = parent.next;
    grandParent = parent.parent;

    if (grandParent) {
      parent.detach();

      if (parentSibling) {
        parentChildren.insertBefore(parentSibling);
      } else {
        parentChildren.appendTo(grandParent);
      }
    }
  }

  return this;
};

var replace = function replace(targetEl) {
  var ref;

  if (targetEl) {
    targetEl = normalizeElementArg(targetEl);

    if (IS$1.quickDomEl(targetEl) && targetEl !== this) {
      targetEl.detach();

      if ((ref = this.parent) != null) {
        ref._removeChild(this, targetEl);
      }

      targetEl._refreshParent(); // Force re-fresh targetEl._parent value to trigger inserted callback

    }
  }

  return this;
};

var hasClass = function hasClass(target) {
  return includes$1(this.classList, target);
};

var addClass = function addClass(target) {
  var classList, targetIndex;
  classList = this.classList;
  targetIndex = classList.indexOf(target);

  if (targetIndex === -1) {
    classList.push(target);
    this.className = classList.length > 1 ? classList.join(' ') : classList[0];
  }

  return this;
};

var removeClass = function removeClass(target) {
  var classList, targetIndex;
  classList = this.classList;
  targetIndex = classList.indexOf(target);

  if (targetIndex !== -1) {
    classList.splice(targetIndex, 1);
    this.className = classList.length ? classList.join(' ') : '';
  }

  return this;
};

var toggleClass = function toggleClass(target) {
  if (this.hasClass(target)) {
    this.removeClass(target);
  } else {
    this.addClass(target);
  }

  return this;
};

var setRef = function setRef(target) {
  this.ref = this.options.ref = target;
  this.attr('data-ref', target);
  return this;
};

var _refreshParent = function _refreshParent() {
  return this.parent;
};

var _removeChild = function _removeChild(targetChild, replacementChild) {
  var indexOfChild;
  indexOfChild = this.children.indexOf(targetChild);

  if (indexOfChild !== -1) {
    if (replacementChild) {
      this.el.replaceChild(replacementChild.el, targetChild.el);

      this._children.splice(indexOfChild, 1, replacementChild);
    } else {
      this.el.removeChild(targetChild.el);

      this._children.splice(indexOfChild, 1);
    }
  }

  return this;
};

function manipulation(QuickElement) {
  Object.defineProperties(QuickElement.prototype, {
    'html': {
      get: function get() {
        return this.el.innerHTML;
      },
      set: function set(newValue) {
        return this.el.innerHTML = newValue;
      }
    },
    'text': {
      get: function get() {
        return this.el.textContent;
      },
      set: function set(newValue) {
        return this.el.textContent = newValue;
      }
    },
    'className': {
      get: function get() {
        if (this.svg) {
          return this.attr('class') || '';
        } else {
          return this.raw.className;
        }
      },
      set: function set(newValue) {
        if (this.svg) {
          return this.attr('class', newValue);
        } else {
          return this.raw.className = newValue;
        }
      }
    },
    'classList': {
      get: function get() {
        var list;
        list = this.className.split(/\s+/);

        if (list[list.length - 1] === '') {
          list.pop();
        }

        if (list[0] === '') {
          list.shift();
        }

        return list;
      }
    }
  });
  QuickElement.prototype.toTemplate = toTemplate;
  QuickElement.prototype.clone = clone;
  QuickElement.prototype.append = append;
  QuickElement.prototype.appendTo = appendTo;
  QuickElement.prototype.prepend = prepend;
  QuickElement.prototype.prependTo = prependTo;
  QuickElement.prototype.after = after;
  QuickElement.prototype.insertAfter = insertAfter;
  QuickElement.prototype.before = before;
  QuickElement.prototype.insertBefore = insertBefore;
  QuickElement.prototype.detach = detach;
  QuickElement.prototype.remove = remove;
  QuickElement.prototype.empty = empty;
  QuickElement.prototype.wrap = wrap;
  QuickElement.prototype.unwrap = unwrap;
  QuickElement.prototype.replace = replace;
  QuickElement.prototype.hasClass = hasClass;
  QuickElement.prototype.addClass = addClass;
  QuickElement.prototype.removeClass = removeClass;
  QuickElement.prototype.toggleClass = toggleClass;
  QuickElement.prototype.setRef = setRef;
  QuickElement.prototype._refreshParent = _refreshParent;
  return QuickElement.prototype._removeChild = _removeChild;
}

var updateOptions = function updateOptions(options) {
  if (IS$1.object(options)) {
    this.options = options;

    this._normalizeOptions();

    this._applyOptions(this.options);
  }

  return this;
};

var updateStateStyles = function updateStateStyles(styles) {
  var i, len, parsed, state, updatedStates;

  if (IS$1.objectPlain(styles)) {
    primaryBuilder$1.deep.concat(this, parsed = this._parseStyles(styles));

    if (parsed._styles) {
      updatedStates = Object.keys(parsed._styles);

      for (i = 0, len = updatedStates.length; i < len; i++) {
        state = updatedStates[i];

        if (this.state(state) || state === 'base') {
          this._applyRegisteredStyle(this._styles[state], this._getActiveStates(state), false);
        }
      }
    }
  }

  return this;
};

var updateStateTexts = function updateStateTexts(texts) {
  var parsed;

  if (IS$1.objectPlain(texts)) {
    primaryBuilder$1.deep.concat(this, parsed = this._parseTexts(texts));
  }

  return this;
};

var applyData = function applyData(data, passThrough) {
  var child, computers, defaults, i, j, key, keys, len, len1, ref;

  if (this.options.passDataToChildren && this._children.length && (passThrough != null ? passThrough : passThrough = true)) {
    ref = this._children;

    for (i = 0, len = ref.length; i < len; i++) {
      child = ref[i];
      child.applyData(data);
    }
  }

  if (computers = this.options.computers) {
    defaults = this.options.defaults;
    keys = Object.keys(computers);

    for (j = 0, len1 = keys.length; j < len1; j++) {
      key = keys[j];

      if (this.options.invokeComputersOnce) {
        if (this._invokedComputers[key]) {
          continue;
        }

        this._invokedComputers[key] = 1;
      }

      if (data && data.hasOwnProperty(key)) {
        this._runComputer(key, data[key], data);
      } else if (defaults && defaults.hasOwnProperty(key)) {
        this._runComputer(key, defaults[key], data);
      }
    }
  }

  return this;
};

var _runComputer = function _runComputer(computer, arg, data) {
  return this.options.computers[computer].call(this, arg, data);
};

function application(QuickElement) {
  QuickElement.prototype.updateOptions = updateOptions;
  QuickElement.prototype.updateStateStyles = updateStateStyles;
  QuickElement.prototype.updateStateTexts = updateStateTexts;
  QuickElement.prototype.applyData = applyData;
  return QuickElement.prototype._runComputer = _runComputer;
}

var attr = function attr(target, newValue) {
  var i, key, keys;

  if (arguments.length === 1) {
    if (typeof target === 'string') {
      return this.el.getAttribute(target);
    }

    if (IS$1.object(target)) {
      keys = Object.keys(target);
      i = -1;

      while (key = keys[++i]) {
        this.attr(key, target[key]);
      }
    }
  } else if (newValue === null) {
    return this.el.removeAttribute(target);
  } else {
    this.el.setAttribute(target, newValue);
  }

  return this;
};

var prop = function prop(target, newValue) {
  var i, key, keys;

  if (arguments.length === 1) {
    if (typeof target === 'string') {
      return this.el[target];
    }

    if (IS$1.object(target)) {
      keys = Object.keys(target);
      i = -1;

      while (key = keys[++i]) {
        this.prop(key, target[key]);
      }
    }
  } else {
    this.el[target] = newValue;
  }

  return this;
};

function attributesAndProperties(QuickElement) {
  QuickElement.prototype.attr = attr;
  return QuickElement.prototype.prop = prop;
}

var QuickElement$1, svgNamespace;
svgNamespace = 'http://www.w3.org/2000/svg';

var QuickElement$2 = QuickElement$1 = function () {
  var QuickElement =
  /*#__PURE__*/
  function () {
    function QuickElement(type, options) {
      _classCallCheck(this, QuickElement);

      this.type = type;
      this.options = options;
      QuickElement.count++;

      if (this.type[0] === '*') {
        this.svg = true;
      }

      this.el = this.options.existing || (this.type === 'text' ? document.createTextNode(typeof this.options.text === 'string' ? this.options.text : '') : this.svg ? document.createElementNS(svgNamespace, this.type.slice(1)) : document.createElement(this.type));

      if (this.type === 'text') {
        this.append = this.prepend = this.attr = function () {};
      } // @_texts = {} # defined conditionally


      this._parent = null;
      this._styles = {};
      this._state = [];
      this._children = []; // @_providedStates = []				# defined conditionally
      // @_providedStatesShared = []		# defined conditionally
      // @_eventCallbacks = {__refs:{}}	# defined conditionally

      this._normalizeOptions();

      this._applyOptions();

      this._attachStateEvents();

      this._proxyParent();

      if (this.options.existing) {
        this._refreshParent();
      }

      this.el._quickElement = this;
    }

    _createClass(QuickElement, [{
      key: "toJSON",
      value: function toJSON() {
        var child, children, i, len, output;
        output = [this.type, primaryBuilder$1.clone.keys(element)(this.options)];
        children = this.children;

        for (i = 0, len = children.length; i < len; i++) {
          child = children[i];
          output.push(child.toJSON());
        }

        return output;
      }
    }]);

    return QuickElement;
  }();

  QuickElement.count = 0;
  return QuickElement;
}.call(undefined);
/* istanbul ignore next */


if (QuickElement$1.name == null) {
  QuickElement$1.name = 'QuickElement';
}

init$1(QuickElement$1);
aliases(QuickElement$1);
traversing(QuickElement$1);
events(QuickElement$1);
state$1(QuickElement$1);
style$1(QuickElement$1);
manipulation(QuickElement$1);
application(QuickElement$1);
attributesAndProperties(QuickElement$1);
var schema = {
  type: 'div',
  ref: void 0,
  options: {},
  children: []
};

var matchesSchema = function matchesSchema(object) {
  return typeof object.type !== 'undefined' || typeof object.ref !== 'undefined' || typeof object.options !== 'undefined' || typeof object.children !== 'undefined';
};

var PARSE_ERROR_PREFIX, parseTree;
PARSE_ERROR_PREFIX = 'Template Parse Error: expected';

var parseTree$1 = parseTree = function parseTree(tree, parseChildren) {
  var output;

  switch (false) {
    case !IS$1.array(tree):
      output = {};

      if (!IS$1.string(tree[0])) {
        throw new Error("".concat(PARSE_ERROR_PREFIX, " string for 'type', got '").concat(String(tree[0]), "'"));
      } else {
        output.type = tree[0];
      }

      if (tree.length > 1 && !IS$1.object(tree[1]) && tree[1] !== null) {
        throw new Error("".concat(PARSE_ERROR_PREFIX, " object for 'options', got '").concat(String(tree[1]), "'"));
      } else {
        output.options = tree[1] ? primaryBuilder$1.deep.clone(tree[1]) : schema.options;

        if (tree[1]) {
          output.ref = tree[1].id || tree[1].ref;
        }
      }

      output.children = tree.slice(2);

      if (parseChildren === false) {
        if (tree.length === 3 && IS$1.objectPlain(tree[2]) && !IS$1.template(tree[2])) {
          output.children = tree[2];
        }
      } else {
        output.children = output.children.map(quickdom.template);
      }

      return output;

    case !(IS$1.string(tree) || IS$1.domText(tree)):
      return {
        type: 'text',
        options: {
          text: tree.textContent || tree
        },
        children: schema.children
      };

    case !IS$1.domEl(tree):
      return {
        type: tree.nodeName.toLowerCase(),
        ref: tree.id,
        options: primaryBuilder$1.clone.keys(template)(tree),
        children: schema.children.map.call(tree.childNodes, quickdom.template)
      };

    case !IS$1.quickDomEl(tree):
      return {
        type: tree.type,
        ref: tree.ref,
        options: primaryBuilder$1.clone.deep.notKeys(['relatedInstance', 'related'])(tree.options),
        children: tree.children.map(quickdom.template)
      };

    case !IS$1.template(tree):
      return tree;

    default:
      throw new Error("".concat(PARSE_ERROR_PREFIX, " (array || string || domEl || quickDomEl || template), got ").concat(String(tree)));
  }
};

var NOT_DEEP_KEYS, NOT_KEYS, _extendByRef, extendTemplate;

NOT_DEEP_KEYS = ['relatedInstance', 'related', 'data'];
NOT_KEYS = ['children', '_childRefs'];

var extendTemplate$1 = extendTemplate = function extendTemplate(currentOpts, newOpts, globalOpts) {
  var currentChild, currentChildren, globalOptsTransform, index, maxLength, needsTemplateWrap, newChild, newChildProcessed, newChildren, noChanges, output, ref, remainingNewChildren;

  if (globalOpts) {
    globalOptsTransform = {
      options: function options(opts) {
        return primaryBuilder$1(opts, globalOpts);
      }
    };
  }

  if (IS$1.array(newOpts)) {
    newOpts = parseTree$1(newOpts, false);
  } else if (newOpts && !matchesSchema(newOpts)) {
    newOpts = {
      options: newOpts
    };
  }

  output = primaryBuilder$1.deep.nullDeletes.notKeys(NOT_KEYS).notDeep(NOT_DEEP_KEYS).transform(globalOptsTransform).clone(currentOpts, newOpts);
  currentChildren = currentOpts.children;
  newChildren = (newOpts != null ? newOpts.children : void 0) || [];
  output.children = [];
  /* istanbul ignore next */

  if (IS$1.array(newChildren)) {
    maxLength = Math.max(currentChildren.length, newChildren.length);
    index = -1;

    while (++index !== maxLength) {
      needsTemplateWrap = noChanges = false;
      currentChild = currentChildren[index];
      newChild = newChildren[index];

      newChildProcessed = function () {
        switch (false) {
          case !IS$1.template(newChild):
            return newChild;

          case !IS$1.array(newChild):
            return needsTemplateWrap = parseTree$1(newChild);

          case !IS$1.string(newChild):
            return needsTemplateWrap = {
              type: 'text',
              options: {
                text: newChild
              }
            };

          case !(!newChild && !globalOpts):
            return noChanges = true;

          default:
            return needsTemplateWrap = newChild || true;
        }
      }();

      if (noChanges) {
        newChildProcessed = currentChild;
      } else if (needsTemplateWrap) {
        newChildProcessed = currentChild ? currentChild.extend(newChildProcessed, globalOpts) : new QuickTemplate$1(primaryBuilder$1.clone(schema, newChildProcessed));
      }

      output.children.push(newChildProcessed);
    }
  } else if (IS$1.object(newChildren)) {
    newChildren = primaryBuilder$1.allowNull.clone(newChildren);
    output.children = _extendByRef(newChildren, currentChildren, globalOpts);
    remainingNewChildren = newChildren;

    for (ref in remainingNewChildren) {
      newChild = remainingNewChildren[ref];
      newChildProcessed = IS$1.objectPlain(newChild) && !IS$1.template(newChild) ? newChild : parseTree$1(newChild);
      output.children.push(new QuickTemplate$1(newChildProcessed));
      delete remainingNewChildren[ref];
    }
  }

  return output;
};

_extendByRef = function extendByRef(newChildrenRefs, currentChildren, globalOpts) {
  var currentChild, i, len, newChild, newChildProcessed, output;

  if (!currentChildren.length) {
    return currentChildren;
  } else {
    output = [];

    for (i = 0, len = currentChildren.length; i < len; i++) {
      currentChild = currentChildren[i];
      newChild = newChildrenRefs[currentChild.ref];

      if (newChild) {
        newChildProcessed = currentChild.extend(newChild, globalOpts);
        delete newChildrenRefs[currentChild.ref];
      } else if (newChild === null) {
        delete newChildrenRefs[currentChild.ref];
        continue;
      } else {
        newChildProcessed = function () {
          switch (false) {
            case !globalOpts:
              return currentChild.extend(null, globalOpts);

            case !Object.keys(newChildrenRefs).length:
              return currentChild.extend();

            default:
              return currentChild;
          }
        }();
      }

      newChildProcessed.children = _extendByRef(newChildrenRefs, newChildProcessed.children);
      output.push(newChildProcessed);
    }

    return output;
  }
};

var QuickTemplate;

var QuickTemplate$1 = QuickTemplate =
/*#__PURE__*/
function () {
  function QuickTemplate(config, isTree) {
    _classCallCheck(this, QuickTemplate);

    if (IS$1.template(config)) {
      return config;
    }

    config = isTree ? parseTree$1(config) : config;
    primaryBuilder$1(this, config);
  }

  _createClass(QuickTemplate, [{
    key: "extend",
    value: function extend(newValues, globalOpts) {
      return new QuickTemplate(extendTemplate$1(this, newValues, globalOpts));
    }
  }, {
    key: "spawn",
    value: function spawn(newValues, globalOpts, data) {
      var child, childData, children, element, i, len, options, type;

      if (newValues && newValues.data) {
        data = newValues.data;

        if (Object.keys(newValues).length === 1) {
          newValues = null;
        }
      }

      if (newValues || globalOpts) {
        var _extendTemplate = extendTemplate$1(this, newValues, globalOpts);

        options = _extendTemplate.options;
        children = _extendTemplate.children;
        type = _extendTemplate.type;
      } else {
        options = this.options;
        children = this.children;
        type = this.type;
        options = primaryBuilder$1.clone(options);
      }

      element = _quickdom.create([type, options]);

      if (children) {
        childData = options.passDataToChildren ? data || options.data : void 0;

        for (i = 0, len = children.length; i < len; i++) {
          child = children[i];
          element.append(child.spawn(null, null, childData));
        }
      }

      element._postCreation(data);

      return element;
    }
  }]);

  return QuickTemplate;
}();
/* istanbul ignore next */


if (QuickTemplate.name == null) {
  QuickTemplate.name = 'QuickTemplate';
}

Object.defineProperty(QuickTemplate.prototype, 'child', {
  get: function get() {
    return this._childRefs || _getChildRefs(this);
  }
});

_quickdom.template = function (tree) {
  return new QuickTemplate(tree, true);
};

_quickdom.isTemplate = function (target) {
  return IS$1.template(target);
};

var QuickBatch;

var QuickBatch$1 = QuickBatch =
/*#__PURE__*/
function () {
  function QuickBatch(elements, returnResults1) {
    _classCallCheck(this, QuickBatch);

    this.returnResults = returnResults1;
    this.elements = elements.map(function (el) {
      return _quickdom(el);
    });
  }

  _createClass(QuickBatch, [{
    key: "reverse",
    value: function reverse() {
      this.elements = this.elements.reverse();
      return this;
    }
  }, {
    key: "return",
    value: function _return(returnNext) {
      if (returnNext) {
        this.returnResults = true;
        return this;
      } else {
        return this.lastResults;
      }
    }
  }]);

  return QuickBatch;
}();
/* istanbul ignore next */


if (QuickBatch.name == null) {
  QuickBatch.name = 'QuickBatch';
}

Object.keys(QuickElement$2.prototype).concat('css', 'replaceWith', 'html', 'text').forEach(function (method) {
  return QuickBatch.prototype[method] = function (newValue) {
    var element, results;

    results = this.lastResults = function () {
      var i, len, ref, results1;
      ref = this.elements;
      results1 = [];

      for (i = 0, len = ref.length; i < len; i++) {
        element = ref[i];

        if (method === 'html' || method === 'text') {
          if (newValue) {
            results1.push(element[method] = newValue);
          } else {
            results1.push(element[method]);
          }
        } else {
          var _element;

          results1.push((_element = element)[method].apply(_element, arguments));
        }
      }

      return results1;
    }.apply(this, arguments);

    if (this.returnResults) {
      return results;
    } else {
      return this;
    }
  };
});

_quickdom.batch = function (elements, returnResults) {
  if (!IS$1.iterable(elements)) {
    throw new Error("Batch: expected an iterable, got ".concat(String(elements)));
  }

  return new QuickBatch(elements, returnResults);
};

var version$2 = "1.0.92";
var SHORTCUTS, i, len, shortcut;
SHORTCUTS = ['link:a', 'anchor:a', 'a', 'text', 'div', 'span', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'footer', 'section', 'button', 'br', 'ul', 'ol', 'li', 'fieldset', 'input', 'textarea', 'select', 'option', 'form', 'frame', 'hr', 'iframe', 'img', 'picture', 'main', 'nav', 'meta', 'object', 'pre', 'style', 'table', 'tbody', 'th', 'tr', 'td', 'tfoot', // 'template'
'video'];

for (i = 0, len = SHORTCUTS.length; i < len; i++) {
  shortcut = SHORTCUTS[i];

  (function (shortcut) {
    var prop, split, type;
    prop = type = shortcut;

    if (includes$1(shortcut, ':')) {
      split = shortcut.split(':');
      prop = split[0];
      type = split[1];
    }

    return _quickdom[prop] = function () {
      return _quickdom.apply(void 0, [type].concat(Array.prototype.slice.call(arguments)));
    };
  })(shortcut);
}

init(QuickElement$2, QuickWindow$2);
_quickdom.QuickElement = QuickElement$2;
_quickdom.QuickTemplate = QuickTemplate$1;
_quickdom.QuickWindow = QuickWindow$2;
_quickdom.QuickBatch = QuickBatch$1;
_quickdom.version = version$2;
_quickdom.CSS = index;
var quickdom = _quickdom; // export {quickdom as default, QuickElement, QuickTemplate, QuickWindow, QuickBatch}
function _typeof$4(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$4 = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof$4 = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof$4(obj);
}

var _extend$1, isArray$1, isObject$1, _shouldDeepExtend$1;

isArray$1 = function isArray(target) {
  return Array.isArray(target);
};

isObject$1 = function isObject(target) {
  return target && Object.prototype.toString.call(target) === '[object Object]' || isArray$1(target);
};

_shouldDeepExtend$1 = function shouldDeepExtend(options, target, parentKey) {
  if (options.deep) {
    if (options.notDeep) {
      return !options.notDeep[target];
    } else {
      return true;
    }
  } else if (options.deepOnly) {
    return options.deepOnly[target] || parentKey && _shouldDeepExtend$1(options, parentKey);
  }
}; // else false


var extend$1 = _extend$1 = function extend(options, target, sources, parentKey) {
  var i, key, len, source, sourceValue, subTarget, targetValue;

  if (!target || _typeof$4(target) !== 'object' && typeof target !== 'function') {
    target = {};
  }

  for (i = 0, len = sources.length; i < len; i++) {
    source = sources[i];

    if (source != null) {
      for (key in source) {
        sourceValue = source[key];
        targetValue = target[key];

        if (sourceValue === target || sourceValue === void 0 || sourceValue === null && !options.allowNull && !options.nullDeletes || options.keys && !options.keys[key] || options.notKeys && options.notKeys[key] || options.own && !source.hasOwnProperty(key) || options.globalFilter && !options.globalFilter(sourceValue, key, source) || options.filters && options.filters[key] && !options.filters[key](sourceValue, key, source)) {
          continue;
        }

        if (sourceValue === null && options.nullDeletes) {
          delete target[key];
          continue;
        }

        if (options.globalTransform) {
          sourceValue = options.globalTransform(sourceValue, key, source);
        }

        if (options.transforms && options.transforms[key]) {
          sourceValue = options.transforms[key](sourceValue, key, source);
        }

        switch (false) {
          case !(options.concat && isArray$1(sourceValue) && isArray$1(targetValue)):
            target[key] = targetValue.concat(sourceValue);
            break;

          case !(_shouldDeepExtend$1(options, key, parentKey) && isObject$1(sourceValue)):
            subTarget = isObject$1(targetValue) ? targetValue : isArray$1(sourceValue) ? [] : {};
            target[key] = _extend$1(options, subTarget, [sourceValue], key);
            break;

          default:
            target[key] = sourceValue;
        }
      }
    }
  }

  return target;
};

var version$3 = "1.7.4";
var modifiers$1, newBuilder$1, normalizeKeys$1, primaryBuilder$2;

normalizeKeys$1 = function normalizeKeys(keys) {
  var i, key, len, output;

  if (keys) {
    output = {};

    if (_typeof$4(keys) !== 'object') {
      output[keys] = true;
    } else {
      if (!Array.isArray(keys)) {
        keys = Object.keys(keys);
      }

      for (i = 0, len = keys.length; i < len; i++) {
        key = keys[i];
        output[key] = true;
      }
    }

    return output;
  }
};

newBuilder$1 = function newBuilder(isBase) {
  var _builder;

  _builder = function builder(target) {
    var theTarget;
    var $_len = arguments.length,
        $_i = -1,
        sources = new Array($_len);

    while (++$_i < $_len) sources[$_i] = arguments[$_i];

    if (_builder.options.target) {
      theTarget = _builder.options.target;
    } else {
      theTarget = target;
      sources.shift();
    }

    return extend$1(_builder.options, theTarget, sources);
  };

  if (isBase) {
    _builder.isBase = true;
  }

  _builder.options = {};
  Object.defineProperties(_builder, modifiers$1);
  return _builder;
};

modifiers$1 = {
  'deep': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder$1() : this;
      _.options.deep = true;
      return _;
    }
  },
  'own': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder$1() : this;
      _.options.own = true;
      return _;
    }
  },
  'allowNull': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder$1() : this;
      _.options.allowNull = true;
      return _;
    }
  },
  'nullDeletes': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder$1() : this;
      _.options.nullDeletes = true;
      return _;
    }
  },
  'concat': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder$1() : this;
      _.options.concat = true;
      return _;
    }
  },
  'clone': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder$1() : this;
      _.options.target = {};
      return _;
    }
  },
  'notDeep': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder$1() : this;
      return function (keys) {
        _.options.notDeep = normalizeKeys$1(keys);
        return _;
      };
    }
  },
  'deepOnly': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder$1() : this;
      return function (keys) {
        _.options.deepOnly = normalizeKeys$1(keys);
        return _;
      };
    }
  },
  'keys': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder$1() : this;
      return function (keys) {
        _.options.keys = normalizeKeys$1(keys);
        return _;
      };
    }
  },
  'notKeys': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder$1() : this;
      return function (keys) {
        _.options.notKeys = normalizeKeys$1(keys);
        return _;
      };
    }
  },
  'transform': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder$1() : this;
      return function (transform) {
        if (typeof transform === 'function') {
          _.options.globalTransform = transform;
        } else if (transform && _typeof$4(transform) === 'object') {
          _.options.transforms = transform;
        }

        return _;
      };
    }
  },
  'filter': {
    get: function get() {
      var _;

      _ = this.isBase ? newBuilder$1() : this;
      return function (filter) {
        if (typeof filter === 'function') {
          _.options.globalFilter = filter;
        } else if (filter && _typeof$4(filter) === 'object') {
          _.options.filters = filter;
        }

        return _;
      };
    }
  }
};
primaryBuilder$2 = newBuilder$1(true);
primaryBuilder$2.version = version$3;
var primaryBuilder$1$1 = primaryBuilder$2;var pFinally = (promise, onFinally) => {
  onFinally = onFinally || (() => {});

  return promise.then(val => new Promise(resolve => {
    resolve(onFinally());
  }).then(() => val), err => new Promise(resolve => {
    resolve(onFinally());
  }).then(() => {
    throw err;
  }));
};class TimeoutError extends Error {
  constructor(message) {
    super(message);
    this.name = 'TimeoutError';
  }

}

var pTimeout = (promise, ms, fallback) => new Promise((resolve, reject) => {
  if (typeof ms !== 'number' || ms < 0) {
    throw new TypeError('Expected `ms` to be a positive number');
  }

  const timer = setTimeout(() => {
    if (typeof fallback === 'function') {
      resolve(fallback());
      return;
    }

    const message = typeof fallback === 'string' ? fallback : `Promise timed out after ${ms} milliseconds`;
    const err = fallback instanceof Error ? fallback : new TimeoutError(message);
    reject(err);
  }, ms);
  pFinally(promise.then(resolve, reject), () => {
    clearTimeout(timer);
  });
});

var TimeoutError_1 = TimeoutError;
pTimeout.TimeoutError = TimeoutError_1;var pEvent = (emitter, event, opts) => {
  let cancel;
  const ret = new Promise((resolve, reject) => {
    if (typeof opts === 'function') {
      opts = {
        filter: opts
      };
    }

    opts = Object.assign({
      rejectionEvents: ['error'],
      multiArgs: false
    }, opts);
    let addListener = emitter.on || emitter.addListener || emitter.addEventListener;
    let removeListener = emitter.off || emitter.removeListener || emitter.removeEventListener;

    if (!addListener || !removeListener) {
      throw new TypeError('Emitter is not compatible');
    }

    addListener = addListener.bind(emitter);
    removeListener = removeListener.bind(emitter);

    const resolveHandler = function (value) {
      if (opts.multiArgs) {
        value = [].slice.apply(arguments);
      }

      if (opts.filter && !opts.filter(value)) {
        return;
      }

      cancel();
      resolve(value);
    };

    const rejectHandler = function (reason) {
      cancel();

      if (opts.multiArgs) {
        reject([].slice.apply(arguments));
      } else {
        reject(reason);
      }
    };

    cancel = () => {
      removeListener(event, resolveHandler);

      for (const rejectionEvent of opts.rejectionEvents) {
        removeListener(rejectionEvent, rejectHandler);
      }
    };

    addListener(event, resolveHandler);

    for (const rejectionEvent of opts.rejectionEvents) {
      addListener(rejectionEvent, rejectHandler);
    }
  });
  ret.cancel = cancel;

  if (typeof opts.timeout === 'number') {
    return pTimeout(ret, opts.timeout);
  }

  return ret;
};function createEndBreak(value) {
  var instance = Object.create(Error.prototype);
  instance.value = value;
  instance.__isEndBreak = true;
  return instance;
}

var promiseBreak = function (val) {
  var err = createEndBreak(val);
  throw err;
};

var end = function (err) {
  if (err.__isEndBreak) {
    return err.value;
  }

  throw err;
};
promiseBreak.end = end;function _typeof$5(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$5 = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof$5 = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof$5(obj);
}

function _classCallCheck$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties$2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties$2(Constructor, staticProps);
  return Constructor;
}

var defined$1 = function defined(subject) {
  return subject !== void 0;
};

var array$1 = function array(subject) {
  return subject instanceof Array;
};

var object$1 = function object(subject) {
  return _typeof$5(subject) === 'object' && subject; // 2nd check is to test against 'null' values
};

var objectPlain$1 = function objectPlain(subject) {
  return object$1(subject) && Object.prototype.toString.call(subject) === '[object Object]' && subject.constructor === Object;
};

var string$1 = function string(subject) {
  return typeof subject === 'string';
};

var number$1 = function number(subject) {
  return typeof subject === 'number' && !isNaN(subject);
};

var numberLoose$1 = function numberLoose(subject) {
  return number$1(subject) || string$1(subject) && number$1(Number(subject));
};

var iterable$1 = function iterable(subject) {
  return object$1(subject) && number$1(subject.length);
};

var function_$1 = function function_(subject) {
  return typeof subject === 'function';
};

var natives$1 =
/*#__PURE__*/
Object.freeze({
  defined: defined$1,
  array: array$1,
  object: object$1,
  objectPlain: objectPlain$1,
  string: string$1,
  number: number$1,
  numberLoose: numberLoose$1,
  iterable: iterable$1,
  function_: function_$1
});

var domDoc$1 = function domDoc(subject) {
  return subject && subject.nodeType === 9;
};

var domEl$1 = function domEl(subject) {
  return subject && subject.nodeType === 1;
};

var domText$1 = function domText(subject) {
  return subject && subject.nodeType === 3;
};

var domNode$1 = function domNode(subject) {
  return domEl$1(subject) || domText$1(subject);
};

var domTextarea$1 = function domTextarea(subject) {
  return subject && subject.nodeName === 'TEXTAREA';
};

var domInput$1 = function domInput(subject) {
  return subject && subject.nodeName === 'INPUT';
};

var domSelect$1 = function domSelect(subject) {
  return subject && subject.nodeName === 'SELECT';
};

var domField$1 = function domField(subject) {
  return domInput$1(subject) || domTextarea$1(subject) || domSelect$1(subject);
};

var dom$1 =
/*#__PURE__*/
Object.freeze({
  domDoc: domDoc$1,
  domEl: domEl$1,
  domText: domText$1,
  domNode: domNode$1,
  domTextarea: domTextarea$1,
  domInput: domInput$1,
  domSelect: domSelect$1,
  domField: domField$1
});
var AVAIL_SETS$1, Checks$1;
AVAIL_SETS$1 = {
  natives: natives$1,
  dom: dom$1
};

Checks$1 =
/*#__PURE__*/
function () {
  _createClass$2(Checks, [{
    key: "create",
    value: function create() {
      var args;

      if (arguments.length) {
        args = Array.prototype.slice.call(arguments);
      }

      return new Checks(args);
    }
  }]);

  function Checks(sets) {
    _classCallCheck$2(this, Checks);

    var i, len, set;

    if (sets == null) {
      sets = ['natives'];
    }

    for (i = 0, len = sets.length; i < len; i++) {
      set = sets[i];

      if (AVAIL_SETS$1[set]) {
        this.load(AVAIL_SETS$1[set]);
      }
    }
  }

  _createClass$2(Checks, [{
    key: "load",
    value: function load(set) {
      var key, value;

      if (AVAIL_SETS$1.natives.string(set)) {
        set = AVAIL_SETS$1[set];
      }

      if (!AVAIL_SETS$1.natives.objectPlain(set)) {
        return;
      }

      for (key in set) {
        value = set[key];

        if (key === 'function_') {
          key = 'function';
        }

        this[key] = value;
      }
    }
  }]);

  return Checks;
}();

var index$2 = Checks$1.prototype.create();var detectAnimationEndHelper = function (type) {
  var types;

  if (type && ('transition' === type || 'trans' === type)) {
    types = {
      'OTransition': 'oTransitionEnd',
      'WebkitTransition': 'webkitTransitionEnd',
      'MozTransition': 'transitionend',
      'transition': 'transitionend'
    };
  } else {
    // animation is default
    types = {
      'OAnimation': 'oAnimationEnd',
      'WebkitAnimation': 'webkitAnimationEnd',
      'MozAnimation': 'animationend',
      'animation': 'animationend'
    };
  }

  var elem = document.createElement('fake');
  return Object.keys(types).reduce(function (prev, trans) {
    return undefined !== elem.style[trans] ? types[trans] : prev;
  }, '');
};var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}var eventLite = createCommonjsModule(function (module) {
  /**
   * event-lite.js - Light-weight EventEmitter (less than 1KB when gzipped)
   *
   * @copyright Yusuke Kawasaki
   * @license MIT
   * @constructor
   * @see https://github.com/kawanet/event-lite
   * @see http://kawanet.github.io/event-lite/EventLite.html
   * @example
   * var EventLite = require("event-lite");
   *
   * function MyClass() {...}             // your class
   *
   * EventLite.mixin(MyClass.prototype);  // import event methods
   *
   * var obj = new MyClass();
   * obj.on("foo", function() {...});     // add event listener
   * obj.once("bar", function() {...});   // add one-time event listener
   * obj.emit("foo");                     // dispatch event
   * obj.emit("bar");                     // dispatch another event
   * obj.off("foo");                      // remove event listener
   */
  function EventLite() {
    if (!(this instanceof EventLite)) return new EventLite();
  }

  (function (EventLite) {
    // export the class for node.js
    module.exports = EventLite; // property name to hold listeners

    var LISTENERS = "listeners"; // methods to export

    var methods = {
      on: on,
      once: once,
      off: off,
      emit: emit
    }; // mixin to self

    mixin(EventLite.prototype); // export mixin function

    EventLite.mixin = mixin;
    /**
     * Import on(), once(), off() and emit() methods into target object.
     *
     * @function EventLite.mixin
     * @param target {Prototype}
     */

    function mixin(target) {
      for (var key in methods) {
        target[key] = methods[key];
      }

      return target;
    }
    /**
     * Add an event listener.
     *
     * @function EventLite.prototype.on
     * @param type {string}
     * @param func {Function}
     * @returns {EventLite} Self for method chaining
     */


    function on(type, func) {
      getListeners(this, type).push(func);
      return this;
    }
    /**
     * Add one-time event listener.
     *
     * @function EventLite.prototype.once
     * @param type {string}
     * @param func {Function}
     * @returns {EventLite} Self for method chaining
     */


    function once(type, func) {
      var that = this;
      wrap.originalListener = func;
      getListeners(that, type).push(wrap);
      return that;

      function wrap() {
        off.call(that, type, wrap);
        func.apply(this, arguments);
      }
    }
    /**
     * Remove an event listener.
     *
     * @function EventLite.prototype.off
     * @param [type] {string}
     * @param [func] {Function}
     * @returns {EventLite} Self for method chaining
     */


    function off(type, func) {
      var that = this;
      var listners;

      if (!arguments.length) {
        delete that[LISTENERS];
      } else if (!func) {
        listners = that[LISTENERS];

        if (listners) {
          delete listners[type];
          if (!Object.keys(listners).length) return off.call(that);
        }
      } else {
        listners = getListeners(that, type, true);

        if (listners) {
          listners = listners.filter(ne);
          if (!listners.length) return off.call(that, type);
          that[LISTENERS][type] = listners;
        }
      }

      return that;

      function ne(test) {
        return test !== func && test.originalListener !== func;
      }
    }
    /**
     * Dispatch (trigger) an event.
     *
     * @function EventLite.prototype.emit
     * @param type {string}
     * @param [value] {*}
     * @returns {boolean} True when a listener received the event
     */


    function emit(type, value) {
      var that = this;
      var listeners = getListeners(that, type, true);
      if (!listeners) return false;
      var arglen = arguments.length;

      if (arglen === 1) {
        listeners.forEach(zeroarg);
      } else if (arglen === 2) {
        listeners.forEach(onearg);
      } else {
        var args = Array.prototype.slice.call(arguments, 1);
        listeners.forEach(moreargs);
      }

      return !!listeners.length;

      function zeroarg(func) {
        func.call(that);
      }

      function onearg(func) {
        func.call(that, value);
      }

      function moreargs(func) {
        func.apply(that, args);
      }
    }
    /**
     * @ignore
     */


    function getListeners(that, type, readonly) {
      if (readonly && !that[LISTENERS]) return;
      var listeners = that[LISTENERS] || (that[LISTENERS] = {});
      return listeners[type] || (listeners[type] = []);
    }
  })(EventLite);
});var IS$2;
IS$2 = index$2.create('natives');
IS$2.load({
  'domEl': quickdom.isEl,
  'quickEl': quickdom.isQuickEl,
  'template': quickdom.isTemplate
});
var IS$1$1 = IS$2;
var popup = quickdom.template(['div', {
  ref: 'popup',
  style: {
    position: 'absolute',
    zIndex: 1e4,
    top: 0,
    left: 0,
    width: '100vw',
    height: 0,
    minHeight: '100%',
    visibility: 'hidden',
    overflow: 'hidden',
    transition: function (popup) {
      return `all 0.001s linear ${popup.settings.animation + 1}ms`;
    },
    $open: {
      transition: function () {
        return 'all 0.001s linear 0s';
      },
      visibility: 'visible',
      overflow: 'visible',
      height: 'auto'
    }
  }
}]);
var overlay = quickdom.template(['div', {
  ref: 'overlay',
  style: {
    position: 'fixed',
    zIndex: 1,
    left: 0,
    top: 0,
    width: '100vw',
    minHeight: '100vh',
    opacity: 0,
    backgroundColor: function (popup) {
      return popup.settings.overlayColor;
    },
    transition: function (popup) {
      return `opacity ${popup.settings.animation}ms`;
    },
    $open: {
      opacity: 1
    }
  }
}]);
var content = quickdom.template(['div', {
  ref: 'content',
  style: {
    position: 'absolute',
    zIndex: 2,
    boxSizing: 'border-box',
    maxWidth: '100%',
    margin: '0 auto',
    padding: function (popup) {
      return popup.settings.contentPadding;
    },
    opacity: 0,
    transition: function (popup) {
      var duration;
      duration = popup.settings.animation;
      return `transform ${duration}ms, -webkit-transform ${duration}ms, opacity ${duration}ms`;
    },
    $open: {
      opacity: 1,
      _: 0
    },
    $centerPlacement: {
      left: '50%',
      transform: 'translateX(-50%)'
    },
    $topPlacement: {
      top: 0,
      left: '50%',
      transform: 'translateX(-50%) translateY(-100%)',
      $open: {
        transform: 'translateX(-50%) translateY(0)',
        _: 1
      }
    },
    $bottomPlacement: {
      bottom: 0,
      left: '50%',
      transform: 'translateX(-50%) translateY(100%)',
      $open: {
        transform: 'translateX(-50%) translateY(0)',
        _: 2
      }
    }
  },
  computers: {
    placement: function (placement) {
      return this.state(`${placement}Placement`, true);
    },
    content: function (content) {
      if (content) {
        return this.append(content);
      }
    }
  },
  events: {
    'stateChange:visible': function (visible) {
      if (visible && quickdom(this).related.settings.placement === 'center') {
        return quickdom(this).related.alignToCenter();
      }
    }
  }
}]);
var close = quickdom.template(['div', {
  ref: 'close',
  style: {
    position: 'absolute',
    display: function (popup) {
      if (popup.settings.close.show) {
        return 'block';
      } else {
        return 'none';
      }
    },
    top: function (popup) {
      if (popup.settings.close.inside) {
        return popup.settings.close.padding;
      } else {
        return popup.settings.close.size * 2.5 * -1;
      }
    },
    right: function (popup) {
      if (popup.settings.close.inside) {
        return popup.settings.close.padding;
      } else {
        return 0;
      }
    },
    width: function (popup) {
      return popup.settings.close.size;
    },
    height: function (popup) {
      return popup.settings.close.size;
    },
    color: function (popup) {
      return popup.settings.close.color;
    }
  }
}, ['*svg', {
  attrs: {
    viewBox: "0 0 492 492"
  },
  style: {
    width: '100%',
    height: '100%'
  }
}, ['*path', {
  attrs: {
    d: 'M300.2 246L484.1 62c5.1-5.1 7.9-11.8 7.9-19 0-7.2-2.8-14-7.9-19L468 7.9c-5.1-5.1-11.8-7.9-19-7.9 -7.2 0-14 2.8-19 7.9L246 191.8 62 7.9c-5.1-5.1-11.8-7.9-19-7.9 -7.2 0-14 2.8-19 7.9L7.9 24c-10.5 10.5-10.5 27.6 0 38.1L191.8 246 7.9 430c-5.1 5.1-7.9 11.8-7.9 19 0 7.2 2.8 14 7.9 19l16.1 16.1c5.1 5.1 11.8 7.9 19 7.9 7.2 0 14-2.8 19-7.9l184-184 184 184c5.1 5.1 11.8 7.9 19 7.9h0c7.2 0 14-2.8 19-7.9l16.1-16.1c5.1-5.1 7.9-11.8 7.9-19 0-7.2-2.8-14-7.9-19L300.2 246z'
  },
  style: {
    fill: function (popup) {
      return popup.settings.close.color;
    }
  }
}]]]);
var bodyWrapper = quickdom.template(['div', {
  id: 'bodyWrapper',
  passStateToChildren: false,
  style: {
    $open: {
      position: 'fixed',
      width: '100%',
      top: '0'
    }
  }
}]);
var html = quickdom.template(['div', {
  computers: {
    html: function (html) {
      return this.html = html;
    }
  }
}]);
var templates =
/*#__PURE__*/
Object.freeze({
  popup: popup,
  overlay: overlay,
  content: content,
  close: close,
  bodyWrapper: bodyWrapper,
  html: html
});

var extendSettings = function (defaults, settings) {
  return primaryBuilder$1$1.filter({
    placement: IS$1$1.string,
    template: IS$1$1.objectPlain,
    condition: IS$1$1.function,
    animation: IS$1$1.number,
    overlayColor: IS$1$1.string,
    open: IS$1$1.objectPlain,
    close: IS$1$1.objectPlain,
    triggers: IS$1$1.objectPlain
  }).clone.deep.notDeep('content')(defaults, settings);
};

var scheduleScrollReset = function (scheduleNext) {
  return setTimeout(function () {
    window.scroll(0, 0);

    if (scheduleNext) {
      return setTimeout(function () {
        return scheduleScrollReset();
      }, scheduleNext);
    }
  });
};

var transitionEnd = function () {
  return detectAnimationEndHelper('transition');
};

var scrollOffset = function () {
  return window.scrollY - documentOffset();
};

var documentOffset = function () {
  var ref;
  return (((ref = document.body.getBoundingClientRect()) != null ? ref.top : void 0) || 0) + window.scrollY;
};

var visibilityApiKeys = function () {
  switch (false) {
    case !IS$1$1.defined(document.hidden):
      return {
        hidden: 'hidden',
        visibilitychange: 'visibilitychange'
      };

    case !IS$1$1.defined(document.msHidden):
      return {
        hidden: 'msHidden',
        visibilitychange: 'msvisibilitychange'
      };

    case !IS$1$1.defined(document.webkitHidden):
      return {
        hidden: 'webkitHidden',
        visibilitychange: 'webkitvisibilitychange'
      };

    default:
      return {};
  }
};

var ref;
var isIE = document.all && !window.atob;
var isIE11 = window.navigator.msPointerEnabled;
var isEdge = /Edge/.test(((ref = window.navigator) != null ? ref.userAgent : void 0) || '');
var Popup, body;
body = quickdom(document.body);

Popup = function () {
  class Popup extends eventLite {
    static wrapBody() {
      var bodyChildren, child, i, len, ref1;

      if (!((ref1 = this.bodyWrapper) != null ? ref1.parent : void 0)) {
        this.bodyWrapper = bodyWrapper.spawn();
        bodyChildren = body.children.slice();
        this.bodyWrapper.prependTo(body);

        for (i = 0, len = bodyChildren.length; i < len; i++) {
          child = bodyChildren[i];
          this.bodyWrapper.append(child);
        }
      }
    }

    static unwrapBody() {
      var bodyChildren, child, i, len;

      if (this.bodyWrapper) {
        bodyChildren = this.bodyWrapper.children.slice();

        for (i = 0, len = bodyChildren.length; i < len; i++) {
          child = bodyChildren[i];
          body.append(child);
        }

        this.bodyWrapper.remove();
        return this.bodyWrapper = null;
      }
    }

    static destroyAll() {
      var i, instance, instances, len;
      instances = this.instances.slice();

      for (i = 0, len = instances.length; i < len; i++) {
        instance = instances[i];
        instance.destroy();
      }

      return this.unwrapBody();
    }

    constructor(settings, defaults, template1) {
      super();
      this.template = template1;
      this.settings = extendSettings(defaults, settings);
      this.id = Math.round(Math.random() * 1e5).toString(16);
      this.state = {
        open: false,
        destroyed: false,
        offset: 0,
        count: 0
      };

      if (this.settings.content) {
        this.content = quickdom(this.settings.content);
      }

      Popup.instances.push(this);
      Popup.wrapBody();

      this._createElements();

      this._attachBindings();

      if (this.settings.template && typeof this.settings.template === 'object') {
        this._applyTemplate();
      }

      this.el.prependTo(body);

      if (this.settings.open) {
        this.open();
      }
    }

    _createElements() {
      var close$$1, config, content$$1, data, overlay$$1;
      data = {
        data: {
          content: this.content,
          placement: this.settings.placement
        }
      };
      config = {
        relatedInstance: this
      };
      this.el = this.template.popup.spawn(data, config);
      overlay$$1 = this.template.overlay.spawn(data, config).appendTo(this.el);
      content$$1 = this.template.content.spawn(data, config).appendTo(this.el);

      if (this.settings.close.show) {
        return close$$1 = this.template.close.spawn(data, config).appendTo(content$$1);
      }
    }

    _applyTemplate() {
      var custom, ref;
      custom = this.settings.template;

      for (ref in this.el.child) {
        if (custom[ref]) {
          this.el.child[ref].updateOptions(custom[ref]);
        }
      }
    }

    _attachBindings() {
      var close$$1, hidden, ref1, ref2, visibilitychange;
      close$$1 = this.close.bind(this);
      this.el.child.overlay.on('mouseup touchend', close$$1);

      if ((ref1 = this.el.child.close) != null) {
        ref1.on('mouseup touchend', close$$1);
      }

      if (this.settings.placement === 'center') {
        quickdom(window).on(`resize.${this.id}`, () => {
          if (this.state.open) {
            return this.alignToCenter();
          }
        });
      }

      if (this.settings.triggers.close.esc) {
        quickdom(document).on(`keyup.${this.id}`, event => {
          if (event.keyCode === 27 && this.state.open) {
            event.stopPropagation();
            event.preventDefault();
            return this.close();
          }
        });
      }

      if (this.settings.triggers.open.visibility) {
        ({
          visibilitychange,
          hidden
        } = visibilityApiKeys());
        quickdom(document).on(`${visibilitychange}.${this.id}`, () => {
          if (document[hidden]) {
            return this.open('visibility');
          }
        });
      }

      if (this.settings.triggers.open.exitIntent) {
        quickdom(document).on(`mouseleave.${this.id}`, event => {
          var base, threshold;
          base = isIE || isIE11 || isEdge ? 110 : 0;
          threshold = this.settings.yThreshold + base;

          if (event.clientY <= threshold) {
            return this.open('exitIntent');
          }
        });
      }

      if (this.settings.triggers.open.navigation && ((ref2 = window.history) != null ? ref2.pushState : void 0)) {
        window.history.replaceState({
          id: 'quickpopup-origin'
        }, '', '');
        window.history.pushState({
          id: 'quickpopup'
        }, '', '');
        return quickdom(window).on(`popstate.${this.id}`, event => {
          if (event.state.state.id === 'quickpopup-origin' && this.open('navigation')) ;else {
            return window.history.back();
          }
        });
      }
    }

    _detachBindings() {
      var hidden, ref1, visibilitychange;
      this.el.child.overlay.off();

      if ((ref1 = this.el.child.close) != null) {
        ref1.off();
      }

      ({
        visibilitychange,
        hidden
      } = visibilityApiKeys());

      if (this.settings.placement === 'center') {
        quickdom(window).off(`resize.${this.id}`);
      }

      if (this.settings.triggers.open.navigation) {
        quickdom(window).off(`popstate.${this.id}`);
      }

      if (this.settings.triggers.open.exitIntent) {
        quickdom(document).off(`mouseleave.${this.id}`);
      }

      if (this.settings.triggers.open.visibility) {
        quickdom(document).off(`${visibilitychange}.${this.id}`);
      }

      if (this.settings.triggers.close.esc) {
        return quickdom(document).off(`keyup.${this.id}`);
      }
    }

    _throwDestroyed() {
      throw new Error("invalid attempt to operate a destroyed popup instance");
    }

    setContent(target) {
      this.content = function () {
        switch (false) {
          case !IS$1$1.quickEl(target):
            return target;

          case !IS$1$1.domEl(target):
            return quickdom(target);

          case !IS$1$1.template(target):
            return target.spawn();

          case !IS$1$1.string(target):
            return html.spawn({
              data: {
                html: target
              }
            });

          default:
            throw new Error('invalid target provided to Popup::setContent()');
        }
      }();

      if (this.el.child.content.children.length) {
        return this.el.child.content.children[1].replaceWith(this.content);
      } else {
        return this.el.child.content.append(this.content);
      }
    }

    alignToCenter() {
      var contentHeight, offset, windowHeight;
      contentHeight = this.el.child.content.raw.clientHeight;
      windowHeight = window.innerHeight;

      if (contentHeight >= windowHeight - 80) {
        offset = window.innerWidth > 736 ? 100 : 60;
      } else {
        offset = (windowHeight - contentHeight) / 2;
      }

      return this.el.child.content.style('margin', `${offset}px auto`);
    }

    open(triggerName) {
      return Promise.resolve().then(() => {
        if (this.state.destroyed) {
          this._throwDestroyed();
        }

        if (this.state.open || Popup.hasOpen && !this.settings.forceOpen || ++this.state.count >= this.settings.openLimit || window.innerWidth < this.settings.triggers.open.minWidth || this.settings.condition && !this.settings.condition()) {
          return promiseBreak();
        }
      }).then(() => {
        var openPopups;
        this.emit('beforeopen', triggerName);

        if (!Popup.hasOpen) {
          return this.state.offset = scrollOffset();
        } else {
          openPopups = Popup.instances.filter(popup$$1 => {
            return popup$$1 !== this && popup$$1.state.open;
          });
          return Promise.all(openPopups.map(popup$$1 => {
            this.state.offset = popup$$1.state.offset;
            return popup$$1.close(true);
          }));
        }
      }).then(() => {
        var promise;
        scheduleScrollReset(5);
        Popup.bodyWrapper.state('open', true);
        Popup.bodyWrapper.style('top', this.state.offset * -1);
        this.el.state('open', true);
        this.state.open = Popup.hasOpen = true;

        if (this.settings.placement === 'center') {
          this.alignToCenter();
        }

        this.emit('open', triggerName);

        if (!this.settings.animation || !Popup.transitionEnd) {
          return this.emit('finishopen');
        } else {
          promise = pEvent(this, 'finishopen');
          this.el.child.content.on(Popup.transitionEnd, event => {
            if (event.target === this.el.child.content.raw) {
              this.emit('finishopen');
              return this.el.child.content.off(Popup.transitionEnd);
            }
          });
          return promise;
        }
      }).catch(promiseBreak.end).then(() => {
        return this;
      });
    }

    close(preventReset) {
      return Promise.resolve().then(() => {
        if (!this.state.open) {
          return promiseBreak();
        }
      }).then(() => {
        var promise;
        this.emit('beforeclose');

        if (preventReset !== true) {
          setTimeout(() => {
            var ref1, ref2;

            if (!Popup.hasOpen) {
              if ((ref1 = Popup.bodyWrapper) != null) {
                ref1.state('open', false);
              }

              if ((ref2 = Popup.bodyWrapper) != null) {
                ref2.style('top', null);
              }

              return window.scroll(0, this.state.offset + documentOffset());
            }
          });
          Popup.hasOpen = false;
        }

        this.el.state('open', false);
        this.state.open = false;
        this.emit('close');

        if (!this.settings.animation || !Popup.transitionEnd) {
          return this.emit('finishclose');
        } else {
          promise = pEvent(this, 'finishclose');
          this.el.child.content.on(Popup.transitionEnd, event => {
            if (event.target === this.el.child.content.raw) {
              this.emit('finishclose');
              return this.el.child.content.off(Popup.transitionEnd);
            }
          });
          return promise;
        }
      }).catch(promiseBreak.end).then(() => {
        return this;
      });
    }

    destroy() {
      if (this.settings.destroyed) {
        this._throwDestroyed();
      }

      this.close();

      this._detachBindings();

      this.el.remove();
      Popup.instances.splice(Popup.instances.indexOf(this), 1);
      return true;
    }

  }

  Popup.instances = [];
  Popup.hasOpen = false;
  Popup.bodyWrapper = null;
  Popup.transitionEnd = transitionEnd();
  return Popup;
}.call(undefined);

var Popup$1 = Popup;
var defaults = {
  placement: 'center',
  open: false,
  forceOpen: false,
  template: null,
  condition: null,
  animation: 300,
  contentPadding: 0,
  yThreshold: 15,
  openLimit: 2e308,
  overlayColor: 'rgba(0,0,0,0.88)',
  close: {
    show: false,
    padding: 20,
    inside: false,
    size: 22
  },
  triggers: {
    open: {
      navigation: false,
      visibility: false,
      exitIntent: false
    },
    close: {
      esc: true
    }
  }
};
var version$4 = "1.0.0";
var newBuilder$2, quickpopup;

newBuilder$2 = function (defaults$$1, templates) {
  var builder;

  builder = function (arg) {
    switch (false) {
      case arguments.length !== 0:
        return new Popup$1(null, defaults$$1, templates);

      case typeof arg !== 'string':
        return new Popup$1({
          content: html.spawn({
            data: {
              html: arg
            }
          })
        }, defaults$$1, templates);

      case !quickdom.isEl(arg):
      case !quickdom.isQuickEl(arg):
        return new Popup$1({
          content: arg
        }, defaults$$1, templates);

      case !quickdom.isTemplate(arg):
        return new Popup$1({
          content: arg.spawn()
        }, defaults$$1, templates);

      case !(arg && typeof arg === 'object'):
        return new Popup$1(arg, defaults$$1, templates);

      default:
        throw new Error('invalid argument provided to QuickPopup');
    }
  };

  builder.config = function (newSettings, newTemplates) {
    var name$$1, outputSettings, outputTemplates, template;

    if (!IS$1$1.object(newSettings)) {
      throw new Error(`QuickPopup Config: invalid config object provided ${String(newSettings)}`);
    }

    outputSettings = primaryBuilder$1$1.clone.deep(defaults$$1, newSettings);

    if (!IS$1$1.object(newTemplates)) {
      outputTemplates = templates;
    } else {
      outputTemplates = Object.create(null);

      for (name$$1 in templates) {
        template = templates[name$$1];

        if (newTemplates[name$$1]) {
          outputTemplates[name$$1] = template.extend(newTemplates[name$$1]);
        } else {
          outputTemplates[name$$1] = template;
        }
      }
    }

    return newBuilder$2(outputSettings, outputTemplates);
  };

  builder.wrapBody = function () {
    return Popup$1.wrapBody();
  };

  builder.unwrapBody = function () {
    return Popup$1.unwrapBody();
  };

  builder.destroyAll = function () {
    return Popup$1.destroyAll();
  };

  builder.version = version$4;
  builder.defaults = defaults$$1;
  builder.templates = templates;
  return builder;
};

quickpopup = newBuilder$2(defaults, templates);
var quickpopup$1 = quickpopup;var restartSandbox = function () {
  if (window.sandbox) {
    window.sandbox.remove();
  }

  window.sandbox = quickdom.div({
    id: 'sandbox',
    style: {
      border: '1px solid',
      padding: 20,
      boxSizing: 'border-box'
    }
  });
  return window.sandbox.appendTo(document.body);
};var version$5 = "1.0.0";/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */

/*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new `{}`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */
function exclude() {
  var excludes = [].slice.call(arguments);

  function excludeProps(res, obj) {
    Object.keys(obj).forEach(function (key) {
      if (!~excludes.indexOf(key)) res[key] = obj[key];
    });
  }

  return function extendExclude() {
    var args = [].slice.call(arguments),
        i = 0,
        res = {};

    for (; i < args.length; i++) {
      excludeProps(res, args[i]);
    }

    return res;
  };
}
/*!
 * Primary Exports
 */

var assertionError = AssertionError;
/**
 * ### AssertionError
 *
 * An extension of the JavaScript `Error` constructor for
 * assertion and validation scenarios.
 *
 * @param {String} message
 * @param {Object} properties to include (optional)
 * @param {callee} start stack function (optional)
 */

function AssertionError(message, _props, ssf) {
  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON'),
      props = extend(_props || {}); // default values

  this.message = message || 'Unspecified AssertionError';
  this.showDiff = false; // copy from properties

  for (var key in props) {
    this[key] = props[key];
  } // capture stack trace


  ssf = ssf || AssertionError;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, ssf);
  } else {
    try {
      throw new Error();
    } catch (e) {
      this.stack = e.stack;
    }
  }
}
/*!
 * Inherit from Error.prototype
 */


AssertionError.prototype = Object.create(Error.prototype);
/*!
 * Statically set name
 */

AssertionError.prototype.name = 'AssertionError';
/*!
 * Ensure correct constructor
 */

AssertionError.prototype.constructor = AssertionError;
/**
 * Allow errors to be converted to JSON for static transfer.
 *
 * @param {Boolean} include stack (default: `true`)
 * @return {Object} object that can be `JSON.stringify`
 */

AssertionError.prototype.toJSON = function (stack) {
  var extend = exclude('constructor', 'toJSON', 'stack'),
      props = extend({
    name: this.name
  }, this); // include stack if exists and not turned off

  if (false !== stack && this.stack) {
    props.stack = this.stack;
  }

  return props;
};/* !
 * Chai - pathval utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * @see https://github.com/logicalparadox/filtr
 * MIT Licensed
 */

/**
 * ### .hasProperty(object, name)
 *
 * This allows checking whether an object has own
 * or inherited from prototype chain named property.
 *
 * Basically does the same thing as the `in`
 * operator but works properly with null/undefined values
 * and other primitives.
 *
 *     var obj = {
 *         arr: ['a', 'b', 'c']
 *       , str: 'Hello'
 *     }
 *
 * The following would be the results.
 *
 *     hasProperty(obj, 'str');  // true
 *     hasProperty(obj, 'constructor');  // true
 *     hasProperty(obj, 'bar');  // false
 *
 *     hasProperty(obj.str, 'length'); // true
 *     hasProperty(obj.str, 1);  // true
 *     hasProperty(obj.str, 5);  // false
 *
 *     hasProperty(obj.arr, 'length');  // true
 *     hasProperty(obj.arr, 2);  // true
 *     hasProperty(obj.arr, 3);  // false
 *
 * @param {Object} object
 * @param {String|Symbol} name
 * @returns {Boolean} whether it exists
 * @namespace Utils
 * @name hasProperty
 * @api public
 */

function hasProperty(obj, name) {
  if (typeof obj === 'undefined' || obj === null) {
    return false;
  } // The `in` operator does not work with primitives.


  return name in Object(obj);
}
/* !
 * ## parsePath(path)
 *
 * Helper function used to parse string object
 * paths. Use in conjunction with `internalGetPathValue`.
 *
 *      var parsed = parsePath('myobject.property.subprop');
 *
 * ### Paths:
 *
 * * Can be infinitely deep and nested.
 * * Arrays are also valid using the formal `myobject.document[3].property`.
 * * Literal dots and brackets (not delimiter) must be backslash-escaped.
 *
 * @param {String} path
 * @returns {Object} parsed
 * @api private
 */


function parsePath(path) {
  var str = path.replace(/([^\\])\[/g, '$1.[');
  var parts = str.match(/(\\\.|[^.]+?)+/g);
  return parts.map(function mapMatches(value) {
    var regexp = /^\[(\d+)\]$/;
    var mArr = regexp.exec(value);
    var parsed = null;

    if (mArr) {
      parsed = {
        i: parseFloat(mArr[1])
      };
    } else {
      parsed = {
        p: value.replace(/\\([.\[\]])/g, '$1')
      };
    }

    return parsed;
  });
}
/* !
 * ## internalGetPathValue(obj, parsed[, pathDepth])
 *
 * Helper companion function for `.parsePath` that returns
 * the value located at the parsed address.
 *
 *      var value = getPathValue(obj, parsed);
 *
 * @param {Object} object to search against
 * @param {Object} parsed definition from `parsePath`.
 * @param {Number} depth (nesting level) of the property we want to retrieve
 * @returns {Object|Undefined} value
 * @api private
 */


function internalGetPathValue(obj, parsed, pathDepth) {
  var temporaryValue = obj;
  var res = null;
  pathDepth = typeof pathDepth === 'undefined' ? parsed.length : pathDepth;

  for (var i = 0; i < pathDepth; i++) {
    var part = parsed[i];

    if (temporaryValue) {
      if (typeof part.p === 'undefined') {
        temporaryValue = temporaryValue[part.i];
      } else {
        temporaryValue = temporaryValue[part.p];
      }

      if (i === pathDepth - 1) {
        res = temporaryValue;
      }
    }
  }

  return res;
}
/* !
 * ## internalSetPathValue(obj, value, parsed)
 *
 * Companion function for `parsePath` that sets
 * the value located at a parsed address.
 *
 *  internalSetPathValue(obj, 'value', parsed);
 *
 * @param {Object} object to search and define on
 * @param {*} value to use upon set
 * @param {Object} parsed definition from `parsePath`
 * @api private
 */


function internalSetPathValue(obj, val, parsed) {
  var tempObj = obj;
  var pathDepth = parsed.length;
  var part = null; // Here we iterate through every part of the path

  for (var i = 0; i < pathDepth; i++) {
    var propName = null;
    var propVal = null;
    part = parsed[i]; // If it's the last part of the path, we set the 'propName' value with the property name

    if (i === pathDepth - 1) {
      propName = typeof part.p === 'undefined' ? part.i : part.p; // Now we set the property with the name held by 'propName' on object with the desired val

      tempObj[propName] = val;
    } else if (typeof part.p !== 'undefined' && tempObj[part.p]) {
      tempObj = tempObj[part.p];
    } else if (typeof part.i !== 'undefined' && tempObj[part.i]) {
      tempObj = tempObj[part.i];
    } else {
      // If the obj doesn't have the property we create one with that name to define it
      var next = parsed[i + 1]; // Here we set the name of the property which will be defined

      propName = typeof part.p === 'undefined' ? part.i : part.p; // Here we decide if this property will be an array or a new object

      propVal = typeof next.p === 'undefined' ? [] : {};
      tempObj[propName] = propVal;
      tempObj = tempObj[propName];
    }
  }
}
/**
 * ### .getPathInfo(object, path)
 *
 * This allows the retrieval of property info in an
 * object given a string path.
 *
 * The path info consists of an object with the
 * following properties:
 *
 * * parent - The parent object of the property referenced by `path`
 * * name - The name of the final property, a number if it was an array indexer
 * * value - The value of the property, if it exists, otherwise `undefined`
 * * exists - Whether the property exists or not
 *
 * @param {Object} object
 * @param {String} path
 * @returns {Object} info
 * @namespace Utils
 * @name getPathInfo
 * @api public
 */


function getPathInfo(obj, path) {
  var parsed = parsePath(path);
  var last = parsed[parsed.length - 1];
  var info = {
    parent: parsed.length > 1 ? internalGetPathValue(obj, parsed, parsed.length - 1) : obj,
    name: last.p || last.i,
    value: internalGetPathValue(obj, parsed)
  };
  info.exists = hasProperty(info.parent, info.name);
  return info;
}
/**
 * ### .getPathValue(object, path)
 *
 * This allows the retrieval of values in an
 * object given a string path.
 *
 *     var obj = {
 *         prop1: {
 *             arr: ['a', 'b', 'c']
 *           , str: 'Hello'
 *         }
 *       , prop2: {
 *             arr: [ { nested: 'Universe' } ]
 *           , str: 'Hello again!'
 *         }
 *     }
 *
 * The following would be the results.
 *
 *     getPathValue(obj, 'prop1.str'); // Hello
 *     getPathValue(obj, 'prop1.att[2]'); // b
 *     getPathValue(obj, 'prop2.arr[0].nested'); // Universe
 *
 * @param {Object} object
 * @param {String} path
 * @returns {Object} value or `undefined`
 * @namespace Utils
 * @name getPathValue
 * @api public
 */


function getPathValue(obj, path) {
  var info = getPathInfo(obj, path);
  return info.value;
}
/**
 * ### .setPathValue(object, path, value)
 *
 * Define the value in an object at a given string path.
 *
 * ```js
 * var obj = {
 *     prop1: {
 *         arr: ['a', 'b', 'c']
 *       , str: 'Hello'
 *     }
 *   , prop2: {
 *         arr: [ { nested: 'Universe' } ]
 *       , str: 'Hello again!'
 *     }
 * };
 * ```
 *
 * The following would be acceptable.
 *
 * ```js
 * var properties = require('tea-properties');
 * properties.set(obj, 'prop1.str', 'Hello Universe!');
 * properties.set(obj, 'prop1.arr[2]', 'B');
 * properties.set(obj, 'prop2.arr[0].nested.value', { hello: 'universe' });
 * ```
 *
 * @param {Object} object
 * @param {String} path
 * @param {Mixed} value
 * @api private
 */


function setPathValue(obj, path, val) {
  var parsed = parsePath(path);
  internalSetPathValue(obj, val, parsed);
  return obj;
}

var pathval = {
  hasProperty: hasProperty,
  getPathInfo: getPathInfo,
  getPathValue: getPathValue,
  setPathValue: setPathValue
};/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .flag(object, key, [value])
 *
 * Get or set a flag value on an object. If a
 * value is provided it will be set, else it will
 * return the currently set value or `undefined` if
 * the value is not set.
 *
 *     utils.flag(this, 'foo', 'bar'); // setter
 *     utils.flag(this, 'foo'); // getter, returns `bar`
 *
 * @param {Object} object constructed Assertion
 * @param {String} key
 * @param {Mixed} value (optional)
 * @namespace Utils
 * @name flag
 * @api private
 */
var flag = function flag(obj, key, value) {
  var flags = obj.__flags || (obj.__flags = Object.create(null));

  if (arguments.length === 3) {
    flags[key] = value;
  } else {
    return flags[key];
  }
};/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

/**
 * ### .test(object, expression)
 *
 * Test and object for expression.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name test
 */

var test$1 = function test(obj, args) {
  var negate = flag(obj, 'negate'),
      expr = args[0];
  return negate ? !expr : expr;
};var typeDetect = createCommonjsModule(function (module, exports) {
  (function (global, factory) {
    module.exports = factory();
  })(commonjsGlobal, function () {
    /* !
     * type-detect
     * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
     * MIT Licensed
     */

    var promiseExists = typeof Promise === 'function';
    /* eslint-disable no-undef */

    var globalObject = typeof self === 'object' ? self : commonjsGlobal; // eslint-disable-line id-blacklist

    var symbolExists = typeof Symbol !== 'undefined';
    var mapExists = typeof Map !== 'undefined';
    var setExists = typeof Set !== 'undefined';
    var weakMapExists = typeof WeakMap !== 'undefined';
    var weakSetExists = typeof WeakSet !== 'undefined';
    var dataViewExists = typeof DataView !== 'undefined';
    var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== 'undefined';
    var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== 'undefined';
    var setEntriesExists = setExists && typeof Set.prototype.entries === 'function';
    var mapEntriesExists = mapExists && typeof Map.prototype.entries === 'function';
    var setIteratorPrototype = setEntriesExists && Object.getPrototypeOf(new Set().entries());
    var mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf(new Map().entries());
    var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';
    var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());
    var stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === 'function';
    var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]());
    var toStringLeftSliceLength = 8;
    var toStringRightSliceLength = -1;
    /**
     * ### typeOf (obj)
     *
     * Uses `Object.prototype.toString` to determine the type of an object,
     * normalising behaviour across engine versions & well optimised.
     *
     * @param {Mixed} object
     * @return {String} object type
     * @api public
     */

    function typeDetect(obj) {
      /* ! Speed optimisation
       * Pre:
       *   string literal     x 3,039,035 ops/sec ±1.62% (78 runs sampled)
       *   boolean literal    x 1,424,138 ops/sec ±4.54% (75 runs sampled)
       *   number literal     x 1,653,153 ops/sec ±1.91% (82 runs sampled)
       *   undefined          x 9,978,660 ops/sec ±1.92% (75 runs sampled)
       *   function           x 2,556,769 ops/sec ±1.73% (77 runs sampled)
       * Post:
       *   string literal     x 38,564,796 ops/sec ±1.15% (79 runs sampled)
       *   boolean literal    x 31,148,940 ops/sec ±1.10% (79 runs sampled)
       *   number literal     x 32,679,330 ops/sec ±1.90% (78 runs sampled)
       *   undefined          x 32,363,368 ops/sec ±1.07% (82 runs sampled)
       *   function           x 31,296,870 ops/sec ±0.96% (83 runs sampled)
       */
      var typeofObj = typeof obj;

      if (typeofObj !== 'object') {
        return typeofObj;
      }
      /* ! Speed optimisation
       * Pre:
       *   null               x 28,645,765 ops/sec ±1.17% (82 runs sampled)
       * Post:
       *   null               x 36,428,962 ops/sec ±1.37% (84 runs sampled)
       */


      if (obj === null) {
        return 'null';
      }
      /* ! Spec Conformance
       * Test: `Object.prototype.toString.call(window)``
       *  - Node === "[object global]"
       *  - Chrome === "[object global]"
       *  - Firefox === "[object Window]"
       *  - PhantomJS === "[object Window]"
       *  - Safari === "[object Window]"
       *  - IE 11 === "[object Window]"
       *  - IE Edge === "[object Window]"
       * Test: `Object.prototype.toString.call(this)``
       *  - Chrome Worker === "[object global]"
       *  - Firefox Worker === "[object DedicatedWorkerGlobalScope]"
       *  - Safari Worker === "[object DedicatedWorkerGlobalScope]"
       *  - IE 11 Worker === "[object WorkerGlobalScope]"
       *  - IE Edge Worker === "[object WorkerGlobalScope]"
       */


      if (obj === globalObject) {
        return 'global';
      }
      /* ! Speed optimisation
       * Pre:
       *   array literal      x 2,888,352 ops/sec ±0.67% (82 runs sampled)
       * Post:
       *   array literal      x 22,479,650 ops/sec ±0.96% (81 runs sampled)
       */


      if (Array.isArray(obj) && (symbolToStringTagExists === false || !(Symbol.toStringTag in obj))) {
        return 'Array';
      } // Not caching existence of `window` and related properties due to potential
      // for `window` to be unset before tests in quasi-browser environments.


      if (typeof window === 'object' && window !== null) {
        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/multipage/browsers.html#location)
         * WhatWG HTML$7.7.3 - The `Location` interface
         * Test: `Object.prototype.toString.call(window.location)``
         *  - IE <=11 === "[object Object]"
         *  - IE Edge <=13 === "[object Object]"
         */
        if (typeof window.location === 'object' && obj === window.location) {
          return 'Location';
        }
        /* ! Spec Conformance
         * (https://html.spec.whatwg.org/#document)
         * WhatWG HTML$3.1.1 - The `Document` object
         * Note: Most browsers currently adher to the W3C DOM Level 2 spec
         *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)
         *       which suggests that browsers should use HTMLTableCellElement for
         *       both TD and TH elements. WhatWG separates these.
         *       WhatWG HTML states:
         *         > For historical reasons, Window objects must also have a
         *         > writable, configurable, non-enumerable property named
         *         > HTMLDocument whose value is the Document interface object.
         * Test: `Object.prototype.toString.call(document)``
         *  - Chrome === "[object HTMLDocument]"
         *  - Firefox === "[object HTMLDocument]"
         *  - Safari === "[object HTMLDocument]"
         *  - IE <=10 === "[object Document]"
         *  - IE 11 === "[object HTMLDocument]"
         *  - IE Edge <=13 === "[object HTMLDocument]"
         */


        if (typeof window.document === 'object' && obj === window.document) {
          return 'Document';
        }

        if (typeof window.navigator === 'object') {
          /* ! Spec Conformance
           * (https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)
           * WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray
           * Test: `Object.prototype.toString.call(navigator.mimeTypes)``
           *  - IE <=10 === "[object MSMimeTypesCollection]"
           */
          if (typeof window.navigator.mimeTypes === 'object' && obj === window.navigator.mimeTypes) {
            return 'MimeTypeArray';
          }
          /* ! Spec Conformance
           * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
           * WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray
           * Test: `Object.prototype.toString.call(navigator.plugins)``
           *  - IE <=10 === "[object MSPluginsCollection]"
           */


          if (typeof window.navigator.plugins === 'object' && obj === window.navigator.plugins) {
            return 'PluginArray';
          }
        }

        if ((typeof window.HTMLElement === 'function' || typeof window.HTMLElement === 'object') && obj instanceof window.HTMLElement) {
          /* ! Spec Conformance
          * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
          * WhatWG HTML$4.4.4 - The `blockquote` element - Interface `HTMLQuoteElement`
          * Test: `Object.prototype.toString.call(document.createElement('blockquote'))``
          *  - IE <=10 === "[object HTMLBlockElement]"
          */
          if (obj.tagName === 'BLOCKQUOTE') {
            return 'HTMLQuoteElement';
          }
          /* ! Spec Conformance
           * (https://html.spec.whatwg.org/#htmltabledatacellelement)
           * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableDataCellElement`
           * Note: Most browsers currently adher to the W3C DOM Level 2 spec
           *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
           *       which suggests that browsers should use HTMLTableCellElement for
           *       both TD and TH elements. WhatWG separates these.
           * Test: Object.prototype.toString.call(document.createElement('td'))
           *  - Chrome === "[object HTMLTableCellElement]"
           *  - Firefox === "[object HTMLTableCellElement]"
           *  - Safari === "[object HTMLTableCellElement]"
           */


          if (obj.tagName === 'TD') {
            return 'HTMLTableDataCellElement';
          }
          /* ! Spec Conformance
           * (https://html.spec.whatwg.org/#htmltableheadercellelement)
           * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableHeaderCellElement`
           * Note: Most browsers currently adher to the W3C DOM Level 2 spec
           *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
           *       which suggests that browsers should use HTMLTableCellElement for
           *       both TD and TH elements. WhatWG separates these.
           * Test: Object.prototype.toString.call(document.createElement('th'))
           *  - Chrome === "[object HTMLTableCellElement]"
           *  - Firefox === "[object HTMLTableCellElement]"
           *  - Safari === "[object HTMLTableCellElement]"
           */


          if (obj.tagName === 'TH') {
            return 'HTMLTableHeaderCellElement';
          }
        }
      }
      /* ! Speed optimisation
      * Pre:
      *   Float64Array       x 625,644 ops/sec ±1.58% (80 runs sampled)
      *   Float32Array       x 1,279,852 ops/sec ±2.91% (77 runs sampled)
      *   Uint32Array        x 1,178,185 ops/sec ±1.95% (83 runs sampled)
      *   Uint16Array        x 1,008,380 ops/sec ±2.25% (80 runs sampled)
      *   Uint8Array         x 1,128,040 ops/sec ±2.11% (81 runs sampled)
      *   Int32Array         x 1,170,119 ops/sec ±2.88% (80 runs sampled)
      *   Int16Array         x 1,176,348 ops/sec ±5.79% (86 runs sampled)
      *   Int8Array          x 1,058,707 ops/sec ±4.94% (77 runs sampled)
      *   Uint8ClampedArray  x 1,110,633 ops/sec ±4.20% (80 runs sampled)
      * Post:
      *   Float64Array       x 7,105,671 ops/sec ±13.47% (64 runs sampled)
      *   Float32Array       x 5,887,912 ops/sec ±1.46% (82 runs sampled)
      *   Uint32Array        x 6,491,661 ops/sec ±1.76% (79 runs sampled)
      *   Uint16Array        x 6,559,795 ops/sec ±1.67% (82 runs sampled)
      *   Uint8Array         x 6,463,966 ops/sec ±1.43% (85 runs sampled)
      *   Int32Array         x 5,641,841 ops/sec ±3.49% (81 runs sampled)
      *   Int16Array         x 6,583,511 ops/sec ±1.98% (80 runs sampled)
      *   Int8Array          x 6,606,078 ops/sec ±1.74% (81 runs sampled)
      *   Uint8ClampedArray  x 6,602,224 ops/sec ±1.77% (83 runs sampled)
      */


      var stringTag = symbolToStringTagExists && obj[Symbol.toStringTag];

      if (typeof stringTag === 'string') {
        return stringTag;
      }

      var objPrototype = Object.getPrototypeOf(obj);
      /* ! Speed optimisation
      * Pre:
      *   regex literal      x 1,772,385 ops/sec ±1.85% (77 runs sampled)
      *   regex constructor  x 2,143,634 ops/sec ±2.46% (78 runs sampled)
      * Post:
      *   regex literal      x 3,928,009 ops/sec ±0.65% (78 runs sampled)
      *   regex constructor  x 3,931,108 ops/sec ±0.58% (84 runs sampled)
      */

      if (objPrototype === RegExp.prototype) {
        return 'RegExp';
      }
      /* ! Speed optimisation
      * Pre:
      *   date               x 2,130,074 ops/sec ±4.42% (68 runs sampled)
      * Post:
      *   date               x 3,953,779 ops/sec ±1.35% (77 runs sampled)
      */


      if (objPrototype === Date.prototype) {
        return 'Date';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)
       * ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be "Promise":
       * Test: `Object.prototype.toString.call(Promise.resolve())``
       *  - Chrome <=47 === "[object Object]"
       *  - Edge <=20 === "[object Object]"
       *  - Firefox 29-Latest === "[object Promise]"
       *  - Safari 7.1-Latest === "[object Promise]"
       */


      if (promiseExists && objPrototype === Promise.prototype) {
        return 'Promise';
      }
      /* ! Speed optimisation
      * Pre:
      *   set                x 2,222,186 ops/sec ±1.31% (82 runs sampled)
      * Post:
      *   set                x 4,545,879 ops/sec ±1.13% (83 runs sampled)
      */


      if (setExists && objPrototype === Set.prototype) {
        return 'Set';
      }
      /* ! Speed optimisation
      * Pre:
      *   map                x 2,396,842 ops/sec ±1.59% (81 runs sampled)
      * Post:
      *   map                x 4,183,945 ops/sec ±6.59% (82 runs sampled)
      */


      if (mapExists && objPrototype === Map.prototype) {
        return 'Map';
      }
      /* ! Speed optimisation
      * Pre:
      *   weakset            x 1,323,220 ops/sec ±2.17% (76 runs sampled)
      * Post:
      *   weakset            x 4,237,510 ops/sec ±2.01% (77 runs sampled)
      */


      if (weakSetExists && objPrototype === WeakSet.prototype) {
        return 'WeakSet';
      }
      /* ! Speed optimisation
      * Pre:
      *   weakmap            x 1,500,260 ops/sec ±2.02% (78 runs sampled)
      * Post:
      *   weakmap            x 3,881,384 ops/sec ±1.45% (82 runs sampled)
      */


      if (weakMapExists && objPrototype === WeakMap.prototype) {
        return 'WeakMap';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)
       * ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be "DataView":
       * Test: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))``
       *  - Edge <=13 === "[object Object]"
       */


      if (dataViewExists && objPrototype === DataView.prototype) {
        return 'DataView';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)
       * ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be "Map Iterator":
       * Test: `Object.prototype.toString.call(new Map().entries())``
       *  - Edge <=13 === "[object Object]"
       */


      if (mapExists && objPrototype === mapIteratorPrototype) {
        return 'Map Iterator';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)
       * ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be "Set Iterator":
       * Test: `Object.prototype.toString.call(new Set().entries())``
       *  - Edge <=13 === "[object Object]"
       */


      if (setExists && objPrototype === setIteratorPrototype) {
        return 'Set Iterator';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)
       * ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be "Array Iterator":
       * Test: `Object.prototype.toString.call([][Symbol.iterator]())``
       *  - Edge <=13 === "[object Object]"
       */


      if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {
        return 'Array Iterator';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)
       * ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be "String Iterator":
       * Test: `Object.prototype.toString.call(''[Symbol.iterator]())``
       *  - Edge <=13 === "[object Object]"
       */


      if (stringIteratorExists && objPrototype === stringIteratorPrototype) {
        return 'String Iterator';
      }
      /* ! Speed optimisation
      * Pre:
      *   object from null   x 2,424,320 ops/sec ±1.67% (76 runs sampled)
      * Post:
      *   object from null   x 5,838,000 ops/sec ±0.99% (84 runs sampled)
      */


      if (objPrototype === null) {
        return 'Object';
      }

      return Object.prototype.toString.call(obj).slice(toStringLeftSliceLength, toStringRightSliceLength);
    }

    return typeDetect;
  });
});/*!
 * Chai - expectTypes utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .expectTypes(obj, types)
 *
 * Ensures that the object being tested against is of a valid type.
 *
 *     utils.expectTypes(this, ['array', 'object', 'string']);
 *
 * @param {Mixed} obj constructed Assertion
 * @param {Array} type A list of allowed types for this assertion
 * @namespace Utils
 * @name expectTypes
 * @api public
 */

var expectTypes = function expectTypes(obj, types) {
  var flagMsg = flag(obj, 'message');
  var ssfi = flag(obj, 'ssfi');
  flagMsg = flagMsg ? flagMsg + ': ' : '';
  obj = flag(obj, 'object');
  types = types.map(function (t) {
    return t.toLowerCase();
  });
  types.sort(); // Transforms ['lorem', 'ipsum'] into 'a lorem, or an ipsum'

  var str = types.map(function (t, index) {
    var art = ~['a', 'e', 'i', 'o', 'u'].indexOf(t.charAt(0)) ? 'an' : 'a';
    var or = types.length > 1 && index === types.length - 1 ? 'or ' : '';
    return or + art + ' ' + t;
  }).join(', ');
  var objType = typeDetect(obj).toLowerCase();

  if (!types.some(function (expected) {
    return objType === expected;
  })) {
    throw new assertionError(flagMsg + 'object tested must be ' + str + ', but ' + objType + ' given', undefined, ssfi);
  }
};/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getActual(object, [actual])
 *
 * Returns the `actual` value for an Assertion.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getActual
 */
var getActual = function getActual(obj, args) {
  return args.length > 4 ? args[4] : obj._obj;
};/* !
 * Chai - getFuncName utility
 * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getFuncName(constructorFn)
 *
 * Returns the name of a function.
 * When a non-function instance is passed, returns `null`.
 * This also includes a polyfill function if `aFunc.name` is not defined.
 *
 * @name getFuncName
 * @param {Function} funct
 * @namespace Utils
 * @api public
 */

var toString = Function.prototype.toString;
var functionNameMatch = /\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\s\(\/]+)/;

function getFuncName(aFunc) {
  if (typeof aFunc !== 'function') {
    return null;
  }

  var name = '';

  if (typeof Function.prototype.name === 'undefined' && typeof aFunc.name === 'undefined') {
    // Here we run a polyfill if Function does not support the `name` property and if aFunc.name is not defined
    var match = toString.call(aFunc).match(functionNameMatch);

    if (match) {
      name = match[1];
    }
  } else {
    // If we've got a `name` property we just use it
    name = aFunc.name;
  }

  return name;
}

var getFuncName_1 = getFuncName;/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getProperties(object)
 *
 * This allows the retrieval of property names of an object, enumerable or not,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getProperties
 * @api public
 */
var getProperties = function getProperties(object) {
  var result = Object.getOwnPropertyNames(object);

  function addProperty(property) {
    if (result.indexOf(property) === -1) {
      result.push(property);
    }
  }

  var proto = Object.getPrototypeOf(object);

  while (proto !== null) {
    Object.getOwnPropertyNames(proto).forEach(addProperty);
    proto = Object.getPrototypeOf(proto);
  }

  return result;
};/*!
 * Chai - getEnumerableProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getEnumerableProperties(object)
 *
 * This allows the retrieval of enumerable property names of an object,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getEnumerableProperties
 * @api public
 */
var getEnumerableProperties = function getEnumerableProperties(object) {
  var result = [];

  for (var name in object) {
    result.push(name);
  }

  return result;
};var config = {
  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {Boolean}
   * @api public
   */
  includeStack: false,

  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {Boolean}
   * @api public
   */
  showDiff: true,

  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {Number}
   * @api public
   */
  truncateThreshold: 40,

  /**
   * ### config.useProxy
   *
   * User configurable property, defines if chai will use a Proxy to throw
   * an error when a non-existent property is read, which protects users
   * from typos when using property-based assertions.
   *
   * Set it to false if you want to disable this feature.
   *
   *     chai.config.useProxy = false;  // disable use of Proxy
   *
   * This feature is automatically disabled regardless of this config value
   * in environments that don't support proxies.
   *
   * @param {Boolean}
   * @api public
   */
  useProxy: true,

  /**
   * ### config.proxyExcludedKeys
   *
   * User configurable property, defines which properties should be ignored
   * instead of throwing an error if they do not exist on the assertion.
   * This is only applied if the environment Chai is running in supports proxies and
   * if the `useProxy` configuration setting is enabled.
   * By default, `then` and `inspect` will not throw an error if they do not exist on the
   * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
   * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
   *
   *     // By default these keys will not throw an error if they do not exist on the assertion object
   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
   *
   * @param {Array}
   * @api public
   */
  proxyExcludedKeys: ['then', 'catch', 'inspect', 'toJSON']
};var inspect_1 = createCommonjsModule(function (module, exports) {
  // This is (almost) directly from Node.js utils
  // https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js
  module.exports = inspect;
  /**
   * ### .inspect(obj, [showHidden], [depth], [colors])
   *
   * Echoes the value of a value. Tries to print the value out
   * in the best way possible given the different types.
   *
   * @param {Object} obj The object to print out.
   * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
   *    properties of objects. Default is false.
   * @param {Number} depth Depth in which to descend in object. Default is 2.
   * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
   *    output. Default is false (no coloring).
   * @namespace Utils
   * @name inspect
   */

  function inspect(obj, showHidden, depth, colors) {
    var ctx = {
      showHidden: showHidden,
      seen: [],
      stylize: function (str) {
        return str;
      }
    };
    return formatValue(ctx, obj, typeof depth === 'undefined' ? 2 : depth);
  } // Returns true if object is a DOM element.


  var isDOMElement = function (object) {
    if (typeof HTMLElement === 'object') {
      return object instanceof HTMLElement;
    } else {
      return object && typeof object === 'object' && 'nodeType' in object && object.nodeType === 1 && typeof object.nodeName === 'string';
    }
  };

  function formatValue(ctx, value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (value && typeof value.inspect === 'function' && // Filter out the util module, it's inspect function is special
    value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
    !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);

      if (typeof ret !== 'string') {
        ret = formatValue(ctx, ret, recurseTimes);
      }

      return ret;
    } // Primitive types cannot have properties


    var primitive = formatPrimitive(ctx, value);

    if (primitive) {
      return primitive;
    } // If this is a DOM element, try to get the outer HTML.


    if (isDOMElement(value)) {
      if ('outerHTML' in value) {
        return value.outerHTML; // This value does not have an outerHTML attribute,
        //   it could still be an XML element
      } else {
        // Attempt to serialize it
        try {
          if (document.xmlVersion) {
            var xmlSerializer = new XMLSerializer();
            return xmlSerializer.serializeToString(value);
          } else {
            // Firefox 11- do not support outerHTML
            //   It does, however, support innerHTML
            //   Use the following to render the element
            var ns = "http://www.w3.org/1999/xhtml";
            var container = document.createElementNS(ns, '_');
            container.appendChild(value.cloneNode(false));
            var html = container.innerHTML.replace('><', '>' + value.innerHTML + '<');
            container.innerHTML = '';
            return html;
          }
        } catch (err) {// This could be a non-native DOM implementation,
          //   continue with the normal flow:
          //   printing the element as if it is an object.
        }
      }
    } // Look up the keys of the object.


    var visibleKeys = getEnumerableProperties(value);
    var keys = ctx.showHidden ? getProperties(value) : visibleKeys;
    var name, nameSuffix; // Some type of object without properties can be shortcut.
    // In IE, errors have a single `stack` property, or if they are vanilla `Error`,
    // a `stack` plus `description` property; ignore those for consistency.

    if (keys.length === 0 || isError(value) && (keys.length === 1 && keys[0] === 'stack' || keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')) {
      if (typeof value === 'function') {
        name = getFuncName_1(value);
        nameSuffix = name ? ': ' + name : '';
        return ctx.stylize('[Function' + nameSuffix + ']', 'special');
      }

      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      }

      if (isDate(value)) {
        return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');
      }

      if (isError(value)) {
        return formatError(value);
      }
    }

    var base = '',
        array = false,
        typedArray = false,
        braces = ['{', '}'];

    if (isTypedArray(value)) {
      typedArray = true;
      braces = ['[', ']'];
    } // Make Array say that they are Array


    if (isArray(value)) {
      array = true;
      braces = ['[', ']'];
    } // Make functions say that they are functions


    if (typeof value === 'function') {
      name = getFuncName_1(value);
      nameSuffix = name ? ': ' + name : '';
      base = ' [Function' + nameSuffix + ']';
    } // Make RegExps say that they are RegExps


    if (isRegExp(value)) {
      base = ' ' + RegExp.prototype.toString.call(value);
    } // Make dates with properties first say the date


    if (isDate(value)) {
      base = ' ' + Date.prototype.toUTCString.call(value);
    } // Make error with message first say the error


    if (isError(value)) {
      return formatError(value);
    }

    if (keys.length === 0 && (!array || value.length == 0)) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      } else {
        return ctx.stylize('[Object]', 'special');
      }
    }

    ctx.seen.push(value);
    var output;

    if (array) {
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    } else if (typedArray) {
      return formatTypedArray(value);
    } else {
      output = keys.map(function (key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
      });
    }

    ctx.seen.pop();
    return reduceToSingleString(output, base, braces);
  }

  function formatPrimitive(ctx, value) {
    switch (typeof value) {
      case 'undefined':
        return ctx.stylize('undefined', 'undefined');

      case 'string':
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');

      case 'number':
        if (value === 0 && 1 / value === -Infinity) {
          return ctx.stylize('-0', 'number');
        }

        return ctx.stylize('' + value, 'number');

      case 'boolean':
        return ctx.stylize('' + value, 'boolean');

      case 'symbol':
        return ctx.stylize(value.toString(), 'symbol');
    } // For some reason typeof null is "object", so special case here.


    if (value === null) {
      return ctx.stylize('null', 'null');
    }
  }

  function formatError(value) {
    return '[' + Error.prototype.toString.call(value) + ']';
  }

  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];

    for (var i = 0, l = value.length; i < l; ++i) {
      if (Object.prototype.hasOwnProperty.call(value, String(i))) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
      } else {
        output.push('');
      }
    }

    keys.forEach(function (key) {
      if (!key.match(/^\d+$/)) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
      }
    });
    return output;
  }

  function formatTypedArray(value) {
    var str = '[ ';

    for (var i = 0; i < value.length; ++i) {
      if (str.length >= config.truncateThreshold - 7) {
        str += '...';
        break;
      }

      str += value[i] + ', ';
    }

    str += ' ]'; // Removing trailing `, ` if the array was not truncated

    if (str.indexOf(',  ]') !== -1) {
      str = str.replace(',  ]', ' ]');
    }

    return str;
  }

  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name;
    var propDescriptor = Object.getOwnPropertyDescriptor(value, key);
    var str;

    if (propDescriptor) {
      if (propDescriptor.get) {
        if (propDescriptor.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (propDescriptor.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
    }

    if (visibleKeys.indexOf(key) < 0) {
      name = '[' + key + ']';
    }

    if (!str) {
      if (ctx.seen.indexOf(value[key]) < 0) {
        if (recurseTimes === null) {
          str = formatValue(ctx, value[key], null);
        } else {
          str = formatValue(ctx, value[key], recurseTimes - 1);
        }

        if (str.indexOf('\n') > -1) {
          if (array) {
            str = str.split('\n').map(function (line) {
              return '  ' + line;
            }).join('\n').substr(2);
          } else {
            str = '\n' + str.split('\n').map(function (line) {
              return '   ' + line;
            }).join('\n');
          }
        }
      } else {
        str = ctx.stylize('[Circular]', 'special');
      }
    }

    if (typeof name === 'undefined') {
      if (array && key.match(/^\d+$/)) {
        return str;
      }

      name = JSON.stringify('' + key);

      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = ctx.stylize(name, 'name');
      } else {
        name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
        name = ctx.stylize(name, 'string');
      }
    }

    return name + ': ' + str;
  }

  function reduceToSingleString(output, base, braces) {
    var length = output.reduce(function (prev, cur) {
      return prev + cur.length + 1;
    }, 0);

    if (length > 60) {
      return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
    }

    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
  }

  function isTypedArray(ar) {
    // Unfortunately there's no way to check if an object is a TypedArray
    // We have to check if it's one of these types
    return typeof ar === 'object' && /\w+Array]$/.test(objectToString(ar));
  }

  function isArray(ar) {
    return Array.isArray(ar) || typeof ar === 'object' && objectToString(ar) === '[object Array]';
  }

  function isRegExp(re) {
    return typeof re === 'object' && objectToString(re) === '[object RegExp]';
  }

  function isDate(d) {
    return typeof d === 'object' && objectToString(d) === '[object Date]';
  }

  function isError(e) {
    return typeof e === 'object' && objectToString(e) === '[object Error]';
  }

  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
});/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

/**
 * ### .objDisplay(object)
 *
 * Determines if an object or an array matches
 * criteria to be inspected in-line for error
 * messages or should be truncated.
 *
 * @param {Mixed} javascript object to inspect
 * @name objDisplay
 * @namespace Utils
 * @api public
 */

var objDisplay = function objDisplay(obj) {
  var str = inspect_1(obj),
      type = Object.prototype.toString.call(obj);

  if (config.truncateThreshold && str.length >= config.truncateThreshold) {
    if (type === '[object Function]') {
      return !obj.name || obj.name === '' ? '[Function]' : '[Function: ' + obj.name + ']';
    } else if (type === '[object Array]') {
      return '[ Array(' + obj.length + ') ]';
    } else if (type === '[object Object]') {
      var keys = Object.keys(obj),
          kstr = keys.length > 2 ? keys.splice(0, 2).join(', ') + ', ...' : keys.join(', ');
      return '{ Object (' + kstr + ') }';
    } else {
      return str;
    }
  } else {
    return str;
  }
};/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

/**
 * ### .getMessage(object, message, negateMessage)
 *
 * Construct the error message based on flags
 * and template tags. Template tags will return
 * a stringified inspection of the object referenced.
 *
 * Message template tags:
 * - `#{this}` current asserted object
 * - `#{act}` actual value
 * - `#{exp}` expected value
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getMessage
 * @api public
 */

var getMessage = function getMessage(obj, args) {
  var negate = flag(obj, 'negate'),
      val = flag(obj, 'object'),
      expected = args[3],
      actual = getActual(obj, args),
      msg = negate ? args[2] : args[1],
      flagMsg = flag(obj, 'message');
  if (typeof msg === "function") msg = msg();
  msg = msg || '';
  msg = msg.replace(/#\{this\}/g, function () {
    return objDisplay(val);
  }).replace(/#\{act\}/g, function () {
    return objDisplay(actual);
  }).replace(/#\{exp\}/g, function () {
    return objDisplay(expected);
  });
  return flagMsg ? flagMsg + ': ' + msg : msg;
};/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .transferFlags(assertion, object, includeAll = true)
 *
 * Transfer all the flags for `assertion` to `object`. If
 * `includeAll` is set to `false`, then the base Chai
 * assertion flags (namely `object`, `ssfi`, `lockSsfi`,
 * and `message`) will not be transferred.
 *
 *
 *     var newAssertion = new Assertion();
 *     utils.transferFlags(assertion, newAssertion);
 *
 *     var anotherAssertion = new Assertion(myObj);
 *     utils.transferFlags(assertion, anotherAssertion, false);
 *
 * @param {Assertion} assertion the assertion to transfer the flags from
 * @param {Object} object the object to transfer the flags to; usually a new assertion
 * @param {Boolean} includeAll
 * @namespace Utils
 * @name transferFlags
 * @api private
 */
var transferFlags = function transferFlags(assertion, object, includeAll) {
  var flags = assertion.__flags || (assertion.__flags = Object.create(null));

  if (!object.__flags) {
    object.__flags = Object.create(null);
  }

  includeAll = arguments.length === 3 ? includeAll : true;

  for (var flag in flags) {
    if (includeAll || flag !== 'object' && flag !== 'ssfi' && flag !== 'lockSsfi' && flag != 'message') {
      object.__flags[flag] = flags[flag];
    }
  }
};/* globals Symbol: false, Uint8Array: false, WeakMap: false */

/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */


function FakeMap() {
  this._key = 'chai/deep-eql__' + Math.random() + Date.now();
}

FakeMap.prototype = {
  get: function getMap(key) {
    return key[this._key];
  },
  set: function setMap(key, value) {
    if (Object.isExtensible(key)) {
      Object.defineProperty(key, this._key, {
        value: value,
        configurable: true
      });
    }
  }
};
var MemoizeMap = typeof WeakMap === 'function' ? WeakMap : FakeMap;
/*!
 * Check to see if the MemoizeMap has recorded a result of the two operands
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @returns {Boolean|null} result
*/

function memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {
  // Technically, WeakMap keys can *only* be objects, not primitives.
  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    return null;
  }

  var leftHandMap = memoizeMap.get(leftHandOperand);

  if (leftHandMap) {
    var result = leftHandMap.get(rightHandOperand);

    if (typeof result === 'boolean') {
      return result;
    }
  }

  return null;
}
/*!
 * Set the result of the equality into the MemoizeMap
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @param {Boolean} result
*/


function memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result) {
  // Technically, WeakMap keys can *only* be objects, not primitives.
  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    return;
  }

  var leftHandMap = memoizeMap.get(leftHandOperand);

  if (leftHandMap) {
    leftHandMap.set(rightHandOperand, result);
  } else {
    leftHandMap = new MemoizeMap();
    leftHandMap.set(rightHandOperand, result);
    memoizeMap.set(leftHandOperand, leftHandMap);
  }
}
/*!
 * Primary Export
 */


var deepEql = deepEqual;
var MemoizeMap_1 = MemoizeMap;
/**
 * Assert deeply nested sameValue equality between two objects of any type.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
 */

function deepEqual(leftHandOperand, rightHandOperand, options) {
  // If we have a comparator, we can't assume anything; so bail to its check first.
  if (options && options.comparator) {
    return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
  }

  var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);

  if (simpleResult !== null) {
    return simpleResult;
  } // Deeper comparisons are pushed through to a larger function


  return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
}
/**
 * Many comparisons can be canceled out early via simple equality or primitive checks.
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @return {Boolean|null} equal match
 */


function simpleEqual(leftHandOperand, rightHandOperand) {
  // Equal references (except for Numbers) can be returned early
  if (leftHandOperand === rightHandOperand) {
    // Handle +-0 cases
    return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand;
  } // handle NaN cases


  if (leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare
  rightHandOperand !== rightHandOperand // eslint-disable-line no-self-compare
  ) {
      return true;
    } // Anything that is not an 'object', i.e. symbols, functions, booleans, numbers,
  // strings, and undefined, can be compared by reference.


  if (isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
    // Easy out b/c it would have passed the first equality check
    return false;
  }

  return null;
}
/*!
 * The main logic of the `deepEqual` function.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
*/


function extensiveDeepEqual(leftHandOperand, rightHandOperand, options) {
  options = options || {};
  options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap();
  var comparator = options && options.comparator; // Check if a memoized result exists.

  var memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options.memoize);

  if (memoizeResultLeft !== null) {
    return memoizeResultLeft;
  }

  var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options.memoize);

  if (memoizeResultRight !== null) {
    return memoizeResultRight;
  } // If a comparator is present, use it.


  if (comparator) {
    var comparatorResult = comparator(leftHandOperand, rightHandOperand); // Comparators may return null, in which case we want to go back to default behavior.

    if (comparatorResult === false || comparatorResult === true) {
      memoizeSet(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);
      return comparatorResult;
    } // To allow comparators to override *any* behavior, we ran them first. Since it didn't decide
    // what to do, we need to make sure to return the basic tests first before we move on.


    var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);

    if (simpleResult !== null) {
      // Don't memoize this, it takes longer to set/retrieve than to just compare.
      return simpleResult;
    }
  }

  var leftHandType = typeDetect(leftHandOperand);

  if (leftHandType !== typeDetect(rightHandOperand)) {
    memoizeSet(leftHandOperand, rightHandOperand, options.memoize, false);
    return false;
  } // Temporarily set the operands in the memoize object to prevent blowing the stack


  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, true);
  var result = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options);
  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, result);
  return result;
}

function extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options) {
  switch (leftHandType) {
    case 'String':
    case 'Number':
    case 'Boolean':
    case 'Date':
      // If these types are their instance types (e.g. `new Number`) then re-deepEqual against their values
      return deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf());

    case 'Promise':
    case 'Symbol':
    case 'function':
    case 'WeakMap':
    case 'WeakSet':
    case 'Error':
      return leftHandOperand === rightHandOperand;

    case 'Arguments':
    case 'Int8Array':
    case 'Uint8Array':
    case 'Uint8ClampedArray':
    case 'Int16Array':
    case 'Uint16Array':
    case 'Int32Array':
    case 'Uint32Array':
    case 'Float32Array':
    case 'Float64Array':
    case 'Array':
      return iterableEqual(leftHandOperand, rightHandOperand, options);

    case 'RegExp':
      return regexpEqual(leftHandOperand, rightHandOperand);

    case 'Generator':
      return generatorEqual(leftHandOperand, rightHandOperand, options);

    case 'DataView':
      return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);

    case 'ArrayBuffer':
      return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);

    case 'Set':
      return entriesEqual(leftHandOperand, rightHandOperand, options);

    case 'Map':
      return entriesEqual(leftHandOperand, rightHandOperand, options);

    default:
      return objectEqual(leftHandOperand, rightHandOperand, options);
  }
}
/*!
 * Compare two Regular Expressions for equality.
 *
 * @param {RegExp} leftHandOperand
 * @param {RegExp} rightHandOperand
 * @return {Boolean} result
 */


function regexpEqual(leftHandOperand, rightHandOperand) {
  return leftHandOperand.toString() === rightHandOperand.toString();
}
/*!
 * Compare two Sets/Maps for equality. Faster than other equality functions.
 *
 * @param {Set} leftHandOperand
 * @param {Set} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function entriesEqual(leftHandOperand, rightHandOperand, options) {
  // IE11 doesn't support Set#entries or Set#@@iterator, so we need manually populate using Set#forEach
  if (leftHandOperand.size !== rightHandOperand.size) {
    return false;
  }

  if (leftHandOperand.size === 0) {
    return true;
  }

  var leftHandItems = [];
  var rightHandItems = [];
  leftHandOperand.forEach(function gatherEntries(key, value) {
    leftHandItems.push([key, value]);
  });
  rightHandOperand.forEach(function gatherEntries(key, value) {
    rightHandItems.push([key, value]);
  });
  return iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options);
}
/*!
 * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function iterableEqual(leftHandOperand, rightHandOperand, options) {
  var length = leftHandOperand.length;

  if (length !== rightHandOperand.length) {
    return false;
  }

  if (length === 0) {
    return true;
  }

  var index = -1;

  while (++index < length) {
    if (deepEqual(leftHandOperand[index], rightHandOperand[index], options) === false) {
      return false;
    }
  }

  return true;
}
/*!
 * Simple equality for generator objects such as those returned by generator functions.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function generatorEqual(leftHandOperand, rightHandOperand, options) {
  return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options);
}
/*!
 * Determine if the given object has an @@iterator function.
 *
 * @param {Object} target
 * @return {Boolean} `true` if the object has an @@iterator function.
 */


function hasIteratorFunction(target) {
  return typeof Symbol !== 'undefined' && typeof target === 'object' && typeof Symbol.iterator !== 'undefined' && typeof target[Symbol.iterator] === 'function';
}
/*!
 * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
 * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
 *
 * @param {Object} target
 * @returns {Array} an array of entries from the @@iterator function
 */


function getIteratorEntries(target) {
  if (hasIteratorFunction(target)) {
    try {
      return getGeneratorEntries(target[Symbol.iterator]());
    } catch (iteratorError) {
      return [];
    }
  }

  return [];
}
/*!
 * Gets all entries from a Generator. This will consume the generator - which could have side effects.
 *
 * @param {Generator} target
 * @returns {Array} an array of entries from the Generator.
 */


function getGeneratorEntries(generator) {
  var generatorResult = generator.next();
  var accumulator = [generatorResult.value];

  while (generatorResult.done === false) {
    generatorResult = generator.next();
    accumulator.push(generatorResult.value);
  }

  return accumulator;
}
/*!
 * Gets all own and inherited enumerable keys from a target.
 *
 * @param {Object} target
 * @returns {Array} an array of own and inherited enumerable keys from the target.
 */


function getEnumerableKeys(target) {
  var keys = [];

  for (var key in target) {
    keys.push(key);
  }

  return keys;
}
/*!
 * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
 * each key. If any value of the given key is not equal, the function will return false (early).
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function keysEqual(leftHandOperand, rightHandOperand, keys, options) {
  var length = keys.length;

  if (length === 0) {
    return true;
  }

  for (var i = 0; i < length; i += 1) {
    if (deepEqual(leftHandOperand[keys[i]], rightHandOperand[keys[i]], options) === false) {
      return false;
    }
  }

  return true;
}
/*!
 * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
 * for each enumerable key in the object.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function objectEqual(leftHandOperand, rightHandOperand, options) {
  var leftHandKeys = getEnumerableKeys(leftHandOperand);
  var rightHandKeys = getEnumerableKeys(rightHandOperand);

  if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {
    leftHandKeys.sort();
    rightHandKeys.sort();

    if (iterableEqual(leftHandKeys, rightHandKeys) === false) {
      return false;
    }

    return keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options);
  }

  var leftHandEntries = getIteratorEntries(leftHandOperand);
  var rightHandEntries = getIteratorEntries(rightHandOperand);

  if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {
    leftHandEntries.sort();
    rightHandEntries.sort();
    return iterableEqual(leftHandEntries, rightHandEntries, options);
  }

  if (leftHandKeys.length === 0 && leftHandEntries.length === 0 && rightHandKeys.length === 0 && rightHandEntries.length === 0) {
    return true;
  }

  return false;
}
/*!
 * Returns true if the argument is a primitive.
 *
 * This intentionally returns true for all objects that can be compared by reference,
 * including functions and symbols.
 *
 * @param {Mixed} value
 * @return {Boolean} result
 */


function isPrimitive(value) {
  return value === null || typeof value !== 'object';
}
deepEql.MemoizeMap = MemoizeMap_1;/*!
 * Chai - isProxyEnabled helper
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .isProxyEnabled()
 *
 * Helper function to check if Chai's proxy protection feature is enabled. If
 * proxies are unsupported or disabled via the user's Chai config, then return
 * false. Otherwise, return true.
 *
 * @namespace Utils
 * @name isProxyEnabled
 */

var isProxyEnabled = function isProxyEnabled() {
  return config.useProxy && typeof Proxy !== 'undefined' && typeof Reflect !== 'undefined';
};/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .addProperty(ctx, name, getter)
 *
 * Adds a property to the prototype of an object.
 *
 *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.instanceof(Foo);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.foo;
 *
 * @param {Object} ctx object to which the property is added
 * @param {String} name of property to add
 * @param {Function} getter function to be used for name
 * @namespace Utils
 * @name addProperty
 * @api public
 */

var addProperty = function addProperty(ctx, name, getter) {
  getter = getter === undefined ? function () {} : getter;
  Object.defineProperty(ctx, name, {
    get: function propertyGetter() {
      // Setting the `ssfi` flag to `propertyGetter` causes this function to
      // be the starting point for removing implementation frames from the
      // stack trace of a failed assertion.
      //
      // However, we only want to use this function as the starting point if
      // the `lockSsfi` flag isn't set and proxy protection is disabled.
      //
      // If the `lockSsfi` flag is set, then either this assertion has been
      // overwritten by another assertion, or this assertion is being invoked
      // from inside of another assertion. In the first case, the `ssfi` flag
      // has already been set by the overwriting assertion. In the second
      // case, the `ssfi` flag has already been set by the outer assertion.
      //
      // If proxy protection is enabled, then the `ssfi` flag has already been
      // set by the proxy getter.
      if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {
        flag(this, 'ssfi', propertyGetter);
      }

      var result = getter.call(this);
      if (result !== undefined) return result;
      var newAssertion = new chai$1.Assertion();
      transferFlags(this, newAssertion);
      return newAssertion;
    },
    configurable: true
  });
};var fnLengthDesc = Object.getOwnPropertyDescriptor(function () {}, 'length');
/*!
 * Chai - addLengthGuard utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .addLengthGuard(fn, assertionName, isChainable)
 *
 * Define `length` as a getter on the given uninvoked method assertion. The
 * getter acts as a guard against chaining `length` directly off of an uninvoked
 * method assertion, which is a problem because it references `function`'s
 * built-in `length` property instead of Chai's `length` assertion. When the
 * getter catches the user making this mistake, it throws an error with a
 * helpful message.
 *
 * There are two ways in which this mistake can be made. The first way is by
 * chaining the `length` assertion directly off of an uninvoked chainable
 * method. In this case, Chai suggests that the user use `lengthOf` instead. The
 * second way is by chaining the `length` assertion directly off of an uninvoked
 * non-chainable method. Non-chainable methods must be invoked prior to
 * chaining. In this case, Chai suggests that the user consult the docs for the
 * given assertion.
 *
 * If the `length` property of functions is unconfigurable, then return `fn`
 * without modification.
 *
 * Note that in ES6, the function's `length` property is configurable, so once
 * support for legacy environments is dropped, Chai's `length` property can
 * replace the built-in function's `length` property, and this length guard will
 * no longer be necessary. In the mean time, maintaining consistency across all
 * environments is the priority.
 *
 * @param {Function} fn
 * @param {String} assertionName
 * @param {Boolean} isChainable
 * @namespace Utils
 * @name addLengthGuard
 */

var addLengthGuard = function addLengthGuard(fn, assertionName, isChainable) {
  if (!fnLengthDesc.configurable) return fn;
  Object.defineProperty(fn, 'length', {
    get: function () {
      if (isChainable) {
        throw Error('Invalid Chai property: ' + assertionName + '.length. Due' + ' to a compatibility issue, "length" cannot directly follow "' + assertionName + '". Use "' + assertionName + '.lengthOf" instead.');
      }

      throw Error('Invalid Chai property: ' + assertionName + '.length. See' + ' docs for proper usage of "' + assertionName + '".');
    }
  });
  return fn;
};/*!
 * Chai - proxify utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .proxify(object)
 *
 * Return a proxy of given object that throws an error when a non-existent
 * property is read. By default, the root cause is assumed to be a misspelled
 * property, and thus an attempt is made to offer a reasonable suggestion from
 * the list of existing properties. However, if a nonChainableMethodName is
 * provided, then the root cause is instead a failure to invoke a non-chainable
 * method prior to reading the non-existent property.
 *
 * If proxies are unsupported or disabled via the user's Chai config, then
 * return object without modification.
 *
 * @param {Object} obj
 * @param {String} nonChainableMethodName
 * @namespace Utils
 * @name proxify
 */

var builtins = ['__flags', '__methods', '_obj', 'assert'];

var proxify = function proxify(obj, nonChainableMethodName) {
  if (!isProxyEnabled()) return obj;
  return new Proxy(obj, {
    get: function proxyGetter(target, property) {
      // This check is here because we should not throw errors on Symbol properties
      // such as `Symbol.toStringTag`.
      // The values for which an error should be thrown can be configured using
      // the `config.proxyExcludedKeys` setting.
      if (typeof property === 'string' && config.proxyExcludedKeys.indexOf(property) === -1 && !Reflect.has(target, property)) {
        // Special message for invalid property access of non-chainable methods.
        if (nonChainableMethodName) {
          throw Error('Invalid Chai property: ' + nonChainableMethodName + '.' + property + '. See docs for proper usage of "' + nonChainableMethodName + '".');
        } // If the property is reasonably close to an existing Chai property,
        // suggest that property to the user. Only suggest properties with a
        // distance less than 4.


        var suggestion = null;
        var suggestionDistance = 4;
        getProperties(target).forEach(function (prop) {
          if (!Object.prototype.hasOwnProperty(prop) && builtins.indexOf(prop) === -1) {
            var dist = stringDistanceCapped(property, prop, suggestionDistance);

            if (dist < suggestionDistance) {
              suggestion = prop;
              suggestionDistance = dist;
            }
          }
        });

        if (suggestion !== null) {
          throw Error('Invalid Chai property: ' + property + '. Did you mean "' + suggestion + '"?');
        } else {
          throw Error('Invalid Chai property: ' + property);
        }
      } // Use this proxy getter as the starting point for removing implementation
      // frames from the stack trace of a failed assertion. For property
      // assertions, this prevents the proxy getter from showing up in the stack
      // trace since it's invoked before the property getter. For method and
      // chainable method assertions, this flag will end up getting changed to
      // the method wrapper, which is good since this frame will no longer be in
      // the stack once the method is invoked. Note that Chai builtin assertion
      // properties such as `__flags` are skipped since this is only meant to
      // capture the starting point of an assertion. This step is also skipped
      // if the `lockSsfi` flag is set, thus indicating that this assertion is
      // being called from within another assertion. In that case, the `ssfi`
      // flag is already set to the outer assertion's starting point.


      if (builtins.indexOf(property) === -1 && !flag(target, 'lockSsfi')) {
        flag(target, 'ssfi', proxyGetter);
      }

      return Reflect.get(target, property);
    }
  });
};
/**
 * # stringDistanceCapped(strA, strB, cap)
 * Return the Levenshtein distance between two strings, but no more than cap.
 * @param {string} strA
 * @param {string} strB
 * @param {number} number
 * @return {number} min(string distance between strA and strB, cap)
 * @api private
 */


function stringDistanceCapped(strA, strB, cap) {
  if (Math.abs(strA.length - strB.length) >= cap) {
    return cap;
  }

  var memo = []; // `memo` is a two-dimensional array containing distances.
  // memo[i][j] is the distance between strA.slice(0, i) and
  // strB.slice(0, j).

  for (var i = 0; i <= strA.length; i++) {
    memo[i] = Array(strB.length + 1).fill(0);
    memo[i][0] = i;
  }

  for (var j = 0; j < strB.length; j++) {
    memo[0][j] = j;
  }

  for (var i = 1; i <= strA.length; i++) {
    var ch = strA.charCodeAt(i - 1);

    for (var j = 1; j <= strB.length; j++) {
      if (Math.abs(i - j) >= cap) {
        memo[i][j] = cap;
        continue;
      }

      memo[i][j] = Math.min(memo[i - 1][j] + 1, memo[i][j - 1] + 1, memo[i - 1][j - 1] + (ch === strB.charCodeAt(j - 1) ? 0 : 1));
    }
  }

  return memo[strA.length][strB.length];
}/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .addMethod(ctx, name, method)
 *
 * Adds a method to the prototype of an object.
 *
 *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(fooStr).to.be.foo('bar');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for name
 * @namespace Utils
 * @name addMethod
 * @api public
 */

var addMethod = function addMethod(ctx, name, method) {
  var methodWrapper = function () {
    // Setting the `ssfi` flag to `methodWrapper` causes this function to be the
    // starting point for removing implementation frames from the stack trace of
    // a failed assertion.
    //
    // However, we only want to use this function as the starting point if the
    // `lockSsfi` flag isn't set.
    //
    // If the `lockSsfi` flag is set, then either this assertion has been
    // overwritten by another assertion, or this assertion is being invoked from
    // inside of another assertion. In the first case, the `ssfi` flag has
    // already been set by the overwriting assertion. In the second case, the
    // `ssfi` flag has already been set by the outer assertion.
    if (!flag(this, 'lockSsfi')) {
      flag(this, 'ssfi', methodWrapper);
    }

    var result = method.apply(this, arguments);
    if (result !== undefined) return result;
    var newAssertion = new chai$1.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  };

  addLengthGuard(methodWrapper, name, false);
  ctx[name] = proxify(methodWrapper, name);
};/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .overwriteProperty(ctx, name, fn)
 *
 * Overwrites an already existing property getter and provides
 * access to previous value. Must return function to use as getter.
 *
 *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
 *       return function () {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.name).to.equal('bar');
 *         } else {
 *           _super.call(this);
 *         }
 *       }
 *     });
 *
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.ok;
 *
 * @param {Object} ctx object whose property is to be overwritten
 * @param {String} name of property to overwrite
 * @param {Function} getter function that returns a getter function to be used for name
 * @namespace Utils
 * @name overwriteProperty
 * @api public
 */

var overwriteProperty = function overwriteProperty(ctx, name, getter) {
  var _get = Object.getOwnPropertyDescriptor(ctx, name),
      _super = function () {};

  if (_get && 'function' === typeof _get.get) _super = _get.get;
  Object.defineProperty(ctx, name, {
    get: function overwritingPropertyGetter() {
      // Setting the `ssfi` flag to `overwritingPropertyGetter` causes this
      // function to be the starting point for removing implementation frames
      // from the stack trace of a failed assertion.
      //
      // However, we only want to use this function as the starting point if
      // the `lockSsfi` flag isn't set and proxy protection is disabled.
      //
      // If the `lockSsfi` flag is set, then either this assertion has been
      // overwritten by another assertion, or this assertion is being invoked
      // from inside of another assertion. In the first case, the `ssfi` flag
      // has already been set by the overwriting assertion. In the second
      // case, the `ssfi` flag has already been set by the outer assertion.
      //
      // If proxy protection is enabled, then the `ssfi` flag has already been
      // set by the proxy getter.
      if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {
        flag(this, 'ssfi', overwritingPropertyGetter);
      } // Setting the `lockSsfi` flag to `true` prevents the overwritten
      // assertion from changing the `ssfi` flag. By this point, the `ssfi`
      // flag is already set to the correct starting point for this assertion.


      var origLockSsfi = flag(this, 'lockSsfi');
      flag(this, 'lockSsfi', true);
      var result = getter(_super).call(this);
      flag(this, 'lockSsfi', origLockSsfi);

      if (result !== undefined) {
        return result;
      }

      var newAssertion = new chai$1.Assertion();
      transferFlags(this, newAssertion);
      return newAssertion;
    },
    configurable: true
  });
};/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .overwriteMethod(ctx, name, fn)
 *
 * Overwrites an already existing method and provides
 * access to previous function. Must return function
 * to be used for name.
 *
 *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
 *       return function (str) {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.value).to.equal(str);
 *         } else {
 *           _super.apply(this, arguments);
 *         }
 *       }
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.equal('bar');
 *
 * @param {Object} ctx object whose method is to be overwritten
 * @param {String} name of method to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @namespace Utils
 * @name overwriteMethod
 * @api public
 */

var overwriteMethod = function overwriteMethod(ctx, name, method) {
  var _method = ctx[name],
      _super = function () {
    throw new Error(name + ' is not a function');
  };

  if (_method && 'function' === typeof _method) _super = _method;

  var overwritingMethodWrapper = function () {
    // Setting the `ssfi` flag to `overwritingMethodWrapper` causes this
    // function to be the starting point for removing implementation frames from
    // the stack trace of a failed assertion.
    //
    // However, we only want to use this function as the starting point if the
    // `lockSsfi` flag isn't set.
    //
    // If the `lockSsfi` flag is set, then either this assertion has been
    // overwritten by another assertion, or this assertion is being invoked from
    // inside of another assertion. In the first case, the `ssfi` flag has
    // already been set by the overwriting assertion. In the second case, the
    // `ssfi` flag has already been set by the outer assertion.
    if (!flag(this, 'lockSsfi')) {
      flag(this, 'ssfi', overwritingMethodWrapper);
    } // Setting the `lockSsfi` flag to `true` prevents the overwritten assertion
    // from changing the `ssfi` flag. By this point, the `ssfi` flag is already
    // set to the correct starting point for this assertion.


    var origLockSsfi = flag(this, 'lockSsfi');
    flag(this, 'lockSsfi', true);
    var result = method(_super).apply(this, arguments);
    flag(this, 'lockSsfi', origLockSsfi);

    if (result !== undefined) {
      return result;
    }

    var newAssertion = new chai$1.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  };

  addLengthGuard(overwritingMethodWrapper, name, false);
  ctx[name] = proxify(overwritingMethodWrapper, name);
};/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

/*!
 * Module variables
 */
// Check whether `Object.setPrototypeOf` is supported

var canSetPrototype = typeof Object.setPrototypeOf === 'function'; // Without `Object.setPrototypeOf` support, this module will need to add properties to a function.
// However, some of functions' own props are not configurable and should be skipped.

var testFn = function () {};

var excludeNames = Object.getOwnPropertyNames(testFn).filter(function (name) {
  var propDesc = Object.getOwnPropertyDescriptor(testFn, name); // Note: PhantomJS 1.x includes `callee` as one of `testFn`'s own properties,
  // but then returns `undefined` as the property descriptor for `callee`. As a
  // workaround, we perform an otherwise unnecessary type-check for `propDesc`,
  // and then filter it out if it's not an object as it should be.

  if (typeof propDesc !== 'object') return true;
  return !propDesc.configurable;
}); // Cache `Function` properties

var call = Function.prototype.call,
    apply = Function.prototype.apply;
/**
 * ### .addChainableMethod(ctx, name, method, chainingBehavior)
 *
 * Adds a method to an object, such that the method can also be chained.
 *
 *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
 *
 * The result can then be used as both a method assertion, executing both `method` and
 * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
 *
 *     expect(fooStr).to.be.foo('bar');
 *     expect(fooStr).to.be.foo.equal('foo');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for `name`, when called
 * @param {Function} chainingBehavior function to be called every time the property is accessed
 * @namespace Utils
 * @name addChainableMethod
 * @api public
 */

var addChainableMethod = function addChainableMethod(ctx, name, method, chainingBehavior) {
  if (typeof chainingBehavior !== 'function') {
    chainingBehavior = function () {};
  }

  var chainableBehavior = {
    method: method,
    chainingBehavior: chainingBehavior
  }; // save the methods so we can overwrite them later, if we need to.

  if (!ctx.__methods) {
    ctx.__methods = {};
  }

  ctx.__methods[name] = chainableBehavior;
  Object.defineProperty(ctx, name, {
    get: function chainableMethodGetter() {
      chainableBehavior.chainingBehavior.call(this);

      var chainableMethodWrapper = function () {
        // Setting the `ssfi` flag to `chainableMethodWrapper` causes this
        // function to be the starting point for removing implementation
        // frames from the stack trace of a failed assertion.
        //
        // However, we only want to use this function as the starting point if
        // the `lockSsfi` flag isn't set.
        //
        // If the `lockSsfi` flag is set, then this assertion is being
        // invoked from inside of another assertion. In this case, the `ssfi`
        // flag has already been set by the outer assertion.
        //
        // Note that overwriting a chainable method merely replaces the saved
        // methods in `ctx.__methods` instead of completely replacing the
        // overwritten assertion. Therefore, an overwriting assertion won't
        // set the `ssfi` or `lockSsfi` flags.
        if (!flag(this, 'lockSsfi')) {
          flag(this, 'ssfi', chainableMethodWrapper);
        }

        var result = chainableBehavior.method.apply(this, arguments);

        if (result !== undefined) {
          return result;
        }

        var newAssertion = new chai$1.Assertion();
        transferFlags(this, newAssertion);
        return newAssertion;
      };

      addLengthGuard(chainableMethodWrapper, name, true); // Use `Object.setPrototypeOf` if available

      if (canSetPrototype) {
        // Inherit all properties from the object by replacing the `Function` prototype
        var prototype = Object.create(this); // Restore the `call` and `apply` methods from `Function`

        prototype.call = call;
        prototype.apply = apply;
        Object.setPrototypeOf(chainableMethodWrapper, prototype);
      } // Otherwise, redefine all properties (slow!)
      else {
          var asserterNames = Object.getOwnPropertyNames(ctx);
          asserterNames.forEach(function (asserterName) {
            if (excludeNames.indexOf(asserterName) !== -1) {
              return;
            }

            var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
            Object.defineProperty(chainableMethodWrapper, asserterName, pd);
          });
        }

      transferFlags(this, chainableMethodWrapper);
      return proxify(chainableMethodWrapper);
    },
    configurable: true
  });
};/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .overwriteChainableMethod(ctx, name, method, chainingBehavior)
 *
 * Overwrites an already existing chainable method
 * and provides access to the previous function or
 * property.  Must return functions to be used for
 * name.
 *
 *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'lengthOf',
 *       function (_super) {
 *       }
 *     , function (_super) {
 *       }
 *     );
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.have.lengthOf(3);
 *     expect(myFoo).to.have.lengthOf.above(3);
 *
 * @param {Object} ctx object whose method / property is to be overwritten
 * @param {String} name of method / property to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @param {Function} chainingBehavior function that returns a function to be used for property
 * @namespace Utils
 * @name overwriteChainableMethod
 * @api public
 */

var overwriteChainableMethod = function overwriteChainableMethod(ctx, name, method, chainingBehavior) {
  var chainableBehavior = ctx.__methods[name];
  var _chainingBehavior = chainableBehavior.chainingBehavior;

  chainableBehavior.chainingBehavior = function overwritingChainableMethodGetter() {
    var result = chainingBehavior(_chainingBehavior).call(this);

    if (result !== undefined) {
      return result;
    }

    var newAssertion = new chai$1.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  };

  var _method = chainableBehavior.method;

  chainableBehavior.method = function overwritingChainableMethodWrapper() {
    var result = method(_method).apply(this, arguments);

    if (result !== undefined) {
      return result;
    }

    var newAssertion = new chai$1.Assertion();
    transferFlags(this, newAssertion);
    return newAssertion;
  };
};/*!
 * Chai - compareByInspect utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

/**
 * ### .compareByInspect(mixed, mixed)
 *
 * To be used as a compareFunction with Array.prototype.sort. Compares elements
 * using inspect instead of default behavior of using toString so that Symbols
 * and objects with irregular/missing toString can still be sorted without a
 * TypeError.
 *
 * @param {Mixed} first element to compare
 * @param {Mixed} second element to compare
 * @returns {Number} -1 if 'a' should come before 'b'; otherwise 1
 * @name compareByInspect
 * @namespace Utils
 * @api public
 */

var compareByInspect = function compareByInspect(a, b) {
  return inspect_1(a) < inspect_1(b) ? -1 : 1;
};/*!
 * Chai - getOwnEnumerablePropertySymbols utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getOwnEnumerablePropertySymbols(object)
 *
 * This allows the retrieval of directly-owned enumerable property symbols of an
 * object. This function is necessary because Object.getOwnPropertySymbols
 * returns both enumerable and non-enumerable property symbols.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getOwnEnumerablePropertySymbols
 * @api public
 */
var getOwnEnumerablePropertySymbols = function getOwnEnumerablePropertySymbols(obj) {
  if (typeof Object.getOwnPropertySymbols !== 'function') return [];
  return Object.getOwnPropertySymbols(obj).filter(function (sym) {
    return Object.getOwnPropertyDescriptor(obj, sym).enumerable;
  });
};/*!
 * Chai - getOwnEnumerableProperties utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

/**
 * ### .getOwnEnumerableProperties(object)
 *
 * This allows the retrieval of directly-owned enumerable property names and
 * symbols of an object. This function is necessary because Object.keys only
 * returns enumerable property names, not enumerable property symbols.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getOwnEnumerableProperties
 * @api public
 */

var getOwnEnumerableProperties = function getOwnEnumerableProperties(obj) {
  return Object.keys(obj).concat(getOwnEnumerablePropertySymbols(obj));
};/* !
 * Chai - checkError utility
 * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .checkError
 *
 * Checks that an error conforms to a given set of criteria and/or retrieves information about it.
 *
 * @api public
 */

/**
 * ### .compatibleInstance(thrown, errorLike)
 *
 * Checks if two instances are compatible (strict equal).
 * Returns false if errorLike is not an instance of Error, because instances
 * can only be compatible if they're both error instances.
 *
 * @name compatibleInstance
 * @param {Error} thrown error
 * @param {Error|ErrorConstructor} errorLike object to compare against
 * @namespace Utils
 * @api public
 */

function compatibleInstance(thrown, errorLike) {
  return errorLike instanceof Error && thrown === errorLike;
}
/**
 * ### .compatibleConstructor(thrown, errorLike)
 *
 * Checks if two constructors are compatible.
 * This function can receive either an error constructor or
 * an error instance as the `errorLike` argument.
 * Constructors are compatible if they're the same or if one is
 * an instance of another.
 *
 * @name compatibleConstructor
 * @param {Error} thrown error
 * @param {Error|ErrorConstructor} errorLike object to compare against
 * @namespace Utils
 * @api public
 */


function compatibleConstructor(thrown, errorLike) {
  if (errorLike instanceof Error) {
    // If `errorLike` is an instance of any error we compare their constructors
    return thrown.constructor === errorLike.constructor || thrown instanceof errorLike.constructor;
  } else if (errorLike.prototype instanceof Error || errorLike === Error) {
    // If `errorLike` is a constructor that inherits from Error, we compare `thrown` to `errorLike` directly
    return thrown.constructor === errorLike || thrown instanceof errorLike;
  }

  return false;
}
/**
 * ### .compatibleMessage(thrown, errMatcher)
 *
 * Checks if an error's message is compatible with a matcher (String or RegExp).
 * If the message contains the String or passes the RegExp test,
 * it is considered compatible.
 *
 * @name compatibleMessage
 * @param {Error} thrown error
 * @param {String|RegExp} errMatcher to look for into the message
 * @namespace Utils
 * @api public
 */


function compatibleMessage(thrown, errMatcher) {
  var comparisonString = typeof thrown === 'string' ? thrown : thrown.message;

  if (errMatcher instanceof RegExp) {
    return errMatcher.test(comparisonString);
  } else if (typeof errMatcher === 'string') {
    return comparisonString.indexOf(errMatcher) !== -1; // eslint-disable-line no-magic-numbers
  }

  return false;
}
/**
 * ### .getFunctionName(constructorFn)
 *
 * Returns the name of a function.
 * This also includes a polyfill function if `constructorFn.name` is not defined.
 *
 * @name getFunctionName
 * @param {Function} constructorFn
 * @namespace Utils
 * @api private
 */


var functionNameMatch$1 = /\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\(\/]+)/;

function getFunctionName(constructorFn) {
  var name = '';

  if (typeof constructorFn.name === 'undefined') {
    // Here we run a polyfill if constructorFn.name is not defined
    var match = String(constructorFn).match(functionNameMatch$1);

    if (match) {
      name = match[1];
    }
  } else {
    name = constructorFn.name;
  }

  return name;
}
/**
 * ### .getConstructorName(errorLike)
 *
 * Gets the constructor name for an Error instance or constructor itself.
 *
 * @name getConstructorName
 * @param {Error|ErrorConstructor} errorLike
 * @namespace Utils
 * @api public
 */


function getConstructorName(errorLike) {
  var constructorName = errorLike;

  if (errorLike instanceof Error) {
    constructorName = getFunctionName(errorLike.constructor);
  } else if (typeof errorLike === 'function') {
    // If `err` is not an instance of Error it is an error constructor itself or another function.
    // If we've got a common function we get its name, otherwise we may need to create a new instance
    // of the error just in case it's a poorly-constructed error. Please see chaijs/chai/issues/45 to know more.
    constructorName = getFunctionName(errorLike).trim() || getFunctionName(new errorLike()); // eslint-disable-line new-cap
  }

  return constructorName;
}
/**
 * ### .getMessage(errorLike)
 *
 * Gets the error message from an error.
 * If `err` is a String itself, we return it.
 * If the error has no message, we return an empty string.
 *
 * @name getMessage
 * @param {Error|String} errorLike
 * @namespace Utils
 * @api public
 */


function getMessage$1(errorLike) {
  var msg = '';

  if (errorLike && errorLike.message) {
    msg = errorLike.message;
  } else if (typeof errorLike === 'string') {
    msg = errorLike;
  }

  return msg;
}

var checkError = {
  compatibleInstance: compatibleInstance,
  compatibleConstructor: compatibleConstructor,
  compatibleMessage: compatibleMessage,
  getMessage: getMessage$1,
  getConstructorName: getConstructorName
};/*!
 * Chai - isNaN utility
 * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
 * MIT Licensed
 */

/**
 * ### .isNaN(value)
 *
 * Checks if the given value is NaN or not.
 *
 *     utils.isNaN(NaN); // true
 *
 * @param {Value} The value which has to be checked if it is NaN
 * @name isNaN
 * @api private
 */
function isNaN$1(value) {
  // Refer http://www.ecma-international.org/ecma-262/6.0/#sec-isnan-number
  // section's NOTE.
  return value !== value;
} // If ECMAScript 6's Number.isNaN is present, prefer that.


var _isNaN = Number.isNaN || isNaN$1;/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Dependencies that are used for multiple exports are required here only once
 */

/*!
 * test utility
 */

var test$2 = test$1;
/*!
 * type utility
 */

var type = typeDetect;
/*!
 * expectTypes utility
 */

var expectTypes$1 = expectTypes;
/*!
 * message utility
 */

var getMessage$2 = getMessage;
/*!
 * actual utility
 */

var getActual$1 = getActual;
/*!
 * Inspect util
 */

var inspect = inspect_1;
/*!
 * Object Display util
 */

var objDisplay$1 = objDisplay;
/*!
 * Flag utility
 */

var flag$1 = flag;
/*!
 * Flag transferring utility
 */

var transferFlags$1 = transferFlags;
/*!
 * Deep equal utility
 */

var eql = deepEql;
/*!
 * Deep path info
 */

var getPathInfo$1 = pathval.getPathInfo;
/*!
 * Check if a property exists
 */

var hasProperty$1 = pathval.hasProperty;
/*!
 * Function name
 */

var getName = getFuncName_1;
/*!
 * add Property
 */

var addProperty$1 = addProperty;
/*!
 * add Method
 */

var addMethod$1 = addMethod;
/*!
 * overwrite Property
 */

var overwriteProperty$1 = overwriteProperty;
/*!
 * overwrite Method
 */

var overwriteMethod$1 = overwriteMethod;
/*!
 * Add a chainable method
 */

var addChainableMethod$1 = addChainableMethod;
/*!
 * Overwrite chainable method
 */

var overwriteChainableMethod$1 = overwriteChainableMethod;
/*!
 * Compare by inspect method
 */

var compareByInspect$1 = compareByInspect;
/*!
 * Get own enumerable property symbols method
 */

var getOwnEnumerablePropertySymbols$1 = getOwnEnumerablePropertySymbols;
/*!
 * Get own enumerable properties method
 */

var getOwnEnumerableProperties$1 = getOwnEnumerableProperties;
/*!
 * Checks error against a given set of criteria
 */

var checkError$1 = checkError;
/*!
 * Proxify util
 */

var proxify$1 = proxify;
/*!
 * addLengthGuard util
 */

var addLengthGuard$1 = addLengthGuard;
/*!
 * isProxyEnabled helper
 */

var isProxyEnabled$1 = isProxyEnabled;
/*!
 * isNaN method
 */

var isNaN$2 = _isNaN;
var utils = {
  test: test$2,
  type: type,
  expectTypes: expectTypes$1,
  getMessage: getMessage$2,
  getActual: getActual$1,
  inspect: inspect,
  objDisplay: objDisplay$1,
  flag: flag$1,
  transferFlags: transferFlags$1,
  eql: eql,
  getPathInfo: getPathInfo$1,
  hasProperty: hasProperty$1,
  getName: getName,
  addProperty: addProperty$1,
  addMethod: addMethod$1,
  overwriteProperty: overwriteProperty$1,
  overwriteMethod: overwriteMethod$1,
  addChainableMethod: addChainableMethod$1,
  overwriteChainableMethod: overwriteChainableMethod$1,
  compareByInspect: compareByInspect$1,
  getOwnEnumerablePropertySymbols: getOwnEnumerablePropertySymbols$1,
  getOwnEnumerableProperties: getOwnEnumerableProperties$1,
  checkError: checkError$1,
  proxify: proxify$1,
  addLengthGuard: addLengthGuard$1,
  isProxyEnabled: isProxyEnabled$1,
  isNaN: isNaN$2
};/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var assertion = function (_chai, util) {
  /*!
   * Module dependencies.
   */
  var AssertionError = _chai.AssertionError,
      flag = util.flag;
  /*!
   * Module export.
   */

  _chai.Assertion = Assertion;
  /*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * `Assertion` objects contain metadata in the form of flags. Three flags can
   * be assigned during instantiation by passing arguments to this constructor:
   *
   * - `object`: This flag contains the target of the assertion. For example, in
   *   the assertion `expect(numKittens).to.equal(7);`, the `object` flag will
   *   contain `numKittens` so that the `equal` assertion can reference it when
   *   needed.
   *
   * - `message`: This flag contains an optional custom error message to be
   *   prepended to the error message that's generated by the assertion when it
   *   fails.
   *
   * - `ssfi`: This flag stands for "start stack function indicator". It
   *   contains a function reference that serves as the starting point for
   *   removing frames from the stack trace of the error that's created by the
   *   assertion when it fails. The goal is to provide a cleaner stack trace to
   *   end users by removing Chai's internal functions. Note that it only works
   *   in environments that support `Error.captureStackTrace`, and only when
   *   `Chai.config.includeStack` hasn't been set to `false`.
   *
   * - `lockSsfi`: This flag controls whether or not the given `ssfi` flag
   *   should retain its current value, even as assertions are chained off of
   *   this object. This is usually set to `true` when creating a new assertion
   *   from within another assertion. It's also temporarily set to `true` before
   *   an overwritten assertion gets called by the overwriting assertion.
   *
   * @param {Mixed} obj target of the assertion
   * @param {String} msg (optional) custom error message
   * @param {Function} ssfi (optional) starting point for removing stack frames
   * @param {Boolean} lockSsfi (optional) whether or not the ssfi flag is locked
   * @api private
   */

  function Assertion(obj, msg, ssfi, lockSsfi) {
    flag(this, 'ssfi', ssfi || Assertion);
    flag(this, 'lockSsfi', lockSsfi);
    flag(this, 'object', obj);
    flag(this, 'message', msg);
    return util.proxify(this);
  }

  Object.defineProperty(Assertion, 'includeStack', {
    get: function () {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      return config.includeStack;
    },
    set: function (value) {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      config.includeStack = value;
    }
  });
  Object.defineProperty(Assertion, 'showDiff', {
    get: function () {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      return config.showDiff;
    },
    set: function (value) {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      config.showDiff = value;
    }
  });

  Assertion.addProperty = function (name, fn) {
    util.addProperty(this.prototype, name, fn);
  };

  Assertion.addMethod = function (name, fn) {
    util.addMethod(this.prototype, name, fn);
  };

  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  Assertion.overwriteProperty = function (name, fn) {
    util.overwriteProperty(this.prototype, name, fn);
  };

  Assertion.overwriteMethod = function (name, fn) {
    util.overwriteMethod(this.prototype, name, fn);
  };

  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {
    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
  };
  /**
   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {Philosophical} expression to be tested
   * @param {String|Function} message or function that returns message to display if expression fails
   * @param {String|Function} negatedMessage or function that returns negatedMessage to display if negated expression fails
   * @param {Mixed} expected value (remember to check for negation)
   * @param {Mixed} actual (optional) will default to `this.obj`
   * @param {Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
   * @api private
   */


  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
    var ok = util.test(this, arguments);
    if (false !== showDiff) showDiff = true;
    if (undefined === expected && undefined === _actual) showDiff = false;
    if (true !== config.showDiff) showDiff = false;

    if (!ok) {
      msg = util.getMessage(this, arguments);
      var actual = util.getActual(this, arguments);
      throw new AssertionError(msg, {
        actual: actual,
        expected: expected,
        showDiff: showDiff
      }, config.includeStack ? this.assert : flag(this, 'ssfi'));
    }
  };
  /*!
   * ### ._obj
   *
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @api private
   */


  Object.defineProperty(Assertion.prototype, '_obj', {
    get: function () {
      return flag(this, 'object');
    },
    set: function (val) {
      flag(this, 'object', val);
    }
  });
};/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var assertions = function (chai, _) {
  var Assertion = chai.Assertion,
      AssertionError = chai.AssertionError,
      flag = _.flag;
  /**
   * ### Language Chains
   *
   * The following are provided as chainable getters to improve the readability
   * of your assertions.
   *
   * **Chains**
   *
   * - to
   * - be
   * - been
   * - is
   * - that
   * - which
   * - and
   * - has
   * - have
   * - with
   * - at
   * - of
   * - same
   * - but
   * - does
   * - still
   *
   * @name language chains
   * @namespace BDD
   * @api public
   */

  ['to', 'be', 'been', 'is', 'and', 'has', 'have', 'with', 'that', 'which', 'at', 'of', 'same', 'but', 'does', 'still'].forEach(function (chain) {
    Assertion.addProperty(chain);
  });
  /**
   * ### .not
   *
   * Negates all assertions that follow in the chain.
   *
   *     expect(function () {}).to.not.throw();
   *     expect({a: 1}).to.not.have.property('b');
   *     expect([1, 2]).to.be.an('array').that.does.not.include(3);
   *
   * Just because you can negate any assertion with `.not` doesn't mean you
   * should. With great power comes great responsibility. It's often best to
   * assert that the one expected output was produced, rather than asserting
   * that one of countless unexpected outputs wasn't produced. See individual
   * assertions for specific guidance.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.not.equal(1); // Not recommended
   *
   * @name not
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('not', function () {
    flag(this, 'negate', true);
  });
  /**
   * ### .deep
   *
   * Causes all `.equal`, `.include`, `.members`, `.keys`, and `.property`
   * assertions that follow in the chain to use deep equality instead of strict
   * (`===`) equality. See the `deep-eql` project page for info on the deep
   * equality algorithm: https://github.com/chaijs/deep-eql.
   *
   *     // Target object deeply (but not strictly) equals `{a: 1}`
   *     expect({a: 1}).to.deep.equal({a: 1});
   *     expect({a: 1}).to.not.equal({a: 1});
   *
   *     // Target array deeply (but not strictly) includes `{a: 1}`
   *     expect([{a: 1}]).to.deep.include({a: 1});
   *     expect([{a: 1}]).to.not.include({a: 1});
   *
   *     // Target object deeply (but not strictly) includes `x: {a: 1}`
   *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
   *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});
   *
   *     // Target array deeply (but not strictly) has member `{a: 1}`
   *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);
   *     expect([{a: 1}]).to.not.have.members([{a: 1}]);
   *
   *     // Target set deeply (but not strictly) has key `{a: 1}`
   *     expect(new Set([{a: 1}])).to.have.deep.keys([{a: 1}]);
   *     expect(new Set([{a: 1}])).to.not.have.keys([{a: 1}]);
   *
   *     // Target object deeply (but not strictly) has property `x: {a: 1}`
   *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
   *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
   *
   * @name deep
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('deep', function () {
    flag(this, 'deep', true);
  });
  /**
   * ### .nested
   *
   * Enables dot- and bracket-notation in all `.property` and `.include`
   * assertions that follow in the chain.
   *
   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
   *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
   *
   * If `.` or `[]` are part of an actual property name, they can be escaped by
   * adding two backslashes before them.
   *
   *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\.a.\\[b\\]');
   *     expect({'.a': {'[b]': 'x'}}).to.nested.include({'\\.a.\\[b\\]': 'x'});
   *
   * `.nested` cannot be combined with `.own`.
   *
   * @name nested
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('nested', function () {
    flag(this, 'nested', true);
  });
  /**
   * ### .own
   *
   * Causes all `.property` and `.include` assertions that follow in the chain
   * to ignore inherited properties.
   *
   *     Object.prototype.b = 2;
   *
   *     expect({a: 1}).to.have.own.property('a');
   *     expect({a: 1}).to.have.property('b');
   *     expect({a: 1}).to.not.have.own.property('b');
   *
   *     expect({a: 1}).to.own.include({a: 1});
   *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
   *
   * `.own` cannot be combined with `.nested`.
   *
   * @name own
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('own', function () {
    flag(this, 'own', true);
  });
  /**
   * ### .ordered
   *
   * Causes all `.members` assertions that follow in the chain to require that
   * members be in the same order.
   *
   *     expect([1, 2]).to.have.ordered.members([1, 2])
   *       .but.not.have.ordered.members([2, 1]);
   *
   * When `.include` and `.ordered` are combined, the ordering begins at the
   * start of both arrays.
   *
   *     expect([1, 2, 3]).to.include.ordered.members([1, 2])
   *       .but.not.include.ordered.members([2, 3]);
   *
   * @name ordered
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('ordered', function () {
    flag(this, 'ordered', true);
  });
  /**
   * ### .any
   *
   * Causes all `.keys` assertions that follow in the chain to only require that
   * the target have at least one of the given keys. This is the opposite of
   * `.all`, which requires that the target have all of the given keys.
   *
   *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');
   *
   * See the `.keys` doc for guidance on when to use `.any` or `.all`.
   *
   * @name any
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('any', function () {
    flag(this, 'any', true);
    flag(this, 'all', false);
  });
  /**
   * ### .all
   *
   * Causes all `.keys` assertions that follow in the chain to require that the
   * target have all of the given keys. This is the opposite of `.any`, which
   * only requires that the target have at least one of the given keys.
   *
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
   *
   * Note that `.all` is used by default when neither `.all` nor `.any` are
   * added earlier in the chain. However, it's often best to add `.all` anyway
   * because it improves readability.
   *
   * See the `.keys` doc for guidance on when to use `.any` or `.all`.
   *
   * @name all
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('all', function () {
    flag(this, 'all', true);
    flag(this, 'any', false);
  });
  /**
   * ### .a(type[, msg])
   *
   * Asserts that the target's type is equal to the given string `type`. Types
   * are case insensitive. See the `type-detect` project page for info on the
   * type detection algorithm: https://github.com/chaijs/type-detect.
   *
   *     expect('foo').to.be.a('string');
   *     expect({a: 1}).to.be.an('object');
   *     expect(null).to.be.a('null');
   *     expect(undefined).to.be.an('undefined');
   *     expect(new Error).to.be.an('error');
   *     expect(Promise.resolve()).to.be.a('promise');
   *     expect(new Float32Array).to.be.a('float32array');
   *     expect(Symbol()).to.be.a('symbol');
   *
   * `.a` supports objects that have a custom type set via `Symbol.toStringTag`.
   *
   *     var myObj = {
   *       [Symbol.toStringTag]: 'myCustomType'
   *     };
   *
   *     expect(myObj).to.be.a('myCustomType').but.not.an('object');
   *
   * It's often best to use `.a` to check a target's type before making more
   * assertions on the same target. That way, you avoid unexpected behavior from
   * any assertion that does different things based on the target's type.
   *
   *     expect([1, 2, 3]).to.be.an('array').that.includes(2);
   *     expect([]).to.be.an('array').that.is.empty;
   *
   * Add `.not` earlier in the chain to negate `.a`. However, it's often best to
   * assert that the target is the expected type, rather than asserting that it
   * isn't one of many unexpected types.
   *
   *     expect('foo').to.be.a('string'); // Recommended
   *     expect('foo').to.not.be.an('array'); // Not recommended
   *
   * `.a` accepts an optional `msg` argument which is a custom error message to
   * show when the assertion fails. The message can also be given as the second
   * argument to `expect`.
   *
   *     expect(1).to.be.a('string', 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.a('string');
   *
   * `.a` can also be used as a language chain to improve the readability of
   * your assertions.
   *
   *     expect({b: 2}).to.have.a.property('b');
   *
   * The alias `.an` can be used interchangeably with `.a`.
   *
   * @name a
   * @alias an
   * @param {String} type
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function an(type, msg) {
    if (msg) flag(this, 'message', msg);
    type = type.toLowerCase();
    var obj = flag(this, 'object'),
        article = ~['a', 'e', 'i', 'o', 'u'].indexOf(type.charAt(0)) ? 'an ' : 'a ';
    this.assert(type === _.type(obj).toLowerCase(), 'expected #{this} to be ' + article + type, 'expected #{this} not to be ' + article + type);
  }

  Assertion.addChainableMethod('an', an);
  Assertion.addChainableMethod('a', an);
  /**
   * ### .include(val[, msg])
   *
   * When the target is a string, `.include` asserts that the given string `val`
   * is a substring of the target.
   *
   *     expect('foobar').to.include('foo');
   *
   * When the target is an array, `.include` asserts that the given `val` is a
   * member of the target.
   *
   *     expect([1, 2, 3]).to.include(2);
   *
   * When the target is an object, `.include` asserts that the given object
   * `val`'s properties are a subset of the target's properties.
   *
   *     expect({a: 1, b: 2, c: 3}).to.include({a: 1, b: 2});
   *
   * When the target is a Set or WeakSet, `.include` asserts that the given `val` is a
   * member of the target. SameValueZero equality algorithm is used.
   *
   *     expect(new Set([1, 2])).to.include(2);
   *
   * When the target is a Map, `.include` asserts that the given `val` is one of
   * the values of the target. SameValueZero equality algorithm is used.
   *
   *     expect(new Map([['a', 1], ['b', 2]])).to.include(2);
   *
   * Because `.include` does different things based on the target's type, it's
   * important to check the target's type before using `.include`. See the `.a`
   * doc for info on testing a target's type.
   *
   *     expect([1, 2, 3]).to.be.an('array').that.includes(2);
   *
   * By default, strict (`===`) equality is used to compare array members and
   * object properties. Add `.deep` earlier in the chain to use deep equality
   * instead (WeakSet targets are not supported). See the `deep-eql` project
   * page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.
   *
   *     // Target array deeply (but not strictly) includes `{a: 1}`
   *     expect([{a: 1}]).to.deep.include({a: 1});
   *     expect([{a: 1}]).to.not.include({a: 1});
   *
   *     // Target object deeply (but not strictly) includes `x: {a: 1}`
   *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});
   *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});
   *
   * By default, all of the target's properties are searched when working with
   * objects. This includes properties that are inherited and/or non-enumerable.
   * Add `.own` earlier in the chain to exclude the target's inherited
   * properties from the search.
   *
   *     Object.prototype.b = 2;
   *
   *     expect({a: 1}).to.own.include({a: 1});
   *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});
   *
   * Note that a target object is always only searched for `val`'s own
   * enumerable properties.
   *
   * `.deep` and `.own` can be combined.
   *
   *     expect({a: {b: 2}}).to.deep.own.include({a: {b: 2}});
   *
   * Add `.nested` earlier in the chain to enable dot- and bracket-notation when
   * referencing nested properties.
   *
   *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});
   *
   * If `.` or `[]` are part of an actual property name, they can be escaped by
   * adding two backslashes before them.
   *
   *     expect({'.a': {'[b]': 2}}).to.nested.include({'\\.a.\\[b\\]': 2});
   *
   * `.deep` and `.nested` can be combined.
   *
   *     expect({a: {b: [{c: 3}]}}).to.deep.nested.include({'a.b[0]': {c: 3}});
   *
   * `.own` and `.nested` cannot be combined.
   *
   * Add `.not` earlier in the chain to negate `.include`.
   *
   *     expect('foobar').to.not.include('taco');
   *     expect([1, 2, 3]).to.not.include(4);
   *
   * However, it's dangerous to negate `.include` when the target is an object.
   * The problem is that it creates uncertain expectations by asserting that the
   * target object doesn't have all of `val`'s key/value pairs but may or may
   * not have some of them. It's often best to identify the exact output that's
   * expected, and then write an assertion that only accepts that exact output.
   *
   * When the target object isn't even expected to have `val`'s keys, it's
   * often best to assert exactly that.
   *
   *     expect({c: 3}).to.not.have.any.keys('a', 'b'); // Recommended
   *     expect({c: 3}).to.not.include({a: 1, b: 2}); // Not recommended
   *
   * When the target object is expected to have `val`'s keys, it's often best to
   * assert that each of the properties has its expected value, rather than
   * asserting that each property doesn't have one of many unexpected values.
   *
   *     expect({a: 3, b: 4}).to.include({a: 3, b: 4}); // Recommended
   *     expect({a: 3, b: 4}).to.not.include({a: 1, b: 2}); // Not recommended
   *
   * `.include` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect([1, 2, 3]).to.include(4, 'nooo why fail??');
   *     expect([1, 2, 3], 'nooo why fail??').to.include(4);
   *
   * `.include` can also be used as a language chain, causing all `.members` and
   * `.keys` assertions that follow in the chain to require the target to be a
   * superset of the expected set, rather than an identical set. Note that
   * `.members` ignores duplicates in the subset when `.include` is added.
   *
   *     // Target object's keys are a superset of ['a', 'b'] but not identical
   *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
   *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');
   *
   *     // Target array is a superset of [1, 2] but not identical
   *     expect([1, 2, 3]).to.include.members([1, 2]);
   *     expect([1, 2, 3]).to.not.have.members([1, 2]);
   *
   *     // Duplicates in the subset are ignored
   *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
   *
   * Note that adding `.any` earlier in the chain causes the `.keys` assertion
   * to ignore `.include`.
   *
   *     // Both assertions are identical
   *     expect({a: 1}).to.include.any.keys('a', 'b');
   *     expect({a: 1}).to.have.any.keys('a', 'b');
   *
   * The aliases `.includes`, `.contain`, and `.contains` can be used
   * interchangeably with `.include`.
   *
   * @name include
   * @alias contain
   * @alias includes
   * @alias contains
   * @param {Mixed} val
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function SameValueZero(a, b) {
    return _.isNaN(a) && _.isNaN(b) || a === b;
  }

  function includeChainingBehavior() {
    flag(this, 'contains', true);
  }

  function include(val, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        objType = _.type(obj).toLowerCase(),
        flagMsg = flag(this, 'message'),
        negate = flag(this, 'negate'),
        ssfi = flag(this, 'ssfi'),
        isDeep = flag(this, 'deep'),
        descriptor = isDeep ? 'deep ' : '';

    flagMsg = flagMsg ? flagMsg + ': ' : '';
    var included = false;

    switch (objType) {
      case 'string':
        included = obj.indexOf(val) !== -1;
        break;

      case 'weakset':
        if (isDeep) {
          throw new AssertionError(flagMsg + 'unable to use .deep.include with WeakSet', undefined, ssfi);
        }

        included = obj.has(val);
        break;

      case 'map':
        var isEql = isDeep ? _.eql : SameValueZero;
        obj.forEach(function (item) {
          included = included || isEql(item, val);
        });
        break;

      case 'set':
        if (isDeep) {
          obj.forEach(function (item) {
            included = included || _.eql(item, val);
          });
        } else {
          included = obj.has(val);
        }

        break;

      case 'array':
        if (isDeep) {
          included = obj.some(function (item) {
            return _.eql(item, val);
          });
        } else {
          included = obj.indexOf(val) !== -1;
        }

        break;

      default:
        // This block is for asserting a subset of properties in an object.
        // `_.expectTypes` isn't used here because `.include` should work with
        // objects with a custom `@@toStringTag`.
        if (val !== Object(val)) {
          throw new AssertionError(flagMsg + 'object tested must be an array, a map, an object,' + ' a set, a string, or a weakset, but ' + objType + ' given', undefined, ssfi);
        }

        var props = Object.keys(val),
            firstErr = null,
            numErrs = 0;
        props.forEach(function (prop) {
          var propAssertion = new Assertion(obj);

          _.transferFlags(this, propAssertion, true);

          flag(propAssertion, 'lockSsfi', true);

          if (!negate || props.length === 1) {
            propAssertion.property(prop, val[prop]);
            return;
          }

          try {
            propAssertion.property(prop, val[prop]);
          } catch (err) {
            if (!_.checkError.compatibleConstructor(err, AssertionError)) {
              throw err;
            }

            if (firstErr === null) firstErr = err;
            numErrs++;
          }
        }, this); // When validating .not.include with multiple properties, we only want
        // to throw an assertion error if all of the properties are included,
        // in which case we throw the first property assertion error that we
        // encountered.

        if (negate && props.length > 1 && numErrs === props.length) {
          throw firstErr;
        }

        return;
    } // Assert inclusion in collection or substring in a string.


    this.assert(included, 'expected #{this} to ' + descriptor + 'include ' + _.inspect(val), 'expected #{this} to not ' + descriptor + 'include ' + _.inspect(val));
  }

  Assertion.addChainableMethod('include', include, includeChainingBehavior);
  Assertion.addChainableMethod('contain', include, includeChainingBehavior);
  Assertion.addChainableMethod('contains', include, includeChainingBehavior);
  Assertion.addChainableMethod('includes', include, includeChainingBehavior);
  /**
   * ### .ok
   *
   * Asserts that the target is a truthy value (considered `true` in boolean context).
   * However, it's often best to assert that the target is strictly (`===`) or
   * deeply equal to its expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.ok; // Not recommended
   *
   *     expect(true).to.be.true; // Recommended
   *     expect(true).to.be.ok; // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.ok`.
   *
   *     expect(0).to.equal(0); // Recommended
   *     expect(0).to.not.be.ok; // Not recommended
   *
   *     expect(false).to.be.false; // Recommended
   *     expect(false).to.not.be.ok; // Not recommended
   *
   *     expect(null).to.be.null; // Recommended
   *     expect(null).to.not.be.ok; // Not recommended
   *
   *     expect(undefined).to.be.undefined; // Recommended
   *     expect(undefined).to.not.be.ok; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(false, 'nooo why fail??').to.be.ok;
   *
   * @name ok
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('ok', function () {
    this.assert(flag(this, 'object'), 'expected #{this} to be truthy', 'expected #{this} to be falsy');
  });
  /**
   * ### .true
   *
   * Asserts that the target is strictly (`===`) equal to `true`.
   *
   *     expect(true).to.be.true;
   *
   * Add `.not` earlier in the chain to negate `.true`. However, it's often best
   * to assert that the target is equal to its expected value, rather than not
   * equal to `true`.
   *
   *     expect(false).to.be.false; // Recommended
   *     expect(false).to.not.be.true; // Not recommended
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.true; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(false, 'nooo why fail??').to.be.true;
   *
   * @name true
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('true', function () {
    this.assert(true === flag(this, 'object'), 'expected #{this} to be true', 'expected #{this} to be false', flag(this, 'negate') ? false : true);
  });
  /**
   * ### .false
   *
   * Asserts that the target is strictly (`===`) equal to `false`.
   *
   *     expect(false).to.be.false;
   *
   * Add `.not` earlier in the chain to negate `.false`. However, it's often
   * best to assert that the target is equal to its expected value, rather than
   * not equal to `false`.
   *
   *     expect(true).to.be.true; // Recommended
   *     expect(true).to.not.be.false; // Not recommended
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.false; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(true, 'nooo why fail??').to.be.false;
   *
   * @name false
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('false', function () {
    this.assert(false === flag(this, 'object'), 'expected #{this} to be false', 'expected #{this} to be true', flag(this, 'negate') ? true : false);
  });
  /**
   * ### .null
   *
   * Asserts that the target is strictly (`===`) equal to `null`.
   *
   *     expect(null).to.be.null;
   *
   * Add `.not` earlier in the chain to negate `.null`. However, it's often best
   * to assert that the target is equal to its expected value, rather than not
   * equal to `null`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.null; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(42, 'nooo why fail??').to.be.null;
   *
   * @name null
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('null', function () {
    this.assert(null === flag(this, 'object'), 'expected #{this} to be null', 'expected #{this} not to be null');
  });
  /**
   * ### .undefined
   *
   * Asserts that the target is strictly (`===`) equal to `undefined`.
   *
   *     expect(undefined).to.be.undefined;
   *
   * Add `.not` earlier in the chain to negate `.undefined`. However, it's often
   * best to assert that the target is equal to its expected value, rather than
   * not equal to `undefined`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.undefined; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(42, 'nooo why fail??').to.be.undefined;
   *
   * @name undefined
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('undefined', function () {
    this.assert(undefined === flag(this, 'object'), 'expected #{this} to be undefined', 'expected #{this} not to be undefined');
  });
  /**
   * ### .NaN
   *
   * Asserts that the target is exactly `NaN`.
   *
   *     expect(NaN).to.be.NaN;
   *
   * Add `.not` earlier in the chain to negate `.NaN`. However, it's often best
   * to assert that the target is equal to its expected value, rather than not
   * equal to `NaN`.
   *
   *     expect('foo').to.equal('foo'); // Recommended
   *     expect('foo').to.not.be.NaN; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(42, 'nooo why fail??').to.be.NaN;
   *
   * @name NaN
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('NaN', function () {
    this.assert(_.isNaN(flag(this, 'object')), 'expected #{this} to be NaN', 'expected #{this} not to be NaN');
  });
  /**
   * ### .exist
   *
   * Asserts that the target is not strictly (`===`) equal to either `null` or
   * `undefined`. However, it's often best to assert that the target is equal to
   * its expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.exist; // Not recommended
   *
   *     expect(0).to.equal(0); // Recommended
   *     expect(0).to.exist; // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.exist`.
   *
   *     expect(null).to.be.null; // Recommended
   *     expect(null).to.not.exist; // Not recommended
   *
   *     expect(undefined).to.be.undefined; // Recommended
   *     expect(undefined).to.not.exist; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(null, 'nooo why fail??').to.exist;
   *
   * @name exist
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('exist', function () {
    var val = flag(this, 'object');
    this.assert(val !== null && val !== undefined, 'expected #{this} to exist', 'expected #{this} to not exist');
  });
  /**
   * ### .empty
   *
   * When the target is a string or array, `.empty` asserts that the target's
   * `length` property is strictly (`===`) equal to `0`.
   *
   *     expect([]).to.be.empty;
   *     expect('').to.be.empty;
   *
   * When the target is a map or set, `.empty` asserts that the target's `size`
   * property is strictly equal to `0`.
   *
   *     expect(new Set()).to.be.empty;
   *     expect(new Map()).to.be.empty;
   *
   * When the target is a non-function object, `.empty` asserts that the target
   * doesn't have any own enumerable properties. Properties with Symbol-based
   * keys are excluded from the count.
   *
   *     expect({}).to.be.empty;
   *
   * Because `.empty` does different things based on the target's type, it's
   * important to check the target's type before using `.empty`. See the `.a`
   * doc for info on testing a target's type.
   *
   *     expect([]).to.be.an('array').that.is.empty;
   *
   * Add `.not` earlier in the chain to negate `.empty`. However, it's often
   * best to assert that the target contains its expected number of values,
   * rather than asserting that it's not empty.
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.not.be.empty; // Not recommended
   *
   *     expect(new Set([1, 2, 3])).to.have.property('size', 3); // Recommended
   *     expect(new Set([1, 2, 3])).to.not.be.empty; // Not recommended
   *
   *     expect(Object.keys({a: 1})).to.have.lengthOf(1); // Recommended
   *     expect({a: 1}).to.not.be.empty; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect([1, 2, 3], 'nooo why fail??').to.be.empty;
   *
   * @name empty
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('empty', function () {
    var val = flag(this, 'object'),
        ssfi = flag(this, 'ssfi'),
        flagMsg = flag(this, 'message'),
        itemsCount;
    flagMsg = flagMsg ? flagMsg + ': ' : '';

    switch (_.type(val).toLowerCase()) {
      case 'array':
      case 'string':
        itemsCount = val.length;
        break;

      case 'map':
      case 'set':
        itemsCount = val.size;
        break;

      case 'weakmap':
      case 'weakset':
        throw new AssertionError(flagMsg + '.empty was passed a weak collection', undefined, ssfi);

      case 'function':
        var msg = flagMsg + '.empty was passed a function ' + _.getName(val);

        throw new AssertionError(msg.trim(), undefined, ssfi);

      default:
        if (val !== Object(val)) {
          throw new AssertionError(flagMsg + '.empty was passed non-string primitive ' + _.inspect(val), undefined, ssfi);
        }

        itemsCount = Object.keys(val).length;
    }

    this.assert(0 === itemsCount, 'expected #{this} to be empty', 'expected #{this} not to be empty');
  });
  /**
   * ### .arguments
   *
   * Asserts that the target is an `arguments` object.
   *
   *     function test () {
   *       expect(arguments).to.be.arguments;
   *     }
   *
   *     test();
   *
   * Add `.not` earlier in the chain to negate `.arguments`. However, it's often
   * best to assert which type the target is expected to be, rather than
   * asserting that its not an `arguments` object.
   *
   *     expect('foo').to.be.a('string'); // Recommended
   *     expect('foo').to.not.be.arguments; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({}, 'nooo why fail??').to.be.arguments;
   *
   * The alias `.Arguments` can be used interchangeably with `.arguments`.
   *
   * @name arguments
   * @alias Arguments
   * @namespace BDD
   * @api public
   */

  function checkArguments() {
    var obj = flag(this, 'object'),
        type = _.type(obj);

    this.assert('Arguments' === type, 'expected #{this} to be arguments but got ' + type, 'expected #{this} to not be arguments');
  }

  Assertion.addProperty('arguments', checkArguments);
  Assertion.addProperty('Arguments', checkArguments);
  /**
   * ### .equal(val[, msg])
   *
   * Asserts that the target is strictly (`===`) equal to the given `val`.
   *
   *     expect(1).to.equal(1);
   *     expect('foo').to.equal('foo');
   *
   * Add `.deep` earlier in the chain to use deep equality instead. See the
   * `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target object deeply (but not strictly) equals `{a: 1}`
   *     expect({a: 1}).to.deep.equal({a: 1});
   *     expect({a: 1}).to.not.equal({a: 1});
   *
   *     // Target array deeply (but not strictly) equals `[1, 2]`
   *     expect([1, 2]).to.deep.equal([1, 2]);
   *     expect([1, 2]).to.not.equal([1, 2]);
   *
   * Add `.not` earlier in the chain to negate `.equal`. However, it's often
   * best to assert that the target is equal to its expected value, rather than
   * not equal to one of countless unexpected values.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.equal(2); // Not recommended
   *
   * `.equal` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.equal(2, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.equal(2);
   *
   * The aliases `.equals` and `eq` can be used interchangeably with `.equal`.
   *
   * @name equal
   * @alias equals
   * @alias eq
   * @param {Mixed} val
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertEqual(val, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');

    if (flag(this, 'deep')) {
      var prevLockSsfi = flag(this, 'lockSsfi');
      flag(this, 'lockSsfi', true);
      this.eql(val);
      flag(this, 'lockSsfi', prevLockSsfi);
    } else {
      this.assert(val === obj, 'expected #{this} to equal #{exp}', 'expected #{this} to not equal #{exp}', val, this._obj, true);
    }
  }

  Assertion.addMethod('equal', assertEqual);
  Assertion.addMethod('equals', assertEqual);
  Assertion.addMethod('eq', assertEqual);
  /**
   * ### .eql(obj[, msg])
   *
   * Asserts that the target is deeply equal to the given `obj`. See the
   * `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target object is deeply (but not strictly) equal to {a: 1}
   *     expect({a: 1}).to.eql({a: 1}).but.not.equal({a: 1});
   *
   *     // Target array is deeply (but not strictly) equal to [1, 2]
   *     expect([1, 2]).to.eql([1, 2]).but.not.equal([1, 2]);
   *
   * Add `.not` earlier in the chain to negate `.eql`. However, it's often best
   * to assert that the target is deeply equal to its expected value, rather
   * than not deeply equal to one of countless unexpected values.
   *
   *     expect({a: 1}).to.eql({a: 1}); // Recommended
   *     expect({a: 1}).to.not.eql({b: 2}); // Not recommended
   *
   * `.eql` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect({a: 1}).to.eql({b: 2}, 'nooo why fail??');
   *     expect({a: 1}, 'nooo why fail??').to.eql({b: 2});
   *
   * The alias `.eqls` can be used interchangeably with `.eql`.
   *
   * The `.deep.equal` assertion is almost identical to `.eql` but with one
   * difference: `.deep.equal` causes deep equality comparisons to also be used
   * for any other assertions that follow in the chain.
   *
   * @name eql
   * @alias eqls
   * @param {Mixed} obj
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertEql(obj, msg) {
    if (msg) flag(this, 'message', msg);
    this.assert(_.eql(obj, flag(this, 'object')), 'expected #{this} to deeply equal #{exp}', 'expected #{this} to not deeply equal #{exp}', obj, this._obj, true);
  }

  Assertion.addMethod('eql', assertEql);
  Assertion.addMethod('eqls', assertEql);
  /**
   * ### .above(n[, msg])
   *
   * Asserts that the target is a number or a date greater than the given number or date `n` respectively.
   * However, it's often best to assert that the target is equal to its expected
   * value.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.be.above(1); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
   * or `size` is greater than the given number `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.above(2); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.above(2); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.above`.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(1).to.not.be.above(2); // Not recommended
   *
   * `.above` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.be.above(2, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.above(2);
   *
   * The aliases `.gt` and `.greaterThan` can be used interchangeably with
   * `.above`.
   *
   * @name above
   * @alias gt
   * @alias greaterThan
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertAbove(n, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        doLength = flag(this, 'doLength'),
        flagMsg = flag(this, 'message'),
        msgPrefix = flagMsg ? flagMsg + ': ' : '',
        ssfi = flag(this, 'ssfi'),
        objType = _.type(obj).toLowerCase(),
        nType = _.type(n).toLowerCase(),
        errorMessage,
        shouldThrow = true;

    if (doLength && objType !== 'map' && objType !== 'set') {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && objType === 'date' && nType !== 'date') {
      errorMessage = msgPrefix + 'the argument to above must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to above must be a number';
    } else if (!doLength && objType !== 'date' && objType !== 'number') {
      var printObj = objType === 'string' ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var descriptor = 'length',
          itemsCount;

      if (objType === 'map' || objType === 'set') {
        descriptor = 'size';
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }

      this.assert(itemsCount > n, 'expected #{this} to have a ' + descriptor + ' above #{exp} but got #{act}', 'expected #{this} to not have a ' + descriptor + ' above #{exp}', n, itemsCount);
    } else {
      this.assert(obj > n, 'expected #{this} to be above #{exp}', 'expected #{this} to be at most #{exp}', n);
    }
  }

  Assertion.addMethod('above', assertAbove);
  Assertion.addMethod('gt', assertAbove);
  Assertion.addMethod('greaterThan', assertAbove);
  /**
   * ### .least(n[, msg])
   *
   * Asserts that the target is a number or a date greater than or equal to the given
   * number or date `n` respectively. However, it's often best to assert that the target is equal to
   * its expected value.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.be.at.least(1); // Not recommended
   *     expect(2).to.be.at.least(2); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
   * or `size` is greater than or equal to the given number `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.at.least(2); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.at.least(2); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.least`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.at.least(2); // Not recommended
   *
   * `.least` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.be.at.least(2, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.at.least(2);
   *
   * The alias `.gte` can be used interchangeably with `.least`.
   *
   * @name least
   * @alias gte
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertLeast(n, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        doLength = flag(this, 'doLength'),
        flagMsg = flag(this, 'message'),
        msgPrefix = flagMsg ? flagMsg + ': ' : '',
        ssfi = flag(this, 'ssfi'),
        objType = _.type(obj).toLowerCase(),
        nType = _.type(n).toLowerCase(),
        errorMessage,
        shouldThrow = true;

    if (doLength && objType !== 'map' && objType !== 'set') {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && objType === 'date' && nType !== 'date') {
      errorMessage = msgPrefix + 'the argument to least must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to least must be a number';
    } else if (!doLength && objType !== 'date' && objType !== 'number') {
      var printObj = objType === 'string' ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var descriptor = 'length',
          itemsCount;

      if (objType === 'map' || objType === 'set') {
        descriptor = 'size';
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }

      this.assert(itemsCount >= n, 'expected #{this} to have a ' + descriptor + ' at least #{exp} but got #{act}', 'expected #{this} to have a ' + descriptor + ' below #{exp}', n, itemsCount);
    } else {
      this.assert(obj >= n, 'expected #{this} to be at least #{exp}', 'expected #{this} to be below #{exp}', n);
    }
  }

  Assertion.addMethod('least', assertLeast);
  Assertion.addMethod('gte', assertLeast);
  /**
   * ### .below(n[, msg])
   *
   * Asserts that the target is a number or a date less than the given number or date `n` respectively.
   * However, it's often best to assert that the target is equal to its expected
   * value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.below(2); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
   * or `size` is less than the given number `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.below(4); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.length(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.below(4); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.below`.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.not.be.below(1); // Not recommended
   *
   * `.below` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(2).to.be.below(1, 'nooo why fail??');
   *     expect(2, 'nooo why fail??').to.be.below(1);
   *
   * The aliases `.lt` and `.lessThan` can be used interchangeably with
   * `.below`.
   *
   * @name below
   * @alias lt
   * @alias lessThan
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertBelow(n, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        doLength = flag(this, 'doLength'),
        flagMsg = flag(this, 'message'),
        msgPrefix = flagMsg ? flagMsg + ': ' : '',
        ssfi = flag(this, 'ssfi'),
        objType = _.type(obj).toLowerCase(),
        nType = _.type(n).toLowerCase(),
        errorMessage,
        shouldThrow = true;

    if (doLength && objType !== 'map' && objType !== 'set') {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && objType === 'date' && nType !== 'date') {
      errorMessage = msgPrefix + 'the argument to below must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to below must be a number';
    } else if (!doLength && objType !== 'date' && objType !== 'number') {
      var printObj = objType === 'string' ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var descriptor = 'length',
          itemsCount;

      if (objType === 'map' || objType === 'set') {
        descriptor = 'size';
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }

      this.assert(itemsCount < n, 'expected #{this} to have a ' + descriptor + ' below #{exp} but got #{act}', 'expected #{this} to not have a ' + descriptor + ' below #{exp}', n, itemsCount);
    } else {
      this.assert(obj < n, 'expected #{this} to be below #{exp}', 'expected #{this} to be at least #{exp}', n);
    }
  }

  Assertion.addMethod('below', assertBelow);
  Assertion.addMethod('lt', assertBelow);
  Assertion.addMethod('lessThan', assertBelow);
  /**
   * ### .most(n[, msg])
   *
   * Asserts that the target is a number or a date less than or equal to the given number
   * or date `n` respectively. However, it's often best to assert that the target is equal to its
   * expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.at.most(2); // Not recommended
   *     expect(1).to.be.at.most(1); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
   * or `size` is less than or equal to the given number `n`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.at.most(4); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.at.most(4); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.most`.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.not.be.at.most(1); // Not recommended
   *
   * `.most` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(2).to.be.at.most(1, 'nooo why fail??');
   *     expect(2, 'nooo why fail??').to.be.at.most(1);
   *
   * The alias `.lte` can be used interchangeably with `.most`.
   *
   * @name most
   * @alias lte
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertMost(n, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        doLength = flag(this, 'doLength'),
        flagMsg = flag(this, 'message'),
        msgPrefix = flagMsg ? flagMsg + ': ' : '',
        ssfi = flag(this, 'ssfi'),
        objType = _.type(obj).toLowerCase(),
        nType = _.type(n).toLowerCase(),
        errorMessage,
        shouldThrow = true;

    if (doLength && objType !== 'map' && objType !== 'set') {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && objType === 'date' && nType !== 'date') {
      errorMessage = msgPrefix + 'the argument to most must be a date';
    } else if (nType !== 'number' && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the argument to most must be a number';
    } else if (!doLength && objType !== 'date' && objType !== 'number') {
      var printObj = objType === 'string' ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var descriptor = 'length',
          itemsCount;

      if (objType === 'map' || objType === 'set') {
        descriptor = 'size';
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }

      this.assert(itemsCount <= n, 'expected #{this} to have a ' + descriptor + ' at most #{exp} but got #{act}', 'expected #{this} to have a ' + descriptor + ' above #{exp}', n, itemsCount);
    } else {
      this.assert(obj <= n, 'expected #{this} to be at most #{exp}', 'expected #{this} to be above #{exp}', n);
    }
  }

  Assertion.addMethod('most', assertMost);
  Assertion.addMethod('lte', assertMost);
  /**
   * ### .within(start, finish[, msg])
   *
   * Asserts that the target is a number or a date greater than or equal to the given
   * number or date `start`, and less than or equal to the given number or date `finish` respectively.
   * However, it's often best to assert that the target is equal to its expected
   * value.
   *
   *     expect(2).to.equal(2); // Recommended
   *     expect(2).to.be.within(1, 3); // Not recommended
   *     expect(2).to.be.within(2, 3); // Not recommended
   *     expect(2).to.be.within(1, 2); // Not recommended
   *
   * Add `.lengthOf` earlier in the chain to assert that the target's `length`
   * or `size` is greater than or equal to the given number `start`, and less
   * than or equal to the given number `finish`.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.have.lengthOf.within(2, 4); // Not recommended
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf.within(2, 4); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.within`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.within(2, 4); // Not recommended
   *
   * `.within` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(4).to.be.within(1, 3, 'nooo why fail??');
   *     expect(4, 'nooo why fail??').to.be.within(1, 3);
   *
   * @name within
   * @param {Number} start lower bound inclusive
   * @param {Number} finish upper bound inclusive
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod('within', function (start, finish, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        doLength = flag(this, 'doLength'),
        flagMsg = flag(this, 'message'),
        msgPrefix = flagMsg ? flagMsg + ': ' : '',
        ssfi = flag(this, 'ssfi'),
        objType = _.type(obj).toLowerCase(),
        startType = _.type(start).toLowerCase(),
        finishType = _.type(finish).toLowerCase(),
        errorMessage,
        shouldThrow = true,
        range = startType === 'date' && finishType === 'date' ? start.toUTCString() + '..' + finish.toUTCString() : start + '..' + finish;

    if (doLength && objType !== 'map' && objType !== 'set') {
      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
    }

    if (!doLength && objType === 'date' && (startType !== 'date' || finishType !== 'date')) {
      errorMessage = msgPrefix + 'the arguments to within must be dates';
    } else if ((startType !== 'number' || finishType !== 'number') && (doLength || objType === 'number')) {
      errorMessage = msgPrefix + 'the arguments to within must be numbers';
    } else if (!doLength && objType !== 'date' && objType !== 'number') {
      var printObj = objType === 'string' ? "'" + obj + "'" : obj;
      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';
    } else {
      shouldThrow = false;
    }

    if (shouldThrow) {
      throw new AssertionError(errorMessage, undefined, ssfi);
    }

    if (doLength) {
      var descriptor = 'length',
          itemsCount;

      if (objType === 'map' || objType === 'set') {
        descriptor = 'size';
        itemsCount = obj.size;
      } else {
        itemsCount = obj.length;
      }

      this.assert(itemsCount >= start && itemsCount <= finish, 'expected #{this} to have a ' + descriptor + ' within ' + range, 'expected #{this} to not have a ' + descriptor + ' within ' + range);
    } else {
      this.assert(obj >= start && obj <= finish, 'expected #{this} to be within ' + range, 'expected #{this} to not be within ' + range);
    }
  });
  /**
   * ### .instanceof(constructor[, msg])
   *
   * Asserts that the target is an instance of the given `constructor`.
   *
   *     function Cat () { }
   *
   *     expect(new Cat()).to.be.an.instanceof(Cat);
   *     expect([1, 2]).to.be.an.instanceof(Array);
   *
   * Add `.not` earlier in the chain to negate `.instanceof`.
   *
   *     expect({a: 1}).to.not.be.an.instanceof(Array);
   *
   * `.instanceof` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(1).to.be.an.instanceof(Array, 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.an.instanceof(Array);
   *
   * Due to limitations in ES5, `.instanceof` may not always work as expected
   * when using a transpiler such as Babel or TypeScript. In particular, it may
   * produce unexpected results when subclassing built-in object such as
   * `Array`, `Error`, and `Map`. See your transpiler's docs for details:
   *
   * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))
   * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))
   *
   * The alias `.instanceOf` can be used interchangeably with `.instanceof`.
   *
   * @name instanceof
   * @param {Constructor} constructor
   * @param {String} msg _optional_
   * @alias instanceOf
   * @namespace BDD
   * @api public
   */

  function assertInstanceOf(constructor, msg) {
    if (msg) flag(this, 'message', msg);
    var target = flag(this, 'object');
    var ssfi = flag(this, 'ssfi');
    var flagMsg = flag(this, 'message');

    try {
      var isInstanceOf = target instanceof constructor;
    } catch (err) {
      if (err instanceof TypeError) {
        flagMsg = flagMsg ? flagMsg + ': ' : '';
        throw new AssertionError(flagMsg + 'The instanceof assertion needs a constructor but ' + _.type(constructor) + ' was given.', undefined, ssfi);
      }

      throw err;
    }

    var name = _.getName(constructor);

    if (name === null) {
      name = 'an unnamed constructor';
    }

    this.assert(isInstanceOf, 'expected #{this} to be an instance of ' + name, 'expected #{this} to not be an instance of ' + name);
  }
  Assertion.addMethod('instanceof', assertInstanceOf);
  Assertion.addMethod('instanceOf', assertInstanceOf);
  /**
   * ### .property(name[, val[, msg]])
   *
   * Asserts that the target has a property with the given key `name`.
   *
   *     expect({a: 1}).to.have.property('a');
   *
   * When `val` is provided, `.property` also asserts that the property's value
   * is equal to the given `val`.
   *
   *     expect({a: 1}).to.have.property('a', 1);
   *
   * By default, strict (`===`) equality is used. Add `.deep` earlier in the
   * chain to use deep equality instead. See the `deep-eql` project page for
   * info on the deep equality algorithm: https://github.com/chaijs/deep-eql.
   *
   *     // Target object deeply (but not strictly) has property `x: {a: 1}`
   *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});
   *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});
   *
   * The target's enumerable and non-enumerable properties are always included
   * in the search. By default, both own and inherited properties are included.
   * Add `.own` earlier in the chain to exclude inherited properties from the
   * search.
   *
   *     Object.prototype.b = 2;
   *
   *     expect({a: 1}).to.have.own.property('a');
   *     expect({a: 1}).to.have.own.property('a', 1);
   *     expect({a: 1}).to.have.property('b');
   *     expect({a: 1}).to.not.have.own.property('b');
   *
   * `.deep` and `.own` can be combined.
   *
   *     expect({x: {a: 1}}).to.have.deep.own.property('x', {a: 1});
   *
   * Add `.nested` earlier in the chain to enable dot- and bracket-notation when
   * referencing nested properties.
   *
   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');
   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]', 'y');
   *
   * If `.` or `[]` are part of an actual property name, they can be escaped by
   * adding two backslashes before them.
   *
   *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\.a.\\[b\\]');
   *
   * `.deep` and `.nested` can be combined.
   *
   *     expect({a: {b: [{c: 3}]}})
   *       .to.have.deep.nested.property('a.b[0]', {c: 3});
   *
   * `.own` and `.nested` cannot be combined.
   *
   * Add `.not` earlier in the chain to negate `.property`.
   *
   *     expect({a: 1}).to.not.have.property('b');
   *
   * However, it's dangerous to negate `.property` when providing `val`. The
   * problem is that it creates uncertain expectations by asserting that the
   * target either doesn't have a property with the given key `name`, or that it
   * does have a property with the given key `name` but its value isn't equal to
   * the given `val`. It's often best to identify the exact output that's
   * expected, and then write an assertion that only accepts that exact output.
   *
   * When the target isn't expected to have a property with the given key
   * `name`, it's often best to assert exactly that.
   *
   *     expect({b: 2}).to.not.have.property('a'); // Recommended
   *     expect({b: 2}).to.not.have.property('a', 1); // Not recommended
   *
   * When the target is expected to have a property with the given key `name`,
   * it's often best to assert that the property has its expected value, rather
   * than asserting that it doesn't have one of many unexpected values.
   *
   *     expect({a: 3}).to.have.property('a', 3); // Recommended
   *     expect({a: 3}).to.not.have.property('a', 1); // Not recommended
   *
   * `.property` changes the target of any assertions that follow in the chain
   * to be the value of the property from the original target object.
   *
   *     expect({a: 1}).to.have.property('a').that.is.a('number');
   *
   * `.property` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing `val`, only use the
   * second form.
   *
   *     // Recommended
   *     expect({a: 1}).to.have.property('a', 2, 'nooo why fail??');
   *     expect({a: 1}, 'nooo why fail??').to.have.property('a', 2);
   *     expect({a: 1}, 'nooo why fail??').to.have.property('b');
   *
   *     // Not recommended
   *     expect({a: 1}).to.have.property('b', undefined, 'nooo why fail??');
   *
   * The above assertion isn't the same thing as not providing `val`. Instead,
   * it's asserting that the target object has a `b` property that's equal to
   * `undefined`.
   *
   * The assertions `.ownProperty` and `.haveOwnProperty` can be used
   * interchangeably with `.own.property`.
   *
   * @name property
   * @param {String} name
   * @param {Mixed} val (optional)
   * @param {String} msg _optional_
   * @returns value of property for chaining
   * @namespace BDD
   * @api public
   */

  function assertProperty(name, val, msg) {
    if (msg) flag(this, 'message', msg);
    var isNested = flag(this, 'nested'),
        isOwn = flag(this, 'own'),
        flagMsg = flag(this, 'message'),
        obj = flag(this, 'object'),
        ssfi = flag(this, 'ssfi'),
        nameType = typeof name;
    flagMsg = flagMsg ? flagMsg + ': ' : '';

    if (isNested) {
      if (nameType !== 'string') {
        throw new AssertionError(flagMsg + 'the argument to property must be a string when using nested syntax', undefined, ssfi);
      }
    } else {
      if (nameType !== 'string' && nameType !== 'number' && nameType !== 'symbol') {
        throw new AssertionError(flagMsg + 'the argument to property must be a string, number, or symbol', undefined, ssfi);
      }
    }

    if (isNested && isOwn) {
      throw new AssertionError(flagMsg + 'The "nested" and "own" flags cannot be combined.', undefined, ssfi);
    }

    if (obj === null || obj === undefined) {
      throw new AssertionError(flagMsg + 'Target cannot be null or undefined.', undefined, ssfi);
    }

    var isDeep = flag(this, 'deep'),
        negate = flag(this, 'negate'),
        pathInfo = isNested ? _.getPathInfo(obj, name) : null,
        value = isNested ? pathInfo.value : obj[name];
    var descriptor = '';
    if (isDeep) descriptor += 'deep ';
    if (isOwn) descriptor += 'own ';
    if (isNested) descriptor += 'nested ';
    descriptor += 'property ';
    var hasProperty;
    if (isOwn) hasProperty = Object.prototype.hasOwnProperty.call(obj, name);else if (isNested) hasProperty = pathInfo.exists;else hasProperty = _.hasProperty(obj, name); // When performing a negated assertion for both name and val, merely having
    // a property with the given name isn't enough to cause the assertion to
    // fail. It must both have a property with the given name, and the value of
    // that property must equal the given val. Therefore, skip this assertion in
    // favor of the next.

    if (!negate || arguments.length === 1) {
      this.assert(hasProperty, 'expected #{this} to have ' + descriptor + _.inspect(name), 'expected #{this} to not have ' + descriptor + _.inspect(name));
    }

    if (arguments.length > 1) {
      this.assert(hasProperty && (isDeep ? _.eql(val, value) : val === value), 'expected #{this} to have ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}', 'expected #{this} to not have ' + descriptor + _.inspect(name) + ' of #{act}', val, value);
    }

    flag(this, 'object', value);
  }

  Assertion.addMethod('property', assertProperty);

  function assertOwnProperty(name, value, msg) {
    flag(this, 'own', true);
    assertProperty.apply(this, arguments);
  }

  Assertion.addMethod('ownProperty', assertOwnProperty);
  Assertion.addMethod('haveOwnProperty', assertOwnProperty);
  /**
   * ### .ownPropertyDescriptor(name[, descriptor[, msg]])
   *
   * Asserts that the target has its own property descriptor with the given key
   * `name`. Enumerable and non-enumerable properties are included in the
   * search.
   *
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a');
   *
   * When `descriptor` is provided, `.ownPropertyDescriptor` also asserts that
   * the property's descriptor is deeply equal to the given `descriptor`. See
   * the `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 1,
   *     });
   *
   * Add `.not` earlier in the chain to negate `.ownPropertyDescriptor`.
   *
   *     expect({a: 1}).to.not.have.ownPropertyDescriptor('b');
   *
   * However, it's dangerous to negate `.ownPropertyDescriptor` when providing
   * a `descriptor`. The problem is that it creates uncertain expectations by
   * asserting that the target either doesn't have a property descriptor with
   * the given key `name`, or that it does have a property descriptor with the
   * given key `name` but its not deeply equal to the given `descriptor`. It's
   * often best to identify the exact output that's expected, and then write an
   * assertion that only accepts that exact output.
   *
   * When the target isn't expected to have a property descriptor with the given
   * key `name`, it's often best to assert exactly that.
   *
   *     // Recommended
   *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a');
   *
   *     // Not recommended
   *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 1,
   *     });
   *
   * When the target is expected to have a property descriptor with the given
   * key `name`, it's often best to assert that the property has its expected
   * descriptor, rather than asserting that it doesn't have one of many
   * unexpected descriptors.
   *
   *     // Recommended
   *     expect({a: 3}).to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 3,
   *     });
   *
   *     // Not recommended
   *     expect({a: 3}).to.not.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 1,
   *     });
   *
   * `.ownPropertyDescriptor` changes the target of any assertions that follow
   * in the chain to be the value of the property descriptor from the original
   * target object.
   *
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a')
   *       .that.has.property('enumerable', true);
   *
   * `.ownPropertyDescriptor` accepts an optional `msg` argument which is a
   * custom error message to show when the assertion fails. The message can also
   * be given as the second argument to `expect`. When not providing
   * `descriptor`, only use the second form.
   *
   *     // Recommended
   *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 2,
   *     }, 'nooo why fail??');
   *
   *     // Recommended
   *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('a', {
   *       configurable: true,
   *       enumerable: true,
   *       writable: true,
   *       value: 2,
   *     });
   *
   *     // Recommended
   *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('b');
   *
   *     // Not recommended
   *     expect({a: 1})
   *       .to.have.ownPropertyDescriptor('b', undefined, 'nooo why fail??');
   *
   * The above assertion isn't the same thing as not providing `descriptor`.
   * Instead, it's asserting that the target object has a `b` property
   * descriptor that's deeply equal to `undefined`.
   *
   * The alias `.haveOwnPropertyDescriptor` can be used interchangeably with
   * `.ownPropertyDescriptor`.
   *
   * @name ownPropertyDescriptor
   * @alias haveOwnPropertyDescriptor
   * @param {String} name
   * @param {Object} descriptor _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertOwnPropertyDescriptor(name, descriptor, msg) {
    if (typeof descriptor === 'string') {
      msg = descriptor;
      descriptor = null;
    }

    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);

    if (actualDescriptor && descriptor) {
      this.assert(_.eql(descriptor, actualDescriptor), 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to match ' + _.inspect(descriptor) + ', got ' + _.inspect(actualDescriptor), 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to not match ' + _.inspect(descriptor), descriptor, actualDescriptor, true);
    } else {
      this.assert(actualDescriptor, 'expected #{this} to have an own property descriptor for ' + _.inspect(name), 'expected #{this} to not have an own property descriptor for ' + _.inspect(name));
    }

    flag(this, 'object', actualDescriptor);
  }

  Assertion.addMethod('ownPropertyDescriptor', assertOwnPropertyDescriptor);
  Assertion.addMethod('haveOwnPropertyDescriptor', assertOwnPropertyDescriptor);
  /**
   * ### .lengthOf(n[, msg])
   *
   * Asserts that the target's `length` or `size` is equal to the given number
   * `n`.
   *
   *     expect([1, 2, 3]).to.have.lengthOf(3);
   *     expect('foo').to.have.lengthOf(3);
   *     expect(new Set([1, 2, 3])).to.have.lengthOf(3);
   *     expect(new Map([['a', 1], ['b', 2], ['c', 3]])).to.have.lengthOf(3);
   *
   * Add `.not` earlier in the chain to negate `.lengthOf`. However, it's often
   * best to assert that the target's `length` property is equal to its expected
   * value, rather than not equal to one of many unexpected values.
   *
   *     expect('foo').to.have.lengthOf(3); // Recommended
   *     expect('foo').to.not.have.lengthOf(4); // Not recommended
   *
   * `.lengthOf` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect([1, 2, 3]).to.have.lengthOf(2, 'nooo why fail??');
   *     expect([1, 2, 3], 'nooo why fail??').to.have.lengthOf(2);
   *
   * `.lengthOf` can also be used as a language chain, causing all `.above`,
   * `.below`, `.least`, `.most`, and `.within` assertions that follow in the
   * chain to use the target's `length` property as the target. However, it's
   * often best to assert that the target's `length` property is equal to its
   * expected length, rather than asserting that its `length` property falls
   * within some range of values.
   *
   *     // Recommended
   *     expect([1, 2, 3]).to.have.lengthOf(3);
   *
   *     // Not recommended
   *     expect([1, 2, 3]).to.have.lengthOf.above(2);
   *     expect([1, 2, 3]).to.have.lengthOf.below(4);
   *     expect([1, 2, 3]).to.have.lengthOf.at.least(3);
   *     expect([1, 2, 3]).to.have.lengthOf.at.most(3);
   *     expect([1, 2, 3]).to.have.lengthOf.within(2,4);
   *
   * Due to a compatibility issue, the alias `.length` can't be chained directly
   * off of an uninvoked method such as `.a`. Therefore, `.length` can't be used
   * interchangeably with `.lengthOf` in every situation. It's recommended to
   * always use `.lengthOf` instead of `.length`.
   *
   *     expect([1, 2, 3]).to.have.a.length(3); // incompatible; throws error
   *     expect([1, 2, 3]).to.have.a.lengthOf(3);  // passes as expected
   *
   * @name lengthOf
   * @alias length
   * @param {Number} n
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertLengthChain() {
    flag(this, 'doLength', true);
  }

  function assertLength(n, msg) {
    if (msg) flag(this, 'message', msg);

    var obj = flag(this, 'object'),
        objType = _.type(obj).toLowerCase(),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi'),
        descriptor = 'length',
        itemsCount;

    switch (objType) {
      case 'map':
      case 'set':
        descriptor = 'size';
        itemsCount = obj.size;
        break;

      default:
        new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');
        itemsCount = obj.length;
    }

    this.assert(itemsCount == n, 'expected #{this} to have a ' + descriptor + ' of #{exp} but got #{act}', 'expected #{this} to not have a ' + descriptor + ' of #{act}', n, itemsCount);
  }

  Assertion.addChainableMethod('length', assertLength, assertLengthChain);
  Assertion.addChainableMethod('lengthOf', assertLength, assertLengthChain);
  /**
   * ### .match(re[, msg])
   *
   * Asserts that the target matches the given regular expression `re`.
   *
   *     expect('foobar').to.match(/^foo/);
   *
   * Add `.not` earlier in the chain to negate `.match`.
   *
   *     expect('foobar').to.not.match(/taco/);
   *
   * `.match` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect('foobar').to.match(/taco/, 'nooo why fail??');
   *     expect('foobar', 'nooo why fail??').to.match(/taco/);
   *
   * The alias `.matches` can be used interchangeably with `.match`.
   *
   * @name match
   * @alias matches
   * @param {RegExp} re
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertMatch(re, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(re.exec(obj), 'expected #{this} to match ' + re, 'expected #{this} not to match ' + re);
  }

  Assertion.addMethod('match', assertMatch);
  Assertion.addMethod('matches', assertMatch);
  /**
   * ### .string(str[, msg])
   *
   * Asserts that the target string contains the given substring `str`.
   *
   *     expect('foobar').to.have.string('bar');
   *
   * Add `.not` earlier in the chain to negate `.string`.
   *
   *     expect('foobar').to.not.have.string('taco');
   *
   * `.string` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect('foobar').to.have.string('taco', 'nooo why fail??');
   *     expect('foobar', 'nooo why fail??').to.have.string('taco');
   *
   * @name string
   * @param {String} str
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod('string', function (str, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(obj, flagMsg, ssfi, true).is.a('string');
    this.assert(~obj.indexOf(str), 'expected #{this} to contain ' + _.inspect(str), 'expected #{this} to not contain ' + _.inspect(str));
  });
  /**
   * ### .keys(key1[, key2[, ...]])
   *
   * Asserts that the target object, array, map, or set has the given keys. Only
   * the target's own inherited properties are included in the search.
   *
   * When the target is an object or array, keys can be provided as one or more
   * string arguments, a single array argument, or a single object argument. In
   * the latter case, only the keys in the given object matter; the values are
   * ignored.
   *
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
   *     expect(['x', 'y']).to.have.all.keys(0, 1);
   *
   *     expect({a: 1, b: 2}).to.have.all.keys(['a', 'b']);
   *     expect(['x', 'y']).to.have.all.keys([0, 1]);
   *
   *     expect({a: 1, b: 2}).to.have.all.keys({a: 4, b: 5}); // ignore 4 and 5
   *     expect(['x', 'y']).to.have.all.keys({0: 4, 1: 5}); // ignore 4 and 5
   *
   * When the target is a map or set, each key must be provided as a separate
   * argument.
   *
   *     expect(new Map([['a', 1], ['b', 2]])).to.have.all.keys('a', 'b');
   *     expect(new Set(['a', 'b'])).to.have.all.keys('a', 'b');
   *
   * Because `.keys` does different things based on the target's type, it's
   * important to check the target's type before using `.keys`. See the `.a` doc
   * for info on testing a target's type.
   *
   *     expect({a: 1, b: 2}).to.be.an('object').that.has.all.keys('a', 'b');
   *
   * By default, strict (`===`) equality is used to compare keys of maps and
   * sets. Add `.deep` earlier in the chain to use deep equality instead. See
   * the `deep-eql` project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target set deeply (but not strictly) has key `{a: 1}`
   *     expect(new Set([{a: 1}])).to.have.all.deep.keys([{a: 1}]);
   *     expect(new Set([{a: 1}])).to.not.have.all.keys([{a: 1}]);
   *
   * By default, the target must have all of the given keys and no more. Add
   * `.any` earlier in the chain to only require that the target have at least
   * one of the given keys. Also, add `.not` earlier in the chain to negate
   * `.keys`. It's often best to add `.any` when negating `.keys`, and to use
   * `.all` when asserting `.keys` without negation.
   *
   * When negating `.keys`, `.any` is preferred because `.not.any.keys` asserts
   * exactly what's expected of the output, whereas `.not.all.keys` creates
   * uncertain expectations.
   *
   *     // Recommended; asserts that target doesn't have any of the given keys
   *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');
   *
   *     // Not recommended; asserts that target doesn't have all of the given
   *     // keys but may or may not have some of them
   *     expect({a: 1, b: 2}).to.not.have.all.keys('c', 'd');
   *
   * When asserting `.keys` without negation, `.all` is preferred because
   * `.all.keys` asserts exactly what's expected of the output, whereas
   * `.any.keys` creates uncertain expectations.
   *
   *     // Recommended; asserts that target has all the given keys
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');
   *
   *     // Not recommended; asserts that target has at least one of the given
   *     // keys but may or may not have more of them
   *     expect({a: 1, b: 2}).to.have.any.keys('a', 'b');
   *
   * Note that `.all` is used by default when neither `.all` nor `.any` appear
   * earlier in the chain. However, it's often best to add `.all` anyway because
   * it improves readability.
   *
   *     // Both assertions are identical
   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b'); // Recommended
   *     expect({a: 1, b: 2}).to.have.keys('a', 'b'); // Not recommended
   *
   * Add `.include` earlier in the chain to require that the target's keys be a
   * superset of the expected keys, rather than identical sets.
   *
   *     // Target object's keys are a superset of ['a', 'b'] but not identical
   *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');
   *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');
   *
   * However, if `.any` and `.include` are combined, only the `.any` takes
   * effect. The `.include` is ignored in this case.
   *
   *     // Both assertions are identical
   *     expect({a: 1}).to.have.any.keys('a', 'b');
   *     expect({a: 1}).to.include.any.keys('a', 'b');
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({a: 1}, 'nooo why fail??').to.have.key('b');
   *
   * The alias `.key` can be used interchangeably with `.keys`.
   *
   * @name keys
   * @alias key
   * @param {...String|Array|Object} keys
   * @namespace BDD
   * @api public
   */

  function assertKeys(keys) {
    var obj = flag(this, 'object'),
        objType = _.type(obj),
        keysType = _.type(keys),
        ssfi = flag(this, 'ssfi'),
        isDeep = flag(this, 'deep'),
        str,
        deepStr = '',
        actual,
        ok = true,
        flagMsg = flag(this, 'message');

    flagMsg = flagMsg ? flagMsg + ': ' : '';
    var mixedArgsMsg = flagMsg + 'when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments';

    if (objType === 'Map' || objType === 'Set') {
      deepStr = isDeep ? 'deeply ' : '';
      actual = []; // Map and Set '.keys' aren't supported in IE 11. Therefore, use .forEach.

      obj.forEach(function (val, key) {
        actual.push(key);
      });

      if (keysType !== 'Array') {
        keys = Array.prototype.slice.call(arguments);
      }
    } else {
      actual = _.getOwnEnumerableProperties(obj);

      switch (keysType) {
        case 'Array':
          if (arguments.length > 1) {
            throw new AssertionError(mixedArgsMsg, undefined, ssfi);
          }

          break;

        case 'Object':
          if (arguments.length > 1) {
            throw new AssertionError(mixedArgsMsg, undefined, ssfi);
          }

          keys = Object.keys(keys);
          break;

        default:
          keys = Array.prototype.slice.call(arguments);
      } // Only stringify non-Symbols because Symbols would become "Symbol()"


      keys = keys.map(function (val) {
        return typeof val === 'symbol' ? val : String(val);
      });
    }

    if (!keys.length) {
      throw new AssertionError(flagMsg + 'keys required', undefined, ssfi);
    }

    var len = keys.length,
        any = flag(this, 'any'),
        all = flag(this, 'all'),
        expected = keys;

    if (!any && !all) {
      all = true;
    } // Has any


    if (any) {
      ok = expected.some(function (expectedKey) {
        return actual.some(function (actualKey) {
          if (isDeep) {
            return _.eql(expectedKey, actualKey);
          } else {
            return expectedKey === actualKey;
          }
        });
      });
    } // Has all


    if (all) {
      ok = expected.every(function (expectedKey) {
        return actual.some(function (actualKey) {
          if (isDeep) {
            return _.eql(expectedKey, actualKey);
          } else {
            return expectedKey === actualKey;
          }
        });
      });

      if (!flag(this, 'contains')) {
        ok = ok && keys.length == actual.length;
      }
    } // Key string


    if (len > 1) {
      keys = keys.map(function (key) {
        return _.inspect(key);
      });
      var last = keys.pop();

      if (all) {
        str = keys.join(', ') + ', and ' + last;
      }

      if (any) {
        str = keys.join(', ') + ', or ' + last;
      }
    } else {
      str = _.inspect(keys[0]);
    } // Form


    str = (len > 1 ? 'keys ' : 'key ') + str; // Have / include

    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str; // Assertion

    this.assert(ok, 'expected #{this} to ' + deepStr + str, 'expected #{this} to not ' + deepStr + str, expected.slice(0).sort(_.compareByInspect), actual.sort(_.compareByInspect), true);
  }

  Assertion.addMethod('keys', assertKeys);
  Assertion.addMethod('key', assertKeys);
  /**
   * ### .throw([errorLike], [errMsgMatcher], [msg])
   *
   * When no arguments are provided, `.throw` invokes the target function and
   * asserts that an error is thrown.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw();
   *
   * When one argument is provided, and it's an error constructor, `.throw`
   * invokes the target function and asserts that an error is thrown that's an
   * instance of that error constructor.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw(TypeError);
   *
   * When one argument is provided, and it's an error instance, `.throw` invokes
   * the target function and asserts that an error is thrown that's strictly
   * (`===`) equal to that error instance.
   *
   *     var err = new TypeError('Illegal salmon!');
   *     var badFn = function () { throw err; };
   *
   *     expect(badFn).to.throw(err);
   *
   * When one argument is provided, and it's a string, `.throw` invokes the
   * target function and asserts that an error is thrown with a message that
   * contains that string.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw('salmon');
   *
   * When one argument is provided, and it's a regular expression, `.throw`
   * invokes the target function and asserts that an error is thrown with a
   * message that matches that regular expression.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw(/salmon/);
   *
   * When two arguments are provided, and the first is an error instance or
   * constructor, and the second is a string or regular expression, `.throw`
   * invokes the function and asserts that an error is thrown that fulfills both
   * conditions as described above.
   *
   *     var err = new TypeError('Illegal salmon!');
   *     var badFn = function () { throw err; };
   *
   *     expect(badFn).to.throw(TypeError, 'salmon');
   *     expect(badFn).to.throw(TypeError, /salmon/);
   *     expect(badFn).to.throw(err, 'salmon');
   *     expect(badFn).to.throw(err, /salmon/);
   *
   * Add `.not` earlier in the chain to negate `.throw`.
   *
   *     var goodFn = function () {};
   *
   *     expect(goodFn).to.not.throw();
   *
   * However, it's dangerous to negate `.throw` when providing any arguments.
   * The problem is that it creates uncertain expectations by asserting that the
   * target either doesn't throw an error, or that it throws an error but of a
   * different type than the given type, or that it throws an error of the given
   * type but with a message that doesn't include the given string. It's often
   * best to identify the exact output that's expected, and then write an
   * assertion that only accepts that exact output.
   *
   * When the target isn't expected to throw an error, it's often best to assert
   * exactly that.
   *
   *     var goodFn = function () {};
   *
   *     expect(goodFn).to.not.throw(); // Recommended
   *     expect(goodFn).to.not.throw(ReferenceError, 'x'); // Not recommended
   *
   * When the target is expected to throw an error, it's often best to assert
   * that the error is of its expected type, and has a message that includes an
   * expected string, rather than asserting that it doesn't have one of many
   * unexpected types, and doesn't have a message that includes some string.
   *
   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };
   *
   *     expect(badFn).to.throw(TypeError, 'salmon'); // Recommended
   *     expect(badFn).to.not.throw(ReferenceError, 'x'); // Not recommended
   *
   * `.throw` changes the target of any assertions that follow in the chain to
   * be the error object that's thrown.
   *
   *     var err = new TypeError('Illegal salmon!');
   *     err.code = 42;
   *     var badFn = function () { throw err; };
   *
   *     expect(badFn).to.throw(TypeError).with.property('code', 42);
   *
   * `.throw` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`. When not providing two arguments, always use
   * the second form.
   *
   *     var goodFn = function () {};
   *
   *     expect(goodFn).to.throw(TypeError, 'x', 'nooo why fail??');
   *     expect(goodFn, 'nooo why fail??').to.throw();
   *
   * Due to limitations in ES5, `.throw` may not always work as expected when
   * using a transpiler such as Babel or TypeScript. In particular, it may
   * produce unexpected results when subclassing the built-in `Error` object and
   * then passing the subclassed constructor to `.throw`. See your transpiler's
   * docs for details:
   *
   * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))
   * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))
   *
   * Beware of some common mistakes when using the `throw` assertion. One common
   * mistake is to accidentally invoke the function yourself instead of letting
   * the `throw` assertion invoke the function for you. For example, when
   * testing if a function named `fn` throws, provide `fn` instead of `fn()` as
   * the target for the assertion.
   *
   *     expect(fn).to.throw();     // Good! Tests `fn` as desired
   *     expect(fn()).to.throw();   // Bad! Tests result of `fn()`, not `fn`
   *
   * If you need to assert that your function `fn` throws when passed certain
   * arguments, then wrap a call to `fn` inside of another function.
   *
   *     expect(function () { fn(42); }).to.throw();  // Function expression
   *     expect(() => fn(42)).to.throw();             // ES6 arrow function
   *
   * Another common mistake is to provide an object method (or any stand-alone
   * function that relies on `this`) as the target of the assertion. Doing so is
   * problematic because the `this` context will be lost when the function is
   * invoked by `.throw`; there's no way for it to know what `this` is supposed
   * to be. There are two ways around this problem. One solution is to wrap the
   * method or function call inside of another function. Another solution is to
   * use `bind`.
   *
   *     expect(function () { cat.meow(); }).to.throw();  // Function expression
   *     expect(() => cat.meow()).to.throw();             // ES6 arrow function
   *     expect(cat.meow.bind(cat)).to.throw();           // Bind
   *
   * Finally, it's worth mentioning that it's a best practice in JavaScript to
   * only throw `Error` and derivatives of `Error` such as `ReferenceError`,
   * `TypeError`, and user-defined objects that extend `Error`. No other type of
   * value will generate a stack trace when initialized. With that said, the
   * `throw` assertion does technically support any type of value being thrown,
   * not just `Error` and its derivatives.
   *
   * The aliases `.throws` and `.Throw` can be used interchangeably with
   * `.throw`.
   *
   * @name throw
   * @alias throws
   * @alias Throw
   * @param {Error|ErrorConstructor} errorLike
   * @param {String|RegExp} errMsgMatcher error message
   * @param {String} msg _optional_
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @returns error for chaining (null if no error)
   * @namespace BDD
   * @api public
   */

  function assertThrows(errorLike, errMsgMatcher, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        ssfi = flag(this, 'ssfi'),
        flagMsg = flag(this, 'message'),
        negate = flag(this, 'negate') || false;
    new Assertion(obj, flagMsg, ssfi, true).is.a('function');

    if (errorLike instanceof RegExp || typeof errorLike === 'string') {
      errMsgMatcher = errorLike;
      errorLike = null;
    }

    var caughtErr;

    try {
      obj();
    } catch (err) {
      caughtErr = err;
    } // If we have the negate flag enabled and at least one valid argument it means we do expect an error
    // but we want it to match a given set of criteria


    var everyArgIsUndefined = errorLike === undefined && errMsgMatcher === undefined; // If we've got the negate flag enabled and both args, we should only fail if both aren't compatible
    // See Issue #551 and PR #683@GitHub

    var everyArgIsDefined = Boolean(errorLike && errMsgMatcher);
    var errorLikeFail = false;
    var errMsgMatcherFail = false; // Checking if error was thrown

    if (everyArgIsUndefined || !everyArgIsUndefined && !negate) {
      // We need this to display results correctly according to their types
      var errorLikeString = 'an error';

      if (errorLike instanceof Error) {
        errorLikeString = '#{exp}';
      } else if (errorLike) {
        errorLikeString = _.checkError.getConstructorName(errorLike);
      }

      this.assert(caughtErr, 'expected #{this} to throw ' + errorLikeString, 'expected #{this} to not throw an error but #{act} was thrown', errorLike && errorLike.toString(), caughtErr instanceof Error ? caughtErr.toString() : typeof caughtErr === 'string' ? caughtErr : caughtErr && _.checkError.getConstructorName(caughtErr));
    }

    if (errorLike && caughtErr) {
      // We should compare instances only if `errorLike` is an instance of `Error`
      if (errorLike instanceof Error) {
        var isCompatibleInstance = _.checkError.compatibleInstance(caughtErr, errorLike);

        if (isCompatibleInstance === negate) {
          // These checks were created to ensure we won't fail too soon when we've got both args and a negate
          // See Issue #551 and PR #683@GitHub
          if (everyArgIsDefined && negate) {
            errorLikeFail = true;
          } else {
            this.assert(negate, 'expected #{this} to throw #{exp} but #{act} was thrown', 'expected #{this} to not throw #{exp}' + (caughtErr && !negate ? ' but #{act} was thrown' : ''), errorLike.toString(), caughtErr.toString());
          }
        }
      }

      var isCompatibleConstructor = _.checkError.compatibleConstructor(caughtErr, errorLike);

      if (isCompatibleConstructor === negate) {
        if (everyArgIsDefined && negate) {
          errorLikeFail = true;
        } else {
          this.assert(negate, 'expected #{this} to throw #{exp} but #{act} was thrown', 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : ''), errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike), caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr));
        }
      }
    }

    if (caughtErr && errMsgMatcher !== undefined && errMsgMatcher !== null) {
      // Here we check compatible messages
      var placeholder = 'including';

      if (errMsgMatcher instanceof RegExp) {
        placeholder = 'matching';
      }

      var isCompatibleMessage = _.checkError.compatibleMessage(caughtErr, errMsgMatcher);

      if (isCompatibleMessage === negate) {
        if (everyArgIsDefined && negate) {
          errMsgMatcherFail = true;
        } else {
          this.assert(negate, 'expected #{this} to throw error ' + placeholder + ' #{exp} but got #{act}', 'expected #{this} to throw error not ' + placeholder + ' #{exp}', errMsgMatcher, _.checkError.getMessage(caughtErr));
        }
      }
    } // If both assertions failed and both should've matched we throw an error


    if (errorLikeFail && errMsgMatcherFail) {
      this.assert(negate, 'expected #{this} to throw #{exp} but #{act} was thrown', 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : ''), errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike), caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr));
    }

    flag(this, 'object', caughtErr);
  }
  Assertion.addMethod('throw', assertThrows);
  Assertion.addMethod('throws', assertThrows);
  Assertion.addMethod('Throw', assertThrows);
  /**
   * ### .respondTo(method[, msg])
   *
   * When the target is a non-function object, `.respondTo` asserts that the
   * target has a method with the given name `method`. The method can be own or
   * inherited, and it can be enumerable or non-enumerable.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *
   *     expect(new Cat()).to.respondTo('meow');
   *
   * When the target is a function, `.respondTo` asserts that the target's
   * `prototype` property has a method with the given name `method`. Again, the
   * method can be own or inherited, and it can be enumerable or non-enumerable.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *
   *     expect(Cat).to.respondTo('meow');
   *
   * Add `.itself` earlier in the chain to force `.respondTo` to treat the
   * target as a non-function object, even if it's a function. Thus, it asserts
   * that the target has a method with the given name `method`, rather than
   * asserting that the target's `prototype` property has a method with the
   * given name `method`.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *     Cat.hiss = function () {};
   *
   *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');
   *
   * When not adding `.itself`, it's important to check the target's type before
   * using `.respondTo`. See the `.a` doc for info on checking a target's type.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *
   *     expect(new Cat()).to.be.an('object').that.respondsTo('meow');
   *
   * Add `.not` earlier in the chain to negate `.respondTo`.
   *
   *     function Dog () {}
   *     Dog.prototype.bark = function () {};
   *
   *     expect(new Dog()).to.not.respondTo('meow');
   *
   * `.respondTo` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect({}).to.respondTo('meow', 'nooo why fail??');
   *     expect({}, 'nooo why fail??').to.respondTo('meow');
   *
   * The alias `.respondsTo` can be used interchangeably with `.respondTo`.
   *
   * @name respondTo
   * @alias respondsTo
   * @param {String} method
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function respondTo(method, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        itself = flag(this, 'itself'),
        context = 'function' === typeof obj && !itself ? obj.prototype[method] : obj[method];
    this.assert('function' === typeof context, 'expected #{this} to respond to ' + _.inspect(method), 'expected #{this} to not respond to ' + _.inspect(method));
  }

  Assertion.addMethod('respondTo', respondTo);
  Assertion.addMethod('respondsTo', respondTo);
  /**
   * ### .itself
   *
   * Forces all `.respondTo` assertions that follow in the chain to behave as if
   * the target is a non-function object, even if it's a function. Thus, it
   * causes `.respondTo` to assert that the target has a method with the given
   * name, rather than asserting that the target's `prototype` property has a
   * method with the given name.
   *
   *     function Cat () {}
   *     Cat.prototype.meow = function () {};
   *     Cat.hiss = function () {};
   *
   *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');
   *
   * @name itself
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('itself', function () {
    flag(this, 'itself', true);
  });
  /**
   * ### .satisfy(matcher[, msg])
   *
   * Invokes the given `matcher` function with the target being passed as the
   * first argument, and asserts that the value returned is truthy.
   *
   *     expect(1).to.satisfy(function(num) {
   *       return num > 0;
   *     });
   *
   * Add `.not` earlier in the chain to negate `.satisfy`.
   *
   *     expect(1).to.not.satisfy(function(num) {
   *       return num > 2;
   *     });
   *
   * `.satisfy` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(1).to.satisfy(function(num) {
   *       return num > 2;
   *     }, 'nooo why fail??');
   *
   *     expect(1, 'nooo why fail??').to.satisfy(function(num) {
   *       return num > 2;
   *     });
   *
   * The alias `.satisfies` can be used interchangeably with `.satisfy`.
   *
   * @name satisfy
   * @alias satisfies
   * @param {Function} matcher
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function satisfy(matcher, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var result = matcher(obj);
    this.assert(result, 'expected #{this} to satisfy ' + _.objDisplay(matcher), 'expected #{this} to not satisfy' + _.objDisplay(matcher), flag(this, 'negate') ? false : true, result);
  }

  Assertion.addMethod('satisfy', satisfy);
  Assertion.addMethod('satisfies', satisfy);
  /**
   * ### .closeTo(expected, delta[, msg])
   *
   * Asserts that the target is a number that's within a given +/- `delta` range
   * of the given number `expected`. However, it's often best to assert that the
   * target is equal to its expected value.
   *
   *     // Recommended
   *     expect(1.5).to.equal(1.5);
   *
   *     // Not recommended
   *     expect(1.5).to.be.closeTo(1, 0.5);
   *     expect(1.5).to.be.closeTo(2, 0.5);
   *     expect(1.5).to.be.closeTo(1, 1);
   *
   * Add `.not` earlier in the chain to negate `.closeTo`.
   *
   *     expect(1.5).to.equal(1.5); // Recommended
   *     expect(1.5).to.not.be.closeTo(3, 1); // Not recommended
   *
   * `.closeTo` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect(1.5).to.be.closeTo(3, 1, 'nooo why fail??');
   *     expect(1.5, 'nooo why fail??').to.be.closeTo(3, 1);
   *
   * The alias `.approximately` can be used interchangeably with `.closeTo`.
   *
   * @name closeTo
   * @alias approximately
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function closeTo(expected, delta, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(obj, flagMsg, ssfi, true).is.a('number');

    if (typeof expected !== 'number' || typeof delta !== 'number') {
      flagMsg = flagMsg ? flagMsg + ': ' : '';
      throw new AssertionError(flagMsg + 'the arguments to closeTo or approximately must be numbers', undefined, ssfi);
    }

    this.assert(Math.abs(obj - expected) <= delta, 'expected #{this} to be close to ' + expected + ' +/- ' + delta, 'expected #{this} not to be close to ' + expected + ' +/- ' + delta);
  }

  Assertion.addMethod('closeTo', closeTo);
  Assertion.addMethod('approximately', closeTo); // Note: Duplicates are ignored if testing for inclusion instead of sameness.

  function isSubsetOf(subset, superset, cmp, contains, ordered) {
    if (!contains) {
      if (subset.length !== superset.length) return false;
      superset = superset.slice();
    }

    return subset.every(function (elem, idx) {
      if (ordered) return cmp ? cmp(elem, superset[idx]) : elem === superset[idx];

      if (!cmp) {
        var matchIdx = superset.indexOf(elem);
        if (matchIdx === -1) return false; // Remove match from superset so not counted twice if duplicate in subset.

        if (!contains) superset.splice(matchIdx, 1);
        return true;
      }

      return superset.some(function (elem2, matchIdx) {
        if (!cmp(elem, elem2)) return false; // Remove match from superset so not counted twice if duplicate in subset.

        if (!contains) superset.splice(matchIdx, 1);
        return true;
      });
    });
  }
  /**
   * ### .members(set[, msg])
   *
   * Asserts that the target array has the same members as the given array
   * `set`.
   *
   *     expect([1, 2, 3]).to.have.members([2, 1, 3]);
   *     expect([1, 2, 2]).to.have.members([2, 1, 2]);
   *
   * By default, members are compared using strict (`===`) equality. Add `.deep`
   * earlier in the chain to use deep equality instead. See the `deep-eql`
   * project page for info on the deep equality algorithm:
   * https://github.com/chaijs/deep-eql.
   *
   *     // Target array deeply (but not strictly) has member `{a: 1}`
   *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);
   *     expect([{a: 1}]).to.not.have.members([{a: 1}]);
   *
   * By default, order doesn't matter. Add `.ordered` earlier in the chain to
   * require that members appear in the same order.
   *
   *     expect([1, 2, 3]).to.have.ordered.members([1, 2, 3]);
   *     expect([1, 2, 3]).to.have.members([2, 1, 3])
   *       .but.not.ordered.members([2, 1, 3]);
   *
   * By default, both arrays must be the same size. Add `.include` earlier in
   * the chain to require that the target's members be a superset of the
   * expected members. Note that duplicates are ignored in the subset when
   * `.include` is added.
   *
   *     // Target array is a superset of [1, 2] but not identical
   *     expect([1, 2, 3]).to.include.members([1, 2]);
   *     expect([1, 2, 3]).to.not.have.members([1, 2]);
   *
   *     // Duplicates in the subset are ignored
   *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);
   *
   * `.deep`, `.ordered`, and `.include` can all be combined. However, if
   * `.include` and `.ordered` are combined, the ordering begins at the start of
   * both arrays.
   *
   *     expect([{a: 1}, {b: 2}, {c: 3}])
   *       .to.include.deep.ordered.members([{a: 1}, {b: 2}])
   *       .but.not.include.deep.ordered.members([{b: 2}, {c: 3}]);
   *
   * Add `.not` earlier in the chain to negate `.members`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the target array doesn't have all of the same members as
   * the given array `set` but may or may not have some of them. It's often best
   * to identify the exact output that's expected, and then write an assertion
   * that only accepts that exact output.
   *
   *     expect([1, 2]).to.not.include(3).and.not.include(4); // Recommended
   *     expect([1, 2]).to.not.have.members([3, 4]); // Not recommended
   *
   * `.members` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`.
   *
   *     expect([1, 2]).to.have.members([1, 2, 3], 'nooo why fail??');
   *     expect([1, 2], 'nooo why fail??').to.have.members([1, 2, 3]);
   *
   * @name members
   * @param {Array} set
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */


  Assertion.addMethod('members', function (subset, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(obj, flagMsg, ssfi, true).to.be.an('array');
    new Assertion(subset, flagMsg, ssfi, true).to.be.an('array');
    var contains = flag(this, 'contains');
    var ordered = flag(this, 'ordered');
    var subject, failMsg, failNegateMsg;

    if (contains) {
      subject = ordered ? 'an ordered superset' : 'a superset';
      failMsg = 'expected #{this} to be ' + subject + ' of #{exp}';
      failNegateMsg = 'expected #{this} to not be ' + subject + ' of #{exp}';
    } else {
      subject = ordered ? 'ordered members' : 'members';
      failMsg = 'expected #{this} to have the same ' + subject + ' as #{exp}';
      failNegateMsg = 'expected #{this} to not have the same ' + subject + ' as #{exp}';
    }

    var cmp = flag(this, 'deep') ? _.eql : undefined;
    this.assert(isSubsetOf(subset, obj, cmp, contains, ordered), failMsg, failNegateMsg, subset, obj, true);
  });
  /**
   * ### .oneOf(list[, msg])
   *
   * Asserts that the target is a member of the given array `list`. However,
   * it's often best to assert that the target is equal to its expected value.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.be.oneOf([1, 2, 3]); // Not recommended
   *
   * Comparisons are performed using strict (`===`) equality.
   *
   * Add `.not` earlier in the chain to negate `.oneOf`.
   *
   *     expect(1).to.equal(1); // Recommended
   *     expect(1).to.not.be.oneOf([2, 3, 4]); // Not recommended
   *
   * `.oneOf` accepts an optional `msg` argument which is a custom error message
   * to show when the assertion fails. The message can also be given as the
   * second argument to `expect`.
   *
   *     expect(1).to.be.oneOf([2, 3, 4], 'nooo why fail??');
   *     expect(1, 'nooo why fail??').to.be.oneOf([2, 3, 4]);
   *
   * @name oneOf
   * @param {Array<*>} list
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function oneOf(list, msg) {
    if (msg) flag(this, 'message', msg);
    var expected = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(list, flagMsg, ssfi, true).to.be.an('array');
    this.assert(list.indexOf(expected) > -1, 'expected #{this} to be one of #{exp}', 'expected #{this} to not be one of #{exp}', list, expected);
  }

  Assertion.addMethod('oneOf', oneOf);
  /**
   * ### .change(subject[, prop[, msg]])
   *
   * When one argument is provided, `.change` asserts that the given function
   * `subject` returns a different value when it's invoked before the target
   * function compared to when it's invoked afterward. However, it's often best
   * to assert that `subject` is equal to its expected value.
   *
   *     var dots = ''
   *       , addDot = function () { dots += '.'; }
   *       , getDots = function () { return dots; };
   *
   *     // Recommended
   *     expect(getDots()).to.equal('');
   *     addDot();
   *     expect(getDots()).to.equal('.');
   *
   *     // Not recommended
   *     expect(addDot).to.change(getDots);
   *
   * When two arguments are provided, `.change` asserts that the value of the
   * given object `subject`'s `prop` property is different before invoking the
   * target function compared to afterward.
   *
   *     var myObj = {dots: ''}
   *       , addDot = function () { myObj.dots += '.'; };
   *
   *     // Recommended
   *     expect(myObj).to.have.property('dots', '');
   *     addDot();
   *     expect(myObj).to.have.property('dots', '.');
   *
   *     // Not recommended
   *     expect(addDot).to.change(myObj, 'dots');
   *
   * Strict (`===`) equality is used to compare before and after values.
   *
   * Add `.not` earlier in the chain to negate `.change`.
   *
   *     var dots = ''
   *       , noop = function () {}
   *       , getDots = function () { return dots; };
   *
   *     expect(noop).to.not.change(getDots);
   *
   *     var myObj = {dots: ''}
   *       , noop = function () {};
   *
   *     expect(noop).to.not.change(myObj, 'dots');
   *
   * `.change` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing two arguments, always
   * use the second form.
   *
   *     var myObj = {dots: ''}
   *       , addDot = function () { myObj.dots += '.'; };
   *
   *     expect(addDot).to.not.change(myObj, 'dots', 'nooo why fail??');
   *
   *     var dots = ''
   *       , addDot = function () { dots += '.'; }
   *       , getDots = function () { return dots; };
   *
   *     expect(addDot, 'nooo why fail??').to.not.change(getDots);
   *
   * `.change` also causes all `.by` assertions that follow in the chain to
   * assert how much a numeric subject was increased or decreased by. However,
   * it's dangerous to use `.change.by`. The problem is that it creates
   * uncertain expectations by asserting that the subject either increases by
   * the given delta, or that it decreases by the given delta. It's often best
   * to identify the exact output that's expected, and then write an assertion
   * that only accepts that exact output.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; }
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   * The alias `.changes` can be used interchangeably with `.change`.
   *
   * @name change
   * @alias changes
   * @param {String} subject
   * @param {String} prop name _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertChanges(subject, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(fn, flagMsg, ssfi, true).is.a('function');
    var initial;

    if (!prop) {
      new Assertion(subject, flagMsg, ssfi, true).is.a('function');
      initial = subject();
    } else {
      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
      initial = subject[prop];
    }

    fn();
    var final = prop === undefined || prop === null ? subject() : subject[prop];
    var msgObj = prop === undefined || prop === null ? initial : '.' + prop; // This gets flagged because of the .by(delta) assertion

    flag(this, 'deltaMsgObj', msgObj);
    flag(this, 'initialDeltaValue', initial);
    flag(this, 'finalDeltaValue', final);
    flag(this, 'deltaBehavior', 'change');
    flag(this, 'realDelta', final !== initial);
    this.assert(initial !== final, 'expected ' + msgObj + ' to change', 'expected ' + msgObj + ' to not change');
  }

  Assertion.addMethod('change', assertChanges);
  Assertion.addMethod('changes', assertChanges);
  /**
   * ### .increase(subject[, prop[, msg]])
   *
   * When one argument is provided, `.increase` asserts that the given function
   * `subject` returns a greater number when it's invoked after invoking the
   * target function compared to when it's invoked beforehand. `.increase` also
   * causes all `.by` assertions that follow in the chain to assert how much
   * greater of a number is returned. It's often best to assert that the return
   * value increased by the expected amount, rather than asserting it increased
   * by any amount.
   *
   *     var val = 1
   *       , addTwo = function () { val += 2; }
   *       , getVal = function () { return val; };
   *
   *     expect(addTwo).to.increase(getVal).by(2); // Recommended
   *     expect(addTwo).to.increase(getVal); // Not recommended
   *
   * When two arguments are provided, `.increase` asserts that the value of the
   * given object `subject`'s `prop` property is greater after invoking the
   * target function compared to beforehand.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.increase(myObj, 'val'); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.increase`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the subject either decreases, or that it stays the same.
   * It's often best to identify the exact output that's expected, and then
   * write an assertion that only accepts that exact output.
   *
   * When the subject is expected to decrease, it's often best to assert that it
   * decreased by the expected amount.
   *
   *     var myObj = {val: 1}
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.not.increase(myObj, 'val'); // Not recommended
   *
   * When the subject is expected to stay the same, it's often best to assert
   * exactly that.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.not.change(myObj, 'val'); // Recommended
   *     expect(noop).to.not.increase(myObj, 'val'); // Not recommended
   *
   * `.increase` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing two arguments, always
   * use the second form.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.increase(myObj, 'val', 'nooo why fail??');
   *
   *     var val = 1
   *       , noop = function () {}
   *       , getVal = function () { return val; };
   *
   *     expect(noop, 'nooo why fail??').to.increase(getVal);
   *
   * The alias `.increases` can be used interchangeably with `.increase`.
   *
   * @name increase
   * @alias increases
   * @param {String|Function} subject
   * @param {String} prop name _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertIncreases(subject, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(fn, flagMsg, ssfi, true).is.a('function');
    var initial;

    if (!prop) {
      new Assertion(subject, flagMsg, ssfi, true).is.a('function');
      initial = subject();
    } else {
      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
      initial = subject[prop];
    } // Make sure that the target is a number


    new Assertion(initial, flagMsg, ssfi, true).is.a('number');
    fn();
    var final = prop === undefined || prop === null ? subject() : subject[prop];
    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;
    flag(this, 'deltaMsgObj', msgObj);
    flag(this, 'initialDeltaValue', initial);
    flag(this, 'finalDeltaValue', final);
    flag(this, 'deltaBehavior', 'increase');
    flag(this, 'realDelta', final - initial);
    this.assert(final - initial > 0, 'expected ' + msgObj + ' to increase', 'expected ' + msgObj + ' to not increase');
  }

  Assertion.addMethod('increase', assertIncreases);
  Assertion.addMethod('increases', assertIncreases);
  /**
   * ### .decrease(subject[, prop[, msg]])
   *
   * When one argument is provided, `.decrease` asserts that the given function
   * `subject` returns a lesser number when it's invoked after invoking the
   * target function compared to when it's invoked beforehand. `.decrease` also
   * causes all `.by` assertions that follow in the chain to assert how much
   * lesser of a number is returned. It's often best to assert that the return
   * value decreased by the expected amount, rather than asserting it decreased
   * by any amount.
   *
   *     var val = 1
   *       , subtractTwo = function () { val -= 2; }
   *       , getVal = function () { return val; };
   *
   *     expect(subtractTwo).to.decrease(getVal).by(2); // Recommended
   *     expect(subtractTwo).to.decrease(getVal); // Not recommended
   *
   * When two arguments are provided, `.decrease` asserts that the value of the
   * given object `subject`'s `prop` property is lesser after invoking the
   * target function compared to beforehand.
   *
   *     var myObj = {val: 1}
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.decrease(myObj, 'val'); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.decrease`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the subject either increases, or that it stays the same.
   * It's often best to identify the exact output that's expected, and then
   * write an assertion that only accepts that exact output.
   *
   * When the subject is expected to increase, it's often best to assert that it
   * increased by the expected amount.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.not.decrease(myObj, 'val'); // Not recommended
   *
   * When the subject is expected to stay the same, it's often best to assert
   * exactly that.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.not.change(myObj, 'val'); // Recommended
   *     expect(noop).to.not.decrease(myObj, 'val'); // Not recommended
   *
   * `.decrease` accepts an optional `msg` argument which is a custom error
   * message to show when the assertion fails. The message can also be given as
   * the second argument to `expect`. When not providing two arguments, always
   * use the second form.
   *
   *     var myObj = {val: 1}
   *       , noop = function () {};
   *
   *     expect(noop).to.decrease(myObj, 'val', 'nooo why fail??');
   *
   *     var val = 1
   *       , noop = function () {}
   *       , getVal = function () { return val; };
   *
   *     expect(noop, 'nooo why fail??').to.decrease(getVal);
   *
   * The alias `.decreases` can be used interchangeably with `.decrease`.
   *
   * @name decrease
   * @alias decreases
   * @param {String|Function} subject
   * @param {String} prop name _optional_
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertDecreases(subject, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object'),
        flagMsg = flag(this, 'message'),
        ssfi = flag(this, 'ssfi');
    new Assertion(fn, flagMsg, ssfi, true).is.a('function');
    var initial;

    if (!prop) {
      new Assertion(subject, flagMsg, ssfi, true).is.a('function');
      initial = subject();
    } else {
      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);
      initial = subject[prop];
    } // Make sure that the target is a number


    new Assertion(initial, flagMsg, ssfi, true).is.a('number');
    fn();
    var final = prop === undefined || prop === null ? subject() : subject[prop];
    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;
    flag(this, 'deltaMsgObj', msgObj);
    flag(this, 'initialDeltaValue', initial);
    flag(this, 'finalDeltaValue', final);
    flag(this, 'deltaBehavior', 'decrease');
    flag(this, 'realDelta', initial - final);
    this.assert(final - initial < 0, 'expected ' + msgObj + ' to decrease', 'expected ' + msgObj + ' to not decrease');
  }

  Assertion.addMethod('decrease', assertDecreases);
  Assertion.addMethod('decreases', assertDecreases);
  /**
   * ### .by(delta[, msg])
   *
   * When following an `.increase` assertion in the chain, `.by` asserts that
   * the subject of the `.increase` assertion increased by the given `delta`.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2);
   *
   * When following a `.decrease` assertion in the chain, `.by` asserts that the
   * subject of the `.decrease` assertion decreased by the given `delta`.
   *
   *     var myObj = {val: 1}
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2);
   *
   * When following a `.change` assertion in the chain, `.by` asserts that the
   * subject of the `.change` assertion either increased or decreased by the
   * given `delta`. However, it's dangerous to use `.change.by`. The problem is
   * that it creates uncertain expectations. It's often best to identify the
   * exact output that's expected, and then write an assertion that only accepts
   * that exact output.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; }
   *       , subtractTwo = function () { myObj.val -= 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended
   *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended
   *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended
   *
   * Add `.not` earlier in the chain to negate `.by`. However, it's often best
   * to assert that the subject changed by its expected delta, rather than
   * asserting that it didn't change by one of countless unexpected deltas.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     // Recommended
   *     expect(addTwo).to.increase(myObj, 'val').by(2);
   *
   *     // Not recommended
   *     expect(addTwo).to.increase(myObj, 'val').but.not.by(3);
   *
   * `.by` accepts an optional `msg` argument which is a custom error message to
   * show when the assertion fails. The message can also be given as the second
   * argument to `expect`.
   *
   *     var myObj = {val: 1}
   *       , addTwo = function () { myObj.val += 2; };
   *
   *     expect(addTwo).to.increase(myObj, 'val').by(3, 'nooo why fail??');
   *     expect(addTwo, 'nooo why fail??').to.increase(myObj, 'val').by(3);
   *
   * @name by
   * @param {Number} delta
   * @param {String} msg _optional_
   * @namespace BDD
   * @api public
   */

  function assertDelta(delta, msg) {
    if (msg) flag(this, 'message', msg);
    var msgObj = flag(this, 'deltaMsgObj');
    var initial = flag(this, 'initialDeltaValue');
    var final = flag(this, 'finalDeltaValue');
    var behavior = flag(this, 'deltaBehavior');
    var realDelta = flag(this, 'realDelta');
    var expression;

    if (behavior === 'change') {
      expression = Math.abs(final - initial) === Math.abs(delta);
    } else {
      expression = realDelta === Math.abs(delta);
    }

    this.assert(expression, 'expected ' + msgObj + ' to ' + behavior + ' by ' + delta, 'expected ' + msgObj + ' to not ' + behavior + ' by ' + delta);
  }

  Assertion.addMethod('by', assertDelta);
  /**
   * ### .extensible
   *
   * Asserts that the target is extensible, which means that new properties can
   * be added to it. Primitives are never extensible.
   *
   *     expect({a: 1}).to.be.extensible;
   *
   * Add `.not` earlier in the chain to negate `.extensible`.
   *
   *     var nonExtensibleObject = Object.preventExtensions({})
   *       , sealedObject = Object.seal({})
   *       , frozenObject = Object.freeze({});
   *
   *     expect(nonExtensibleObject).to.not.be.extensible;
   *     expect(sealedObject).to.not.be.extensible;
   *     expect(frozenObject).to.not.be.extensible;
   *     expect(1).to.not.be.extensible;
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect(1, 'nooo why fail??').to.be.extensible;
   *
   * @name extensible
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('extensible', function () {
    var obj = flag(this, 'object'); // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible
    // The following provides ES6 behavior for ES5 environments.

    var isExtensible = obj === Object(obj) && Object.isExtensible(obj);
    this.assert(isExtensible, 'expected #{this} to be extensible', 'expected #{this} to not be extensible');
  });
  /**
   * ### .sealed
   *
   * Asserts that the target is sealed, which means that new properties can't be
   * added to it, and its existing properties can't be reconfigured or deleted.
   * However, it's possible that its existing properties can still be reassigned
   * to different values. Primitives are always sealed.
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     expect(sealedObject).to.be.sealed;
   *     expect(frozenObject).to.be.sealed;
   *     expect(1).to.be.sealed;
   *
   * Add `.not` earlier in the chain to negate `.sealed`.
   *
   *     expect({a: 1}).to.not.be.sealed;
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({a: 1}, 'nooo why fail??').to.be.sealed;
   *
   * @name sealed
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('sealed', function () {
    var obj = flag(this, 'object'); // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed
    // The following provides ES6 behavior for ES5 environments.

    var isSealed = obj === Object(obj) ? Object.isSealed(obj) : true;
    this.assert(isSealed, 'expected #{this} to be sealed', 'expected #{this} to not be sealed');
  });
  /**
   * ### .frozen
   *
   * Asserts that the target is frozen, which means that new properties can't be
   * added to it, and its existing properties can't be reassigned to different
   * values, reconfigured, or deleted. Primitives are always frozen.
   *
   *     var frozenObject = Object.freeze({});
   *
   *     expect(frozenObject).to.be.frozen;
   *     expect(1).to.be.frozen;
   *
   * Add `.not` earlier in the chain to negate `.frozen`.
   *
   *     expect({a: 1}).to.not.be.frozen;
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect({a: 1}, 'nooo why fail??').to.be.frozen;
   *
   * @name frozen
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('frozen', function () {
    var obj = flag(this, 'object'); // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen
    // The following provides ES6 behavior for ES5 environments.

    var isFrozen = obj === Object(obj) ? Object.isFrozen(obj) : true;
    this.assert(isFrozen, 'expected #{this} to be frozen', 'expected #{this} to not be frozen');
  });
  /**
   * ### .finite
   *
   * Asserts that the target is a number, and isn't `NaN` or positive/negative
   * `Infinity`.
   *
   *     expect(1).to.be.finite;
   *
   * Add `.not` earlier in the chain to negate `.finite`. However, it's
   * dangerous to do so. The problem is that it creates uncertain expectations
   * by asserting that the subject either isn't a number, or that it's `NaN`, or
   * that it's positive `Infinity`, or that it's negative `Infinity`. It's often
   * best to identify the exact output that's expected, and then write an
   * assertion that only accepts that exact output.
   *
   * When the target isn't expected to be a number, it's often best to assert
   * that it's the expected type, rather than asserting that it isn't one of
   * many unexpected types.
   *
   *     expect('foo').to.be.a('string'); // Recommended
   *     expect('foo').to.not.be.finite; // Not recommended
   *
   * When the target is expected to be `NaN`, it's often best to assert exactly
   * that.
   *
   *     expect(NaN).to.be.NaN; // Recommended
   *     expect(NaN).to.not.be.finite; // Not recommended
   *
   * When the target is expected to be positive infinity, it's often best to
   * assert exactly that.
   *
   *     expect(Infinity).to.equal(Infinity); // Recommended
   *     expect(Infinity).to.not.be.finite; // Not recommended
   *
   * When the target is expected to be negative infinity, it's often best to
   * assert exactly that.
   *
   *     expect(-Infinity).to.equal(-Infinity); // Recommended
   *     expect(-Infinity).to.not.be.finite; // Not recommended
   *
   * A custom error message can be given as the second argument to `expect`.
   *
   *     expect('foo', 'nooo why fail??').to.be.finite;
   *
   * @name finite
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('finite', function (msg) {
    var obj = flag(this, 'object');
    this.assert(typeof obj === 'number' && isFinite(obj), 'expected #{this} to be a finite number', 'expected #{this} to not be a finite number');
  });
};/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var expect = function (chai, util) {
  chai.expect = function (val, message) {
    return new chai.Assertion(val, message);
  };
  /**
   * ### .fail([message])
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure.
   *
   *     expect.fail();
   *     expect.fail("custom error message");
   *     expect.fail(1, 2);
   *     expect.fail(1, 2, "custom error message");
   *     expect.fail(1, 2, "custom error message", ">");
   *     expect.fail(1, 2, undefined, ">");
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @namespace BDD
   * @api public
   */


  chai.expect.fail = function (actual, expected, message, operator) {
    if (arguments.length < 2) {
      message = actual;
      actual = undefined;
    }

    message = message || 'expect.fail()';
    throw new chai.AssertionError(message, {
      actual: actual,
      expected: expected,
      operator: operator
    }, chai.expect.fail);
  };
};/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var should = function (chai, util) {
  var Assertion = chai.Assertion;

  function loadShould() {
    // explicitly define this method as function as to have it's name to include as `ssfi`
    function shouldGetter() {
      if (this instanceof String || this instanceof Number || this instanceof Boolean || typeof Symbol === 'function' && this instanceof Symbol) {
        return new Assertion(this.valueOf(), null, shouldGetter);
      }

      return new Assertion(this, null, shouldGetter);
    }

    function shouldSetter(value) {
      // See https://github.com/chaijs/chai/issues/86: this makes
      // `whatever.should = someValue` actually set `someValue`, which is
      // especially useful for `global.should = require('chai').should()`.
      //
      // Note that we have to use [[DefineProperty]] instead of [[Put]]
      // since otherwise we would trigger this very setter!
      Object.defineProperty(this, 'should', {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } // modify Object.prototype to have `should`


    Object.defineProperty(Object.prototype, 'should', {
      set: shouldSetter,
      get: shouldGetter,
      configurable: true
    });
    var should = {};
    /**
     * ### .fail([message])
     * ### .fail(actual, expected, [message], [operator])
     *
     * Throw a failure.
     *
     *     should.fail();
     *     should.fail("custom error message");
     *     should.fail(1, 2);
     *     should.fail(1, 2, "custom error message");
     *     should.fail(1, 2, "custom error message", ">");
     *     should.fail(1, 2, undefined, ">");
     *
     *
     * @name fail
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @param {String} operator
     * @namespace BDD
     * @api public
     */

    should.fail = function (actual, expected, message, operator) {
      if (arguments.length < 2) {
        message = actual;
        actual = undefined;
      }

      message = message || 'should.fail()';
      throw new chai.AssertionError(message, {
        actual: actual,
        expected: expected,
        operator: operator
      }, should.fail);
    };
    /**
     * ### .equal(actual, expected, [message])
     *
     * Asserts non-strict equality (`==`) of `actual` and `expected`.
     *
     *     should.equal(3, '3', '== coerces values to strings');
     *
     * @name equal
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @namespace Should
     * @api public
     */


    should.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.equal(val2);
    };
    /**
     * ### .throw(function, [constructor/string/regexp], [string/regexp], [message])
     *
     * Asserts that `function` will throw an error that is an instance of
     * `constructor`, or alternately that it will throw an error with message
     * matching `regexp`.
     *
     *     should.throw(fn, 'function throws a reference error');
     *     should.throw(fn, /function throws a reference error/);
     *     should.throw(fn, ReferenceError);
     *     should.throw(fn, ReferenceError, 'function throws a reference error');
     *     should.throw(fn, ReferenceError, /function throws a reference error/);
     *
     * @name throw
     * @alias Throw
     * @param {Function} function
     * @param {ErrorConstructor} constructor
     * @param {RegExp} regexp
     * @param {String} message
     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
     * @namespace Should
     * @api public
     */


    should.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.Throw(errt, errs);
    };
    /**
     * ### .exist
     *
     * Asserts that the target is neither `null` nor `undefined`.
     *
     *     var foo = 'hi';
     *
     *     should.exist(foo, 'foo exists');
     *
     * @name exist
     * @namespace Should
     * @api public
     */


    should.exist = function (val, msg) {
      new Assertion(val, msg).to.exist;
    }; // negation


    should.not = {};
    /**
     * ### .not.equal(actual, expected, [message])
     *
     * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
     *
     *     should.not.equal(3, 4, 'these numbers are not equal');
     *
     * @name not.equal
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @namespace Should
     * @api public
     */

    should.not.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.not.equal(val2);
    };
    /**
     * ### .throw(function, [constructor/regexp], [message])
     *
     * Asserts that `function` will _not_ throw an error that is an instance of
     * `constructor`, or alternately that it will not throw an error with message
     * matching `regexp`.
     *
     *     should.not.throw(fn, Error, 'function does not throw');
     *
     * @name not.throw
     * @alias not.Throw
     * @param {Function} function
     * @param {ErrorConstructor} constructor
     * @param {RegExp} regexp
     * @param {String} message
     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
     * @namespace Should
     * @api public
     */


    should.not.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.not.Throw(errt, errs);
    };
    /**
     * ### .not.exist
     *
     * Asserts that the target is neither `null` nor `undefined`.
     *
     *     var bar = null;
     *
     *     should.not.exist(bar, 'bar does not exist');
     *
     * @name not.exist
     * @namespace Should
     * @api public
     */


    should.not.exist = function (val, msg) {
      new Assertion(val, msg).to.not.exist;
    };

    should['throw'] = should['Throw'];
    should.not['throw'] = should.not['Throw'];
    return should;
  }
  chai.should = loadShould;
  chai.Should = loadShould;
};/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var assert = function (chai, util) {
  /*!
   * Chai dependencies.
   */
  var Assertion = chai.Assertion,
      flag = util.flag;
  /*!
   * Module export.
   */

  /**
   * ### assert(expression, message)
   *
   * Write your own test expressions.
   *
   *     assert('foo' !== 'bar', 'foo is not bar');
   *     assert(Array.isArray([]), 'empty arrays are arrays');
   *
   * @param {Mixed} expression to test for truthiness
   * @param {String} message to display on error
   * @name assert
   * @namespace Assert
   * @api public
   */

  var assert = chai.assert = function (express, errmsg) {
    var test = new Assertion(null, null, chai.assert, true);
    test.assert(express, errmsg, '[ negation message unavailable ]');
  };
  /**
   * ### .fail([message])
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure. Node.js `assert` module-compatible.
   *
   *     assert.fail();
   *     assert.fail("custom error message");
   *     assert.fail(1, 2);
   *     assert.fail(1, 2, "custom error message");
   *     assert.fail(1, 2, "custom error message", ">");
   *     assert.fail(1, 2, undefined, ">");
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @namespace Assert
   * @api public
   */


  assert.fail = function (actual, expected, message, operator) {
    if (arguments.length < 2) {
      // Comply with Node's fail([message]) interface
      message = actual;
      actual = undefined;
    }

    message = message || 'assert.fail()';
    throw new chai.AssertionError(message, {
      actual: actual,
      expected: expected,
      operator: operator
    }, assert.fail);
  };
  /**
   * ### .isOk(object, [message])
   *
   * Asserts that `object` is truthy.
   *
   *     assert.isOk('everything', 'everything is ok');
   *     assert.isOk(false, 'this will fail');
   *
   * @name isOk
   * @alias ok
   * @param {Mixed} object to test
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isOk = function (val, msg) {
    new Assertion(val, msg, assert.isOk, true).is.ok;
  };
  /**
   * ### .isNotOk(object, [message])
   *
   * Asserts that `object` is falsy.
   *
   *     assert.isNotOk('everything', 'this will fail');
   *     assert.isNotOk(false, 'this will pass');
   *
   * @name isNotOk
   * @alias notOk
   * @param {Mixed} object to test
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotOk = function (val, msg) {
    new Assertion(val, msg, assert.isNotOk, true).is.not.ok;
  };
  /**
   * ### .equal(actual, expected, [message])
   *
   * Asserts non-strict equality (`==`) of `actual` and `expected`.
   *
   *     assert.equal(3, '3', '== coerces values to strings');
   *
   * @name equal
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.equal = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.equal, true);
    test.assert(exp == flag(test, 'object'), 'expected #{this} to equal #{exp}', 'expected #{this} to not equal #{act}', exp, act, true);
  };
  /**
   * ### .notEqual(actual, expected, [message])
   *
   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
   *
   *     assert.notEqual(3, 4, 'these numbers are not equal');
   *
   * @name notEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notEqual = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.notEqual, true);
    test.assert(exp != flag(test, 'object'), 'expected #{this} to not equal #{exp}', 'expected #{this} to equal #{act}', exp, act, true);
  };
  /**
   * ### .strictEqual(actual, expected, [message])
   *
   * Asserts strict equality (`===`) of `actual` and `expected`.
   *
   *     assert.strictEqual(true, true, 'these booleans are strictly equal');
   *
   * @name strictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.strictEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.strictEqual, true).to.equal(exp);
  };
  /**
   * ### .notStrictEqual(actual, expected, [message])
   *
   * Asserts strict inequality (`!==`) of `actual` and `expected`.
   *
   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
   *
   * @name notStrictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notStrictEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.notStrictEqual, true).to.not.equal(exp);
  };
  /**
   * ### .deepEqual(actual, expected, [message])
   *
   * Asserts that `actual` is deeply equal to `expected`.
   *
   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });
   *
   * @name deepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @alias deepStrictEqual
   * @namespace Assert
   * @api public
   */


  assert.deepEqual = assert.deepStrictEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.deepEqual, true).to.eql(exp);
  };
  /**
   * ### .notDeepEqual(actual, expected, [message])
   *
   * Assert that `actual` is not deeply equal to `expected`.
   *
   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
   *
   * @name notDeepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notDeepEqual = function (act, exp, msg) {
    new Assertion(act, msg, assert.notDeepEqual, true).to.not.eql(exp);
  };
  /**
  * ### .isAbove(valueToCheck, valueToBeAbove, [message])
  *
  * Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`.
  *
  *     assert.isAbove(5, 2, '5 is strictly greater than 2');
  *
  * @name isAbove
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeAbove
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.isAbove = function (val, abv, msg) {
    new Assertion(val, msg, assert.isAbove, true).to.be.above(abv);
  };
  /**
  * ### .isAtLeast(valueToCheck, valueToBeAtLeast, [message])
  *
  * Asserts `valueToCheck` is greater than or equal to (>=) `valueToBeAtLeast`.
  *
  *     assert.isAtLeast(5, 2, '5 is greater or equal to 2');
  *     assert.isAtLeast(3, 3, '3 is greater or equal to 3');
  *
  * @name isAtLeast
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeAtLeast
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.isAtLeast = function (val, atlst, msg) {
    new Assertion(val, msg, assert.isAtLeast, true).to.be.least(atlst);
  };
  /**
  * ### .isBelow(valueToCheck, valueToBeBelow, [message])
  *
  * Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`.
  *
  *     assert.isBelow(3, 6, '3 is strictly less than 6');
  *
  * @name isBelow
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeBelow
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.isBelow = function (val, blw, msg) {
    new Assertion(val, msg, assert.isBelow, true).to.be.below(blw);
  };
  /**
  * ### .isAtMost(valueToCheck, valueToBeAtMost, [message])
  *
  * Asserts `valueToCheck` is less than or equal to (<=) `valueToBeAtMost`.
  *
  *     assert.isAtMost(3, 6, '3 is less than or equal to 6');
  *     assert.isAtMost(4, 4, '4 is less than or equal to 4');
  *
  * @name isAtMost
  * @param {Mixed} valueToCheck
  * @param {Mixed} valueToBeAtMost
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.isAtMost = function (val, atmst, msg) {
    new Assertion(val, msg, assert.isAtMost, true).to.be.most(atmst);
  };
  /**
   * ### .isTrue(value, [message])
   *
   * Asserts that `value` is true.
   *
   *     var teaServed = true;
   *     assert.isTrue(teaServed, 'the tea has been served');
   *
   * @name isTrue
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isTrue = function (val, msg) {
    new Assertion(val, msg, assert.isTrue, true).is['true'];
  };
  /**
   * ### .isNotTrue(value, [message])
   *
   * Asserts that `value` is not true.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotTrue(tea, 'great, time for tea!');
   *
   * @name isNotTrue
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotTrue = function (val, msg) {
    new Assertion(val, msg, assert.isNotTrue, true).to.not.equal(true);
  };
  /**
   * ### .isFalse(value, [message])
   *
   * Asserts that `value` is false.
   *
   *     var teaServed = false;
   *     assert.isFalse(teaServed, 'no tea yet? hmm...');
   *
   * @name isFalse
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isFalse = function (val, msg) {
    new Assertion(val, msg, assert.isFalse, true).is['false'];
  };
  /**
   * ### .isNotFalse(value, [message])
   *
   * Asserts that `value` is not false.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotFalse(tea, 'great, time for tea!');
   *
   * @name isNotFalse
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotFalse = function (val, msg) {
    new Assertion(val, msg, assert.isNotFalse, true).to.not.equal(false);
  };
  /**
   * ### .isNull(value, [message])
   *
   * Asserts that `value` is null.
   *
   *     assert.isNull(err, 'there was no error');
   *
   * @name isNull
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNull = function (val, msg) {
    new Assertion(val, msg, assert.isNull, true).to.equal(null);
  };
  /**
   * ### .isNotNull(value, [message])
   *
   * Asserts that `value` is not null.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotNull(tea, 'great, time for tea!');
   *
   * @name isNotNull
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotNull = function (val, msg) {
    new Assertion(val, msg, assert.isNotNull, true).to.not.equal(null);
  };
  /**
   * ### .isNaN
   *
   * Asserts that value is NaN.
   *
   *     assert.isNaN(NaN, 'NaN is NaN');
   *
   * @name isNaN
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNaN = function (val, msg) {
    new Assertion(val, msg, assert.isNaN, true).to.be.NaN;
  };
  /**
   * ### .isNotNaN
   *
   * Asserts that value is not NaN.
   *
   *     assert.isNotNaN(4, '4 is not NaN');
   *
   * @name isNotNaN
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotNaN = function (val, msg) {
    new Assertion(val, msg, assert.isNotNaN, true).not.to.be.NaN;
  };
  /**
   * ### .exists
   *
   * Asserts that the target is neither `null` nor `undefined`.
   *
   *     var foo = 'hi';
   *
   *     assert.exists(foo, 'foo is neither `null` nor `undefined`');
   *
   * @name exists
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.exists = function (val, msg) {
    new Assertion(val, msg, assert.exists, true).to.exist;
  };
  /**
   * ### .notExists
   *
   * Asserts that the target is either `null` or `undefined`.
   *
   *     var bar = null
   *       , baz;
   *
   *     assert.notExists(bar);
   *     assert.notExists(baz, 'baz is either null or undefined');
   *
   * @name notExists
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notExists = function (val, msg) {
    new Assertion(val, msg, assert.notExists, true).to.not.exist;
  };
  /**
   * ### .isUndefined(value, [message])
   *
   * Asserts that `value` is `undefined`.
   *
   *     var tea;
   *     assert.isUndefined(tea, 'no tea defined');
   *
   * @name isUndefined
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isUndefined = function (val, msg) {
    new Assertion(val, msg, assert.isUndefined, true).to.equal(undefined);
  };
  /**
   * ### .isDefined(value, [message])
   *
   * Asserts that `value` is not `undefined`.
   *
   *     var tea = 'cup of chai';
   *     assert.isDefined(tea, 'tea has been defined');
   *
   * @name isDefined
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isDefined = function (val, msg) {
    new Assertion(val, msg, assert.isDefined, true).to.not.equal(undefined);
  };
  /**
   * ### .isFunction(value, [message])
   *
   * Asserts that `value` is a function.
   *
   *     function serveTea() { return 'cup of tea'; };
   *     assert.isFunction(serveTea, 'great, we can have tea now');
   *
   * @name isFunction
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isFunction = function (val, msg) {
    new Assertion(val, msg, assert.isFunction, true).to.be.a('function');
  };
  /**
   * ### .isNotFunction(value, [message])
   *
   * Asserts that `value` is _not_ a function.
   *
   *     var serveTea = [ 'heat', 'pour', 'sip' ];
   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
   *
   * @name isNotFunction
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotFunction = function (val, msg) {
    new Assertion(val, msg, assert.isNotFunction, true).to.not.be.a('function');
  };
  /**
   * ### .isObject(value, [message])
   *
   * Asserts that `value` is an object of type 'Object' (as revealed by `Object.prototype.toString`).
   * _The assertion does not match subclassed objects._
   *
   *     var selection = { name: 'Chai', serve: 'with spices' };
   *     assert.isObject(selection, 'tea selection is an object');
   *
   * @name isObject
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isObject = function (val, msg) {
    new Assertion(val, msg, assert.isObject, true).to.be.a('object');
  };
  /**
   * ### .isNotObject(value, [message])
   *
   * Asserts that `value` is _not_ an object of type 'Object' (as revealed by `Object.prototype.toString`).
   *
   *     var selection = 'chai'
   *     assert.isNotObject(selection, 'tea selection is not an object');
   *     assert.isNotObject(null, 'null is not an object');
   *
   * @name isNotObject
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotObject = function (val, msg) {
    new Assertion(val, msg, assert.isNotObject, true).to.not.be.a('object');
  };
  /**
   * ### .isArray(value, [message])
   *
   * Asserts that `value` is an array.
   *
   *     var menu = [ 'green', 'chai', 'oolong' ];
   *     assert.isArray(menu, 'what kind of tea do we want?');
   *
   * @name isArray
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isArray = function (val, msg) {
    new Assertion(val, msg, assert.isArray, true).to.be.an('array');
  };
  /**
   * ### .isNotArray(value, [message])
   *
   * Asserts that `value` is _not_ an array.
   *
   *     var menu = 'green|chai|oolong';
   *     assert.isNotArray(menu, 'what kind of tea do we want?');
   *
   * @name isNotArray
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotArray = function (val, msg) {
    new Assertion(val, msg, assert.isNotArray, true).to.not.be.an('array');
  };
  /**
   * ### .isString(value, [message])
   *
   * Asserts that `value` is a string.
   *
   *     var teaOrder = 'chai';
   *     assert.isString(teaOrder, 'order placed');
   *
   * @name isString
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isString = function (val, msg) {
    new Assertion(val, msg, assert.isString, true).to.be.a('string');
  };
  /**
   * ### .isNotString(value, [message])
   *
   * Asserts that `value` is _not_ a string.
   *
   *     var teaOrder = 4;
   *     assert.isNotString(teaOrder, 'order placed');
   *
   * @name isNotString
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotString = function (val, msg) {
    new Assertion(val, msg, assert.isNotString, true).to.not.be.a('string');
  };
  /**
   * ### .isNumber(value, [message])
   *
   * Asserts that `value` is a number.
   *
   *     var cups = 2;
   *     assert.isNumber(cups, 'how many cups');
   *
   * @name isNumber
   * @param {Number} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNumber = function (val, msg) {
    new Assertion(val, msg, assert.isNumber, true).to.be.a('number');
  };
  /**
   * ### .isNotNumber(value, [message])
   *
   * Asserts that `value` is _not_ a number.
   *
   *     var cups = '2 cups please';
   *     assert.isNotNumber(cups, 'how many cups');
   *
   * @name isNotNumber
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotNumber = function (val, msg) {
    new Assertion(val, msg, assert.isNotNumber, true).to.not.be.a('number');
  };
  /**
  * ### .isFinite(value, [message])
  *
  * Asserts that `value` is a finite number. Unlike `.isNumber`, this will fail for `NaN` and `Infinity`.
  *
  *     var cups = 2;
  *     assert.isFinite(cups, 'how many cups');
  *
  *     assert.isFinite(NaN); // throws
  *
  * @name isFinite
  * @param {Number} value
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.isFinite = function (val, msg) {
    new Assertion(val, msg, assert.isFinite, true).to.be.finite;
  };
  /**
   * ### .isBoolean(value, [message])
   *
   * Asserts that `value` is a boolean.
   *
   *     var teaReady = true
   *       , teaServed = false;
   *
   *     assert.isBoolean(teaReady, 'is the tea ready');
   *     assert.isBoolean(teaServed, 'has tea been served');
   *
   * @name isBoolean
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isBoolean = function (val, msg) {
    new Assertion(val, msg, assert.isBoolean, true).to.be.a('boolean');
  };
  /**
   * ### .isNotBoolean(value, [message])
   *
   * Asserts that `value` is _not_ a boolean.
   *
   *     var teaReady = 'yep'
   *       , teaServed = 'nope';
   *
   *     assert.isNotBoolean(teaReady, 'is the tea ready');
   *     assert.isNotBoolean(teaServed, 'has tea been served');
   *
   * @name isNotBoolean
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.isNotBoolean = function (val, msg) {
    new Assertion(val, msg, assert.isNotBoolean, true).to.not.be.a('boolean');
  };
  /**
   * ### .typeOf(value, name, [message])
   *
   * Asserts that `value`'s type is `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
   *     assert.typeOf('tea', 'string', 'we have a string');
   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
   *     assert.typeOf(null, 'null', 'we have a null');
   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
   *
   * @name typeOf
   * @param {Mixed} value
   * @param {String} name
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.typeOf = function (val, type, msg) {
    new Assertion(val, msg, assert.typeOf, true).to.be.a(type);
  };
  /**
   * ### .notTypeOf(value, name, [message])
   *
   * Asserts that `value`'s type is _not_ `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
   *
   * @name notTypeOf
   * @param {Mixed} value
   * @param {String} typeof name
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notTypeOf = function (val, type, msg) {
    new Assertion(val, msg, assert.notTypeOf, true).to.not.be.a(type);
  };
  /**
   * ### .instanceOf(object, constructor, [message])
   *
   * Asserts that `value` is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new Tea('chai');
   *
   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
   *
   * @name instanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.instanceOf = function (val, type, msg) {
    new Assertion(val, msg, assert.instanceOf, true).to.be.instanceOf(type);
  };
  /**
   * ### .notInstanceOf(object, constructor, [message])
   *
   * Asserts `value` is not an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new String('chai');
   *
   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
   *
   * @name notInstanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notInstanceOf = function (val, type, msg) {
    new Assertion(val, msg, assert.notInstanceOf, true).to.not.be.instanceOf(type);
  };
  /**
   * ### .include(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Can be used to assert the
   * inclusion of a value in an array, a substring in a string, or a subset of
   * properties in an object.
   *
   *     assert.include([1,2,3], 2, 'array contains value');
   *     assert.include('foobar', 'foo', 'string contains substring');
   *     assert.include({ foo: 'bar', hello: 'universe' }, { foo: 'bar' }, 'object contains property');
   *
   * Strict equality (===) is used. When asserting the inclusion of a value in
   * an array, the array is searched for an element that's strictly equal to the
   * given value. When asserting a subset of properties in an object, the object
   * is searched for the given property keys, checking that each one is present
   * and strictly equal to the given property value. For instance:
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.include([obj1, obj2], obj1);
   *     assert.include({foo: obj1, bar: obj2}, {foo: obj1});
   *     assert.include({foo: obj1, bar: obj2}, {foo: obj1, bar: obj2});
   *
   * @name include
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.include = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.include, true).include(inc);
  };
  /**
   * ### .notInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Can be used to assert
   * the absence of a value in an array, a substring in a string, or a subset of
   * properties in an object.
   *
   *     assert.notInclude([1,2,3], 4, "array doesn't contain value");
   *     assert.notInclude('foobar', 'baz', "string doesn't contain substring");
   *     assert.notInclude({ foo: 'bar', hello: 'universe' }, { foo: 'baz' }, 'object doesn't contain property');
   *
   * Strict equality (===) is used. When asserting the absence of a value in an
   * array, the array is searched to confirm the absence of an element that's
   * strictly equal to the given value. When asserting a subset of properties in
   * an object, the object is searched to confirm that at least one of the given
   * property keys is either not present or not strictly equal to the given
   * property value. For instance:
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.notInclude([obj1, obj2], {a: 1});
   *     assert.notInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});
   *     assert.notInclude({foo: obj1, bar: obj2}, {foo: obj1, bar: {b: 2}});
   *
   * @name notInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notInclude, true).not.include(inc);
  };
  /**
   * ### .deepInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Can be used to assert the
   * inclusion of a value in an array or a subset of properties in an object.
   * Deep equality is used.
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.deepInclude([obj1, obj2], {a: 1});
   *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});
   *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 2}});
   *
   * @name deepInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.deepInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.deepInclude, true).deep.include(inc);
  };
  /**
   * ### .notDeepInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Can be used to assert
   * the absence of a value in an array or a subset of properties in an object.
   * Deep equality is used.
   *
   *     var obj1 = {a: 1}
   *       , obj2 = {b: 2};
   *     assert.notDeepInclude([obj1, obj2], {a: 9});
   *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 9}});
   *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 9}});
   *
   * @name notDeepInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notDeepInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notDeepInclude, true).not.deep.include(inc);
  };
  /**
   * ### .nestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.nestedInclude({'.a': {'b': 'x'}}, {'\\.a.[b]': 'x'});
   *     assert.nestedInclude({'a': {'[b]': 'x'}}, {'a.\\[b\\]': 'x'});
   *
   * @name nestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.nestedInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.nestedInclude, true).nested.include(inc);
  };
  /**
   * ### .notNestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' does not include 'needle'.
   * Can be used to assert the absence of a subset of properties in an
   * object.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.notNestedInclude({'.a': {'b': 'x'}}, {'\\.a.b': 'y'});
   *     assert.notNestedInclude({'a': {'[b]': 'x'}}, {'a.\\[b\\]': 'y'});
   *
   * @name notNestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notNestedInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notNestedInclude, true).not.nested.include(inc);
  };
  /**
   * ### .deepNestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object while checking for deep equality.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.deepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {x: 1}});
   *     assert.deepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\.a.\\[b\\]': {x: 1}});
   *
   * @name deepNestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.deepNestedInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.deepNestedInclude, true).deep.nested.include(inc);
  };
  /**
   * ### .notDeepNestedInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' does not include 'needle'.
   * Can be used to assert the absence of a subset of properties in an
   * object while checking for deep equality.
   * Enables the use of dot- and bracket-notation for referencing nested
   * properties.
   * '[]' and '.' in property names can be escaped using double backslashes.
   *
   *     assert.notDeepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {y: 1}})
   *     assert.notDeepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\.a.\\[b\\]': {y: 2}});
   *
   * @name notDeepNestedInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notDeepNestedInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notDeepNestedInclude, true).not.deep.nested.include(inc);
  };
  /**
   * ### .ownInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object while ignoring inherited properties.
   *
   *     assert.ownInclude({ a: 1 }, { a: 1 });
   *
   * @name ownInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.ownInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.ownInclude, true).own.include(inc);
  };
  /**
   * ### .notOwnInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the absence of a subset of properties in an
   * object while ignoring inherited properties.
   *
   *     Object.prototype.b = 2;
   *
   *     assert.notOwnInclude({ a: 1 }, { b: 2 });
   *
   * @name notOwnInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notOwnInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notOwnInclude, true).not.own.include(inc);
  };
  /**
   * ### .deepOwnInclude(haystack, needle, [message])
   *
   * Asserts that 'haystack' includes 'needle'.
   * Can be used to assert the inclusion of a subset of properties in an
   * object while ignoring inherited properties and checking for deep equality.
   *
   *      assert.deepOwnInclude({a: {b: 2}}, {a: {b: 2}});
   *
   * @name deepOwnInclude
   * @param {Object} haystack
   * @param {Object} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.deepOwnInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.deepOwnInclude, true).deep.own.include(inc);
  };
  /**
  * ### .notDeepOwnInclude(haystack, needle, [message])
  *
  * Asserts that 'haystack' includes 'needle'.
  * Can be used to assert the absence of a subset of properties in an
  * object while ignoring inherited properties and checking for deep equality.
  *
  *      assert.notDeepOwnInclude({a: {b: 2}}, {a: {c: 3}});
  *
  * @name notDeepOwnInclude
  * @param {Object} haystack
  * @param {Object} needle
  * @param {String} message
  * @namespace Assert
  * @api public
  */


  assert.notDeepOwnInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notDeepOwnInclude, true).not.deep.own.include(inc);
  };
  /**
   * ### .match(value, regexp, [message])
   *
   * Asserts that `value` matches the regular expression `regexp`.
   *
   *     assert.match('foobar', /^foo/, 'regexp matches');
   *
   * @name match
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.match = function (exp, re, msg) {
    new Assertion(exp, msg, assert.match, true).to.match(re);
  };
  /**
   * ### .notMatch(value, regexp, [message])
   *
   * Asserts that `value` does not match the regular expression `regexp`.
   *
   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
   *
   * @name notMatch
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notMatch = function (exp, re, msg) {
    new Assertion(exp, msg, assert.notMatch, true).to.not.match(re);
  };
  /**
   * ### .property(object, property, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property`.
   *
   *     assert.property({ tea: { green: 'matcha' }}, 'tea');
   *     assert.property({ tea: { green: 'matcha' }}, 'toString');
   *
   * @name property
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.property = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.property, true).to.have.property(prop);
  };
  /**
   * ### .notProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a direct or inherited property named
   * by `property`.
   *
   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
   *
   * @name notProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.notProperty, true).to.not.have.property(prop);
  };
  /**
   * ### .propertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property` with a value given by `value`. Uses a strict equality check
   * (===).
   *
   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
   *
   * @name propertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.propertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.propertyVal, true).to.have.property(prop, val);
  };
  /**
   * ### .notPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct or inherited property named
   * by `property` with value given by `value`. Uses a strict equality check
   * (===).
   *
   *     assert.notPropertyVal({ tea: 'is good' }, 'tea', 'is bad');
   *     assert.notPropertyVal({ tea: 'is good' }, 'coffee', 'is good');
   *
   * @name notPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notPropertyVal, true).to.not.have.property(prop, val);
  };
  /**
   * ### .deepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property` with a value given by `value`. Uses a deep equality check.
   *
   *     assert.deepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });
   *
   * @name deepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.deepPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.deepPropertyVal, true).to.have.deep.property(prop, val);
  };
  /**
   * ### .notDeepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct or inherited property named
   * by `property` with value given by `value`. Uses a deep equality check.
   *
   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });
   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });
   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });
   *
   * @name notDeepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notDeepPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notDeepPropertyVal, true).to.not.have.deep.property(prop, val);
  };
  /**
   * ### .ownProperty(object, property, [message])
   *
   * Asserts that `object` has a direct property named by `property`. Inherited
   * properties aren't checked.
   *
   *     assert.ownProperty({ tea: { green: 'matcha' }}, 'tea');
   *
   * @name ownProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */


  assert.ownProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.ownProperty, true).to.have.own.property(prop);
  };
  /**
   * ### .notOwnProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a direct property named by
   * `property`. Inherited properties aren't checked.
   *
   *     assert.notOwnProperty({ tea: { green: 'matcha' }}, 'coffee');
   *     assert.notOwnProperty({}, 'toString');
   *
   * @name notOwnProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */


  assert.notOwnProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.notOwnProperty, true).to.not.have.own.property(prop);
  };
  /**
   * ### .ownPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct property named by `property` and a value
   * equal to the provided `value`. Uses a strict equality check (===).
   * Inherited properties aren't checked.
   *
   *     assert.ownPropertyVal({ coffee: 'is good'}, 'coffee', 'is good');
   *
   * @name ownPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */


  assert.ownPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.ownPropertyVal, true).to.have.own.property(prop, value);
  };
  /**
   * ### .notOwnPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct property named by `property`
   * with a value equal to the provided `value`. Uses a strict equality check
   * (===). Inherited properties aren't checked.
   *
   *     assert.notOwnPropertyVal({ tea: 'is better'}, 'tea', 'is worse');
   *     assert.notOwnPropertyVal({}, 'toString', Object.prototype.toString);
   *
   * @name notOwnPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */


  assert.notOwnPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.notOwnPropertyVal, true).to.not.have.own.property(prop, value);
  };
  /**
   * ### .deepOwnPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a direct property named by `property` and a value
   * equal to the provided `value`. Uses a deep equality check. Inherited
   * properties aren't checked.
   *
   *     assert.deepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });
   *
   * @name deepOwnPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */


  assert.deepOwnPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.deepOwnPropertyVal, true).to.have.deep.own.property(prop, value);
  };
  /**
   * ### .notDeepOwnPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a direct property named by `property`
   * with a value equal to the provided `value`. Uses a deep equality check.
   * Inherited properties aren't checked.
   *
   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });
   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });
   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });
   *     assert.notDeepOwnPropertyVal({}, 'toString', Object.prototype.toString);
   *
   * @name notDeepOwnPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */


  assert.notDeepOwnPropertyVal = function (obj, prop, value, msg) {
    new Assertion(obj, msg, assert.notDeepOwnPropertyVal, true).to.not.have.deep.own.property(prop, value);
  };
  /**
   * ### .nestedProperty(object, property, [message])
   *
   * Asserts that `object` has a direct or inherited property named by
   * `property`, which can be a string using dot- and bracket-notation for
   * nested reference.
   *
   *     assert.nestedProperty({ tea: { green: 'matcha' }}, 'tea.green');
   *
   * @name nestedProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.nestedProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.nestedProperty, true).to.have.nested.property(prop);
  };
  /**
   * ### .notNestedProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`, which
   * can be a string using dot- and bracket-notation for nested reference. The
   * property cannot exist on the object nor anywhere in its prototype chain.
   *
   *     assert.notNestedProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
   *
   * @name notNestedProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notNestedProperty = function (obj, prop, msg) {
    new Assertion(obj, msg, assert.notNestedProperty, true).to.not.have.nested.property(prop);
  };
  /**
   * ### .nestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`. `property` can use dot- and bracket-notation for nested
   * reference. Uses a strict equality check (===).
   *
   *     assert.nestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
   *
   * @name nestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.nestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.nestedPropertyVal, true).to.have.nested.property(prop, val);
  };
  /**
   * ### .notNestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property` with
   * value given by `value`. `property` can use dot- and bracket-notation for
   * nested reference. Uses a strict equality check (===).
   *
   *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
   *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'coffee.green', 'matcha');
   *
   * @name notNestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notNestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notNestedPropertyVal, true).to.not.have.nested.property(prop, val);
  };
  /**
   * ### .deepNestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with a value given
   * by `value`. `property` can use dot- and bracket-notation for nested
   * reference. Uses a deep equality check.
   *
   *     assert.deepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yum' });
   *
   * @name deepNestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.deepNestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.deepNestedPropertyVal, true).to.have.deep.nested.property(prop, val);
  };
  /**
   * ### .notDeepNestedPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property` with
   * value given by `value`. `property` can use dot- and bracket-notation for
   * nested reference. Uses a deep equality check.
   *
   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { oolong: 'yum' });
   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yuck' });
   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.black', { matcha: 'yum' });
   *
   * @name notDeepNestedPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notDeepNestedPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg, assert.notDeepNestedPropertyVal, true).to.not.have.deep.nested.property(prop, val);
  };
  /**
   * ### .lengthOf(object, length, [message])
   *
   * Asserts that `object` has a `length` or `size` with the expected value.
   *
   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
   *     assert.lengthOf('foobar', 6, 'string has length of 6');
   *     assert.lengthOf(new Set([1,2,3]), 3, 'set has size of 3');
   *     assert.lengthOf(new Map([['a',1],['b',2],['c',3]]), 3, 'map has size of 3');
   *
   * @name lengthOf
   * @param {Mixed} object
   * @param {Number} length
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.lengthOf = function (exp, len, msg) {
    new Assertion(exp, msg, assert.lengthOf, true).to.have.lengthOf(len);
  };
  /**
   * ### .hasAnyKeys(object, [keys], [message])
   *
   * Asserts that `object` has at least one of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'iDontExist', 'baz']);
   *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, iDontExist: 99, baz: 1337});
   *     assert.hasAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
   *     assert.hasAnyKeys(new Set([{foo: 'bar'}, 'anotherKey']), [{foo: 'bar'}, 'anotherKey']);
   *
   * @name hasAnyKeys
   * @param {Mixed} object
   * @param {Array|Object} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.hasAnyKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAnyKeys, true).to.have.any.keys(keys);
  };
  /**
   * ### .hasAllKeys(object, [keys], [message])
   *
   * Asserts that `object` has all and only all of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);
   *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337]);
   *     assert.hasAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
   *     assert.hasAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);
   *
   * @name hasAllKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.hasAllKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAllKeys, true).to.have.all.keys(keys);
  };
  /**
   * ### .containsAllKeys(object, [keys], [message])
   *
   * Asserts that `object` has all of the `keys` provided but may have more keys not listed.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'baz']);
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, baz: 1337});
   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337});
   *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}]);
   *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);
   *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}]);
   *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);
   *
   * @name containsAllKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.containsAllKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.containsAllKeys, true).to.contain.all.keys(keys);
  };
  /**
   * ### .doesNotHaveAnyKeys(object, [keys], [message])
   *
   * Asserts that `object` has none of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);
   *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});
   *     assert.doesNotHaveAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);
   *     assert.doesNotHaveAnyKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);
   *
   * @name doesNotHaveAnyKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.doesNotHaveAnyKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAnyKeys, true).to.not.have.any.keys(keys);
  };
  /**
   * ### .doesNotHaveAllKeys(object, [keys], [message])
   *
   * Asserts that `object` does not have at least one of the `keys` provided.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);
   *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});
   *     assert.doesNotHaveAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);
   *     assert.doesNotHaveAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);
   *
   * @name doesNotHaveAllKeys
   * @param {Mixed} object
   * @param {String[]} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.doesNotHaveAllKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAllKeys, true).to.not.have.all.keys(keys);
  };
  /**
   * ### .hasAnyDeepKeys(object, [keys], [message])
   *
   * Asserts that `object` has at least one of the `keys` provided.
   * Since Sets and Maps can have objects as keys you can use this assertion to perform
   * a deep comparison.
   * You can also provide a single object instead of a `keys` array and its keys
   * will be used as the expected set of keys.
   *
   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});
   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), [{one: 'one'}, {two: 'two'}]);
   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});
   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {three: 'three'}]);
   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
   *
   * @name doesNotHaveAllKeys
   * @param {Mixed} object
   * @param {Array|Object} keys
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.hasAnyDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAnyDeepKeys, true).to.have.any.deep.keys(keys);
  };
  /**
    * ### .hasAllDeepKeys(object, [keys], [message])
    *
    * Asserts that `object` has all and only all of the `keys` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a `keys` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne']]), {one: 'one'});
    *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
    *     assert.hasAllDeepKeys(new Set([{one: 'one'}]), {one: 'one'});
    *     assert.hasAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
    *
    * @name hasAllDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */


  assert.hasAllDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.hasAllDeepKeys, true).to.have.all.deep.keys(keys);
  };
  /**
    * ### .containsAllDeepKeys(object, [keys], [message])
    *
    * Asserts that `object` contains all of the `keys` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a `keys` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});
    *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);
    *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});
    *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);
    *
    * @name containsAllDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */


  assert.containsAllDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.containsAllDeepKeys, true).to.contain.all.deep.keys(keys);
  };
  /**
    * ### .doesNotHaveAnyDeepKeys(object, [keys], [message])
    *
    * Asserts that `object` has none of the `keys` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a `keys` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});
    *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);
    *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});
    *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);
    *
    * @name doesNotHaveAnyDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */


  assert.doesNotHaveAnyDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAnyDeepKeys, true).to.not.have.any.deep.keys(keys);
  };
  /**
    * ### .doesNotHaveAllDeepKeys(object, [keys], [message])
    *
    * Asserts that `object` does not have at least one of the `keys` provided.
    * Since Sets and Maps can have objects as keys you can use this assertion to perform
    * a deep comparison.
    * You can also provide a single object instead of a `keys` array and its keys
    * will be used as the expected set of keys.
    *
    *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});
    *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {one: 'one'}]);
    *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});
    *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {fifty: 'fifty'}]);
    *
    * @name doesNotHaveAllDeepKeys
    * @param {Mixed} object
    * @param {Array|Object} keys
    * @param {String} message
    * @namespace Assert
    * @api public
    */


  assert.doesNotHaveAllDeepKeys = function (obj, keys, msg) {
    new Assertion(obj, msg, assert.doesNotHaveAllDeepKeys, true).to.not.have.all.deep.keys(keys);
  };
  /**
    * ### .throws(fn, [errorLike/string/regexp], [string/regexp], [message])
    *
    * If `errorLike` is an `Error` constructor, asserts that `fn` will throw an error that is an
    * instance of `errorLike`.
    * If `errorLike` is an `Error` instance, asserts that the error thrown is the same
    * instance as `errorLike`.
    * If `errMsgMatcher` is provided, it also asserts that the error thrown will have a
    * message matching `errMsgMatcher`.
    *
    *     assert.throws(fn, 'Error thrown must have this msg');
    *     assert.throws(fn, /Error thrown must have a msg that matches this/);
    *     assert.throws(fn, ReferenceError);
    *     assert.throws(fn, errorInstance);
    *     assert.throws(fn, ReferenceError, 'Error thrown must be a ReferenceError and have this msg');
    *     assert.throws(fn, errorInstance, 'Error thrown must be the same errorInstance and have this msg');
    *     assert.throws(fn, ReferenceError, /Error thrown must be a ReferenceError and match this/);
    *     assert.throws(fn, errorInstance, /Error thrown must be the same errorInstance and match this/);
    *
    * @name throws
    * @alias throw
    * @alias Throw
    * @param {Function} fn
    * @param {ErrorConstructor|Error} errorLike
    * @param {RegExp|String} errMsgMatcher
    * @param {String} message
    * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
    * @namespace Assert
    * @api public
    */


  assert.throws = function (fn, errorLike, errMsgMatcher, msg) {
    if ('string' === typeof errorLike || errorLike instanceof RegExp) {
      errMsgMatcher = errorLike;
      errorLike = null;
    }

    var assertErr = new Assertion(fn, msg, assert.throws, true).to.throw(errorLike, errMsgMatcher);
    return flag(assertErr, 'object');
  };
  /**
   * ### .doesNotThrow(fn, [errorLike/string/regexp], [string/regexp], [message])
   *
   * If `errorLike` is an `Error` constructor, asserts that `fn` will _not_ throw an error that is an
   * instance of `errorLike`.
   * If `errorLike` is an `Error` instance, asserts that the error thrown is _not_ the same
   * instance as `errorLike`.
   * If `errMsgMatcher` is provided, it also asserts that the error thrown will _not_ have a
   * message matching `errMsgMatcher`.
   *
   *     assert.doesNotThrow(fn, 'Any Error thrown must not have this message');
   *     assert.doesNotThrow(fn, /Any Error thrown must not match this/);
   *     assert.doesNotThrow(fn, Error);
   *     assert.doesNotThrow(fn, errorInstance);
   *     assert.doesNotThrow(fn, Error, 'Error must not have this message');
   *     assert.doesNotThrow(fn, errorInstance, 'Error must not have this message');
   *     assert.doesNotThrow(fn, Error, /Error must not match this/);
   *     assert.doesNotThrow(fn, errorInstance, /Error must not match this/);
   *
   * @name doesNotThrow
   * @param {Function} fn
   * @param {ErrorConstructor} errorLike
   * @param {RegExp|String} errMsgMatcher
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @namespace Assert
   * @api public
   */


  assert.doesNotThrow = function (fn, errorLike, errMsgMatcher, msg) {
    if ('string' === typeof errorLike || errorLike instanceof RegExp) {
      errMsgMatcher = errorLike;
      errorLike = null;
    }

    new Assertion(fn, msg, assert.doesNotThrow, true).to.not.throw(errorLike, errMsgMatcher);
  };
  /**
   * ### .operator(val1, operator, val2, [message])
   *
   * Compares two values using `operator`.
   *
   *     assert.operator(1, '<', 2, 'everything is ok');
   *     assert.operator(1, '>', 2, 'this will fail');
   *
   * @name operator
   * @param {Mixed} val1
   * @param {String} operator
   * @param {Mixed} val2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.operator = function (val, operator, val2, msg) {
    var ok;

    switch (operator) {
      case '==':
        ok = val == val2;
        break;

      case '===':
        ok = val === val2;
        break;

      case '>':
        ok = val > val2;
        break;

      case '>=':
        ok = val >= val2;
        break;

      case '<':
        ok = val < val2;
        break;

      case '<=':
        ok = val <= val2;
        break;

      case '!=':
        ok = val != val2;
        break;

      case '!==':
        ok = val !== val2;
        break;

      default:
        msg = msg ? msg + ': ' : msg;
        throw new chai.AssertionError(msg + 'Invalid operator "' + operator + '"', undefined, assert.operator);
    }

    var test = new Assertion(ok, msg, assert.operator, true);
    test.assert(true === flag(test, 'object'), 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2), 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2));
  };
  /**
   * ### .closeTo(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
   *
   * @name closeTo
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.closeTo = function (act, exp, delta, msg) {
    new Assertion(act, msg, assert.closeTo, true).to.be.closeTo(exp, delta);
  };
  /**
   * ### .approximately(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.approximately(1.5, 1, 0.5, 'numbers are close');
   *
   * @name approximately
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.approximately = function (act, exp, delta, msg) {
    new Assertion(act, msg, assert.approximately, true).to.be.approximately(exp, delta);
  };
  /**
   * ### .sameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in any order. Uses a
   * strict equality check (===).
   *
   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
   *
   * @name sameMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.sameMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameMembers, true).to.have.same.members(set2);
  };
  /**
   * ### .notSameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in any order.
   * Uses a strict equality check (===).
   *
   *     assert.notSameMembers([ 1, 2, 3 ], [ 5, 1, 3 ], 'not same members');
   *
   * @name notSameMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notSameMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameMembers, true).to.not.have.same.members(set2);
  };
  /**
   * ### .sameDeepMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in any order. Uses a
   * deep equality check.
   *
   *     assert.sameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { c: 3 }], 'same deep members');
   *
   * @name sameDeepMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.sameDeepMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameDeepMembers, true).to.have.same.deep.members(set2);
  };
  /**
   * ### .notSameDeepMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in any order.
   * Uses a deep equality check.
   *
   *     assert.notSameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { f: 5 }], 'not same deep members');
   *
   * @name notSameDeepMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notSameDeepMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameDeepMembers, true).to.not.have.same.deep.members(set2);
  };
  /**
   * ### .sameOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in the same order.
   * Uses a strict equality check (===).
   *
   *     assert.sameOrderedMembers([ 1, 2, 3 ], [ 1, 2, 3 ], 'same ordered members');
   *
   * @name sameOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.sameOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameOrderedMembers, true).to.have.same.ordered.members(set2);
  };
  /**
   * ### .notSameOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in the same
   * order. Uses a strict equality check (===).
   *
   *     assert.notSameOrderedMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'not same ordered members');
   *
   * @name notSameOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notSameOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameOrderedMembers, true).to.not.have.same.ordered.members(set2);
  };
  /**
   * ### .sameDeepOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members in the same order.
   * Uses a deep equality check.
   *
   * assert.sameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { c: 3 } ], 'same deep ordered members');
   *
   * @name sameDeepOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.sameDeepOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.sameDeepOrderedMembers, true).to.have.same.deep.ordered.members(set2);
  };
  /**
   * ### .notSameDeepOrderedMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` don't have the same members in the same
   * order. Uses a deep equality check.
   *
   * assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { z: 5 } ], 'not same deep ordered members');
   * assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { c: 3 } ], 'not same deep ordered members');
   *
   * @name notSameDeepOrderedMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notSameDeepOrderedMembers = function (set1, set2, msg) {
    new Assertion(set1, msg, assert.notSameDeepOrderedMembers, true).to.not.have.same.deep.ordered.members(set2);
  };
  /**
   * ### .includeMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in any order. Uses a
   * strict equality check (===). Duplicates are ignored.
   *
   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1, 2 ], 'include members');
   *
   * @name includeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.includeMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeMembers, true).to.include.members(subset);
  };
  /**
   * ### .notIncludeMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in any order. Uses a
   * strict equality check (===). Duplicates are ignored.
   *
   *     assert.notIncludeMembers([ 1, 2, 3 ], [ 5, 1 ], 'not include members');
   *
   * @name notIncludeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notIncludeMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeMembers, true).to.not.include.members(subset);
  };
  /**
   * ### .includeDeepMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in any order. Uses a deep
   * equality check. Duplicates are ignored.
   *
   *     assert.includeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { b: 2 } ], 'include deep members');
   *
   * @name includeDeepMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.includeDeepMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeDeepMembers, true).to.include.deep.members(subset);
  };
  /**
   * ### .notIncludeDeepMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in any order. Uses a
   * deep equality check. Duplicates are ignored.
   *
   *     assert.notIncludeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { f: 5 } ], 'not include deep members');
   *
   * @name notIncludeDeepMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notIncludeDeepMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeDeepMembers, true).to.not.include.deep.members(subset);
  };
  /**
   * ### .includeOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a strict equality
   * check (===).
   *
   *     assert.includeOrderedMembers([ 1, 2, 3 ], [ 1, 2 ], 'include ordered members');
   *
   * @name includeOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.includeOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeOrderedMembers, true).to.include.ordered.members(subset);
  };
  /**
   * ### .notIncludeOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a strict equality
   * check (===).
   *
   *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 1 ], 'not include ordered members');
   *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 3 ], 'not include ordered members');
   *
   * @name notIncludeOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notIncludeOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeOrderedMembers, true).to.not.include.ordered.members(subset);
  };
  /**
   * ### .includeDeepOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a deep equality
   * check.
   *
   *     assert.includeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 } ], 'include deep ordered members');
   *
   * @name includeDeepOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.includeDeepOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.includeDeepOrderedMembers, true).to.include.deep.ordered.members(subset);
  };
  /**
   * ### .notIncludeDeepOrderedMembers(superset, subset, [message])
   *
   * Asserts that `subset` isn't included in `superset` in the same order
   * beginning with the first element in `superset`. Uses a deep equality
   * check.
   *
   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { f: 5 } ], 'not include deep ordered members');
   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 } ], 'not include deep ordered members');
   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { c: 3 } ], 'not include deep ordered members');
   *
   * @name notIncludeDeepOrderedMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.notIncludeDeepOrderedMembers = function (superset, subset, msg) {
    new Assertion(superset, msg, assert.notIncludeDeepOrderedMembers, true).to.not.include.deep.ordered.members(subset);
  };
  /**
   * ### .oneOf(inList, list, [message])
   *
   * Asserts that non-object, non-array value `inList` appears in the flat array `list`.
   *
   *     assert.oneOf(1, [ 2, 1 ], 'Not found in list');
   *
   * @name oneOf
   * @param {*} inList
   * @param {Array<*>} list
   * @param {String} message
   * @namespace Assert
   * @api public
   */


  assert.oneOf = function (inList, list, msg) {
    new Assertion(inList, msg, assert.oneOf, true).to.be.oneOf(list);
  };
  /**
   * ### .changes(function, object, property, [message])
   *
   * Asserts that a function changes the value of a property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 22 };
   *     assert.changes(fn, obj, 'val');
   *
   * @name changes
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.changes = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.changes, true).to.change(obj, prop);
  };
  /**
  * ### .changesBy(function, object, property, delta, [message])
  *
  * Asserts that a function changes the value of a property by an amount (delta).
  *
  *     var obj = { val: 10 };
  *     var fn = function() { obj.val += 2 };
  *     assert.changesBy(fn, obj, 'val', 2);
  *
  * @name changesBy
  * @param {Function} modifier function
  * @param {Object} object or getter function
  * @param {String} property name _optional_
  * @param {Number} change amount (delta)
  * @param {String} message _optional_
  * @namespace Assert
  * @api public
  */


  assert.changesBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.changesBy, true).to.change(obj, prop).by(delta);
  };
  /**
  * ### .doesNotChange(function, object, property, [message])
  *
  * Asserts that a function does not change the value of a property.
  *
  *     var obj = { val: 10 };
  *     var fn = function() { console.log('foo'); };
  *     assert.doesNotChange(fn, obj, 'val');
  *
  * @name doesNotChange
  * @param {Function} modifier function
  * @param {Object} object or getter function
  * @param {String} property name _optional_
  * @param {String} message _optional_
  * @namespace Assert
  * @api public
  */


  assert.doesNotChange = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotChange, true).to.not.change(obj, prop);
  };
  /**
   * ### .changesButNotBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not change the value of a property or of a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val += 10 };
   *     assert.changesButNotBy(fn, obj, 'val', 5);
   *
   * @name changesButNotBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.changesButNotBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.changesButNotBy, true).to.change(obj, prop).but.not.by(delta);
  };
  /**
   * ### .increases(function, object, property, [message])
   *
   * Asserts that a function increases a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 13 };
   *     assert.increases(fn, obj, 'val');
   *
   * @name increases
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.increases = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.increases, true).to.increase(obj, prop);
  };
  /**
   * ### .increasesBy(function, object, property, delta, [message])
   *
   * Asserts that a function increases a numeric object property or a function's return value by an amount (delta).
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val += 10 };
   *     assert.increasesBy(fn, obj, 'val', 10);
   *
   * @name increasesBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.increasesBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.increasesBy, true).to.increase(obj, prop).by(delta);
  };
  /**
   * ### .doesNotIncrease(function, object, property, [message])
   *
   * Asserts that a function does not increase a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 8 };
   *     assert.doesNotIncrease(fn, obj, 'val');
   *
   * @name doesNotIncrease
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.doesNotIncrease = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotIncrease, true).to.not.increase(obj, prop);
  };
  /**
   * ### .increasesButNotBy(function, object, property, [message])
   *
   * Asserts that a function does not increase a numeric object property or function's return value by an amount (delta).
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     assert.increasesButNotBy(fn, obj, 'val', 10);
   *
   * @name increasesButNotBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.increasesButNotBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.increasesButNotBy, true).to.increase(obj, prop).but.not.by(delta);
  };
  /**
   * ### .decreases(function, object, property, [message])
   *
   * Asserts that a function decreases a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.decreases(fn, obj, 'val');
   *
   * @name decreases
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.decreases = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.decreases, true).to.decrease(obj, prop);
  };
  /**
   * ### .decreasesBy(function, object, property, delta, [message])
   *
   * Asserts that a function decreases a numeric object property or a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val -= 5 };
   *     assert.decreasesBy(fn, obj, 'val', 5);
   *
   * @name decreasesBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.decreasesBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.decreasesBy, true).to.decrease(obj, prop).by(delta);
  };
  /**
   * ### .doesNotDecrease(function, object, property, [message])
   *
   * Asserts that a function does not decreases a numeric object property.
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     assert.doesNotDecrease(fn, obj, 'val');
   *
   * @name doesNotDecrease
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.doesNotDecrease = function (fn, obj, prop, msg) {
    if (arguments.length === 3 && typeof obj === 'function') {
      msg = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotDecrease, true).to.not.decrease(obj, prop);
  };
  /**
   * ### .doesNotDecreaseBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.doesNotDecreaseBy(fn, obj, 'val', 1);
   *
   * @name doesNotDecrease
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.doesNotDecreaseBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    return new Assertion(fn, msg, assert.doesNotDecreaseBy, true).to.not.decrease(obj, prop).by(delta);
  };
  /**
   * ### .decreasesButNotBy(function, object, property, delta, [message])
   *
   * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.decreasesButNotBy(fn, obj, 'val', 1);
   *
   * @name decreasesButNotBy
   * @param {Function} modifier function
   * @param {Object} object or getter function
   * @param {String} property name _optional_
   * @param {Number} change amount (delta)
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.decreasesButNotBy = function (fn, obj, prop, delta, msg) {
    if (arguments.length === 4 && typeof obj === 'function') {
      var tmpMsg = delta;
      delta = prop;
      msg = tmpMsg;
    } else if (arguments.length === 3) {
      delta = prop;
      prop = null;
    }

    new Assertion(fn, msg, assert.decreasesButNotBy, true).to.decrease(obj, prop).but.not.by(delta);
  };
  /*!
   * ### .ifError(object)
   *
   * Asserts if value is not a false value, and throws if it is a true value.
   * This is added to allow for chai to be a drop-in replacement for Node's
   * assert class.
   *
   *     var err = new Error('I am a custom error');
   *     assert.ifError(err); // Rethrows err!
   *
   * @name ifError
   * @param {Object} object
   * @namespace Assert
   * @api public
   */


  assert.ifError = function (val) {
    if (val) {
      throw val;
    }
  };
  /**
   * ### .isExtensible(object)
   *
   * Asserts that `object` is extensible (can have new properties added to it).
   *
   *     assert.isExtensible({});
   *
   * @name isExtensible
   * @alias extensible
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isExtensible = function (obj, msg) {
    new Assertion(obj, msg, assert.isExtensible, true).to.be.extensible;
  };
  /**
   * ### .isNotExtensible(object)
   *
   * Asserts that `object` is _not_ extensible.
   *
   *     var nonExtensibleObject = Object.preventExtensions({});
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     assert.isNotExtensible(nonExtensibleObject);
   *     assert.isNotExtensible(sealedObject);
   *     assert.isNotExtensible(frozenObject);
   *
   * @name isNotExtensible
   * @alias notExtensible
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isNotExtensible = function (obj, msg) {
    new Assertion(obj, msg, assert.isNotExtensible, true).to.not.be.extensible;
  };
  /**
   * ### .isSealed(object)
   *
   * Asserts that `object` is sealed (cannot have new properties added to it
   * and its existing properties cannot be removed).
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.seal({});
   *
   *     assert.isSealed(sealedObject);
   *     assert.isSealed(frozenObject);
   *
   * @name isSealed
   * @alias sealed
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isSealed = function (obj, msg) {
    new Assertion(obj, msg, assert.isSealed, true).to.be.sealed;
  };
  /**
   * ### .isNotSealed(object)
   *
   * Asserts that `object` is _not_ sealed.
   *
   *     assert.isNotSealed({});
   *
   * @name isNotSealed
   * @alias notSealed
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isNotSealed = function (obj, msg) {
    new Assertion(obj, msg, assert.isNotSealed, true).to.not.be.sealed;
  };
  /**
   * ### .isFrozen(object)
   *
   * Asserts that `object` is frozen (cannot have new properties added to it
   * and its existing properties cannot be modified).
   *
   *     var frozenObject = Object.freeze({});
   *     assert.frozen(frozenObject);
   *
   * @name isFrozen
   * @alias frozen
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isFrozen = function (obj, msg) {
    new Assertion(obj, msg, assert.isFrozen, true).to.be.frozen;
  };
  /**
   * ### .isNotFrozen(object)
   *
   * Asserts that `object` is _not_ frozen.
   *
   *     assert.isNotFrozen({});
   *
   * @name isNotFrozen
   * @alias notFrozen
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isNotFrozen = function (obj, msg) {
    new Assertion(obj, msg, assert.isNotFrozen, true).to.not.be.frozen;
  };
  /**
   * ### .isEmpty(target)
   *
   * Asserts that the target does not contain any values.
   * For arrays and strings, it checks the `length` property.
   * For `Map` and `Set` instances, it checks the `size` property.
   * For non-function objects, it gets the count of own
   * enumerable string keys.
   *
   *     assert.isEmpty([]);
   *     assert.isEmpty('');
   *     assert.isEmpty(new Map);
   *     assert.isEmpty({});
   *
   * @name isEmpty
   * @alias empty
   * @param {Object|Array|String|Map|Set} target
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isEmpty = function (val, msg) {
    new Assertion(val, msg, assert.isEmpty, true).to.be.empty;
  };
  /**
   * ### .isNotEmpty(target)
   *
   * Asserts that the target contains values.
   * For arrays and strings, it checks the `length` property.
   * For `Map` and `Set` instances, it checks the `size` property.
   * For non-function objects, it gets the count of own
   * enumerable string keys.
   *
   *     assert.isNotEmpty([1, 2]);
   *     assert.isNotEmpty('34');
   *     assert.isNotEmpty(new Set([5, 6]));
   *     assert.isNotEmpty({ key: 7 });
   *
   * @name isNotEmpty
   * @alias notEmpty
   * @param {Object|Array|String|Map|Set} target
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */


  assert.isNotEmpty = function (val, msg) {
    new Assertion(val, msg, assert.isNotEmpty, true).to.not.be.empty;
  };
  /*!
   * Aliases.
   */


  (function alias(name, as) {
    assert[as] = assert[name];
    return alias;
  })('isOk', 'ok')('isNotOk', 'notOk')('throws', 'throw')('throws', 'Throw')('isExtensible', 'extensible')('isNotExtensible', 'notExtensible')('isSealed', 'sealed')('isNotSealed', 'notSealed')('isFrozen', 'frozen')('isNotFrozen', 'notFrozen')('isEmpty', 'empty')('isNotEmpty', 'notEmpty');
};var chai$1 = createCommonjsModule(function (module, exports) {
  /*!
   * chai
   * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   */
  var used = [];
  /*!
   * Chai version
   */

  exports.version = '4.2.0';
  /*!
   * Assertion Error
   */

  exports.AssertionError = assertionError;
  /*!
   * Utils for plugins (not exported)
   */

  /**
   * # .use(function)
   *
   * Provides a way to extend the internals of Chai.
   *
   * @param {Function}
   * @returns {this} for chaining
   * @api public
   */

  exports.use = function (fn) {
    if (!~used.indexOf(fn)) {
      fn(exports, utils);
      used.push(fn);
    }

    return exports;
  };
  /*!
   * Utility Functions
   */


  exports.util = utils;
  /*!
   * Configuration
   */

  exports.config = config;
  /*!
   * Primary `Assertion` prototype
   */

  exports.use(assertion);
  /*!
   * Core Assertions
   */

  exports.use(assertions);
  /*!
   * Expect interface
   */

  exports.use(expect);
  /*!
   * Should interface
   */

  exports.use(should);
  /*!
   * Assert interface
   */

  exports.use(assert);
});
var chai_1 = chai$1.version;
var chai_2 = chai$1.AssertionError;
var chai_3 = chai$1.use;
var chai_4 = chai$1.util;
var chai_5 = chai$1.config;var chai$2 = chai$1;var chaiDom = createCommonjsModule(function (module, exports) {
  (function (chaiDom) {
    if (typeof commonjsRequire === 'function' && 'object' === 'object' && 'object' === 'object') {
      module.exports = chaiDom;
    } else {
      chai.use(chaiDom);
    }
  })(function (chai, utils) {
    var flag = utils.flag,
        elToString = function (el) {
      var desc;

      if (isNodeList(el)) {
        if (el.length === 0) return 'empty NodeList';
        desc = Array.prototype.slice.call(el, 0, 5).map(elToString).join(', ');
        return el.length > 5 ? desc + '... (+' + (el.length - 5) + ' more)' : desc;
      }

      if (!isHTMLElement(el)) {
        return String(el);
      }

      desc = el.tagName.toLowerCase();

      if (el.id) {
        desc += '#' + el.id;
      }

      if (el.className) {
        desc += '.' + String(el.className).replace(/\s+/g, '.');
      }

      Array.prototype.forEach.call(el.attributes, function (attr) {
        if (attr.name !== 'class' && attr.name !== 'id') {
          desc += '[' + attr.name + (attr.value ? '="' + attr.value + '"]' : ']');
        }
      });
      return desc;
    },
        attrAssert = function (name, val) {
      var el = flag(this, 'object'),
          actual = el.getAttribute(name);

      if (!flag(this, 'negate') || undefined === val) {
        this.assert(!!el.attributes[name], 'expected ' + elToString(el) + ' to have an attribute #{exp}', 'expected ' + elToString(el) + ' not to have an attribute #{exp}', name);
      }

      if (undefined !== val) {
        this.assert(val === actual, 'expected ' + elToString(el) + ' to have an attribute ' + utils.inspect(name) + ' with the value #{exp}, but the value was #{act}', 'expected ' + elToString(el) + ' not to have an attribute ' + utils.inspect(name) + ' with the value #{act}', val, actual);
      }

      flag(this, 'object', actual);
    },
        isHTMLElement = function (el) {
      return el.nodeType === 1; // window.Node.ELEMENT_NODE
    },
        isNodeList = function (obj) {
      return Object.prototype.toString.call(obj) === '[object NodeList]';
    };

    utils.elToString = elToString;
    chai.Assertion.addMethod('attr', attrAssert);
    chai.Assertion.addMethod('attribute', attrAssert);
    chai.Assertion.addMethod('class', function (className) {
      var el = flag(this, 'object');
      this.assert(el.classList.contains(className), 'expected ' + elToString(el) + ' to have class #{exp}', 'expected ' + elToString(el) + ' not to have class #{exp}', className);
    });
    chai.Assertion.addMethod('id', function (id) {
      var el = flag(this, 'object');
      this.assert(el.id == id, 'expected ' + elToString(el) + ' to have id #{exp}', 'expected ' + elToString(el) + ' not to have id #{exp}', id);
    });
    chai.Assertion.addMethod('html', function (html) {
      var el = flag(this, 'object'),
          actual = flag(this, 'object').innerHTML;

      if (flag(this, 'contains')) {
        this.assert(actual.indexOf(html) >= 0, 'expected #{act} to contain HTML #{exp}', 'expected #{act} not to contain HTML #{exp}', html, actual);
      } else {
        this.assert(actual === html, 'expected ' + elToString(el) + ' to have HTML #{exp}, but the HTML was #{act}', 'expected ' + elToString(el) + ' not to have HTML #{exp}', html, actual);
      }
    });
    chai.Assertion.addChainableMethod('trimmed', null, function () {
      flag(this, 'trim-text', true);
    });
    chai.Assertion.addMethod('text', function (text) {
      var obj = flag(this, 'object'),
          contains = flag(this, 'contains'),
          trim = flag(this, 'trim-text'),
          actual,
          result;

      if (isNodeList(obj)) {
        actual = Array.prototype.map.call(obj, function (el) {
          return trim ? el.textContent.trim() : el.textContent;
        });

        if (Array.isArray(text)) {
          result = contains ? text[flag(this, 'negate') ? 'some' : 'every'](function (t) {
            return Array.prototype.some.call(obj, function (el) {
              return (trim ? el.textContent.trim() : el.textContent) === t;
            });
          }) : utils.eql(actual, text);
          actual = actual.join();
          text = text.join();
        } else {
          actual = actual.join('');
          result = contains ? actual.indexOf(text) >= 0 : actual === text;
        }
      } else {
        actual = trim ? obj.textContent.trim() : obj.textContent;
        result = contains ? actual.indexOf(text) >= 0 : actual === text;
      }

      var objDesc = elToString(obj),
          textMsg = trim ? 'trimmed text' : 'text';

      if (contains) {
        this.assert(result, 'expected ' + objDesc + ' to contain #{exp}, but the ' + textMsg + ' was #{act}', 'expected ' + objDesc + ' not to contain #{exp}, but the ' + textMsg + ' was #{act}', text, actual);
      } else {
        this.assert(result, 'expected ' + objDesc + ' to have ' + textMsg + ' #{exp}, but the ' + textMsg + ' was #{act}', 'expected ' + objDesc + ' not to have ' + textMsg + ' #{exp}', text, actual);
      }
    });
    chai.Assertion.addMethod('value', function (value) {
      var el = flag(this, 'object'),
          actual = flag(this, 'object').value;
      this.assert(flag(this, 'object').value === value, 'expected ' + elToString(el) + ' to have value #{exp}, but the value was #{act}', 'expected ' + elToString(el) + ' not to have value #{exp}', value, actual);
    });
    chai.Assertion.overwriteProperty('exist', function (_super) {
      return function () {
        var obj = flag(this, 'object');

        if (isNodeList(obj)) {
          this.assert(obj.length > 0, 'expected an empty NodeList to have nodes', 'expected ' + elToString(obj) + ' to not exist');
        } else {
          _super.apply(this, arguments);
        }
      };
    });
    chai.Assertion.overwriteProperty('empty', function (_super) {
      return function () {
        var obj = flag(this, 'object');

        if (isHTMLElement(obj)) {
          this.assert(obj.children.length === 0, 'expected ' + elToString(obj) + ' to be empty', 'expected ' + elToString(obj) + ' to not be empty');
        } else if (isNodeList(obj)) {
          this.assert(obj.length === 0, 'expected ' + elToString(obj) + ' to be empty', 'expected ' + elToString(obj) + ' to not be empty');
        } else {
          _super.apply(this, arguments);
        }
      };
    });
    chai.Assertion.overwriteChainableMethod('length', function (_super) {
      return function (length) {
        var obj = flag(this, 'object');

        if (isNodeList(obj) || isHTMLElement(obj)) {
          var actualLength = obj.children ? obj.children.length : obj.length;
          this.assert(actualLength === length, 'expected ' + elToString(obj) + ' to have #{exp} children but it had #{act} children', 'expected ' + elToString(obj) + ' to not have #{exp} children', length, actualLength);
        } else {
          _super.apply(this, arguments);
        }
      };
    }, function (_super) {
      return function () {
        _super.call(this);
      };
    });
    chai.Assertion.overwriteMethod('match', function (_super) {
      return function (selector) {
        var obj = flag(this, 'object');

        if (isHTMLElement(obj)) {
          this.assert(obj.matches(selector), 'expected ' + elToString(obj) + ' to match #{exp}', 'expected ' + elToString(obj) + ' to not match #{exp}', selector);
        } else if (isNodeList(obj)) {
          this.assert(!!obj.length && Array.prototype.every.call(obj, function (el) {
            return el.matches(selector);
          }), 'expected ' + elToString(obj) + ' to match #{exp}', 'expected ' + elToString(obj) + ' to not match #{exp}', selector);
        } else {
          _super.apply(this, arguments);
        }
      };
    });
    chai.Assertion.overwriteChainableMethod('contain', function (_super) {
      return function (subitem) {
        var obj = flag(this, 'object');

        if (isHTMLElement(obj)) {
          if (typeof subitem === 'string') {
            this.assert(!!obj.querySelector(subitem), 'expected ' + elToString(obj) + ' to contain #{exp}', 'expected ' + elToString(obj) + ' to not contain #{exp}', subitem);
          } else {
            this.assert(obj.contains(subitem), 'expected ' + elToString(obj) + ' to contain ' + elToString(subitem), 'expected ' + elToString(obj) + ' to not contain ' + elToString(subitem));
          }
        } else {
          _super.apply(this, arguments);
        }
      };
    }, function (_super) {
      return function () {
        _super.call(this);
      };
    });
    chai.Assertion.addMethod('descendant', function (subitem) {
      var obj = flag(this, 'object'),
          actual = subitem;

      if (typeof subitem === 'string') {
        actual = obj.querySelector(subitem);
        this.assert(!!actual, 'expected ' + elToString(obj) + ' to have descendant #{exp}', 'expected ' + elToString(obj) + ' to not have descendant #{exp}', subitem);
      } else {
        this.assert(obj.contains(subitem), 'expected ' + elToString(obj) + ' to contain ' + elToString(subitem), 'expected ' + elToString(obj) + ' to not contain ' + elToString(subitem));
      }

      flag(this, 'object', actual);
    });
    chai.Assertion.addMethod('descendants', function (selector) {
      var obj = flag(this, 'object'),
          actual = obj.querySelectorAll(selector);
      this.assert(!!actual.length, 'expected ' + elToString(obj) + ' to have descendants #{exp}', 'expected ' + elToString(obj) + ' to not have descendants #{exp}', selector);
      flag(this, 'object', actual);
    });
    chai.Assertion.addProperty('displayed', function () {
      var el = flag(this, 'object'),
          actual = document.body.contains(el) ? window.getComputedStyle(el).display : el.style.display;
      this.assert(actual !== 'none', 'expected ' + elToString(el) + ' to be displayed, but it was not', 'expected ' + elToString(el) + ' to not be displayed, but it was as ' + actual, actual);
    });
    chai.Assertion.addProperty('visible', function () {
      var el = flag(this, 'object'),
          actual = document.body.contains(el) ? window.getComputedStyle(el).visibility : el.style.visibility;
      this.assert(actual !== 'hidden' && actual !== 'collapse', 'expected ' + elToString(el) + ' to be visible, but it was ' + (actual === 'hidden' ? 'hidden' : 'collapsed'), 'expected ' + elToString(el) + ' to not be visible, but it was', actual);
    });
  });
});var sources = chaiStyle;

function chaiStyle(chai, utils) {
  const {
    Assertion
  } = chai;
  const {
    flag
  } = utils;
  Assertion.addMethod('style', function (property, value = '') {
    const element = flag(this, 'object');
    const style = window.getComputedStyle(element);
    value = value.trim();
    const isNonColors = style[property] === 'rgba(0, 0, 0, 0)' // webkit
    || style[property] === 'transparent'; // firefox

    const propertyValue = isNonColors ? '' : style[property];
    const assertion = value ? compareCSSValue(propertyValue, value) : Boolean(propertyValue);
    const elementTag = element.tagName.toLowerCase();
    const throwMessage = `expect ${elementTag} to have {${property}: ${value}}, is receiving {${property}: ${propertyValue}}`;
    const throwMessageNegative = `expect ${elementTag} to not have {${property}: ${value}}, is receiving {${property}: ${propertyValue}}`;
    this.assert(assertion, throwMessage, throwMessageNegative, value);

    function compareCSSValue(computed, expected) {
      const propertyHifenCase = property.replace(/[A-Z]/g, match => '-' + match.toLowerCase());
      const fake = document.createElement('div');
      fake.style.fontSize = style.fontSize;
      fake.style.setProperty(propertyHifenCase, expected, 'important');
      const iframe = document.createElement('iframe');
      iframe.style.visibility = 'hidden';
      document.body.appendChild(iframe);
      iframe.appendChild(fake);
      const fakeStyle = window.getComputedStyle(fake);
      const value = fakeStyle[property];
      const hasAutoValue = value.includes('auto');
      const reg = new RegExp(escapeRegExp(value).replace(/auto/g, '(\\d+(.\\d+)?px|auto)'));
      const comparisonResult = hasAutoValue ? reg.test(computed) : computed === value;
      document.body.removeChild(iframe);
      return comparisonResult;
    }
  });
} // https://github.com/benjamingr/RegExp.escape/blob/master/polyfill.js


function escapeRegExp(value) {
  return String(value).replace(/[\\^$*+?.()|[\]{}]/g, '\\$&');
}var typeDetect$1 = createCommonjsModule(function (module) {
  /* !
   * type-detect
   * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
   * MIT Licensed
   */

  var getPrototypeOfExists = typeof Object.getPrototypeOf === 'function';
  var promiseExists = typeof Promise === 'function';
  var globalObject = typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : self; // eslint-disable-line

  var isDom = 'location' in globalObject && 'document' in globalObject;
  var htmlElementExists = typeof HTMLElement !== 'undefined';
  var isArrayExists = typeof Array.isArray === 'function';
  var symbolExists = typeof Symbol !== 'undefined';
  var mapExists = typeof Map !== 'undefined';
  var setExists = typeof Set !== 'undefined';
  var weakMapExists = typeof WeakMap !== 'undefined';
  var weakSetExists = typeof WeakSet !== 'undefined';
  var dataViewExists = typeof DataView !== 'undefined';
  var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== 'undefined';
  var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== 'undefined';
  var setEntriesExists = setExists && typeof Set.prototype.entries === 'function';
  var mapEntriesExists = mapExists && typeof Map.prototype.entries === 'function';
  var setIteratorPrototype = getPrototypeOfExists && setEntriesExists && Object.getPrototypeOf(new Set().entries());
  var mapIteratorPrototype = getPrototypeOfExists && mapEntriesExists && Object.getPrototypeOf(new Map().entries());
  var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';
  var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());
  var stringIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';
  var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]());
  var toStringLeftSliceLength = 8;
  var toStringRightSliceLength = -1;
  /**
   * ### typeOf (obj)
   *
   * Uses `Object.prototype.toString` to determine the type of an object,
   * normalising behaviour across engine versions & well optimised.
   *
   * @param {Mixed} object
   * @return {String} object type
   * @api public
   */

  module.exports = function typeDetect(obj) {
    /* ! Speed optimisation
     * Pre:
     *   string literal     x 3,039,035 ops/sec ±1.62% (78 runs sampled)
     *   boolean literal    x 1,424,138 ops/sec ±4.54% (75 runs sampled)
     *   number literal     x 1,653,153 ops/sec ±1.91% (82 runs sampled)
     *   undefined          x 9,978,660 ops/sec ±1.92% (75 runs sampled)
     *   function           x 2,556,769 ops/sec ±1.73% (77 runs sampled)
     * Post:
     *   string literal     x 38,564,796 ops/sec ±1.15% (79 runs sampled)
     *   boolean literal    x 31,148,940 ops/sec ±1.10% (79 runs sampled)
     *   number literal     x 32,679,330 ops/sec ±1.90% (78 runs sampled)
     *   undefined          x 32,363,368 ops/sec ±1.07% (82 runs sampled)
     *   function           x 31,296,870 ops/sec ±0.96% (83 runs sampled)
     */
    var typeofObj = typeof obj;

    if (typeofObj !== 'object') {
      return typeofObj;
    }
    /* ! Speed optimisation
     * Pre:
     *   null               x 28,645,765 ops/sec ±1.17% (82 runs sampled)
     * Post:
     *   null               x 36,428,962 ops/sec ±1.37% (84 runs sampled)
     */


    if (obj === null) {
      return 'null';
    }
    /* ! Spec Conformance
     * Test: `Object.prototype.toString.call(window)``
     *  - Node === "[object global]"
     *  - Chrome === "[object global]"
     *  - Firefox === "[object Window]"
     *  - PhantomJS === "[object Window]"
     *  - Safari === "[object Window]"
     *  - IE 11 === "[object Window]"
     *  - IE Edge === "[object Window]"
     * Test: `Object.prototype.toString.call(this)``
     *  - Chrome Worker === "[object global]"
     *  - Firefox Worker === "[object DedicatedWorkerGlobalScope]"
     *  - Safari Worker === "[object DedicatedWorkerGlobalScope]"
     *  - IE 11 Worker === "[object WorkerGlobalScope]"
     *  - IE Edge Worker === "[object WorkerGlobalScope]"
     */


    if (obj === globalObject) {
      return 'global';
    }
    /* ! Speed optimisation
     * Pre:
     *   array literal      x 2,888,352 ops/sec ±0.67% (82 runs sampled)
     * Post:
     *   array literal      x 22,479,650 ops/sec ±0.96% (81 runs sampled)
     */


    if (isArrayExists && Array.isArray(obj)) {
      return 'Array';
    }

    if (isDom) {
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/browsers.html#location)
       * WhatWG HTML$7.7.3 - The `Location` interface
       * Test: `Object.prototype.toString.call(window.location)``
       *  - IE <=11 === "[object Object]"
       *  - IE Edge <=13 === "[object Object]"
       */
      if (obj === globalObject.location) {
        return 'Location';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/#document)
       * WhatWG HTML$3.1.1 - The `Document` object
       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)
       *       which suggests that browsers should use HTMLTableCellElement for
       *       both TD and TH elements. WhatWG separates these.
       *       WhatWG HTML states:
       *         > For historical reasons, Window objects must also have a
       *         > writable, configurable, non-enumerable property named
       *         > HTMLDocument whose value is the Document interface object.
       * Test: `Object.prototype.toString.call(document)``
       *  - Chrome === "[object HTMLDocument]"
       *  - Firefox === "[object HTMLDocument]"
       *  - Safari === "[object HTMLDocument]"
       *  - IE <=10 === "[object Document]"
       *  - IE 11 === "[object HTMLDocument]"
       *  - IE Edge <=13 === "[object HTMLDocument]"
       */


      if (obj === globalObject.document) {
        return 'Document';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)
       * WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray
       * Test: `Object.prototype.toString.call(navigator.mimeTypes)``
       *  - IE <=10 === "[object MSMimeTypesCollection]"
       */


      if (obj === (globalObject.navigator || {}).mimeTypes) {
        return 'MimeTypeArray';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
       * WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray
       * Test: `Object.prototype.toString.call(navigator.plugins)``
       *  - IE <=10 === "[object MSPluginsCollection]"
       */


      if (obj === (globalObject.navigator || {}).plugins) {
        return 'PluginArray';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)
       * WhatWG HTML$4.4.4 - The `blockquote` element - Interface `HTMLQuoteElement`
       * Test: `Object.prototype.toString.call(document.createElement('blockquote'))``
       *  - IE <=10 === "[object HTMLBlockElement]"
       */


      if (htmlElementExists && obj instanceof HTMLElement && obj.tagName === 'BLOCKQUOTE') {
        return 'HTMLQuoteElement';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/#htmltabledatacellelement)
       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableDataCellElement`
       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
       *       which suggests that browsers should use HTMLTableCellElement for
       *       both TD and TH elements. WhatWG separates these.
       * Test: Object.prototype.toString.call(document.createElement('td'))
       *  - Chrome === "[object HTMLTableCellElement]"
       *  - Firefox === "[object HTMLTableCellElement]"
       *  - Safari === "[object HTMLTableCellElement]"
       */


      if (htmlElementExists && obj instanceof HTMLElement && obj.tagName === 'TD') {
        return 'HTMLTableDataCellElement';
      }
      /* ! Spec Conformance
       * (https://html.spec.whatwg.org/#htmltableheadercellelement)
       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableHeaderCellElement`
       * Note: Most browsers currently adher to the W3C DOM Level 2 spec
       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)
       *       which suggests that browsers should use HTMLTableCellElement for
       *       both TD and TH elements. WhatWG separates these.
       * Test: Object.prototype.toString.call(document.createElement('th'))
       *  - Chrome === "[object HTMLTableCellElement]"
       *  - Firefox === "[object HTMLTableCellElement]"
       *  - Safari === "[object HTMLTableCellElement]"
       */


      if (htmlElementExists && obj instanceof HTMLElement && obj.tagName === 'TH') {
        return 'HTMLTableHeaderCellElement';
      }
    }
    /* ! Speed optimisation
    * Pre:
    *   Float64Array       x 625,644 ops/sec ±1.58% (80 runs sampled)
    *   Float32Array       x 1,279,852 ops/sec ±2.91% (77 runs sampled)
    *   Uint32Array        x 1,178,185 ops/sec ±1.95% (83 runs sampled)
    *   Uint16Array        x 1,008,380 ops/sec ±2.25% (80 runs sampled)
    *   Uint8Array         x 1,128,040 ops/sec ±2.11% (81 runs sampled)
    *   Int32Array         x 1,170,119 ops/sec ±2.88% (80 runs sampled)
    *   Int16Array         x 1,176,348 ops/sec ±5.79% (86 runs sampled)
    *   Int8Array          x 1,058,707 ops/sec ±4.94% (77 runs sampled)
    *   Uint8ClampedArray  x 1,110,633 ops/sec ±4.20% (80 runs sampled)
    * Post:
    *   Float64Array       x 7,105,671 ops/sec ±13.47% (64 runs sampled)
    *   Float32Array       x 5,887,912 ops/sec ±1.46% (82 runs sampled)
    *   Uint32Array        x 6,491,661 ops/sec ±1.76% (79 runs sampled)
    *   Uint16Array        x 6,559,795 ops/sec ±1.67% (82 runs sampled)
    *   Uint8Array         x 6,463,966 ops/sec ±1.43% (85 runs sampled)
    *   Int32Array         x 5,641,841 ops/sec ±3.49% (81 runs sampled)
    *   Int16Array         x 6,583,511 ops/sec ±1.98% (80 runs sampled)
    *   Int8Array          x 6,606,078 ops/sec ±1.74% (81 runs sampled)
    *   Uint8ClampedArray  x 6,602,224 ops/sec ±1.77% (83 runs sampled)
    */


    var stringTag = symbolToStringTagExists && obj[Symbol.toStringTag];

    if (typeof stringTag === 'string') {
      return stringTag;
    }

    if (getPrototypeOfExists) {
      var objPrototype = Object.getPrototypeOf(obj);
      /* ! Speed optimisation
      * Pre:
      *   regex literal      x 1,772,385 ops/sec ±1.85% (77 runs sampled)
      *   regex constructor  x 2,143,634 ops/sec ±2.46% (78 runs sampled)
      * Post:
      *   regex literal      x 3,928,009 ops/sec ±0.65% (78 runs sampled)
      *   regex constructor  x 3,931,108 ops/sec ±0.58% (84 runs sampled)
      */

      if (objPrototype === RegExp.prototype) {
        return 'RegExp';
      }
      /* ! Speed optimisation
      * Pre:
      *   date               x 2,130,074 ops/sec ±4.42% (68 runs sampled)
      * Post:
      *   date               x 3,953,779 ops/sec ±1.35% (77 runs sampled)
      */


      if (objPrototype === Date.prototype) {
        return 'Date';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)
       * ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be "Promise":
       * Test: `Object.prototype.toString.call(Promise.resolve())``
       *  - Chrome <=47 === "[object Object]"
       *  - Edge <=20 === "[object Object]"
       *  - Firefox 29-Latest === "[object Promise]"
       *  - Safari 7.1-Latest === "[object Promise]"
       */


      if (promiseExists && objPrototype === Promise.prototype) {
        return 'Promise';
      }
      /* ! Speed optimisation
      * Pre:
      *   set                x 2,222,186 ops/sec ±1.31% (82 runs sampled)
      * Post:
      *   set                x 4,545,879 ops/sec ±1.13% (83 runs sampled)
      */


      if (setExists && objPrototype === Set.prototype) {
        return 'Set';
      }
      /* ! Speed optimisation
      * Pre:
      *   map                x 2,396,842 ops/sec ±1.59% (81 runs sampled)
      * Post:
      *   map                x 4,183,945 ops/sec ±6.59% (82 runs sampled)
      */


      if (mapExists && objPrototype === Map.prototype) {
        return 'Map';
      }
      /* ! Speed optimisation
      * Pre:
      *   weakset            x 1,323,220 ops/sec ±2.17% (76 runs sampled)
      * Post:
      *   weakset            x 4,237,510 ops/sec ±2.01% (77 runs sampled)
      */


      if (weakSetExists && objPrototype === WeakSet.prototype) {
        return 'WeakSet';
      }
      /* ! Speed optimisation
      * Pre:
      *   weakmap            x 1,500,260 ops/sec ±2.02% (78 runs sampled)
      * Post:
      *   weakmap            x 3,881,384 ops/sec ±1.45% (82 runs sampled)
      */


      if (weakMapExists && objPrototype === WeakMap.prototype) {
        return 'WeakMap';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)
       * ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be "DataView":
       * Test: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))``
       *  - Edge <=13 === "[object Object]"
       */


      if (dataViewExists && objPrototype === DataView.prototype) {
        return 'DataView';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)
       * ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be "Map Iterator":
       * Test: `Object.prototype.toString.call(new Map().entries())``
       *  - Edge <=13 === "[object Object]"
       */


      if (mapExists && objPrototype === mapIteratorPrototype) {
        return 'Map Iterator';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)
       * ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be "Set Iterator":
       * Test: `Object.prototype.toString.call(new Set().entries())``
       *  - Edge <=13 === "[object Object]"
       */


      if (setExists && objPrototype === setIteratorPrototype) {
        return 'Set Iterator';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)
       * ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be "Array Iterator":
       * Test: `Object.prototype.toString.call([][Symbol.iterator]())``
       *  - Edge <=13 === "[object Object]"
       */


      if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {
        return 'Array Iterator';
      }
      /* ! Spec Conformance
       * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)
       * ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be "String Iterator":
       * Test: `Object.prototype.toString.call(''[Symbol.iterator]())``
       *  - Edge <=13 === "[object Object]"
       */


      if (stringIteratorExists && objPrototype === stringIteratorPrototype) {
        return 'String Iterator';
      }
      /* ! Speed optimisation
      * Pre:
      *   object from null   x 2,424,320 ops/sec ±1.67% (76 runs sampled)
      * Post:
      *   object from null   x 5,838,000 ops/sec ±0.99% (84 runs sampled)
      */


      if (objPrototype === null) {
        return 'Object';
      }
    }

    return Object.prototype.toString.call(obj).slice(toStringLeftSliceLength, toStringRightSliceLength);
  };

  module.exports.typeDetect = module.exports;
});
var typeDetect_1 = typeDetect$1.typeDetect;/* globals Symbol: true, Uint8Array: true, WeakMap: true */

/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */


function FakeMap$1() {
  this.clear();
}

FakeMap$1.prototype = {
  clear: function clearMap() {
    this.keys = [];
    this.values = [];
    return this;
  },
  set: function setMap(key, value) {
    var index = this.keys.indexOf(key);

    if (index >= 0) {
      this.values[index] = value;
    } else {
      this.keys.push(key);
      this.values.push(value);
    }

    return this;
  },
  get: function getMap(key) {
    return this.values[this.keys.indexOf(key)];
  },
  delete: function deleteMap(key) {
    var index = this.keys.indexOf(key);

    if (index >= 0) {
      this.values = this.values.slice(0, index).concat(this.values.slice(index + 1));
      this.keys = this.keys.slice(0, index).concat(this.keys.slice(index + 1));
    }

    return this;
  }
};
var MemoizeMap$1 = null;

if (typeof WeakMap === 'function') {
  MemoizeMap$1 = WeakMap;
} else {
  MemoizeMap$1 = FakeMap$1;
}
/*!
 * Check to see if the MemoizeMap has recorded a result of the two operands
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @returns {Boolean|null} result
*/


function memoizeCompare$1(leftHandOperand, rightHandOperand, memoizeMap) {
  // Technically, WeakMap keys can *only* be objects, not primitives.
  if (!memoizeMap || isPrimitive$1(leftHandOperand) || isPrimitive$1(rightHandOperand)) {
    return null;
  }

  var leftHandMap = memoizeMap.get(leftHandOperand);

  if (leftHandMap) {
    var result = leftHandMap.get(rightHandOperand);

    if (typeof result === 'boolean') {
      return result;
    }
  }

  return null;
}
/*!
 * Set the result of the equality into the MemoizeMap
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @param {Boolean} result
*/


function memoizeSet$1(leftHandOperand, rightHandOperand, memoizeMap, result) {
  // Technically, WeakMap keys can *only* be objects, not primitives.
  if (!memoizeMap || isPrimitive$1(leftHandOperand) || isPrimitive$1(rightHandOperand)) {
    return;
  }

  var leftHandMap = memoizeMap.get(leftHandOperand);

  if (leftHandMap) {
    leftHandMap.set(rightHandOperand, result);
  } else {
    leftHandMap = new MemoizeMap$1();
    leftHandMap.set(rightHandOperand, result);
    memoizeMap.set(leftHandOperand, leftHandMap);
  }
}
/*!
 * Primary Export
 */


var deepEql$1 = deepEqual$1;
var MemoizeMap_1$1 = MemoizeMap$1;
/**
 * Assert deeply nested sameValue equality between two objects of any type.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
 */

function deepEqual$1(leftHandOperand, rightHandOperand, options) {
  // If we have a comparator, we can't assume anything; so bail to its check first.
  if (options && options.comparator) {
    return extensiveDeepEqual$1(leftHandOperand, rightHandOperand, options);
  }

  var simpleResult = simpleEqual$1(leftHandOperand, rightHandOperand);

  if (simpleResult !== null) {
    return simpleResult;
  } // Deeper comparisons are pushed through to a larger function


  return extensiveDeepEqual$1(leftHandOperand, rightHandOperand, options);
}
/**
 * Many comparisons can be canceled out early via simple equality or primitive checks.
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @return {Boolean|null} equal match
 */


function simpleEqual$1(leftHandOperand, rightHandOperand) {
  // Equal references (except for Numbers) can be returned early
  if (leftHandOperand === rightHandOperand) {
    // Handle +-0 cases
    return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand;
  } // handle NaN cases


  if (leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare
  rightHandOperand !== rightHandOperand // eslint-disable-line no-self-compare
  ) {
      return true;
    } // Anything that is not an 'object', i.e. symbols, functions, booleans, numbers,
  // strings, and undefined, can be compared by reference.


  if (isPrimitive$1(leftHandOperand) || isPrimitive$1(rightHandOperand)) {
    // Easy out b/c it would have passed the first equality check
    return false;
  }

  return null;
}
/*!
 * The main logic of the `deepEqual` function.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
*/


function extensiveDeepEqual$1(leftHandOperand, rightHandOperand, options) {
  options = options || {};
  options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap$1();
  var comparator = options && options.comparator; // Check if a memoized result exists.

  var memoizeResultLeft = memoizeCompare$1(leftHandOperand, rightHandOperand, options.memoize);

  if (memoizeResultLeft !== null) {
    return memoizeResultLeft;
  }

  var memoizeResultRight = memoizeCompare$1(rightHandOperand, leftHandOperand, options.memoize);

  if (memoizeResultRight !== null) {
    return memoizeResultRight;
  } // If a comparator is present, use it.


  if (comparator) {
    var comparatorResult = comparator(leftHandOperand, rightHandOperand); // Comparators may return null, in which case we want to go back to default behavior.

    if (comparatorResult === false || comparatorResult === true) {
      memoizeSet$1(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);
      return comparatorResult;
    } // To allow comparators to override *any* behavior, we ran them first. Since it didn't decide
    // what to do, we need to make sure to return the basic tests first before we move on.


    var simpleResult = simpleEqual$1(leftHandOperand, rightHandOperand);

    if (simpleResult !== null) {
      // Don't memoize this, it takes longer to set/retrieve than to just compare.
      return simpleResult;
    }
  }

  var leftHandType = typeDetect$1(leftHandOperand);

  if (leftHandType !== typeDetect$1(rightHandOperand)) {
    memoizeSet$1(leftHandOperand, rightHandOperand, options.memoize, false);
    return false;
  } // Temporarily set the operands in the memoize object to prevent blowing the stack


  memoizeSet$1(leftHandOperand, rightHandOperand, options.memoize, true);
  var result = extensiveDeepEqualByType$1(leftHandOperand, rightHandOperand, leftHandType, options);
  memoizeSet$1(leftHandOperand, rightHandOperand, options.memoize, result);
  return result;
}

function extensiveDeepEqualByType$1(leftHandOperand, rightHandOperand, leftHandType, options) {
  switch (leftHandType) {
    case 'String':
    case 'Number':
    case 'Boolean':
    case 'Date':
      // If these types are their instance types (e.g. `new Number`) then re-deepEqual against their values
      return deepEqual$1(leftHandOperand.valueOf(), rightHandOperand.valueOf());

    case 'Promise':
    case 'Symbol':
    case 'function':
    case 'WeakMap':
    case 'WeakSet':
    case 'Error':
      return leftHandOperand === rightHandOperand;

    case 'Arguments':
    case 'Int8Array':
    case 'Uint8Array':
    case 'Uint8ClampedArray':
    case 'Int16Array':
    case 'Uint16Array':
    case 'Int32Array':
    case 'Uint32Array':
    case 'Float32Array':
    case 'Float64Array':
    case 'Array':
      return iterableEqual$1(leftHandOperand, rightHandOperand, options);

    case 'RegExp':
      return regexpEqual$1(leftHandOperand, rightHandOperand);

    case 'Generator':
      return generatorEqual$1(leftHandOperand, rightHandOperand, options);

    case 'DataView':
      return iterableEqual$1(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);

    case 'ArrayBuffer':
      return iterableEqual$1(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);

    case 'Set':
      return entriesEqual$1(leftHandOperand, rightHandOperand, options);

    case 'Map':
      return entriesEqual$1(leftHandOperand, rightHandOperand, options);

    default:
      return objectEqual$1(leftHandOperand, rightHandOperand, options);
  }
}
/*!
 * Compare two Regular Expressions for equality.
 *
 * @param {RegExp} leftHandOperand
 * @param {RegExp} rightHandOperand
 * @return {Boolean} result
 */


function regexpEqual$1(leftHandOperand, rightHandOperand) {
  return leftHandOperand.toString() === rightHandOperand.toString();
}
/*!
 * Compare two Sets/Maps for equality. Faster than other equality functions.
 *
 * @param {Set} leftHandOperand
 * @param {Set} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function entriesEqual$1(leftHandOperand, rightHandOperand, options) {
  // IE11 doesn't support Set#entries or Set#@@iterator, so we need manually populate using Set#forEach
  if (leftHandOperand.size !== rightHandOperand.size) {
    return false;
  }

  if (leftHandOperand.size === 0) {
    return true;
  }

  var leftHandItems = [];
  var rightHandItems = [];
  leftHandOperand.forEach(function gatherEntries(key, value) {
    leftHandItems.push([key, value]);
  });
  rightHandOperand.forEach(function gatherEntries(key, value) {
    rightHandItems.push([key, value]);
  });
  return iterableEqual$1(leftHandItems.sort(), rightHandItems.sort(), options);
}
/*!
 * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function iterableEqual$1(leftHandOperand, rightHandOperand, options) {
  var length = leftHandOperand.length;

  if (length !== rightHandOperand.length) {
    return false;
  }

  if (length === 0) {
    return true;
  }

  var index = -1;

  while (++index < length) {
    if (deepEqual$1(leftHandOperand[index], rightHandOperand[index], options) === false) {
      return false;
    }
  }

  return true;
}
/*!
 * Simple equality for generator objects such as those returned by generator functions.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function generatorEqual$1(leftHandOperand, rightHandOperand, options) {
  return iterableEqual$1(getGeneratorEntries$1(leftHandOperand), getGeneratorEntries$1(rightHandOperand), options);
}
/*!
 * Determine if the given object has an @@iterator function.
 *
 * @param {Object} target
 * @return {Boolean} `true` if the object has an @@iterator function.
 */


function hasIteratorFunction$1(target) {
  return typeof Symbol !== 'undefined' && typeof target === 'object' && typeof Symbol.iterator !== 'undefined' && typeof target[Symbol.iterator] === 'function';
}
/*!
 * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
 * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
 *
 * @param {Object} target
 * @returns {Array} an array of entries from the @@iterator function
 */


function getIteratorEntries$1(target) {
  if (hasIteratorFunction$1(target)) {
    try {
      return getGeneratorEntries$1(target[Symbol.iterator]());
    } catch (iteratorError) {
      return [];
    }
  }

  return [];
}
/*!
 * Gets all entries from a Generator. This will consume the generator - which could have side effects.
 *
 * @param {Generator} target
 * @returns {Array} an array of entries from the Generator.
 */


function getGeneratorEntries$1(generator) {
  var generatorResult = generator.next();
  var accumulator = [generatorResult.value];

  while (generatorResult.done === false) {
    generatorResult = generator.next();
    accumulator.push(generatorResult.value);
  }

  return accumulator;
}
/*!
 * Gets all own and inherited enumerable keys from a target.
 *
 * @param {Object} target
 * @returns {Array} an array of own and inherited enumerable keys from the target.
 */


function getEnumerableKeys$1(target) {
  var keys = [];

  for (var key in target) {
    keys.push(key);
  }

  return keys;
}
/*!
 * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
 * each key. If any value of the given key is not equal, the function will return false (early).
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function keysEqual$1(leftHandOperand, rightHandOperand, keys, options) {
  var length = keys.length;

  if (length === 0) {
    return true;
  }

  for (var i = 0; i < length; i += 1) {
    if (deepEqual$1(leftHandOperand[keys[i]], rightHandOperand[keys[i]], options) === false) {
      return false;
    }
  }

  return true;
}
/*!
 * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
 * for each enumerable key in the object.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */


function objectEqual$1(leftHandOperand, rightHandOperand, options) {
  var leftHandKeys = getEnumerableKeys$1(leftHandOperand);
  var rightHandKeys = getEnumerableKeys$1(rightHandOperand);

  if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {
    leftHandKeys.sort();
    rightHandKeys.sort();

    if (iterableEqual$1(leftHandKeys, rightHandKeys) === false) {
      return false;
    }

    return keysEqual$1(leftHandOperand, rightHandOperand, leftHandKeys, options);
  }

  var leftHandEntries = getIteratorEntries$1(leftHandOperand);
  var rightHandEntries = getIteratorEntries$1(rightHandOperand);

  if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {
    leftHandEntries.sort();
    rightHandEntries.sort();
    return iterableEqual$1(leftHandEntries, rightHandEntries, options);
  }

  if (leftHandKeys.length === 0 && leftHandEntries.length === 0 && rightHandKeys.length === 0 && rightHandEntries.length === 0) {
    return true;
  }

  return false;
}
/*!
 * Returns true if the argument is a primitive.
 *
 * This intentionally returns true for all objects that can be compared by reference,
 * including functions and symbols.
 *
 * @param {Mixed} value
 * @return {Boolean} result
 */


function isPrimitive$1(value) {
  return value === null || typeof value !== 'object';
}
deepEql$1.MemoizeMap = MemoizeMap_1$1;var DEFAULT_TOLERANCE = 1e-6;
/**
 * small utility functions
 */

function isNumber(val) {
  return typeDetect(val) === 'number';
}

function bothNumbers(left, right) {
  return isNumber(right) && isNumber(left);
}

function almostEqual(left, right, tol) {
  return Math.abs(left - right) <= tol;
}
/**
 * Makes a comparator function to be passed to deepEqual.
 * The returned function will return null if both arguments are not numbers,
 * indicating that deepEqual should proceed with other equality checks
 */


function comparator(tolerance) {
  return function (left, right) {
    if (bothNumbers(left, right)) {
      return almostEqual(left, right, tolerance);
    }

    return null;
  };
}
/**
 * Sets global tolerance and returns a function to be passed to chai.use
 * @see http://chaijs.com/guide/plugins/
 */


function chaiAlmost(customTolerance) {
  var standardTolerance = customTolerance || DEFAULT_TOLERANCE;
  return function (chai, utils) {
    var Assertion = chai.Assertion;
    var flag = utils.flag;
    /**
     * Returns a new shallow equality function to override
     * .equal, .equals, .eq that tests 'almost' equality
     * if both values are numbers and a 'tolerance' flag is set.
     * Sends to deep equality check if deep flag is set
     */

    function overrideAssertEqual(_super) {
      return function assertEqual(val, msg) {
        if (msg) flag(this, 'message', msg);
        var deep = flag(this, 'deep');
        var tolerance = flag(this, 'tolerance');

        if (deep) {
          return this.eql(val);
        } else if (tolerance && bothNumbers(val, this._obj)) {
          this.assert(almostEqual(val, this._obj, tolerance), 'expected #{this} to almost equal #{exp}', 'expected #{this} to not almost equal #{exp}', val, this._obj, true);
        } else {
          return _super.apply(this, arguments);
        }
      };
    }
    /**
     * Returns a new deep equality function to override
     * .eql, .eqls that tests 'almost' equality if both corresponding
     * values are numbers and tolerance flag is set
     */


    function overrideAssertEql(_super) {
      return function assertEql(val, msg) {
        if (msg) flag(this, 'message', msg);
        var tolerance = flag(this, 'tolerance');

        if (tolerance) {
          this.assert(deepEql$1(val, this._obj, {
            comparator: comparator(tolerance)
          }), 'expected #{this} to deeply almost equal #{exp}', 'expected #{this} to not deeply almost equal #{exp}', val, this._obj, true);
        } else {
          return _super.apply(this, arguments);
        }
      };
    }
    /**
     * .almost() method. To be used at the end of the chain like:
     * expect(4).to.not.be.almost(5, 1.5). Simply adds tolerance flag then calls
     * .equal. This will redirect to .eql if deep flag set
     */


    function method(val, toleranceOverride) {
      var tolerance = toleranceOverride || standardTolerance;
      flag(this, 'tolerance', tolerance);
      return this.equal(val);
    }
    /**
     * .almost chainable property to be used like:
     * expect(3.99999999).to.almost.equal(4). Simply adds
     * tolerance flag to be read by equality checking methods
     */


    function chainingBehavior() {
      flag(this, 'tolerance', standardTolerance);
    }

    Assertion.addChainableMethod('almost', method, chainingBehavior);
    Assertion.overwriteMethod('equal', overrideAssertEqual);
    Assertion.overwriteMethod('equals', overrideAssertEqual);
    Assertion.overwriteMethod('eq', overrideAssertEqual);
    Assertion.overwriteMethod('eql', overrideAssertEql);
    Assertion.overwriteMethod('eqls', overrideAssertEql);
  };
}

var chaiAlmost_1 = chaiAlmost;var checkTypes = createCommonjsModule(function (module) {
  /*globals define, module, Symbol */

  /*jshint -W056 */
  (function (globals) {

    var strings, messages, predicates, functions, assert, not, maybe, collections, slice, neginf, posinf, isArray, haveSymbols;
    strings = {
      v: 'value',
      n: 'number',
      s: 'string',
      b: 'boolean',
      o: 'object',
      t: 'type',
      a: 'array',
      al: 'array-like',
      i: 'iterable',
      d: 'date',
      f: 'function',
      l: 'length'
    };
    messages = {};
    predicates = {};
    [{
      n: 'equal',
      f: equal,
      s: 'v'
    }, {
      n: 'undefined',
      f: isUndefined,
      s: 'v'
    }, {
      n: 'null',
      f: isNull,
      s: 'v'
    }, {
      n: 'assigned',
      f: assigned,
      s: 'v'
    }, {
      n: 'primitive',
      f: primitive,
      s: 'v'
    }, {
      n: 'includes',
      f: includes,
      s: 'v'
    }, {
      n: 'zero',
      f: zero
    }, {
      n: 'infinity',
      f: infinity
    }, {
      n: 'number',
      f: number
    }, {
      n: 'integer',
      f: integer
    }, {
      n: 'even',
      f: even
    }, {
      n: 'odd',
      f: odd
    }, {
      n: 'greater',
      f: greater
    }, {
      n: 'less',
      f: less
    }, {
      n: 'between',
      f: between
    }, {
      n: 'greaterOrEqual',
      f: greaterOrEqual
    }, {
      n: 'lessOrEqual',
      f: lessOrEqual
    }, {
      n: 'inRange',
      f: inRange
    }, {
      n: 'positive',
      f: positive
    }, {
      n: 'negative',
      f: negative
    }, {
      n: 'string',
      f: string,
      s: 's'
    }, {
      n: 'emptyString',
      f: emptyString,
      s: 's'
    }, {
      n: 'nonEmptyString',
      f: nonEmptyString,
      s: 's'
    }, {
      n: 'contains',
      f: contains,
      s: 's'
    }, {
      n: 'match',
      f: match,
      s: 's'
    }, {
      n: 'boolean',
      f: boolean,
      s: 'b'
    }, {
      n: 'object',
      f: object,
      s: 'o'
    }, {
      n: 'emptyObject',
      f: emptyObject,
      s: 'o'
    }, {
      n: 'nonEmptyObject',
      f: nonEmptyObject,
      s: 'o'
    }, {
      n: 'instanceStrict',
      f: instanceStrict,
      s: 't'
    }, {
      n: 'instance',
      f: instance,
      s: 't'
    }, {
      n: 'like',
      f: like,
      s: 't'
    }, {
      n: 'array',
      f: array,
      s: 'a'
    }, {
      n: 'emptyArray',
      f: emptyArray,
      s: 'a'
    }, {
      n: 'nonEmptyArray',
      f: nonEmptyArray,
      s: 'a'
    }, {
      n: 'arrayLike',
      f: arrayLike,
      s: 'al'
    }, {
      n: 'iterable',
      f: iterable,
      s: 'i'
    }, {
      n: 'date',
      f: date,
      s: 'd'
    }, {
      n: 'function',
      f: isFunction,
      s: 'f'
    }, {
      n: 'hasLength',
      f: hasLength,
      s: 'l'
    }].map(function (data) {
      var n = data.n;
      messages[n] = 'Invalid ' + strings[data.s || 'n'];
      predicates[n] = data.f;
    });
    functions = {
      apply: apply,
      map: map,
      all: all,
      any: any
    };
    collections = ['array', 'arrayLike', 'iterable', 'object'];
    slice = Array.prototype.slice;
    neginf = Number.NEGATIVE_INFINITY;
    posinf = Number.POSITIVE_INFINITY;
    isArray = Array.isArray;
    haveSymbols = typeof Symbol === 'function';
    functions = mixin(functions, predicates);
    assert = createModifiedPredicates(assertModifier, assertImpl);
    not = createModifiedPredicates(notModifier, notImpl);
    maybe = createModifiedPredicates(maybeModifier, maybeImpl);
    assert.not = createModifiedModifier(assertModifier, not);
    assert.maybe = createModifiedModifier(assertModifier, maybe);
    collections.forEach(createOfPredicates);
    createOfModifiers(assert, assertModifier);
    createOfModifiers(not, notModifier);
    collections.forEach(createMaybeOfModifiers);
    exportFunctions(mixin(functions, {
      assert: assert,
      not: not,
      maybe: maybe
    }));
    /**
     * Public function `equal`.
     *
     * Returns true if `lhs` and `rhs` are strictly equal, without coercion.
     * Returns false otherwise.
     */

    function equal(lhs, rhs) {
      return lhs === rhs;
    }
    /**
     * Public function `undefined`.
     *
     * Returns true if `data` is undefined, false otherwise.
     */


    function isUndefined(data) {
      return data === undefined;
    }
    /**
     * Public function `null`.
     *
     * Returns true if `data` is null, false otherwise.
     */


    function isNull(data) {
      return data === null;
    }
    /**
     * Public function `assigned`.
     *
     * Returns true if `data` is not null or undefined, false otherwise.
     */


    function assigned(data) {
      return data !== undefined && data !== null;
    }
    /**
     * Public function `primitive`.
     *
     * Returns true if `data` is a primitive type, false otherwise.
     */


    function primitive(data) {
      var type;

      switch (data) {
        case null:
        case undefined:
        case false:
        case true:
          return true;
      }

      type = typeof data;
      return type === 'string' || type === 'number' || haveSymbols && type === 'symbol';
    }
    /**
     * Public function `zero`.
     *
     * Returns true if `data` is zero, false otherwise.
     */


    function zero(data) {
      return data === 0;
    }
    /**
     * Public function `infinity`.
     *
     * Returns true if `data` is positive or negative infinity, false otherwise.
     */


    function infinity(data) {
      return data === neginf || data === posinf;
    }
    /**
     * Public function `number`.
     *
     * Returns true if `data` is a number, false otherwise.
     */


    function number(data) {
      return typeof data === 'number' && data > neginf && data < posinf;
    }
    /**
     * Public function `integer`.
     *
     * Returns true if `data` is an integer, false otherwise.
     */


    function integer(data) {
      return typeof data === 'number' && data % 1 === 0;
    }
    /**
     * Public function `even`.
     *
     * Returns true if `data` is an even number, false otherwise.
     */


    function even(data) {
      return typeof data === 'number' && data % 2 === 0;
    }
    /**
     * Public function `odd`.
     *
     * Returns true if `data` is an odd number, false otherwise.
     */


    function odd(data) {
      return integer(data) && data % 2 !== 0;
    }
    /**
     * Public function `greater`.
     *
     * Returns true if `lhs` is a number greater than `rhs`, false otherwise.
     */


    function greater(lhs, rhs) {
      return number(lhs) && lhs > rhs;
    }
    /**
     * Public function `less`.
     *
     * Returns true if `lhs` is a number less than `rhs`, false otherwise.
     */


    function less(lhs, rhs) {
      return number(lhs) && lhs < rhs;
    }
    /**
     * Public function `between`.
     *
     * Returns true if `data` is a number between `x` and `y`, false otherwise.
     */


    function between(data, x, y) {
      if (x < y) {
        return greater(data, x) && data < y;
      }

      return less(data, x) && data > y;
    }
    /**
     * Public function `greaterOrEqual`.
     *
     * Returns true if `lhs` is a number greater than or equal to `rhs`, false
     * otherwise.
     */


    function greaterOrEqual(lhs, rhs) {
      return number(lhs) && lhs >= rhs;
    }
    /**
     * Public function `lessOrEqual`.
     *
     * Returns true if `lhs` is a number less than or equal to `rhs`, false
     * otherwise.
     */


    function lessOrEqual(lhs, rhs) {
      return number(lhs) && lhs <= rhs;
    }
    /**
     * Public function `inRange`.
     *
     * Returns true if `data` is a number in the range `x..y`, false otherwise.
     */


    function inRange(data, x, y) {
      if (x < y) {
        return greaterOrEqual(data, x) && data <= y;
      }

      return lessOrEqual(data, x) && data >= y;
    }
    /**
     * Public function `positive`.
     *
     * Returns true if `data` is a positive number, false otherwise.
     */


    function positive(data) {
      return greater(data, 0);
    }
    /**
     * Public function `negative`.
     *
     * Returns true if `data` is a negative number, false otherwise.
     */


    function negative(data) {
      return less(data, 0);
    }
    /**
     * Public function `string`.
     *
     * Returns true if `data` is a string, false otherwise.
     */


    function string(data) {
      return typeof data === 'string';
    }
    /**
     * Public function `emptyString`.
     *
     * Returns true if `data` is the empty string, false otherwise.
     */


    function emptyString(data) {
      return data === '';
    }
    /**
     * Public function `nonEmptyString`.
     *
     * Returns true if `data` is a non-empty string, false otherwise.
     */


    function nonEmptyString(data) {
      return string(data) && data !== '';
    }
    /**
     * Public function `contains`.
     *
     * Returns true if `data` is a string that contains `substring`, false
     * otherwise.
     */


    function contains(data, substring) {
      return string(data) && data.indexOf(substring) !== -1;
    }
    /**
     * Public function `match`.
     *
     * Returns true if `data` is a string that matches `regex`, false otherwise.
     */


    function match(data, regex) {
      return string(data) && !!data.match(regex);
    }
    /**
     * Public function `boolean`.
     *
     * Returns true if `data` is a boolean value, false otherwise.
     */


    function boolean(data) {
      return data === false || data === true;
    }
    /**
     * Public function `object`.
     *
     * Returns true if `data` is a plain-old JS object, false otherwise.
     */


    function object(data) {
      return Object.prototype.toString.call(data) === '[object Object]';
    }
    /**
     * Public function `emptyObject`.
     *
     * Returns true if `data` is an empty object, false otherwise.
     */


    function emptyObject(data) {
      return object(data) && Object.keys(data).length === 0;
    }
    /**
     * Public function `nonEmptyObject`.
     *
     * Returns true if `data` is a non-empty object, false otherwise.
     */


    function nonEmptyObject(data) {
      return object(data) && Object.keys(data).length > 0;
    }
    /**
     * Public function `instanceStrict`.
     *
     * Returns true if `data` is an instance of `prototype`, false otherwise.
     */


    function instanceStrict(data, prototype) {
      try {
        return data instanceof prototype;
      } catch (error) {
        return false;
      }
    }
    /**
     * Public function `instance`.
     *
     * Returns true if `data` is an instance of `prototype`, false otherwise.
     * Falls back to testing constructor.name and Object.prototype.toString
     * if the initial instanceof test fails.
     */


    function instance(data, prototype) {
      try {
        return instanceStrict(data, prototype) || data.constructor.name === prototype.name || Object.prototype.toString.call(data) === '[object ' + prototype.name + ']';
      } catch (error) {
        return false;
      }
    }
    /**
     * Public function `like`.
     *
     * Tests whether `data` 'quacks like a duck'. Returns true if `data` has all
     * of the properties of `archetype` (the 'duck'), false otherwise.
     */


    function like(data, archetype) {
      var name;

      for (name in archetype) {
        if (archetype.hasOwnProperty(name)) {
          if (data.hasOwnProperty(name) === false || typeof data[name] !== typeof archetype[name]) {
            return false;
          }

          if (object(data[name]) && like(data[name], archetype[name]) === false) {
            return false;
          }
        }
      }

      return true;
    }
    /**
     * Public function `array`.
     *
     * Returns true if `data` is an array, false otherwise.
     */


    function array(data) {
      return isArray(data);
    }
    /**
     * Public function `emptyArray`.
     *
     * Returns true if `data` is an empty array, false otherwise.
     */


    function emptyArray(data) {
      return array(data) && data.length === 0;
    }
    /**
     * Public function `nonEmptyArray`.
     *
     * Returns true if `data` is a non-empty array, false otherwise.
     */


    function nonEmptyArray(data) {
      return array(data) && greater(data.length, 0);
    }
    /**
     * Public function `arrayLike`.
     *
     * Returns true if `data` is an array-like object, false otherwise.
     */


    function arrayLike(data) {
      return assigned(data) && greaterOrEqual(data.length, 0);
    }
    /**
     * Public function `iterable`.
     *
     * Returns true if `data` is an iterable, false otherwise.
     */


    function iterable(data) {
      if (!haveSymbols) {
        // Fall back to `arrayLike` predicate in pre-ES6 environments.
        return arrayLike(data);
      }

      return assigned(data) && isFunction(data[Symbol.iterator]);
    }
    /**
     * Public function `includes`.
     *
     * Returns true if `data` contains `value`, false otherwise.
     */


    function includes(data, value) {
      var iterator, iteration, keys, length, i;

      if (!assigned(data)) {
        return false;
      }

      if (haveSymbols && data[Symbol.iterator] && isFunction(data.values)) {
        iterator = data.values();

        do {
          iteration = iterator.next();

          if (iteration.value === value) {
            return true;
          }
        } while (!iteration.done);

        return false;
      }

      keys = Object.keys(data);
      length = keys.length;

      for (i = 0; i < length; ++i) {
        if (data[keys[i]] === value) {
          return true;
        }
      }

      return false;
    }
    /**
     * Public function `hasLength`.
     *
     * Returns true if `data` has a length property that equals `length`, false
     * otherwise.
     */


    function hasLength(data, length) {
      return assigned(data) && data.length === length;
    }
    /**
     * Public function `date`.
     *
     * Returns true if `data` is a valid date, false otherwise.
     */


    function date(data) {
      return instanceStrict(data, Date) && integer(data.getTime());
    }
    /**
     * Public function `function`.
     *
     * Returns true if `data` is a function, false otherwise.
     */


    function isFunction(data) {
      return typeof data === 'function';
    }
    /**
     * Public function `apply`.
     *
     * Maps each value from the `data` to the corresponding predicate and returns
     * the result array. If the same function is to be applied across all of the
     * data, a single predicate function may be passed in.
     *
     */


    function apply(data, predicates) {
      assert.array(data);

      if (isFunction(predicates)) {
        return data.map(function (value) {
          return predicates(value);
        });
      }

      assert.array(predicates);
      assert.hasLength(data, predicates.length);
      return data.map(function (value, index) {
        return predicates[index](value);
      });
    }
    /**
     * Public function `map`.
     *
     * Maps each value from the `data` to the corresponding predicate and returns
     * the result object. Supports nested objects. If the `data` is not nested and
     * the same function is to be applied across all of it, a single predicate
     * function may be passed in.
     *
     */


    function map(data, predicates) {
      assert.object(data);

      if (isFunction(predicates)) {
        return mapSimple(data, predicates);
      }

      assert.object(predicates);
      return mapComplex(data, predicates);
    }

    function mapSimple(data, predicate) {
      var result = {};
      Object.keys(data).forEach(function (key) {
        result[key] = predicate(data[key]);
      });
      return result;
    }

    function mapComplex(data, predicates) {
      var result = {};
      Object.keys(predicates).forEach(function (key) {
        var predicate = predicates[key];

        if (isFunction(predicate)) {
          if (not.assigned(data)) {
            result[key] = !!predicate.m;
          } else {
            result[key] = predicate(data[key]);
          }
        } else if (object(predicate)) {
          result[key] = mapComplex(data[key], predicate);
        }
      });
      return result;
    }
    /**
     * Public function `all`
     *
     * Check that all boolean values are true
     * in an array (returned from `apply`)
     * or object (returned from `map`).
     *
     */


    function all(data) {
      if (array(data)) {
        return testArray(data, false);
      }

      assert.object(data);
      return testObject(data, false);
    }

    function testArray(data, result) {
      var i;

      for (i = 0; i < data.length; i += 1) {
        if (data[i] === result) {
          return result;
        }
      }

      return !result;
    }

    function testObject(data, result) {
      var key, value;

      for (key in data) {
        if (data.hasOwnProperty(key)) {
          value = data[key];

          if (object(value) && testObject(value, result) === result) {
            return result;
          }

          if (value === result) {
            return result;
          }
        }
      }

      return !result;
    }
    /**
     * Public function `any`
     *
     * Check that at least one boolean value is true
     * in an array (returned from `apply`)
     * or object (returned from `map`).
     *
     */


    function any(data) {
      if (array(data)) {
        return testArray(data, true);
      }

      assert.object(data);
      return testObject(data, true);
    }

    function mixin(target, source) {
      Object.keys(source).forEach(function (key) {
        target[key] = source[key];
      });
      return target;
    }
    /**
     * Public modifier `assert`.
     *
     * Throws if `predicate` returns false.
     */


    function assertModifier(predicate, defaultMessage) {
      return function () {
        return assertPredicate(predicate, arguments, defaultMessage);
      };
    }

    function assertPredicate(predicate, args, defaultMessage) {
      var argCount = predicate.l || predicate.length;
      var message = args[argCount];
      var ErrorType = args[argCount + 1];
      assertImpl(predicate.apply(null, args), nonEmptyString(message) ? message : defaultMessage, isFunction(ErrorType) ? ErrorType : TypeError);
      return args[0];
    }

    function assertImpl(value, message, ErrorType) {
      if (value) {
        return value;
      }

      throw new (ErrorType || Error)(message || 'Assertion failed');
    }
    /**
     * Public modifier `not`.
     *
     * Negates `predicate`.
     */


    function notModifier(predicate) {
      var modifiedPredicate = function () {
        return notImpl(predicate.apply(null, arguments));
      };

      modifiedPredicate.l = predicate.length;
      return modifiedPredicate;
    }

    function notImpl(value) {
      return !value;
    }
    /**
     * Public modifier `maybe`.
     *
     * Returns true if predicate argument is  null or undefined,
     * otherwise propagates the return value from `predicate`.
     */


    function maybeModifier(predicate) {
      var modifiedPredicate = function () {
        if (not.assigned(arguments[0])) {
          return true;
        }

        return predicate.apply(null, arguments);
      };

      modifiedPredicate.l = predicate.length; // Hackishly indicate that this is a maybe.xxx predicate.
      // Without this flag, the alternative would be to iterate
      // through the maybe predicates or use indexOf to check,
      // which would be time-consuming.

      modifiedPredicate.m = true;
      return modifiedPredicate;
    }

    function maybeImpl(value) {
      if (assigned(value) === false) {
        return true;
      }

      return value;
    }
    /**
     * Public modifier `of`.
     *
     * Applies the chained predicate to members of the collection.
     */


    function ofModifier(target, type, predicate) {
      var modifiedPredicate = function () {
        var collection, args;
        collection = arguments[0];

        if (target === 'maybe' && not.assigned(collection)) {
          return true;
        }

        if (!type(collection)) {
          return false;
        }

        collection = coerceCollection(type, collection);
        args = slice.call(arguments, 1);

        try {
          collection.forEach(function (item) {
            if ((target !== 'maybe' || assigned(item)) && !predicate.apply(null, [item].concat(args))) {
              // TODO: Replace with for...of when ES6 is required.
              throw 0;
            }
          });
        } catch (ignore) {
          return false;
        }

        return true;
      };

      modifiedPredicate.l = predicate.length;
      return modifiedPredicate;
    }

    function coerceCollection(type, collection) {
      switch (type) {
        case arrayLike:
          return slice.call(collection);

        case object:
          return Object.keys(collection).map(function (key) {
            return collection[key];
          });

        default:
          return collection;
      }
    }

    function createModifiedPredicates(modifier, object) {
      return createModifiedFunctions([modifier, predicates, object]);
    }

    function createModifiedFunctions(args) {
      var modifier, object, functions, result;
      modifier = args.shift();
      object = args.pop();
      functions = args.pop();
      result = object || {};
      Object.keys(functions).forEach(function (key) {
        Object.defineProperty(result, key, {
          configurable: false,
          enumerable: true,
          writable: false,
          value: modifier.apply(null, args.concat(functions[key], messages[key]))
        });
      });
      return result;
    }

    function createModifiedModifier(modifier, modified) {
      return createModifiedFunctions([modifier, modified, null]);
    }

    function createOfPredicates(key) {
      predicates[key].of = createModifiedFunctions([ofModifier.bind(null, null), predicates[key], predicates, null]);
    }

    function createOfModifiers(base, modifier) {
      collections.forEach(function (key) {
        base[key].of = createModifiedModifier(modifier, predicates[key].of);
      });
    }

    function createMaybeOfModifiers(key) {
      maybe[key].of = createModifiedFunctions([ofModifier.bind(null, 'maybe'), predicates[key], predicates, null]);
      assert.maybe[key].of = createModifiedModifier(assertModifier, maybe[key].of);
      assert.not[key].of = createModifiedModifier(assertModifier, not[key].of);
    }

    function exportFunctions(functions) {
      if (module !== null && module.exports) {
        module.exports = functions;
      } else {
        globals.check = functions;
      }
    }
  })(commonjsGlobal);
});var asserttype = chai => {
  const types = ['number', 'string', 'boolean', 'object', 'array', 'date', 'function'];
  types.forEach(type => {
    chai.Assertion.addMethod(type, function () {
      this.assert(checkTypes[type](this._obj), `expected #{this} to be ${type}`, `expected #{this} not to be ${type}`);
    });
  });
};var chaiEvents = createCommonjsModule(function (module, exports) {
  function plugin(chai, utils) {
    var Assertion = chai.Assertion;
    /**
     * Checks if a given entry is an event emitter.
     * Uses EventEmitter or EventTarget if available to quickly check `instanceof`.  Otherwise, checks that common methods
     * to event emitters are available.
     *
     * Gracefully handles custom implementations of event emitters even if EventEmitter or EventTarget are available,
     * checking methods if the emitter doesn't inherit from the global emitter.
    */

    function isEmitter() {
      // Easy check: if Node's EventEmitter or window.EventEmitter exist, check if this is an instance of it.
      if (typeof EventEmitter !== "undefined" && EventEmitter !== null && this._obj instanceof EventEmitter) {
        return this.assert(true, "", "expected #{this} to not be an EventEmitter");
      } // Easy check: if the browser's EventTarget exists, check if this is an instance of it.


      if (typeof EventTarget !== "undefined" && EventTarget !== null && this._obj instanceof EventTarget) {
        return this.assert(true, "", "expected #{this} to not be an EventTarget");
      }

      var obj = this._obj; // Check for Node.js style event emitters with "on", "emit", etc.

      var node = ["on", "emit"].every(function (method) {
        return typeof obj[method] === "function";
      });

      if (node) {
        return this.assert(true, "", "expected #{this} to not be an EventEmitter");
      } // Check for Browser-based event emitters with "addEventListener", etc.


      var browser = ["addEventListener", "dispatchEvent", "removeEventListener"].every(function (method) {
        return typeof obj[method] === "function";
      });

      if (browser) {
        return this.assert(true, "", "expected #{this} to not be an EventEmitter");
      }

      this.assert(false, "expected #{this} to be an EventEmitter", "");
    }
    Assertion.addProperty("emitter", isEmitter);
    Assertion.addProperty("target", isEmitter);
    Assertion.addMethod("emit", function (name, args) {
      new Assertion(this._obj).to.be.an.emitter;
      new Assertion(name).to.be.a("string");
      var obj = this._obj;

      var _this = this;

      var assert = function () {
        _this.assert.apply(_this, arguments);
      };

      var timeout = utils.flag(this, 'timeout') || 1500;

      if (utils.flag(this, 'negate')) {
        // Ensure that the event doesn't fire before timeout
        return new Promise(function (resolve, reject) {
          var done = false;
          obj.on(name, function () {
            if (done) {
              return;
            }

            done = true;
            assert(false, "expected #{this} to not emit " + name + ".");
            resolve();
          });
          setTimeout(function () {
            if (done) {
              return;
            }

            done = true;
            resolve();
          }, timeout);
        });
      } else {
        // Ensure that the event fires
        return new Promise(function (resolve, reject) {
          var done = false;
          obj.on(name, function () {
            if (done) {
              return;
            }

            done = true;
            resolve();
          });
          setTimeout(function () {
            if (done) {
              return;
            }

            done = true;
            assert(false, "expected #{this} to emit " + name + ".");
            resolve();
          }, timeout);
        });
      }
    });
  }

  if (typeof commonjsRequire === "function" && 'object' === "object" && 'object' === "object") {
    module.exports = plugin;
  } else {
    // Other environment (usually <script> tag): plug in to global chai instance directly.
    chai.use(plugin);
  }
});// @Popup = window.quickpopup
var assert$1, expect$1;
chai$2.use(chaiDom);
chai$2.use(sources);
chai$2.use(chaiAlmost_1);
chai$2.use(asserttype);
chai$2.use(chaiEvents);
mocha.setup('tdd');
mocha.slow(400);
mocha.timeout(6000);

if (!window.__karma__) {
  mocha.bail();
}

expect$1 = chai$2.expect;
assert$1 = chai$2.assert;
window.sandbox = null;
suite("QuickPopup", function () {
  setup(restartSandbox);
  teardown(quickpopup$1.destroyAll);
  test("Version Property", function () {
    return expect$1(quickpopup$1.version).to.equal(version$5);
  });
  suite("instance", function () {
    test("should be an event emitter", function () {
      var popup;
      popup = quickpopup$1();
      assert$1.equal(typeof popup.on, 'function');
      assert$1.equal(typeof popup.off, 'function');
      assert$1.equal(typeof popup.emit, 'function');
      Promise.delay().then(function () {
        return popup.emit('someEvent');
      });
      return expect$1(popup).to.emit('someEvent');
    });
    return suite("args", function () {
      test("using no args", function () {
        var popup;
        popup = quickpopup$1();
        popup = new quickpopup$1();
        assert$1(!(popup instanceof quickpopup$1));
        assert$1.equal(typeof popup, 'object');
        assert$1.equal(typeof popup.open, 'function');
        return assert$1.equal(popup.el.text, '');
      });
      test("with string arg", function () {
        var popup;
        popup = quickpopup$1('provided string');
        return assert$1.equal(popup.el.text, 'provided string');
      });
      test("with html string arg", function () {
        var contents, popup;
        popup = quickpopup$1('<b class="theBoldOne">provided string</b><i class="theSlantedOne"> is slanted</b>');
        assert$1.equal(popup.el.text, 'provided string is slanted');
        contents = popup.el.child.content.lastChild.children;
        assert$1.equal(contents.length, 2);
        assert$1.equal(contents[0].type, 'b');
        assert$1.equal(contents[1].type, 'i');
        assert$1.equal(contents[0].raw.className, 'theBoldOne');
        return assert$1.equal(contents[1].raw.className, 'theSlantedOne');
      });
      test("with DOM element arg", function () {
        var contents, div, popup, span;
        span = quickdom.span({
          class: 'abc123-child'
        }, 'provided el');
        div = quickdom.div({
          class: 'abc123'
        }, span);
        popup = quickpopup$1(div.raw);
        assert$1.equal(popup.el.text, 'provided el');
        contents = popup.el.child.content.children;
        assert$1.equal(contents.length, 1);
        assert$1.equal(contents[0].type, 'div');
        assert$1.equal(contents[0].raw.className, 'abc123');
        assert$1.equal(contents[0], div);
        return assert$1.equal(contents[0].children[0], span);
      });
      test("with QuickDOM element arg", function () {
        var contents, div, popup, span;
        span = quickdom.span({
          class: 'abc123-child'
        }, 'provided el');
        div = quickdom.div({
          class: 'abc123'
        }, span);
        popup = quickpopup$1(div);
        assert$1.equal(popup.el.text, 'provided el');
        contents = popup.el.child.content.children;
        assert$1.equal(contents.length, 1);
        assert$1.equal(contents[0].type, 'div');
        assert$1.equal(contents[0].raw.className, 'abc123');
        assert$1.equal(contents[0], div);
        return assert$1.equal(contents[0].children[0], span);
      });
      return test("with settings arg", function () {
        var popupA, popupB;
        popupA = quickpopup$1({});
        popupB = quickpopup$1({
          placement: 'bottom'
        });
        assert$1.equal(popupA.settings.placement, 'center');
        return assert$1.equal(popupB.settings.placement, 'bottom');
      });
    });
  });
  suite("behavior", function () {
    test("should create a wrapper element around body contents", function () {
      var bodyChildren, popup;
      assert$1.equal(typeof quickdom.query('#bodyWrapper'), 'undefined');
      bodyChildren = quickdom(document.body).children.slice();
      popup = quickpopup$1();
      assert$1.equal(typeof quickdom.query('#bodyWrapper'), 'object');
      assert$1.equal(quickdom.query('#bodyWrapper').parent, quickdom(document.body));
      assert$1.equal(quickdom(document.body).children.length, 2);
      assert$1.equal(quickdom.query('#bodyWrapper').children.length, bodyChildren.length);
      quickpopup$1.unwrapBody();
      assert$1.equal(typeof quickdom.query('#bodyWrapper'), 'undefined');
      assert$1.equal(quickdom(document.body).children.length, bodyChildren.length + 1);
      popup.destroy();
      assert$1.equal(quickdom(document.body).children.length, bodyChildren.length);
      popup = quickpopup$1();
      assert$1.equal(quickdom(document.body).children.length, 2);
      return assert$1.equal(quickdom.query('#bodyWrapper').children.length, bodyChildren.length);
    });
    return test("Popup.config() will return a new constructor with customized setting defaults & templates", function () {
      var Popup2;
      Popup2 = quickpopup$1.config({
        animation: 100
      });
      assert$1.notEqual(Popup2, quickpopup$1);
      assert$1.equal(Popup2.defaults.animation, 100);
      assert$1.notEqual(quickpopup$1.defaults.animation, 100);
      quickpopup$1();
      return Popup2();
    });
  });
  return suite("open/close", function () {
    suiteSetup(function () {
      return this.Popup = quickpopup$1.config({
        animation: 50
      });
    });
    test("will return promises that resolve when animation ends", function () {
      var content, openPromise, openTime, popup, startTime;
      content = quickdom.div(null, 'abc123');
      popup = this.Popup(content);
      startTime = Date.now();
      openTime = null;
      assert$1.equal(popup.state.open, false);
      openPromise = popup.open();
      assert$1.ok(openPromise instanceof Promise);
      assert$1.ok(openPromise.isPending());
      return Promise.bind(this).then(function () {
        return openPromise;
      }).then(function () {
        openTime = Date.now();
        assert$1.isAtLeast(openTime - startTime, this.Popup.defaults.animation / 2);
        return assert$1.equal(popup.state.open, true);
      }).then(function () {
        return popup.close();
      }).then(function () {
        assert$1.isAtLeast(Date.now() - openTime, this.Popup.defaults.animation / 2);
        return assert$1.equal(popup.state.open, false);
      });
    });
    test("will emit events before/present/finish for open/close", function () {
      var count, events, popup;
      popup = this.Popup();
      events = ['beforeopen', 'open', 'finishopen', 'beforeclose', 'close', 'finishclose'];
      count = {};
      events.forEach(function (event) {
        count[event] = 0;
        return popup.on(event, function () {
          return count[event]++;
        });
      });
      return Promise.resolve().then(function () {
        return assert$1.deepEqual(count, {
          beforeopen: 0,
          open: 0,
          finishopen: 0,
          beforeclose: 0,
          close: 0,
          finishclose: 0
        });
      }).then(function () {
        return popup.open();
      }).then(function () {
        return assert$1.deepEqual(count, {
          beforeopen: 1,
          open: 1,
          finishopen: 1,
          beforeclose: 0,
          close: 0,
          finishclose: 0
        });
      }).then(function () {
        return popup.close();
      }).then(function () {
        return assert$1.deepEqual(count, {
          beforeopen: 1,
          open: 1,
          finishopen: 1,
          beforeclose: 1,
          close: 1,
          finishclose: 1
        });
      });
    });
    test("will fail to open if another popup is open", function () {
      var popupA, popupB;
      popupA = this.Popup();
      popupB = this.Popup();
      return Promise.resolve().then(function () {
        assert$1.equal(popupA.state.open, false);
        return assert$1.equal(popupB.state.open, false);
      }).then(function () {
        return popupA.open();
      }).then(function () {
        assert$1.equal(popupA.state.open, true);
        return assert$1.equal(popupB.state.open, false);
      }).then(function () {
        return popupB.open();
      }).then(function () {
        assert$1.equal(popupA.state.open, true);
        return assert$1.equal(popupB.state.open, false);
      });
    });
    return test("will close all other open popups and will force open when options.forceOpen", function () {
      var popupA, popupB;
      popupA = this.Popup();
      popupB = this.Popup({
        forceOpen: true
      });
      return Promise.resolve().then(function () {
        assert$1.equal(popupA.state.open, false);
        return assert$1.equal(popupB.state.open, false);
      }).then(function () {
        return popupA.open();
      }).then(function () {
        assert$1.equal(popupA.state.open, true);
        return assert$1.equal(popupB.state.open, false);
      }).then(function () {
        return popupB.open();
      }).then(function () {
        assert$1.equal(popupA.state.open, false);
        return assert$1.equal(popupB.state.open, true);
      }).then(function () {
        return popupA.open();
      }).then(function () {
        assert$1.equal(popupA.state.open, false);
        return assert$1.equal(popupB.state.open, true);
      });
    });
  });
});}));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdC5qcyIsInNvdXJjZXMiOlsiLi4vbm9kZV9tb2R1bGVzL3F1aWNrZG9tL2Rpc3QvcXVpY2tkb20uZXNtLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3NtYXJ0LWV4dGVuZC9kaXN0L3NtYXJ0LWV4dGVuZC5lc20uanMiLCIuLi9ub2RlX21vZHVsZXMvcC1maW5hbGx5L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3AtdGltZW91dC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wLWV2ZW50L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Byb21pc2UtYnJlYWsvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQGRhbmllbGthbGVuL2lzL2Rpc3QvaXMuZXNtLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2RldGVjdC1hbmltYXRpb24tZW5kLWhlbHBlci9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9ldmVudC1saXRlL2V2ZW50LWxpdGUuanMiLCIuLi9idWlsZC9xdWlja3BvcHVwLmVzbS5qcyIsImhlbHBlcnMuY29mZmVlIiwiLi4vbm9kZV9tb2R1bGVzL2Fzc2VydGlvbi1lcnJvci9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wYXRodmFsL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZmxhZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL3Rlc3QuanMiLCIuLi9ub2RlX21vZHVsZXMvdHlwZS1kZXRlY3QvdHlwZS1kZXRlY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9leHBlY3RUeXBlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2dldEFjdHVhbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9nZXQtZnVuYy1uYW1lL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0UHJvcGVydGllcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2dldEVudW1lcmFibGVQcm9wZXJ0aWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvY29uZmlnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvaW5zcGVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL29iakRpc3BsYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXRNZXNzYWdlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvdHJhbnNmZXJGbGFncy5qcyIsIi4uL25vZGVfbW9kdWxlcy9kZWVwLWVxbC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2lzUHJveHlFbmFibGVkLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvYWRkUHJvcGVydHkuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9hZGRMZW5ndGhHdWFyZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL3Byb3hpZnkuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9hZGRNZXRob2QuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9vdmVyd3JpdGVQcm9wZXJ0eS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL292ZXJ3cml0ZU1ldGhvZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2FkZENoYWluYWJsZU1ldGhvZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL292ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2NvbXBhcmVCeUluc3BlY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXRPd25FbnVtZXJhYmxlUHJvcGVydHlTeW1ib2xzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0T3duRW51bWVyYWJsZVByb3BlcnRpZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hlY2stZXJyb3IvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9pc05hTi5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvYXNzZXJ0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvY29yZS9hc3NlcnRpb25zLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvaW50ZXJmYWNlL2V4cGVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL2ludGVyZmFjZS9zaG91bGQuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS9pbnRlcmZhY2UvYXNzZXJ0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkuanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpLWRvbS9jaGFpLWRvbS5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpLXN0eWxlL3NvdXJjZXMvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS1hbG1vc3Qvbm9kZV9tb2R1bGVzL2RlZXAtZXFsL25vZGVfbW9kdWxlcy90eXBlLWRldGVjdC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jaGFpLWFsbW9zdC9ub2RlX21vZHVsZXMvZGVlcC1lcWwvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvY2hhaS1hbG1vc3QvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvY2hlY2stdHlwZXMvc3JjL2NoZWNrLXR5cGVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWktYXNzZXJ0dHlwZS9hc3NlcnR0eXBlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2NoYWktZXZlbnRzL2NoYWktZXZlbnRzLmpzIiwidGVzdC5jb2ZmZWUiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG52YXIgUkVHRVhfTEVOX1ZBTCA9IC9eXFxkKyg/OlthLXpdfFxcJSkrJC9pO1xudmFyIFJFR0VYX0RJR0lUUyA9IC9cXGQrJC87XG52YXIgUkVHRVhfU1BBQ0UgPSAvXFxzLztcbnZhciBSRUdFWF9LRUJBQiA9IC8oW0EtWl0pKy9nO1xudmFyIElNUE9SVEFOVCA9ICdpbXBvcnRhbnQnO1xudmFyIFBPU1NJQkxFX1BSRUZJWEVTID0gWyd3ZWJraXQnLCAnbW96JywgJ21zJywgJ28nXTtcbnZhciBSRVFVSVJFU19VTklUX1ZBTFVFID0gWydiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnLCAnYmFja2dyb3VuZC1wb3NpdGlvbi15JywgJ2Jsb2NrLXNpemUnLCAnYm9yZGVyLXdpZHRoJywgJ2NvbHVtblJ1bGUtd2lkdGgnLCAnY3gnLCAnY3knLCAnZm9udC1zaXplJywgJ2dyaWQtY29sdW1uLWdhcCcsICdncmlkLXJvdy1nYXAnLCAnaGVpZ2h0JywgJ2lubGluZS1zaXplJywgJ2xpbmUtaGVpZ2h0JywgJ21pbkJsb2NrLXNpemUnLCAnbWluLWhlaWdodCcsICdtaW4taW5saW5lLXNpemUnLCAnbWluLXdpZHRoJywgJ21heC1oZWlnaHQnLCAnbWF4LXdpZHRoJywgJ291dGxpbmUtb2Zmc2V0JywgJ291dGxpbmUtd2lkdGgnLCAncGVyc3BlY3RpdmUnLCAnc2hhcGUtbWFyZ2luJywgJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ3N0cm9rZS13aWR0aCcsICd0ZXh0LWluZGVudCcsICd3aWR0aCcsICd3b3JkLXNwYWNpbmcnLCAndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0JywgJ3gnLCAneSddO1xudmFyIFFVQURfU0hPUlRIQU5EUyA9IFsnbWFyZ2luJywgJ3BhZGRpbmcnLCAnYm9yZGVyJywgJ2JvcmRlci1yYWRpdXMnXTtcbnZhciBESVJFQ1RJT05TID0gWyd0b3AnLCAnYm90dG9tJywgJ2xlZnQnLCAncmlnaHQnXTtcblFVQURfU0hPUlRIQU5EUy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICB2YXIgZGlyZWN0aW9uLCBpLCBsZW47XG4gIFJFUVVJUkVTX1VOSVRfVkFMVUUucHVzaChwcm9wZXJ0eSk7XG5cbiAgZm9yIChpID0gMCwgbGVuID0gRElSRUNUSU9OUy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGRpcmVjdGlvbiA9IERJUkVDVElPTlNbaV07XG4gICAgUkVRVUlSRVNfVU5JVF9WQUxVRS5wdXNoKHByb3BlcnR5ICsgJy0nICsgZGlyZWN0aW9uKTtcbiAgfVxufSk7XG52YXIgU0FNUExFX1NUWUxFLCBzdHlsZUNvbmZpZztcblNBTVBMRV9TVFlMRSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuXG52YXIgaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyh0YXJnZXQsIGl0ZW0pIHtcbiAgcmV0dXJuIHRhcmdldCAmJiB0YXJnZXQuaW5kZXhPZihpdGVtKSAhPT0gLTE7XG59O1xuXG52YXIgaXNJdGVyYWJsZSA9IGZ1bmN0aW9uIGlzSXRlcmFibGUodGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXQgJiYgX3R5cGVvZih0YXJnZXQpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGFyZ2V0Lmxlbmd0aCA9PT0gJ251bWJlcicgJiYgIXRhcmdldC5ub2RlVHlwZTtcbn07XG5cbnZhciB0b0tlYmFiQ2FzZSA9IGZ1bmN0aW9uIHRvS2ViYWJDYXNlKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoUkVHRVhfS0VCQUIsIGZ1bmN0aW9uIChlLCBsZXR0ZXIpIHtcbiAgICByZXR1cm4gXCItXCIuY29uY2F0KGxldHRlci50b0xvd2VyQ2FzZSgpKTtcbiAgfSk7XG59O1xuXG52YXIgaXNQcm9wU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNQcm9wU3VwcG9ydGVkKHByb3BlcnR5KSB7XG4gIHJldHVybiB0eXBlb2YgU0FNUExFX1NUWUxFW3Byb3BlcnR5XSAhPT0gJ3VuZGVmaW5lZCc7XG59O1xuXG52YXIgaXNWYWx1ZVN1cHBvcnRlZCA9IGZ1bmN0aW9uIGlzVmFsdWVTdXBwb3J0ZWQocHJvcGVydHksIHZhbHVlKSB7XG4gIGlmICh3aW5kb3cuQ1NTICYmIHdpbmRvdy5DU1Muc3VwcG9ydHMpIHtcbiAgICByZXR1cm4gd2luZG93LkNTUy5zdXBwb3J0cyhwcm9wZXJ0eSwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIFNBTVBMRV9TVFlMRVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gU0FNUExFX1NUWUxFW3Byb3BlcnR5XSA9PT0gJycgKyB2YWx1ZTtcbiAgfVxufTtcblxudmFyIGdldFByZWZpeCA9IGZ1bmN0aW9uIGdldFByZWZpeChwcm9wZXJ0eSwgc2tpcEluaXRpYWxDaGVjaykge1xuICB2YXIgaiwgbGVuMSwgcHJlZml4O1xuXG4gIGlmIChza2lwSW5pdGlhbENoZWNrIHx8ICFpc1Byb3BTdXBwb3J0ZWQocHJvcGVydHkpKSB7XG4gICAgZm9yIChqID0gMCwgbGVuMSA9IFBPU1NJQkxFX1BSRUZJWEVTLmxlbmd0aDsgaiA8IGxlbjE7IGorKykge1xuICAgICAgcHJlZml4ID0gUE9TU0lCTEVfUFJFRklYRVNbal07XG5cbiAgICAgIGlmIChpc1Byb3BTdXBwb3J0ZWQoXCItXCIuY29uY2F0KHByZWZpeCwgXCItXCIpLmNvbmNhdChwcm9wZXJ0eSkpKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBcIi1cIi5jb25jYXQocHJlZml4LCBcIi1cIik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufTtcblxudmFyIG5vcm1hbGl6ZVByb3BlcnR5ID0gZnVuY3Rpb24gbm9ybWFsaXplUHJvcGVydHkocHJvcGVydHkpIHtcbiAgcHJvcGVydHkgPSB0b0tlYmFiQ2FzZShwcm9wZXJ0eSk7XG5cbiAgaWYgKGlzUHJvcFN1cHBvcnRlZChwcm9wZXJ0eSkpIHtcbiAgICByZXR1cm4gcHJvcGVydHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGdldFByZWZpeChwcm9wZXJ0eSwgdHJ1ZSkpLmNvbmNhdChwcm9wZXJ0eSk7XG4gIH1cbn07XG5cbnZhciBub3JtYWxpemVWYWx1ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHByb3BlcnR5LCB2YWx1ZSkge1xuICBpZiAoaW5jbHVkZXMoUkVRVUlSRVNfVU5JVF9WQUxVRSwgcHJvcGVydHkpICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgdmFsdWUgPSAnJyArIHZhbHVlO1xuXG4gICAgaWYgKFJFR0VYX0RJR0lUUy50ZXN0KHZhbHVlKSAmJiAhUkVHRVhfTEVOX1ZBTC50ZXN0KHZhbHVlKSAmJiAhUkVHRVhfU1BBQ0UudGVzdCh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlICs9IHByb3BlcnR5ID09PSAnbGluZS1oZWlnaHQnID8gJ2VtJyA6ICdweCc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxudmFyIHNvcnQgPSBmdW5jdGlvbiBzb3J0KGFycmF5KSB7XG4gIHZhciBncmVhdCwgaSwgbGVuLCBsZXNzLCBwaXZvdDtcblxuICBpZiAoYXJyYXkubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiBhcnJheTtcbiAgfSBlbHNlIHtcbiAgICBwaXZvdCA9IGFycmF5WzBdO1xuICAgIGxlc3MgPSBbXTtcbiAgICBncmVhdCA9IFtdO1xuICAgIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICBpID0gMDtcblxuICAgIHdoaWxlICgrK2kgIT09IGxlbikge1xuICAgICAgaWYgKGFycmF5W2ldIDw9IHBpdm90KSB7XG4gICAgICAgIGxlc3MucHVzaChhcnJheVtpXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBncmVhdC5wdXNoKGFycmF5W2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc29ydChsZXNzKS5jb25jYXQocGl2b3QsIHNvcnQoZ3JlYXQpKTtcbiAgfVxufTtcblxudmFyIGhhc2ggPSBmdW5jdGlvbiBoYXNoKHN0cmluZykge1xuICB2YXIgaHNoLCBpLCBsZW5ndGg7XG4gIGhzaCA9IDUzODE7XG4gIGkgPSAtMTtcbiAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblxuICB3aGlsZSAoKytpICE9PSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgaHNoID0gKGhzaCA8PCA1KSAtIGhzaCArIHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgIGhzaCB8PSAwO1xuICB9XG5cbiAgcmV0dXJuICdfJyArIChoc2ggPCAwID8gaHNoICogLTIgOiBoc2gpO1xufTtcblxudmFyIHJ1bGVUb1N0cmluZyA9IGZ1bmN0aW9uIHJ1bGVUb1N0cmluZyhydWxlLCBpbXBvcnRhbnQpIHtcbiAgdmFyIGosIGxlbjEsIG91dHB1dCwgcHJvcCwgcHJvcGVydHksIHByb3BzLCB2YWx1ZTtcbiAgb3V0cHV0ID0gJyc7XG4gIHByb3BzID0gc29ydChPYmplY3Qua2V5cyhydWxlKSk7XG5cbiAgZm9yIChqID0gMCwgbGVuMSA9IHByb3BzLmxlbmd0aDsgaiA8IGxlbjE7IGorKykge1xuICAgIHByb3AgPSBwcm9wc1tqXTtcblxuICAgIGlmICh0eXBlb2YgcnVsZVtwcm9wXSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHJ1bGVbcHJvcF0gPT09ICdudW1iZXInKSB7XG4gICAgICBwcm9wZXJ0eSA9IG5vcm1hbGl6ZVByb3BlcnR5KHByb3ApO1xuICAgICAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZShwcm9wZXJ0eSwgcnVsZVtwcm9wXSk7XG5cbiAgICAgIGlmIChpbXBvcnRhbnQpIHtcbiAgICAgICAgdmFsdWUgKz0gXCIgIWltcG9ydGFudFwiO1xuICAgICAgfVxuXG4gICAgICBvdXRwdXQgKz0gXCJcIi5jb25jYXQocHJvcGVydHksIFwiOlwiKS5jb25jYXQodmFsdWUsIFwiO1wiKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxudmFyIGlubGluZVN0eWxlQ29uZmlnID0gc3R5bGVDb25maWcgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG52YXIgaW5saW5lU3R5bGUgPSBmdW5jdGlvbiBpbmxpbmVTdHlsZShydWxlLCB2YWx1ZVRvU3RvcmUsIGxldmVsKSB7XG4gIHZhciBjb25maWcsIHN0eWxlRWw7XG5cbiAgaWYgKCEoY29uZmlnID0gc3R5bGVDb25maWdbbGV2ZWxdKSkge1xuICAgIHN0eWxlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHN0eWxlRWwuaWQgPSBcInF1aWNrY3NzXCIuY29uY2F0KGxldmVsIHx8ICcnKTtcbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlRWwpO1xuICAgIHN0eWxlQ29uZmlnW2xldmVsXSA9IGNvbmZpZyA9IHtcbiAgICAgIGVsOiBzdHlsZUVsLFxuICAgICAgY29udGVudDogJycsXG4gICAgICBjYWNoZTogT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIH07XG4gIH1cblxuICBpZiAoIWNvbmZpZy5jYWNoZVtydWxlXSkge1xuICAgIGNvbmZpZy5jYWNoZVtydWxlXSA9IHZhbHVlVG9TdG9yZSB8fCB0cnVlO1xuICAgIGNvbmZpZy5lbC50ZXh0Q29udGVudCA9IGNvbmZpZy5jb250ZW50ICs9IHJ1bGU7XG4gIH1cbn07XG5cbnZhciBjbGVhcklubGluZVN0eWxlID0gZnVuY3Rpb24gY2xlYXJJbmxpbmVTdHlsZShsZXZlbCkge1xuICB2YXIgY29uZmlnLCBqLCBrZXksIGtleXMsIGxlbjE7XG5cbiAgaWYgKGNvbmZpZyA9IHN0eWxlQ29uZmlnW2xldmVsXSkge1xuICAgIGlmICghY29uZmlnLmNvbnRlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25maWcuZWwudGV4dENvbnRlbnQgPSBjb25maWcuY29udGVudCA9ICcnO1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcuY2FjaGUpO1xuXG4gICAgZm9yIChqID0gMCwgbGVuMSA9IGtleXMubGVuZ3RoOyBqIDwgbGVuMTsgaisrKSB7XG4gICAgICBrZXkgPSBrZXlzW2pdO1xuICAgICAgY29uZmlnLmNhY2hlW2tleV0gPSBudWxsO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHZlcnNpb24gPSBcIjEuNC4yXCI7XG5cbnZhciBfcXVpY2tjc3M7XG5cbnZhciBpbmRleCA9IF9xdWlja2NzcyA9IGZ1bmN0aW9uIHF1aWNrY3NzKHRhcmdldEVsLCBwcm9wZXJ0eSwgdmFsdWUsIGltcG9ydGFudCkge1xuICB2YXIgY29tcHV0ZWRTdHlsZSwgaSwgbGVuLCBzdWJFbCwgc3ViUHJvcGVydHksIHN1YlZhbHVlO1xuXG4gIHN3aXRjaCAoZmFsc2UpIHtcbiAgICBjYXNlICFpc0l0ZXJhYmxlKHRhcmdldEVsKTpcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRhcmdldEVsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHN1YkVsID0gdGFyZ2V0RWxbaV07XG5cbiAgICAgICAgX3F1aWNrY3NzKHN1YkVsLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgX3R5cGVvZihwcm9wZXJ0eSkgIT09ICdvYmplY3QnOlxuICAgICAgLy8gUGFzc2VkIGEgc3R5bGUgbWFwXG4gICAgICBmb3IgKHN1YlByb3BlcnR5IGluIHByb3BlcnR5KSB7XG4gICAgICAgIHN1YlZhbHVlID0gcHJvcGVydHlbc3ViUHJvcGVydHldO1xuXG4gICAgICAgIF9xdWlja2Nzcyh0YXJnZXRFbCwgc3ViUHJvcGVydHksIHN1YlZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcHJvcGVydHkgPSBub3JtYWxpemVQcm9wZXJ0eShwcm9wZXJ0eSk7XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbXB1dGVkU3R5bGUgPSB0YXJnZXRFbC5fY29tcHV0ZWRTdHlsZSB8fCAodGFyZ2V0RWwuX2NvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldEVsKSk7XG4gICAgICAgIHJldHVybiBjb21wdXRlZFN0eWxlW3Byb3BlcnR5XTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcGVydHkpIHtcbiAgICAgICAgdGFyZ2V0RWwuc3R5bGUuc2V0UHJvcGVydHkocHJvcGVydHksIG5vcm1hbGl6ZVZhbHVlKHByb3BlcnR5LCB2YWx1ZSksIGltcG9ydGFudCA/IElNUE9SVEFOVCA6IHZvaWQgMCk7XG4gICAgICB9XG5cbiAgfVxufTtcblxuX3F1aWNrY3NzLmFuaW1hdGlvbiA9IGZ1bmN0aW9uIChuYW1lJCQxLCBmcmFtZXMpIHtcbiAgdmFyIGZyYW1lLCBnZW5lcmF0ZWQsIHByZWZpeCwgcnVsZXM7XG5cbiAgaWYgKG5hbWUkJDEgJiYgdHlwZW9mIG5hbWUkJDEgPT09ICdzdHJpbmcnICYmIGZyYW1lcyAmJiBfdHlwZW9mKGZyYW1lcykgPT09ICdvYmplY3QnKSB7XG4gICAgcHJlZml4ID0gZ2V0UHJlZml4KCdhbmltYXRpb24nKTtcbiAgICBnZW5lcmF0ZWQgPSAnJztcblxuICAgIGZvciAoZnJhbWUgaW4gZnJhbWVzKSB7XG4gICAgICBydWxlcyA9IGZyYW1lc1tmcmFtZV07XG4gICAgICBnZW5lcmF0ZWQgKz0gXCJcIi5jb25jYXQoZnJhbWUsIFwiIHtcIikuY29uY2F0KHJ1bGVUb1N0cmluZyhydWxlcyksIFwifVwiKTtcbiAgICB9XG5cbiAgICBnZW5lcmF0ZWQgPSBcIkBcIi5jb25jYXQocHJlZml4LCBcImtleWZyYW1lcyBcIikuY29uY2F0KG5hbWUkJDEsIFwiIHtcIikuY29uY2F0KGdlbmVyYXRlZCwgXCJ9XCIpO1xuICAgIHJldHVybiBpbmxpbmVTdHlsZShnZW5lcmF0ZWQsIHRydWUsIDApO1xuICB9XG59O1xuXG5fcXVpY2tjc3MucmVnaXN0ZXIgPSBmdW5jdGlvbiAocnVsZSwgbGV2ZWwsIGltcG9ydGFudCkge1xuICB2YXIgY2xhc3NOYW1lLCByZWYsIHN0eWxlO1xuXG4gIGlmIChydWxlICYmIF90eXBlb2YocnVsZSkgPT09ICdvYmplY3QnKSB7XG4gICAgbGV2ZWwgfHwgKGxldmVsID0gMCk7XG4gICAgcnVsZSA9IHJ1bGVUb1N0cmluZyhydWxlLCBpbXBvcnRhbnQpO1xuXG4gICAgaWYgKCEoY2xhc3NOYW1lID0gKHJlZiA9IGlubGluZVN0eWxlQ29uZmlnW2xldmVsXSkgIT0gbnVsbCA/IHJlZltydWxlXSA6IHZvaWQgMCkpIHtcbiAgICAgIGNsYXNzTmFtZSA9IGhhc2gocnVsZSk7XG4gICAgICBzdHlsZSA9IFwiLlwiLmNvbmNhdChjbGFzc05hbWUsIFwiIHtcIikuY29uY2F0KHJ1bGUsIFwifVwiKTtcbiAgICAgIGlubGluZVN0eWxlKHN0eWxlLCBjbGFzc05hbWUsIGxldmVsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG59O1xuXG5fcXVpY2tjc3MuY2xlYXJSZWdpc3RlcmVkID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gIHJldHVybiBjbGVhcklubGluZVN0eWxlKGxldmVsIHx8IDApO1xufTtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cblxuX3F1aWNrY3NzLlVOU0VUID0gZnVuY3Rpb24gKCkge1xuICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgY2FzZSAhaXNWYWx1ZVN1cHBvcnRlZCgnZGlzcGxheScsICd1bnNldCcpOlxuICAgICAgcmV0dXJuICd1bnNldCc7XG5cbiAgICBjYXNlICFpc1ZhbHVlU3VwcG9ydGVkKCdkaXNwbGF5JywgJ2luaXRpYWwnKTpcbiAgICAgIHJldHVybiAnaW5pdGlhbCc7XG5cbiAgICBjYXNlICFpc1ZhbHVlU3VwcG9ydGVkKCdkaXNwbGF5JywgJ2luaGVyaXQnKTpcbiAgICAgIHJldHVybiAnaW5oZXJpdCc7XG4gIH1cbn0oKTtcblxuX3F1aWNrY3NzLnN1cHBvcnRzID0gaXNWYWx1ZVN1cHBvcnRlZDtcbl9xdWlja2Nzcy5zdXBwb3J0c1Byb3BlcnR5ID0gaXNQcm9wU3VwcG9ydGVkO1xuX3F1aWNrY3NzLm5vcm1hbGl6ZVByb3BlcnR5ID0gbm9ybWFsaXplUHJvcGVydHk7XG5fcXVpY2tjc3Mubm9ybWFsaXplVmFsdWUgPSBub3JtYWxpemVWYWx1ZTtcbl9xdWlja2Nzcy52ZXJzaW9uID0gdmVyc2lvbjtmdW5jdGlvbiBfdHlwZW9mJDEob2JqKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YkMSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiQxID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mJDEob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gICAgcmV0dXJuIGFycjI7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIikgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xufWZ1bmN0aW9uIF90eXBlb2YkMihvYmopIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiQyID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mJDIgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2YkMihvYmopO1xufVxuXG52YXIgX2V4dGVuZCwgaXNBcnJheSwgaXNPYmplY3QsIF9zaG91bGREZWVwRXh0ZW5kO1xuXG5pc0FycmF5ID0gZnVuY3Rpb24gaXNBcnJheSh0YXJnZXQpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodGFyZ2V0KTtcbn07XG5cbmlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3QodGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXQgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRhcmdldCkgPT09ICdbb2JqZWN0IE9iamVjdF0nIHx8IGlzQXJyYXkodGFyZ2V0KTtcbn07XG5cbl9zaG91bGREZWVwRXh0ZW5kID0gZnVuY3Rpb24gc2hvdWxkRGVlcEV4dGVuZChvcHRpb25zLCB0YXJnZXQsIHBhcmVudEtleSkge1xuICBpZiAob3B0aW9ucy5kZWVwKSB7XG4gICAgaWYgKG9wdGlvbnMubm90RGVlcCkge1xuICAgICAgcmV0dXJuICFvcHRpb25zLm5vdERlZXBbdGFyZ2V0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG9wdGlvbnMuZGVlcE9ubHkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5kZWVwT25seVt0YXJnZXRdIHx8IHBhcmVudEtleSAmJiBfc2hvdWxkRGVlcEV4dGVuZChvcHRpb25zLCBwYXJlbnRLZXkpO1xuICB9XG59OyAvLyBlbHNlIGZhbHNlXG5cblxudmFyIGV4dGVuZCA9IF9leHRlbmQgPSBmdW5jdGlvbiBleHRlbmQob3B0aW9ucywgdGFyZ2V0LCBzb3VyY2VzLCBwYXJlbnRLZXkpIHtcbiAgdmFyIGksIGtleSwgbGVuLCBzb3VyY2UsIHNvdXJjZVZhbHVlLCBzdWJUYXJnZXQsIHRhcmdldFZhbHVlO1xuXG4gIGlmICghdGFyZ2V0IHx8IF90eXBlb2YkMih0YXJnZXQpICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGFyZ2V0ID0ge307XG4gIH1cblxuICBmb3IgKGkgPSAwLCBsZW4gPSBzb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgc291cmNlID0gc291cmNlc1tpXTtcblxuICAgIGlmIChzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIHNvdXJjZVZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgIHRhcmdldFZhbHVlID0gdGFyZ2V0W2tleV07XG5cbiAgICAgICAgaWYgKHNvdXJjZVZhbHVlID09PSB0YXJnZXQgfHwgc291cmNlVmFsdWUgPT09IHZvaWQgMCB8fCBzb3VyY2VWYWx1ZSA9PT0gbnVsbCAmJiAhb3B0aW9ucy5hbGxvd051bGwgJiYgIW9wdGlvbnMubnVsbERlbGV0ZXMgfHwgb3B0aW9ucy5rZXlzICYmICFvcHRpb25zLmtleXNba2V5XSB8fCBvcHRpb25zLm5vdEtleXMgJiYgb3B0aW9ucy5ub3RLZXlzW2tleV0gfHwgb3B0aW9ucy5vd24gJiYgIXNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpIHx8IG9wdGlvbnMuZ2xvYmFsRmlsdGVyICYmICFvcHRpb25zLmdsb2JhbEZpbHRlcihzb3VyY2VWYWx1ZSwga2V5LCBzb3VyY2UpIHx8IG9wdGlvbnMuZmlsdGVycyAmJiBvcHRpb25zLmZpbHRlcnNba2V5XSAmJiAhb3B0aW9ucy5maWx0ZXJzW2tleV0oc291cmNlVmFsdWUsIGtleSwgc291cmNlKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNvdXJjZVZhbHVlID09PSBudWxsICYmIG9wdGlvbnMubnVsbERlbGV0ZXMpIHtcbiAgICAgICAgICBkZWxldGUgdGFyZ2V0W2tleV07XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5nbG9iYWxUcmFuc2Zvcm0pIHtcbiAgICAgICAgICBzb3VyY2VWYWx1ZSA9IG9wdGlvbnMuZ2xvYmFsVHJhbnNmb3JtKHNvdXJjZVZhbHVlLCBrZXksIHNvdXJjZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy50cmFuc2Zvcm1zICYmIG9wdGlvbnMudHJhbnNmb3Jtc1trZXldKSB7XG4gICAgICAgICAgc291cmNlVmFsdWUgPSBvcHRpb25zLnRyYW5zZm9ybXNba2V5XShzb3VyY2VWYWx1ZSwga2V5LCBzb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICAgIGNhc2UgIShvcHRpb25zLmNvbmNhdCAmJiBpc0FycmF5KHNvdXJjZVZhbHVlKSAmJiBpc0FycmF5KHRhcmdldFZhbHVlKSk6XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHRhcmdldFZhbHVlLmNvbmNhdChzb3VyY2VWYWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgIShfc2hvdWxkRGVlcEV4dGVuZChvcHRpb25zLCBrZXksIHBhcmVudEtleSkgJiYgaXNPYmplY3Qoc291cmNlVmFsdWUpKTpcbiAgICAgICAgICAgIHN1YlRhcmdldCA9IGlzT2JqZWN0KHRhcmdldFZhbHVlKSA/IHRhcmdldFZhbHVlIDogaXNBcnJheShzb3VyY2VWYWx1ZSkgPyBbXSA6IHt9O1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBfZXh0ZW5kKG9wdGlvbnMsIHN1YlRhcmdldCwgW3NvdXJjZVZhbHVlXSwga2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIHZlcnNpb24kMSA9IFwiMS43LjRcIjtcbnZhciBtb2RpZmllcnMsIG5ld0J1aWxkZXIsIG5vcm1hbGl6ZUtleXMsIHByaW1hcnlCdWlsZGVyO1xuXG5ub3JtYWxpemVLZXlzID0gZnVuY3Rpb24gbm9ybWFsaXplS2V5cyhrZXlzKSB7XG4gIHZhciBpLCBrZXksIGxlbiwgb3V0cHV0O1xuXG4gIGlmIChrZXlzKSB7XG4gICAgb3V0cHV0ID0ge307XG5cbiAgICBpZiAoX3R5cGVvZiQyKGtleXMpICE9PSAnb2JqZWN0Jykge1xuICAgICAgb3V0cHV0W2tleXNdID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGtleXMpKSB7XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhrZXlzKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBvdXRwdXRba2V5XSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxufTtcblxubmV3QnVpbGRlciA9IGZ1bmN0aW9uIG5ld0J1aWxkZXIoaXNCYXNlKSB7XG4gIHZhciBfYnVpbGRlcjtcblxuICBfYnVpbGRlciA9IGZ1bmN0aW9uIGJ1aWxkZXIodGFyZ2V0KSB7XG4gICAgdmFyIHRoZVRhcmdldDtcbiAgICB2YXIgJF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAkX2kgPSAtMSxcbiAgICAgICAgc291cmNlcyA9IG5ldyBBcnJheSgkX2xlbik7XG5cbiAgICB3aGlsZSAoKyskX2kgPCAkX2xlbikgc291cmNlc1skX2ldID0gYXJndW1lbnRzWyRfaV07XG5cbiAgICBpZiAoX2J1aWxkZXIub3B0aW9ucy50YXJnZXQpIHtcbiAgICAgIHRoZVRhcmdldCA9IF9idWlsZGVyLm9wdGlvbnMudGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGVUYXJnZXQgPSB0YXJnZXQ7XG4gICAgICBzb3VyY2VzLnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4dGVuZChfYnVpbGRlci5vcHRpb25zLCB0aGVUYXJnZXQsIHNvdXJjZXMpO1xuICB9O1xuXG4gIGlmIChpc0Jhc2UpIHtcbiAgICBfYnVpbGRlci5pc0Jhc2UgPSB0cnVlO1xuICB9XG5cbiAgX2J1aWxkZXIub3B0aW9ucyA9IHt9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfYnVpbGRlciwgbW9kaWZpZXJzKTtcbiAgcmV0dXJuIF9idWlsZGVyO1xufTtcblxubW9kaWZpZXJzID0ge1xuICAnZGVlcCc6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfO1xuXG4gICAgICBfID0gdGhpcy5pc0Jhc2UgPyBuZXdCdWlsZGVyKCkgOiB0aGlzO1xuICAgICAgXy5vcHRpb25zLmRlZXAgPSB0cnVlO1xuICAgICAgcmV0dXJuIF87XG4gICAgfVxuICB9LFxuICAnb3duJzoge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF87XG5cbiAgICAgIF8gPSB0aGlzLmlzQmFzZSA/IG5ld0J1aWxkZXIoKSA6IHRoaXM7XG4gICAgICBfLm9wdGlvbnMub3duID0gdHJ1ZTtcbiAgICAgIHJldHVybiBfO1xuICAgIH1cbiAgfSxcbiAgJ2FsbG93TnVsbCc6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfO1xuXG4gICAgICBfID0gdGhpcy5pc0Jhc2UgPyBuZXdCdWlsZGVyKCkgOiB0aGlzO1xuICAgICAgXy5vcHRpb25zLmFsbG93TnVsbCA9IHRydWU7XG4gICAgICByZXR1cm4gXztcbiAgICB9XG4gIH0sXG4gICdudWxsRGVsZXRlcyc6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfO1xuXG4gICAgICBfID0gdGhpcy5pc0Jhc2UgPyBuZXdCdWlsZGVyKCkgOiB0aGlzO1xuICAgICAgXy5vcHRpb25zLm51bGxEZWxldGVzID0gdHJ1ZTtcbiAgICAgIHJldHVybiBfO1xuICAgIH1cbiAgfSxcbiAgJ2NvbmNhdCc6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfO1xuXG4gICAgICBfID0gdGhpcy5pc0Jhc2UgPyBuZXdCdWlsZGVyKCkgOiB0aGlzO1xuICAgICAgXy5vcHRpb25zLmNvbmNhdCA9IHRydWU7XG4gICAgICByZXR1cm4gXztcbiAgICB9XG4gIH0sXG4gICdjbG9uZSc6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfO1xuXG4gICAgICBfID0gdGhpcy5pc0Jhc2UgPyBuZXdCdWlsZGVyKCkgOiB0aGlzO1xuICAgICAgXy5vcHRpb25zLnRhcmdldCA9IHt9O1xuICAgICAgcmV0dXJuIF87XG4gICAgfVxuICB9LFxuICAnbm90RGVlcCc6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfO1xuXG4gICAgICBfID0gdGhpcy5pc0Jhc2UgPyBuZXdCdWlsZGVyKCkgOiB0aGlzO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgIF8ub3B0aW9ucy5ub3REZWVwID0gbm9ybWFsaXplS2V5cyhrZXlzKTtcbiAgICAgICAgcmV0dXJuIF87XG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgJ2RlZXBPbmx5Jzoge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF87XG5cbiAgICAgIF8gPSB0aGlzLmlzQmFzZSA/IG5ld0J1aWxkZXIoKSA6IHRoaXM7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgXy5vcHRpb25zLmRlZXBPbmx5ID0gbm9ybWFsaXplS2V5cyhrZXlzKTtcbiAgICAgICAgcmV0dXJuIF87XG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgJ2tleXMnOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgXztcblxuICAgICAgXyA9IHRoaXMuaXNCYXNlID8gbmV3QnVpbGRlcigpIDogdGhpcztcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICBfLm9wdGlvbnMua2V5cyA9IG5vcm1hbGl6ZUtleXMoa2V5cyk7XG4gICAgICAgIHJldHVybiBfO1xuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gICdub3RLZXlzJzoge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF87XG5cbiAgICAgIF8gPSB0aGlzLmlzQmFzZSA/IG5ld0J1aWxkZXIoKSA6IHRoaXM7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgXy5vcHRpb25zLm5vdEtleXMgPSBub3JtYWxpemVLZXlzKGtleXMpO1xuICAgICAgICByZXR1cm4gXztcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICAndHJhbnNmb3JtJzoge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF87XG5cbiAgICAgIF8gPSB0aGlzLmlzQmFzZSA/IG5ld0J1aWxkZXIoKSA6IHRoaXM7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHRyYW5zZm9ybSkge1xuICAgICAgICBpZiAodHlwZW9mIHRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIF8ub3B0aW9ucy5nbG9iYWxUcmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICAgIH0gZWxzZSBpZiAodHJhbnNmb3JtICYmIF90eXBlb2YkMih0cmFuc2Zvcm0pID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIF8ub3B0aW9ucy50cmFuc2Zvcm1zID0gdHJhbnNmb3JtO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF87XG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgJ2ZpbHRlcic6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfO1xuXG4gICAgICBfID0gdGhpcy5pc0Jhc2UgPyBuZXdCdWlsZGVyKCkgOiB0aGlzO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBfLm9wdGlvbnMuZ2xvYmFsRmlsdGVyID0gZmlsdGVyO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbHRlciAmJiBfdHlwZW9mJDIoZmlsdGVyKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBfLm9wdGlvbnMuZmlsdGVycyA9IGZpbHRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbn07XG5wcmltYXJ5QnVpbGRlciA9IG5ld0J1aWxkZXIodHJ1ZSk7XG5wcmltYXJ5QnVpbGRlci52ZXJzaW9uID0gdmVyc2lvbiQxO1xudmFyIHByaW1hcnlCdWlsZGVyJDEgPSBwcmltYXJ5QnVpbGRlcjt2YXIgdGVtcGxhdGUgPSBbJ2lkJywgJ25hbWUnLCAndHlwZScsICdocmVmJywgJ3NlbGVjdGVkJywgJ2NoZWNrZWQnLCAnY2xhc3NOYW1lJ107IC8vIFRvIGNvcHkgZnJvbSBET00gRWxlbWVudHNcblxudmFyIGVsZW1lbnQgPSBbJ2lkJywgJ3JlZicsICd0eXBlJywgJ25hbWUnLCAndGV4dCcsICdzdHlsZScsICdjbGFzcycsICdjbGFzc05hbWUnLCAndXJsJywgJ2hyZWYnLCAnc2VsZWN0ZWQnLCAnY2hlY2tlZCcsICdwcm9wcycsICdhdHRycycsICdwYXNzU3RhdGVUb0NoaWxkcmVuJywgJ3N0YXRlVHJpZ2dlcnMnLCAndW5wYXNzYWJsZVN0YXRlcyddOyAvLyBVc2VkIGluIFF1aWNrRWxlbWVudDo6dG9KU09OXG4vLyAncmVsYXRlZEluc3RhbmNlJ1xuZnVuY3Rpb24gX3R5cGVvZiQzKG9iaikge1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mJDMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YkMyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZiQzKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayQxKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMkMSh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzJDEoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyQxKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMkMShDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbnZhciBkZWZpbmVkID0gZnVuY3Rpb24gZGVmaW5lZChzdWJqZWN0KSB7XG4gIHJldHVybiBzdWJqZWN0ICE9PSB2b2lkIDA7XG59O1xuXG52YXIgYXJyYXkgPSBmdW5jdGlvbiBhcnJheShzdWJqZWN0KSB7XG4gIHJldHVybiBzdWJqZWN0IGluc3RhbmNlb2YgQXJyYXk7XG59O1xuXG52YXIgb2JqZWN0ID0gZnVuY3Rpb24gb2JqZWN0KHN1YmplY3QpIHtcbiAgcmV0dXJuIF90eXBlb2YkMyhzdWJqZWN0KSA9PT0gJ29iamVjdCcgJiYgc3ViamVjdDsgLy8gMm5kIGNoZWNrIGlzIHRvIHRlc3QgYWdhaW5zdCAnbnVsbCcgdmFsdWVzXG59O1xuXG52YXIgb2JqZWN0UGxhaW4gPSBmdW5jdGlvbiBvYmplY3RQbGFpbihzdWJqZWN0KSB7XG4gIHJldHVybiBvYmplY3Qoc3ViamVjdCkgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN1YmplY3QpID09PSAnW29iamVjdCBPYmplY3RdJyAmJiBzdWJqZWN0LmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG59O1xuXG52YXIgc3RyaW5nID0gZnVuY3Rpb24gc3RyaW5nKHN1YmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdWJqZWN0ID09PSAnc3RyaW5nJztcbn07XG5cbnZhciBudW1iZXIgPSBmdW5jdGlvbiBudW1iZXIoc3ViamVjdCkge1xuICByZXR1cm4gdHlwZW9mIHN1YmplY3QgPT09ICdudW1iZXInICYmICFpc05hTihzdWJqZWN0KTtcbn07XG5cbnZhciBudW1iZXJMb29zZSA9IGZ1bmN0aW9uIG51bWJlckxvb3NlKHN1YmplY3QpIHtcbiAgcmV0dXJuIG51bWJlcihzdWJqZWN0KSB8fCBzdHJpbmcoc3ViamVjdCkgJiYgbnVtYmVyKE51bWJlcihzdWJqZWN0KSk7XG59O1xuXG52YXIgaXRlcmFibGUgPSBmdW5jdGlvbiBpdGVyYWJsZShzdWJqZWN0KSB7XG4gIHJldHVybiBvYmplY3Qoc3ViamVjdCkgJiYgbnVtYmVyKHN1YmplY3QubGVuZ3RoKTtcbn07XG5cbnZhciBmdW5jdGlvbl8gPSBmdW5jdGlvbiBmdW5jdGlvbl8oc3ViamVjdCkge1xuICByZXR1cm4gdHlwZW9mIHN1YmplY3QgPT09ICdmdW5jdGlvbic7XG59O1xuXG52YXIgbmF0aXZlcyA9XG4vKiNfX1BVUkVfXyovXG5PYmplY3QuZnJlZXplKHtcbiAgZGVmaW5lZDogZGVmaW5lZCxcbiAgYXJyYXk6IGFycmF5LFxuICBvYmplY3Q6IG9iamVjdCxcbiAgb2JqZWN0UGxhaW46IG9iamVjdFBsYWluLFxuICBzdHJpbmc6IHN0cmluZyxcbiAgbnVtYmVyOiBudW1iZXIsXG4gIG51bWJlckxvb3NlOiBudW1iZXJMb29zZSxcbiAgaXRlcmFibGU6IGl0ZXJhYmxlLFxuICBmdW5jdGlvbl86IGZ1bmN0aW9uX1xufSk7XG5cbnZhciBkb21Eb2MgPSBmdW5jdGlvbiBkb21Eb2Moc3ViamVjdCkge1xuICByZXR1cm4gc3ViamVjdCAmJiBzdWJqZWN0Lm5vZGVUeXBlID09PSA5O1xufTtcblxudmFyIGRvbUVsID0gZnVuY3Rpb24gZG9tRWwoc3ViamVjdCkge1xuICByZXR1cm4gc3ViamVjdCAmJiBzdWJqZWN0Lm5vZGVUeXBlID09PSAxO1xufTtcblxudmFyIGRvbVRleHQgPSBmdW5jdGlvbiBkb21UZXh0KHN1YmplY3QpIHtcbiAgcmV0dXJuIHN1YmplY3QgJiYgc3ViamVjdC5ub2RlVHlwZSA9PT0gMztcbn07XG5cbnZhciBkb21Ob2RlID0gZnVuY3Rpb24gZG9tTm9kZShzdWJqZWN0KSB7XG4gIHJldHVybiBkb21FbChzdWJqZWN0KSB8fCBkb21UZXh0KHN1YmplY3QpO1xufTtcblxudmFyIGRvbVRleHRhcmVhID0gZnVuY3Rpb24gZG9tVGV4dGFyZWEoc3ViamVjdCkge1xuICByZXR1cm4gc3ViamVjdCAmJiBzdWJqZWN0Lm5vZGVOYW1lID09PSAnVEVYVEFSRUEnO1xufTtcblxudmFyIGRvbUlucHV0ID0gZnVuY3Rpb24gZG9tSW5wdXQoc3ViamVjdCkge1xuICByZXR1cm4gc3ViamVjdCAmJiBzdWJqZWN0Lm5vZGVOYW1lID09PSAnSU5QVVQnO1xufTtcblxudmFyIGRvbVNlbGVjdCA9IGZ1bmN0aW9uIGRvbVNlbGVjdChzdWJqZWN0KSB7XG4gIHJldHVybiBzdWJqZWN0ICYmIHN1YmplY3Qubm9kZU5hbWUgPT09ICdTRUxFQ1QnO1xufTtcblxudmFyIGRvbUZpZWxkID0gZnVuY3Rpb24gZG9tRmllbGQoc3ViamVjdCkge1xuICByZXR1cm4gZG9tSW5wdXQoc3ViamVjdCkgfHwgZG9tVGV4dGFyZWEoc3ViamVjdCkgfHwgZG9tU2VsZWN0KHN1YmplY3QpO1xufTtcblxudmFyIGRvbSA9XG4vKiNfX1BVUkVfXyovXG5PYmplY3QuZnJlZXplKHtcbiAgZG9tRG9jOiBkb21Eb2MsXG4gIGRvbUVsOiBkb21FbCxcbiAgZG9tVGV4dDogZG9tVGV4dCxcbiAgZG9tTm9kZTogZG9tTm9kZSxcbiAgZG9tVGV4dGFyZWE6IGRvbVRleHRhcmVhLFxuICBkb21JbnB1dDogZG9tSW5wdXQsXG4gIGRvbVNlbGVjdDogZG9tU2VsZWN0LFxuICBkb21GaWVsZDogZG9tRmllbGRcbn0pO1xudmFyIEFWQUlMX1NFVFMsIENoZWNrcztcbkFWQUlMX1NFVFMgPSB7XG4gIG5hdGl2ZXM6IG5hdGl2ZXMsXG4gIGRvbTogZG9tXG59O1xuXG5DaGVja3MgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBfY3JlYXRlQ2xhc3MkMShDaGVja3MsIFt7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICB2YXIgYXJncztcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgQ2hlY2tzKGFyZ3MpO1xuICAgIH1cbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIENoZWNrcyhzZXRzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrJDEodGhpcywgQ2hlY2tzKTtcblxuICAgIHZhciBpLCBsZW4sIHNldDtcblxuICAgIGlmIChzZXRzID09IG51bGwpIHtcbiAgICAgIHNldHMgPSBbJ25hdGl2ZXMnXTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBzZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzZXQgPSBzZXRzW2ldO1xuXG4gICAgICBpZiAoQVZBSUxfU0VUU1tzZXRdKSB7XG4gICAgICAgIHRoaXMubG9hZChBVkFJTF9TRVRTW3NldF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyQxKENoZWNrcywgW3tcbiAgICBrZXk6IFwibG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkKHNldCkge1xuICAgICAgdmFyIGtleSwgdmFsdWU7XG5cbiAgICAgIGlmIChBVkFJTF9TRVRTLm5hdGl2ZXMuc3RyaW5nKHNldCkpIHtcbiAgICAgICAgc2V0ID0gQVZBSUxfU0VUU1tzZXRdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIUFWQUlMX1NFVFMubmF0aXZlcy5vYmplY3RQbGFpbihzZXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yIChrZXkgaW4gc2V0KSB7XG4gICAgICAgIHZhbHVlID0gc2V0W2tleV07XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ2Z1bmN0aW9uXycpIHtcbiAgICAgICAgICBrZXkgPSAnZnVuY3Rpb24nO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpc1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENoZWNrcztcbn0oKTtcblxudmFyIGluZGV4JDEgPSBDaGVja3MucHJvdG90eXBlLmNyZWF0ZSgpO3ZhciBJUztcbklTID0gaW5kZXgkMS5jcmVhdGUoJ25hdGl2ZXMnLCAnZG9tJyk7XG5JUy5sb2FkKHtcbiAgcXVpY2tEb21FbDogZnVuY3Rpb24gcXVpY2tEb21FbChzdWJqZWN0KSB7XG4gICAgcmV0dXJuIHN1YmplY3QgJiYgc3ViamVjdC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnUXVpY2tFbGVtZW50JztcbiAgfSxcbiAgdGVtcGxhdGU6IGZ1bmN0aW9uIHRlbXBsYXRlKHN1YmplY3QpIHtcbiAgICByZXR1cm4gc3ViamVjdCAmJiBzdWJqZWN0LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdRdWlja1RlbXBsYXRlJztcbiAgfVxufSk7IC8vIGJhdGNoOiAoc3ViamVjdCktPiBzdWJqZWN0IGFuZCBzdWJqZWN0LmNvbnN0cnVjdG9yLm5hbWUgaXMgJ1F1aWNrQmF0Y2gnXG5cbnZhciBJUyQxID0gSVM7dmFyIFF1aWNrRWxlbWVudCwgUXVpY2tXaW5kb3csIF9xdWlja2RvbTtcblF1aWNrRWxlbWVudCA9IG51bGw7XG5RdWlja1dpbmRvdyA9IG51bGw7XG5cbl9xdWlja2RvbSA9IGZ1bmN0aW9uIHF1aWNrZG9tKCkge1xuICB2YXIgYXJnLCBhcmdzLCBlbGVtZW50LCBpLCBqLCBsZW4sIHByZXZDb3VudDtcbiAgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcblxuICBmb3IgKGkgPSBqID0gMCwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaiA8IGxlbjsgaSA9ICsraikge1xuICAgIGFyZyA9IGFyZ3VtZW50c1tpXTtcbiAgICBhcmdzW2ldID0gYXJnO1xuICB9XG5cbiAgcHJldkNvdW50ID0gUXVpY2tFbGVtZW50LmNvdW50O1xuICBlbGVtZW50ID0gX3F1aWNrZG9tLmNyZWF0ZShhcmdzKTtcblxuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9wb3N0Q3JlYXRpb24gJiYgUXVpY2tFbGVtZW50LmNvdW50ICE9PSBwcmV2Q291bnQpIHtcbiAgICBlbGVtZW50Ll9wb3N0Q3JlYXRpb24oKTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuX3F1aWNrZG9tLmNyZWF0ZSA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gIHZhciBhcmdzTGVuZ3RoLCBjaGlsZCwgY2hpbGRyZW4sIGVsZW1lbnQsIGksIGosIGxlbiwgb3B0aW9ucywgdHlwZTtcblxuICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgY2FzZSAhSVMkMS5hcnJheShhcmdzWzBdKTpcbiAgICAgIHJldHVybiBfcXVpY2tkb20uYXBwbHkodm9pZCAwLCBfdG9Db25zdW1hYmxlQXJyYXkoYXJnc1swXSkpO1xuXG4gICAgY2FzZSAhSVMkMS50ZW1wbGF0ZShhcmdzWzBdKTpcbiAgICAgIHJldHVybiBhcmdzWzBdLnNwYXduKCk7XG5cbiAgICBjYXNlICFJUyQxLnF1aWNrRG9tRWwoYXJnc1swXSk6XG4gICAgICBpZiAoYXJnc1sxXSkge1xuICAgICAgICByZXR1cm4gYXJnc1swXS51cGRhdGVPcHRpb25zKGFyZ3NbMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgICB9XG5cbiAgICBjYXNlICEoSVMkMS5kb21Ob2RlKGFyZ3NbMF0pIHx8IElTJDEuZG9tRG9jKGFyZ3NbMF0pKTpcbiAgICAgIGlmIChhcmdzWzBdLl9xdWlja0VsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbMF0uX3F1aWNrRWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgdHlwZSA9IGFyZ3NbMF0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCcjJywgJycpO1xuICAgICAgb3B0aW9ucyA9IGFyZ3NbMV0gfHwge307XG4gICAgICBvcHRpb25zLmV4aXN0aW5nID0gYXJnc1swXTtcbiAgICAgIHJldHVybiBuZXcgUXVpY2tFbGVtZW50KHR5cGUsIG9wdGlvbnMpO1xuXG4gICAgY2FzZSBhcmdzWzBdICE9PSB3aW5kb3c6XG4gICAgICByZXR1cm4gUXVpY2tXaW5kb3c7XG5cbiAgICBjYXNlICFJUyQxLnN0cmluZyhhcmdzWzBdKTpcbiAgICAgIHR5cGUgPSBhcmdzWzBdLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIGlmICh0eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgb3B0aW9ucyA9IElTJDEub2JqZWN0KGFyZ3NbMV0pID8gYXJnc1sxXSA6IHtcbiAgICAgICAgICB0ZXh0OiBhcmdzWzFdIHx8ICcnXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zID0gSVMkMS5vYmplY3QoYXJnc1sxXSkgPyBhcmdzWzFdIDoge307XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQgPSBuZXcgUXVpY2tFbGVtZW50KHR5cGUsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAyKSB7XG4gICAgICAgIGNoaWxkcmVuID0gbmV3IEFycmF5KGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCk7XG4gICAgICAgIGkgPSAxO1xuXG4gICAgICAgIHdoaWxlICgrK2kgPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgICAgY2hpbGRyZW5baSArIDFdID0gYXJnc1tpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltqXTtcblxuICAgICAgICAgIGlmIChJUyQxLnN0cmluZyhjaGlsZCkpIHtcbiAgICAgICAgICAgIGNoaWxkID0gX3F1aWNrZG9tLnRleHQoY2hpbGQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChJUyQxLmFycmF5KGNoaWxkKSkge1xuICAgICAgICAgICAgY2hpbGQgPSBfcXVpY2tkb20uYXBwbHkodm9pZCAwLCBfdG9Db25zdW1hYmxlQXJyYXkoY2hpbGQpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoSVMkMS5xdWlja0RvbUVsKGNoaWxkKSkge1xuICAgICAgICAgICAgZWxlbWVudC5hcHBlbmQoY2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxlbWVudDtcblxuICAgIGNhc2UgIShhcmdzWzBdICYmIChJUyQxLmRvbU5vZGUoYXJnc1swXVswXSkgfHwgSVMkMS5kb21Eb2MoYXJnc1swXVswXSkpKTpcbiAgICAgIHJldHVybiBfcXVpY2tkb20oYXJnc1swXVswXSk7XG4gIH1cbn07XG5cbl9xdWlja2RvbS5odG1sID0gZnVuY3Rpb24gKGlubmVySFRNTCkge1xuICB2YXIgY2hpbGRyZW4sIGNvbnRhaW5lcjtcbiAgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNvbnRhaW5lci5pbm5lckhUTUwgPSBpbm5lckhUTUw7XG4gIGNoaWxkcmVuID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY29udGFpbmVyLmNoaWxkTm9kZXMpO1xuICByZXR1cm4gX3F1aWNrZG9tLmJhdGNoKGNoaWxkcmVuKTtcbn07XG5cbl9xdWlja2RvbS5pc1F1aWNrRWwgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIHJldHVybiBJUyQxLnF1aWNrRG9tRWwodGFyZ2V0KTtcbn07XG5cbl9xdWlja2RvbS5pc0VsID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICByZXR1cm4gSVMkMS5kb21FbCh0YXJnZXQpO1xufTtcbnZhciBpbml0ID0gZnVuY3Rpb24gaW5pdChRdWlja0VsZW1lbnRfLCBRdWlja1dpbmRvd18pIHtcbiAgUXVpY2tFbGVtZW50ID0gUXVpY2tFbGVtZW50XztcbiAgUXVpY2tXaW5kb3cgPSBRdWlja1dpbmRvd187XG4gIHJldHVybiBfcXVpY2tkb207XG59O3ZhciBpbmNsdWRlcyQxID0gZnVuY3Rpb24gaW5jbHVkZXModGFyZ2V0LCBpdGVtKSB7XG4gIHJldHVybiB0YXJnZXQgJiYgdGFyZ2V0LmluZGV4T2YoaXRlbSkgIT09IC0xO1xufTtcbnZhciByZW1vdmVJdGVtID0gZnVuY3Rpb24gcmVtb3ZlSXRlbSh0YXJnZXQsIGl0ZW0pIHtcbiAgdmFyIGl0ZW1JbmRleDtcbiAgaXRlbUluZGV4ID0gdGFyZ2V0LmluZGV4T2YoaXRlbSk7XG5cbiAgaWYgKGl0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICB0YXJnZXQuc3BsaWNlKGl0ZW1JbmRleCwgMSk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBub3JtYWxpemVFbGVtZW50QXJnID0gZnVuY3Rpb24gbm9ybWFsaXplRWxlbWVudEFyZyh0YXJnZXRFbCkge1xuICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgY2FzZSAhSVMkMS5zdHJpbmcodGFyZ2V0RWwpOlxuICAgICAgcmV0dXJuIHF1aWNrZG9tLnRleHQodGFyZ2V0RWwpO1xuXG4gICAgY2FzZSAhSVMkMS5kb21Ob2RlKHRhcmdldEVsKTpcbiAgICAgIHJldHVybiBxdWlja2RvbSh0YXJnZXRFbCk7XG5cbiAgICBjYXNlICFJUyQxLnRlbXBsYXRlKHRhcmdldEVsKTpcbiAgICAgIHJldHVybiB0YXJnZXRFbC5zcGF3bigpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB0YXJnZXRFbDtcbiAgfVxufTtcbnZhciBpc1N0YXRlU3R5bGUgPSBmdW5jdGlvbiBpc1N0YXRlU3R5bGUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmdbMF0gPT09ICckJyB8fCBzdHJpbmdbMF0gPT09ICdAJztcbn07XG52YXIgcmVnaXN0ZXJTdHlsZSA9IGZ1bmN0aW9uIHJlZ2lzdGVyU3R5bGUocnVsZSwgbGV2ZWwsIGltcG9ydGFudCkge1xuICB2YXIgY2FjaGVkLCBpLCBsZW4sIG91dHB1dCwgcHJvcCwgcHJvcHM7XG4gIGxldmVsIHx8IChsZXZlbCA9IDApO1xuICBjYWNoZWQgPSBzdHlsZUNhY2hlLmdldChydWxlLCBsZXZlbCk7XG5cbiAgaWYgKGNhY2hlZCkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cblxuICBvdXRwdXQgPSB7XG4gICAgY2xhc3NOYW1lOiBbaW5kZXgucmVnaXN0ZXIocnVsZSwgbGV2ZWwsIGltcG9ydGFudCldLFxuICAgIGZuczogW10sXG4gICAgcnVsZTogcnVsZVxuICB9O1xuICBwcm9wcyA9IE9iamVjdC5rZXlzKHJ1bGUpO1xuXG4gIGZvciAoaSA9IDAsIGxlbiA9IHByb3BzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcHJvcCA9IHByb3BzW2ldO1xuXG4gICAgaWYgKHR5cGVvZiBydWxlW3Byb3BdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvdXRwdXQuZm5zLnB1c2goW3Byb3AsIHJ1bGVbcHJvcF1dKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3R5bGVDYWNoZS5zZXQocnVsZSwgb3V0cHV0LCBsZXZlbCk7XG59O1xudmFyIHN0eWxlQ2FjaGUgPSBuZXcgKFxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBfY2xhc3MoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9jbGFzcyk7XG5cbiAgICB0aGlzLmtleXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMudmFsdWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhfY2xhc3MsIFt7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoa2V5LCBsZXZlbCkge1xuICAgICAgdmFyIGluZGV4JCQxO1xuXG4gICAgICBpZiAodGhpcy5rZXlzW2xldmVsXSkge1xuICAgICAgICBpbmRleCQkMSA9IHRoaXMua2V5c1tsZXZlbF0uaW5kZXhPZihrZXkpO1xuXG4gICAgICAgIGlmIChpbmRleCQkMSAhPT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNbbGV2ZWxdW2luZGV4JCQxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUsIGxldmVsKSB7XG4gICAgICBpZiAoIXRoaXMua2V5c1tsZXZlbF0pIHtcbiAgICAgICAgdGhpcy5rZXlzW2xldmVsXSA9IFtdO1xuICAgICAgICB0aGlzLnZhbHVlc1tsZXZlbF0gPSBbXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5rZXlzW2xldmVsXS5wdXNoKGtleSk7XG4gICAgICB0aGlzLnZhbHVlc1tsZXZlbF0ucHVzaCh2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIF9jbGFzcztcbn0oKSkoKTt2YXIgUkVHRVhfV0hJVEVTUEFDRTtcblJFR0VYX1dISVRFU1BBQ0UgPSAvXFxzKy87XG52YXIgb25fID0gZnVuY3Rpb24gb25fKGV2ZW50TmFtZXMsIGNhbGxiYWNrLCB1c2VDYXB0dXJlLCBpc1ByaXZhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgY2FsbGJhY2tSZWYsIHNwbGl0O1xuXG4gIGlmICh0aGlzLl9ldmVudENhbGxiYWNrcyA9PSBudWxsKSB7XG4gICAgdGhpcy5fZXZlbnRDYWxsYmFja3MgPSB7XG4gICAgICBfX3JlZnM6IHt9XG4gICAgfTtcbiAgfVxuXG4gIGlmIChJUyQxLnN0cmluZyhldmVudE5hbWVzKSAmJiBJUyQxLmZ1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgIHNwbGl0ID0gZXZlbnROYW1lcy5zcGxpdCgnLicpO1xuICAgIGNhbGxiYWNrUmVmID0gc3BsaXRbMV07XG4gICAgZXZlbnROYW1lcyA9IHNwbGl0WzBdO1xuXG4gICAgaWYgKGV2ZW50TmFtZXMgPT09ICdpbnNlcnRlZCcgJiYgdGhpcy5faW5zZXJ0ZWQpIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgdGhpcy5fcGFyZW50KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGV2ZW50TmFtZXMuc3BsaXQoUkVHRVhfV0hJVEVTUEFDRSkuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICB2YXIgYmFzZTtcblxuICAgICAgaWYgKCFfdGhpcy5fZXZlbnRDYWxsYmFja3NbZXZlbnROYW1lXSkge1xuICAgICAgICBfdGhpcy5fZXZlbnRDYWxsYmFja3NbZXZlbnROYW1lXSA9IFtdO1xuXG4gICAgICAgIGlmICghaXNQcml2YXRlKSB7XG4gICAgICAgICAgX3RoaXMuX2xpc3RlblRvKGV2ZW50TmFtZSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX2ludm9rZUhhbmRsZXJzKGV2ZW50TmFtZSwgZXZlbnQpO1xuICAgICAgICAgIH0sIHVzZUNhcHR1cmUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjYWxsYmFja1JlZikge1xuICAgICAgICBpZiAoKGJhc2UgPSBfdGhpcy5fZXZlbnRDYWxsYmFja3MuX19yZWZzKVtldmVudE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgICBiYXNlW2V2ZW50TmFtZV0gPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLl9ldmVudENhbGxiYWNrcy5fX3JlZnNbZXZlbnROYW1lXVtjYWxsYmFja1JlZl0gPSBjYWxsYmFjaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzLl9ldmVudENhbGxiYWNrc1tldmVudE5hbWVdLnB1c2goY2FsbGJhY2spO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIG9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50TmFtZXMsIGNhbGxiYWNrKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIHZhciBfb25jZUNhbGxiYWNrO1xuXG4gIGlmIChJUyQxLnN0cmluZyhldmVudE5hbWVzKSAmJiBJUyQxLmZ1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgIHRoaXMub24oZXZlbnROYW1lcywgX29uY2VDYWxsYmFjayA9IGZ1bmN0aW9uIG9uY2VDYWxsYmFjayhldmVudCkge1xuICAgICAgX3RoaXMyLm9mZihldmVudE5hbWVzLCBfb25jZUNhbGxiYWNrKTtcblxuICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoX3RoaXMyLCBldmVudCk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgb2ZmXyA9IGZ1bmN0aW9uIG9mZl8oZXZlbnROYW1lcywgY2FsbGJhY2spIHtcbiAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgdmFyIGNhbGxiYWNrUmVmLCBldmVudE5hbWUsIHNwbGl0O1xuXG4gIGlmICh0aGlzLl9ldmVudENhbGxiYWNrcyA9PSBudWxsKSB7XG4gICAgdGhpcy5fZXZlbnRDYWxsYmFja3MgPSB7XG4gICAgICBfX3JlZnM6IHt9XG4gICAgfTtcbiAgfVxuXG4gIGlmICghSVMkMS5zdHJpbmcoZXZlbnROYW1lcykpIHtcbiAgICBmb3IgKGV2ZW50TmFtZSBpbiB0aGlzLl9ldmVudENhbGxiYWNrcykge1xuICAgICAgdGhpcy5vZmYoZXZlbnROYW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3BsaXQgPSBldmVudE5hbWVzLnNwbGl0KCcuJyk7XG4gICAgY2FsbGJhY2tSZWYgPSBzcGxpdFsxXTtcbiAgICBldmVudE5hbWVzID0gc3BsaXRbMF07XG4gICAgZXZlbnROYW1lcy5zcGxpdChSRUdFWF9XSElURVNQQUNFKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgIHZhciByZWY7XG5cbiAgICAgIGlmIChfdGhpczMuX2V2ZW50Q2FsbGJhY2tzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrID09IG51bGwpIHtcbiAgICAgICAgICBjYWxsYmFjayA9IChyZWYgPSBfdGhpczMuX2V2ZW50Q2FsbGJhY2tzLl9fcmVmc1tldmVudE5hbWVdKSAhPSBudWxsID8gcmVmW2NhbGxiYWNrUmVmXSA6IHZvaWQgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChJUyQxLmZ1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgIHJldHVybiByZW1vdmVJdGVtKF90aGlzMy5fZXZlbnRDYWxsYmFja3NbZXZlbnROYW1lXSwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2UgaWYgKCFjYWxsYmFja1JlZikge1xuICAgICAgICAgIHJldHVybiBfdGhpczMuX2V2ZW50Q2FsbGJhY2tzW2V2ZW50TmFtZV0ubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIGVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50TmFtZSkge1xuICB2YXIgYnViYmxlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgdmFyIGNhbmNlbGFibGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gIHZhciBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG4gIHZhciBldmVudDtcblxuICBpZiAoZXZlbnROYW1lICYmIElTJDEuc3RyaW5nKGV2ZW50TmFtZSkpIHtcbiAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2ZW50LmluaXRFdmVudChldmVudE5hbWUsIGJ1YmJsZXMsIGNhbmNlbGFibGUpO1xuXG4gICAgaWYgKGRhdGEgJiYgX3R5cGVvZiQxKGRhdGEpID09PSAnb2JqZWN0Jykge1xuICAgICAgcHJpbWFyeUJ1aWxkZXIkMShldmVudCwgZGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5lbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciBlbWl0UHJpdmF0ZSA9IGZ1bmN0aW9uIGVtaXRQcml2YXRlKGV2ZW50TmFtZSwgYXJnKSB7XG4gIHZhciByZWY7XG5cbiAgaWYgKGV2ZW50TmFtZSAmJiBJUyQxLnN0cmluZyhldmVudE5hbWUpICYmICgocmVmID0gdGhpcy5fZXZlbnRDYWxsYmFja3MpICE9IG51bGwgPyByZWZbZXZlbnROYW1lXSA6IHZvaWQgMCkpIHtcbiAgICB0aGlzLl9pbnZva2VIYW5kbGVycyhldmVudE5hbWUsIGFyZyk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgX2ludm9rZUhhbmRsZXJzID0gZnVuY3Rpb24gX2ludm9rZUhhbmRsZXJzKGV2ZW50TmFtZSwgYXJnKSB7XG4gIHZhciBjYWxsYmFja3MsIGNiLCBpLCBsZW47XG4gIGNhbGxiYWNrcyA9IHRoaXMuX2V2ZW50Q2FsbGJhY2tzW2V2ZW50TmFtZV0uc2xpY2UoKTtcblxuICBmb3IgKGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcbiAgICBjYi5jYWxsKHRoaXMsIGFyZyk7XG4gIH1cbn07XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG52YXIgX2xpc3RlblRvID0gZnVuY3Rpb24gX2xpc3RlblRvKGV2ZW50TmFtZSwgY2FsbGJhY2ssIHVzZUNhcHR1cmUpIHtcbiAgdmFyIGV2ZW50TmFtZVRvTGlzdGVuRm9yLCBsaXN0ZW5NZXRob2Q7XG4gIGxpc3Rlbk1ldGhvZCA9IHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lciA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdhdHRhY2hFdmVudCc7XG4gIGV2ZW50TmFtZVRvTGlzdGVuRm9yID0gdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyID8gZXZlbnROYW1lIDogXCJvblwiLmNvbmNhdChldmVudE5hbWUpO1xuICB0aGlzLmVsW2xpc3Rlbk1ldGhvZF0oZXZlbnROYW1lVG9MaXN0ZW5Gb3IsIGNhbGxiYWNrLCB1c2VDYXB0dXJlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZnVuY3Rpb24gZXZlbnRzIChRdWlja0VsZW1lbnQpIHtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5vbiA9IG9uXztcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5vbmNlID0gb25jZTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5vZmYgPSBvZmZfO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLmVtaXQgPSBlbWl0O1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLmVtaXRQcml2YXRlID0gZW1pdFByaXZhdGU7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX2ludm9rZUhhbmRsZXJzID0gX2ludm9rZUhhbmRsZXJzO1xuICByZXR1cm4gUXVpY2tFbGVtZW50LnByb3RvdHlwZS5fbGlzdGVuVG8gPSBfbGlzdGVuVG87XG59LyoqXG4gKiBTZXRzL2dldHMgdGhlIHZhbHVlIG9mIGEgc3R5bGUgcHJvcGVydHkuIEluIGdldHRlciBtb2RlIHRoZSBjb21wdXRlZCBwcm9wZXJ0eSBvZlxuICogdGhlIHN0eWxlIHdpbGwgYmUgcmV0dXJuZWQgdW5sZXNzIHRoZSBlbGVtZW50IGlzIG5vdCBpbnNlcnRlZCBpbnRvIHRoZSBET00uIEluXG4gKiB3ZWJraXQgYnJvd3NlcnMgYWxsIGNvbXB1dGVkIHByb3BlcnRpZXMgb2YgYSBkZXRhY2hlZCBub2RlIGFyZSBhbHdheXMgYW4gZW1wdHlcbiAqIHN0cmluZyBidXQgaW4gZ2Vja28gdGhleSByZWZsZWN0IG9uIHRoZSBhY3R1YWwgY29tcHV0ZWQgdmFsdWUsIGhlbmNlIHdlIG5lZWRcbiAqIHRvIFwibm9ybWFsaXplXCIgdGhpcyBiZWhhdmlvciBhbmQgbWFrZSBzdXJlIHRoYXQgZXZlbiBvbiBnZWNrbyBhbiBlbXB0eSBzdHJpbmdcbiAqIGlzIHJldHVybmVkXG4gKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cbiAqL1xuXG52YXIgc3R5bGUgPSBmdW5jdGlvbiBzdHlsZShwcm9wZXJ0eSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBhcmdzLCBpLCBrZXksIGtleXMsIHJlc3VsdCwgdmFsdWU7XG5cbiAgaWYgKHRoaXMudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYXJncyA9IGFyZ3VtZW50cztcblxuICBpZiAoSVMkMS5zdHJpbmcocHJvcGVydHkpKSB7XG4gICAgdmFsdWUgPSB0eXBlb2YgYXJnc1sxXSA9PT0gJ2Z1bmN0aW9uJyA/IGFyZ3NbMV0uY2FsbCh0aGlzLCB0aGlzLnJlbGF0ZWQpIDogYXJnc1sxXTtcblxuICAgIGlmIChhcmdzWzFdID09PSBudWxsICYmIElTJDEuZGVmaW5lZCh0aGlzLmN1cnJlbnRTdGF0ZVN0eWxlKHByb3BlcnR5KSkgJiYgIUlTJDEuZnVuY3Rpb24odGhpcy5jdXJyZW50U3RhdGVTdHlsZShwcm9wZXJ0eSkpKSB7XG4gICAgICB2YWx1ZSA9IGluZGV4LlVOU0VUO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFsdWUudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4KF90aGlzLmVsLCBwcm9wZXJ0eSwgdmFsdWUsIF90aGlzLm9wdGlvbnMuZm9yY2VTdHlsZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gaW5kZXgodGhpcy5lbCwgcHJvcGVydHksIHZhbHVlLCB0aGlzLm9wdGlvbnMuZm9yY2VTdHlsZSk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgaWYgKHRoaXMuX2luc2VydGVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2UgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoSVMkMS5vYmplY3QocHJvcGVydHkpKSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnR5KTtcbiAgICBpID0gLTE7XG5cbiAgICB3aGlsZSAoa2V5ID0ga2V5c1srK2ldKSB7XG4gICAgICB0aGlzLnN0eWxlKGtleSwgcHJvcGVydHlba2V5XSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuLyoqXG4qIEF0dGVtcHRzIHRvIHJlc29sdmUgdGhlIHZhbHVlIGZvciBhIGdpdmVuIHByb3BlcnR5IGluIHRoZSBmb2xsb3dpbmcgb3JkZXIgaWYgZWFjaCBvbmUgaXNuJ3QgYSB2YWxpZCB2YWx1ZTpcbiogMS4gZnJvbSBjb21wdXRlZCBzdHlsZSAoZm9yIGRvbS1pbnNlcnRlZCBlbHMpXG4qIDIuIGZyb20gRE9NRWxlbWVudC5zdHlsZSBvYmplY3QgKGZvciBub24taW5zZXJ0ZWQgZWxzOyBpZiBvcHRpb25zLnN0eWxlQWZ0ZXJJbnNlcnQsIHdpbGwgb25seSBoYXZlIHN0YXRlIHN0eWxlcylcbiogMy4gZnJvbSBwcm92aWRlZCBzdHlsZSBvcHRpb25zXG4qIChmb3Igbm9uLWluc2VydGVkIGVsczsgY2hlY2tpbmcgb25seSAkYmFzZSBzaW5jZSBzdGF0ZSBzdHlsZXMgd2lsbCBhbHdheXMgYmUgYXBwbGllZCB0byB0aGUgc3R5bGUgb2JqZWN0IGV2ZW4gZm9yIG5vbi1pbnNlcnRlZClcbiAqL1xuXG52YXIgc3R5bGVTYWZlID0gZnVuY3Rpb24gc3R5bGVTYWZlKHByb3BlcnR5LCBza2lwQ29tcHV0ZWQpIHtcbiAgdmFyIGNvbXB1dGVkLCByZXN1bHQsIHNhbXBsZTtcblxuICBpZiAodGhpcy50eXBlID09PSAndGV4dCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzYW1wbGUgPSB0aGlzLmVsLnN0eWxlW3Byb3BlcnR5XTtcblxuICBpZiAoSVMkMS5zdHJpbmcoc2FtcGxlKSB8fCBJUyQxLm51bWJlcihzYW1wbGUpKSB7XG4gICAgY29tcHV0ZWQgPSBza2lwQ29tcHV0ZWQgPyAwIDogdGhpcy5zdHlsZShwcm9wZXJ0eSk7XG4gICAgcmVzdWx0ID0gY29tcHV0ZWQgfHwgdGhpcy5lbC5zdHlsZVtwcm9wZXJ0eV0gfHwgdGhpcy5jdXJyZW50U3RhdGVTdHlsZShwcm9wZXJ0eSkgfHwgJyc7XG5cbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIHRoaXMucmVsYXRlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIHN0eWxlUGFyc2VkID0gZnVuY3Rpb24gc3R5bGVQYXJzZWQocHJvcGVydHksIHNraXBDb21wdXRlZCkge1xuICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLnN0eWxlU2FmZShwcm9wZXJ0eSwgc2tpcENvbXB1dGVkKSk7XG59O1xudmFyIHJlY2FsY1N0eWxlID0gZnVuY3Rpb24gcmVjYWxjU3R5bGUocmVjYWxjQ2hpbGRyZW4pIHtcbiAgdmFyIGNoaWxkLCBqLCBsZW4sIHJlZiwgdGFyZ2V0U3R5bGVzO1xuICB0YXJnZXRTdHlsZXMgPSB0aGlzLl9yZXNvbHZlRm5TdHlsZXModGhpcy5fZ2V0QWN0aXZlU3RhdGVzKCksIHRydWUpO1xuICB0aGlzLnN0eWxlKHRhcmdldFN0eWxlcyk7XG5cbiAgaWYgKHJlY2FsY0NoaWxkcmVuKSB7XG4gICAgcmVmID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIGNoaWxkID0gcmVmW2pdO1xuICAgICAgY2hpbGQucmVjYWxjU3R5bGUoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgY3VycmVudFN0YXRlU3R5bGUgPSBmdW5jdGlvbiBjdXJyZW50U3RhdGVTdHlsZShwcm9wZXJ0eSkge1xuICB2YXIgaSwgc3RhdGUsIHN0YXRlcztcblxuICBpZiAocHJvcGVydHkpIHtcbiAgICBpZiAodGhpcy5fc3RhdGUubGVuZ3RoKSB7XG4gICAgICBzdGF0ZXMgPSB0aGlzLl9zdGF0ZS5zbGljZSgpO1xuXG4gICAgICBpZiAodGhpcy5fc3RhdGVTaGFyZWQgJiYgdGhpcy5fc3RhdGVTaGFyZWQubGVuZ3RoKSB7XG4gICAgICAgIHZhciBfc3RhdGVzO1xuXG4gICAgICAgIChfc3RhdGVzID0gc3RhdGVzKS5wdXNoLmFwcGx5KF9zdGF0ZXMsIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLl9zdGF0ZVNoYXJlZCkpO1xuICAgICAgfVxuXG4gICAgICBpID0gc3RhdGVzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKHN0YXRlID0gc3RhdGVzWy0taV0pIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0eWxlc1tzdGF0ZV0gJiYgSVMkMS5kZWZpbmVkKHRoaXMuX3N0eWxlc1tzdGF0ZV0ucnVsZVtwcm9wZXJ0eV0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3N0eWxlc1tzdGF0ZV0ucnVsZVtwcm9wZXJ0eV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3R5bGVzLmJhc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdHlsZXMuYmFzZS5ydWxlW3Byb3BlcnR5XTtcbiAgICB9XG4gIH1cbn07XG52YXIgaGlkZSA9IGZ1bmN0aW9uIGhpZGUoKSB7XG4gIHJldHVybiB0aGlzLnN0eWxlKCdkaXNwbGF5JywgJ25vbmUnKTtcbn07XG52YXIgc2hvdyA9IGZ1bmN0aW9uIHNob3coZGlzcGxheSkge1xuICB2YXIgcmVmO1xuXG4gIGlmICghZGlzcGxheSkge1xuICAgIGRpc3BsYXkgPSB0aGlzLmN1cnJlbnRTdGF0ZVN0eWxlKCdkaXNwbGF5Jyk7XG5cbiAgICBpZiAoZGlzcGxheSA9PT0gJ25vbmUnIHx8ICFkaXNwbGF5KSB7XG4gICAgICBkaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICB9XG4gIH1cblxuICBpZiAoZGlzcGxheSA9PSBudWxsKSB7XG4gICAgZGlzcGxheSA9ICgocmVmID0gdGhpcy5fc3R5bGVzLmJhc2UpICE9IG51bGwgPyByZWYuZGlzcGxheSA6IHZvaWQgMCkgfHwgJ2Jsb2NrJztcbiAgfVxuXG4gIHJldHVybiB0aGlzLnN0eWxlKCdkaXNwbGF5JywgZGlzcGxheSk7XG59O1xudmFyIG9yaWVudGF0aW9uR2V0dGVyID0ge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy53aWR0aCA+IHRoaXMuaGVpZ2h0KSB7XG4gICAgICByZXR1cm4gJ2xhbmRzY2FwZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAncG9ydHJhaXQnO1xuICAgIH1cbiAgfVxufTtcbnZhciBhc3BlY3RSYXRpb0dldHRlciA9IHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMud2lkdGggLyB0aGlzLmhlaWdodDtcbiAgfVxufTtcbmZ1bmN0aW9uIHN0eWxlJDEgKFF1aWNrRWxlbWVudCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhRdWlja0VsZW1lbnQucHJvdG90eXBlLCB7XG4gICAgJ29yaWVudGF0aW9uJzogb3JpZW50YXRpb25HZXR0ZXIsXG4gICAgJ2FzcGVjdFJhdGlvJzogYXNwZWN0UmF0aW9HZXR0ZXIsXG4gICAgJ3JlY3QnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAnd2lkdGgnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy5zdHlsZSgnd2lkdGgnKSk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUoJ3dpZHRoJywgdmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2hlaWdodCc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLnN0eWxlKCdoZWlnaHQnKSk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUoJ2hlaWdodCcsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnN0eWxlID0gc3R5bGU7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuc3R5bGVTYWZlID0gc3R5bGVTYWZlO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnN0eWxlUGFyc2VkID0gc3R5bGVQYXJzZWQ7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUucmVjYWxjU3R5bGUgPSByZWNhbGNTdHlsZTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5jdXJyZW50U3RhdGVTdHlsZSA9IGN1cnJlbnRTdGF0ZVN0eWxlO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLmhpZGUgPSBoaWRlO1xuICByZXR1cm4gUXVpY2tFbGVtZW50LnByb3RvdHlwZS5zaG93ID0gc2hvdztcbn12YXIgUXVpY2tXaW5kb3ckMTtcbnZhciBRdWlja1dpbmRvdyQyID0gUXVpY2tXaW5kb3ckMSA9IHtcbiAgdHlwZTogJ3dpbmRvdycsXG4gIGVsOiB3aW5kb3csXG4gIHJhdzogd2luZG93LFxuICBfZXZlbnRDYWxsYmFja3M6IHtcbiAgICBfX3JlZnM6IHt9XG4gIH1cbn07XG5RdWlja1dpbmRvdyQxLm9uID0gb25fO1xuUXVpY2tXaW5kb3ckMS5vZmYgPSBvZmZfO1xuUXVpY2tXaW5kb3ckMS5lbWl0ID0gZW1pdDtcblF1aWNrV2luZG93JDEuZW1pdFByaXZhdGUgPSBlbWl0UHJpdmF0ZTtcblF1aWNrV2luZG93JDEuX2xpc3RlblRvID0gX2xpc3RlblRvO1xuUXVpY2tXaW5kb3ckMS5faW52b2tlSGFuZGxlcnMgPSBfaW52b2tlSGFuZGxlcnM7XG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhRdWlja1dpbmRvdyQxLCB7XG4gICd3aWR0aCc6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICB9XG4gIH0sXG4gICdoZWlnaHQnOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIH1cbiAgfSxcbiAgJ29yaWVudGF0aW9uJzogb3JpZW50YXRpb25HZXR0ZXIsXG4gICdhc3BlY3RSYXRpbyc6IGFzcGVjdFJhdGlvR2V0dGVyXG59KTt2YXIgTWVkaWFRdWVyeSwgUlVMRV9ERUlMSU1JVEVSO1xuUlVMRV9ERUlMSU1JVEVSID0gLyxcXHMqLztcbnZhciBNZWRpYVF1ZXJ5JDEgPSBNZWRpYVF1ZXJ5ID0gbmV3IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNhbGxiYWNrcywgdGVzdFJ1bGU7XG4gIGNhbGxiYWNrcyA9IFtdO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYWxsYmFjaywgaSwgbGVuO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrc1tpXTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9KTtcblxuICB0aGlzLnBhcnNlUXVlcnkgPSBmdW5jdGlvbiAodGFyZ2V0LCBxdWVyeVN0cmluZykge1xuICAgIHZhciBxdWVyeVNwbGl0LCBydWxlcywgc291cmNlO1xuICAgIHF1ZXJ5U3BsaXQgPSBxdWVyeVN0cmluZy5zcGxpdCgnKCcpO1xuICAgIHNvdXJjZSA9IHF1ZXJ5U3BsaXRbMF07XG5cbiAgICBzb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzd2l0Y2ggKHNvdXJjZSkge1xuICAgICAgICBjYXNlICd3aW5kb3cnOlxuICAgICAgICAgIHJldHVybiBRdWlja1dpbmRvdyQyO1xuXG4gICAgICAgIGNhc2UgJ3BhcmVudCc6XG4gICAgICAgICAgcmV0dXJuIHRhcmdldC5wYXJlbnQ7XG5cbiAgICAgICAgY2FzZSAnc2VsZic6XG4gICAgICAgICAgcmV0dXJuIHRhcmdldDtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB0YXJnZXQucGFyZW50TWF0Y2hpbmcoZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5yZWYgPT09IHNvdXJjZS5zbGljZSgxKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KCk7XG5cbiAgICBydWxlcyA9IHF1ZXJ5U3BsaXRbMV0uc2xpY2UoMCwgLTEpLnNwbGl0KFJVTEVfREVJTElNSVRFUikubWFwKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICB2YXIgZ2V0dGVyLCBrZXksIGtleVByZWZpeCwgbWF4LCBtaW4sIHNwbGl0LCB2YWx1ZTtcbiAgICAgIHNwbGl0ID0gcnVsZS5zcGxpdCgnOicpO1xuICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHNwbGl0WzFdKTtcblxuICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHNwbGl0WzFdO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSBzcGxpdFswXTtcbiAgICAgIGtleVByZWZpeCA9IGtleS5zbGljZSgwLCA0KTtcbiAgICAgIG1heCA9IGtleVByZWZpeCA9PT0gJ21heC0nO1xuICAgICAgbWluID0gIW1heCAmJiBrZXlQcmVmaXggPT09ICdtaW4tJztcblxuICAgICAgaWYgKG1heCB8fCBtaW4pIHtcbiAgICAgICAga2V5ID0ga2V5LnNsaWNlKDQpO1xuICAgICAgfVxuXG4gICAgICBnZXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgY2FzZSAnb3JpZW50YXRpb24nOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5vcmllbnRhdGlvbjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICBjYXNlICdhc3BlY3QtcmF0aW8nOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5hc3BlY3RSYXRpbztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICBjYXNlICd3aWR0aCc6XG4gICAgICAgICAgY2FzZSAnaGVpZ2h0JzpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcnNlZFZhbHVlLCBzdHJpbmdWYWx1ZTtcbiAgICAgICAgICAgICAgc3RyaW5nVmFsdWUgPSBzb3VyY2Uuc3R5bGUoa2V5KTtcbiAgICAgICAgICAgICAgcGFyc2VkVmFsdWUgPSBwYXJzZUZsb2F0KHN0cmluZ1ZhbHVlKTtcblxuICAgICAgICAgICAgICBpZiAoaXNOYU4ocGFyc2VkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWRWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSgpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBtaW46IG1pbixcbiAgICAgICAgbWF4OiBtYXgsXG4gICAgICAgIGdldHRlcjogZ2V0dGVyXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIHJ1bGVzOiBydWxlc1xuICAgIH07XG4gIH07XG5cbiAgdGhpcy5yZWdpc3RlciA9IGZ1bmN0aW9uICh0YXJnZXQsIHF1ZXJ5U3RyaW5nKSB7XG4gICAgdmFyIGNhbGxiYWNrLCBxdWVyeTtcbiAgICBxdWVyeSA9IHRoaXMucGFyc2VRdWVyeSh0YXJnZXQsIHF1ZXJ5U3RyaW5nKTtcblxuICAgIGlmIChxdWVyeS5zb3VyY2UpIHtcbiAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2soKSB7XG4gICAgICAgIHJldHVybiB0ZXN0UnVsZSh0YXJnZXQsIHF1ZXJ5LCBxdWVyeVN0cmluZyk7XG4gICAgICB9KTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1ZXJ5O1xuICB9O1xuXG4gIHRlc3RSdWxlID0gZnVuY3Rpb24gdGVzdFJ1bGUodGFyZ2V0LCBxdWVyeSwgcXVlcnlTdHJpbmcpIHtcbiAgICB2YXIgY3VycmVudFZhbHVlLCBpLCBsZW4sIHBhc3NlZCwgcmVmLCBydWxlO1xuICAgIHBhc3NlZCA9IHRydWU7XG4gICAgcmVmID0gcXVlcnkucnVsZXM7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHJ1bGUgPSByZWZbaV07XG4gICAgICBjdXJyZW50VmFsdWUgPSBydWxlLmdldHRlcigpO1xuXG4gICAgICBwYXNzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAoZmFsc2UpIHtcbiAgICAgICAgICBjYXNlICFydWxlLm1pbjpcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50VmFsdWUgPj0gcnVsZS52YWx1ZTtcblxuICAgICAgICAgIGNhc2UgIXJ1bGUubWF4OlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZSA8PSBydWxlLnZhbHVlO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50VmFsdWUgPT09IHJ1bGUudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0oKTtcblxuICAgICAgaWYgKCFwYXNzZWQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldC5zdGF0ZShxdWVyeVN0cmluZywgcGFzc2VkKTtcbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn0oKTt2YXIgU3RhdGVDaGFpbjtcbnZhciBTdGF0ZUNoYWluJDEgPSBTdGF0ZUNoYWluID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3RhdGVDaGFpbihzdGF0ZXMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RhdGVDaGFpbik7XG5cbiAgICB0aGlzLnN0cmluZyA9IHN0YXRlcy5qb2luKCcrJyk7XG4gICAgdGhpcy5hcnJheSA9IHN0YXRlcy5zbGljZSgpO1xuICAgIHRoaXMubGVuZ3RoID0gc3RhdGVzLmxlbmd0aDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTdGF0ZUNoYWluLCBbe1xuICAgIGtleTogXCJpbmNsdWRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmNsdWRlcyh0YXJnZXQpIHtcbiAgICAgIHZhciBpLCBsZW4sIHJlZiwgc3RhdGU7XG4gICAgICByZWYgPSB0aGlzLmFycmF5O1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc3RhdGUgPSByZWZbaV07XG5cbiAgICAgICAgaWYgKHN0YXRlID09PSB0YXJnZXQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhvdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2l0aG91dCh0YXJnZXQpIHtcbiAgICAgIHJldHVybiB0aGlzLmFycmF5LmZpbHRlcihmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlICE9PSB0YXJnZXQ7XG4gICAgICB9KS5qb2luKCcrJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzQXBwbGljYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0FwcGxpY2FibGUodGFyZ2V0LCBvdGhlckFjdGl2ZSkge1xuICAgICAgdmFyIGFjdGl2ZTtcbiAgICAgIGFjdGl2ZSA9IHRoaXMuYXJyYXkuZmlsdGVyKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICByZXR1cm4gc3RhdGUgPT09IHRhcmdldCB8fCBvdGhlckFjdGl2ZS5pbmRleE9mKHN0YXRlKSAhPT0gLTE7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY3RpdmUubGVuZ3RoID09PSB0aGlzLmFycmF5Lmxlbmd0aDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3RhdGVDaGFpbjtcbn0oKTt2YXIgQkFTRV9TVEFURV9UUklHR0VSUywgQ0FDSEVEX0ZOX0lOU0VSVEVEO1xuQkFTRV9TVEFURV9UUklHR0VSUyA9IHtcbiAgJ2hvdmVyJzoge1xuICAgIG9uOiAnbW91c2VlbnRlcicsXG4gICAgb2ZmOiAnbW91c2VsZWF2ZScsXG4gICAgYnViYmxlczogdHJ1ZVxuICB9LFxuICAnZm9jdXMnOiB7XG4gICAgb246ICdmb2N1cycsXG4gICAgb2ZmOiAnYmx1cicsXG4gICAgYnViYmxlczogdHJ1ZVxuICB9XG59O1xudmFyIF9ub3JtYWxpemVPcHRpb25zID0gZnVuY3Rpb24gX25vcm1hbGl6ZU9wdGlvbnMoKSB7XG4gIHZhciBiYXNlMSwgYmFzZTIsIGJhc2UzLCBiYXNlNCwgYmFzZTU7XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5yZWxhdGVkSW5zdGFuY2UpIHtcbiAgICAoYmFzZTEgPSB0aGlzLm9wdGlvbnMpLnJlbGF0ZWQgfHwgKGJhc2UxLnJlbGF0ZWQgPSB0aGlzLm9wdGlvbnMucmVsYXRlZEluc3RhbmNlKTtcbiAgICB0aGlzLm9wdGlvbnMucmVsYXRlZEluc3RhbmNlID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMucmVsYXRlZCA9IChiYXNlMiA9IHRoaXMub3B0aW9ucykucmVsYXRlZCAhPSBudWxsID8gYmFzZTIucmVsYXRlZCA6IGJhc2UyLnJlbGF0ZWQgPSB0aGlzO1xuXG4gIGlmICh0aGlzLm9wdGlvbnMuY2xhc3MpIHtcbiAgICB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lID0gdGhpcy5vcHRpb25zLmNsYXNzO1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy51cmwpIHtcbiAgICB0aGlzLm9wdGlvbnMuaHJlZiA9IHRoaXMub3B0aW9ucy51cmw7XG4gIH1cblxuICBpZiAoKGJhc2UzID0gdGhpcy5vcHRpb25zKS51bnBhc3NhYmxlU3RhdGVzID09IG51bGwpIHtcbiAgICBiYXNlMy51bnBhc3NhYmxlU3RhdGVzID0gW107XG4gIH1cblxuICBpZiAoKGJhc2U0ID0gdGhpcy5vcHRpb25zKS5wYXNzU3RhdGVUb0NoaWxkcmVuID09IG51bGwpIHtcbiAgICBiYXNlNC5wYXNzU3RhdGVUb0NoaWxkcmVuID0gdHJ1ZTtcbiAgfVxuXG4gIGlmICgoYmFzZTUgPSB0aGlzLm9wdGlvbnMpLnBhc3NEYXRhVG9DaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgYmFzZTUucGFzc0RhdGFUb0NoaWxkcmVuID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMub3B0aW9ucy5zdGF0ZVRyaWdnZXJzID0gdGhpcy5vcHRpb25zLnN0YXRlVHJpZ2dlcnMgPyBwcmltYXJ5QnVpbGRlciQxLmNsb25lLmRlZXAoQkFTRV9TVEFURV9UUklHR0VSUywgdGhpcy5vcHRpb25zLnN0YXRlVHJpZ2dlcnMpIDogQkFTRV9TVEFURV9UUklHR0VSUztcblxuICBpZiAodGhpcy50eXBlID09PSAndGV4dCcpIHtcbiAgICBwcmltYXJ5QnVpbGRlciQxKHRoaXMsIHRoaXMuX3BhcnNlVGV4dHModGhpcy5vcHRpb25zLnRleHQsIHRoaXMuX3RleHRzKSk7XG4gIH0gZWxzZSB7XG4gICAgcHJpbWFyeUJ1aWxkZXIkMSh0aGlzLCB0aGlzLl9wYXJzZVN0eWxlcyh0aGlzLm9wdGlvbnMuc3R5bGUsIHRoaXMuX3N0eWxlcykpO1xuICB9XG59O1xudmFyIF9wYXJzZVN0eWxlcyA9IGZ1bmN0aW9uIF9wYXJzZVN0eWxlcyhzdHlsZXMsIHN0b3JlKSB7XG4gIHZhciBfbWVkaWFTdGF0ZXMsIF9wcm92aWRlZFN0YXRlcywgX3Byb3ZpZGVkU3RhdGVzU2hhcmVkLCBfc3RhdGVTaGFyZWQsIF9zdHlsZXMsIGJhc2UsIF9mbGF0dGVuTmVzdGVkU3RhdGVzLCBmb3JjZVN0eWxlLCBpLCBrZXlzLCBsZW4sIHNwZWNpYWxTdGF0ZXMsIHN0YXRlLCBzdGF0ZVN0eWxlcywgc3RhdGVfLCBzdGF0ZXM7XG5cbiAgaWYgKCFJUyQxLm9iamVjdFBsYWluKHN0eWxlcykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBrZXlzID0gT2JqZWN0LmtleXMoc3R5bGVzKTtcbiAgc3RhdGVzID0ga2V5cy5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBpc1N0YXRlU3R5bGUoa2V5KTtcbiAgfSk7XG4gIHNwZWNpYWxTdGF0ZXMgPSByZW1vdmVJdGVtKHN0YXRlcy5zbGljZSgpLCAnJGJhc2UnKTtcbiAgX21lZGlhU3RhdGVzID0gc3RhdGVzLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGtleVswXSA9PT0gJ0AnO1xuICB9KS5tYXAoZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLnNsaWNlKDEpO1xuICB9KTtcbiAgX3Byb3ZpZGVkU3RhdGVzID0gc3RhdGVzLm1hcChmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUuc2xpY2UoMSk7IC8vIFJlbW92ZSAnJCcgcHJlZml4XG4gIH0pO1xuICBfc3R5bGVzID0gc3RvcmUgfHwge307XG4gIF9zdGF0ZVNoYXJlZCA9IF9wcm92aWRlZFN0YXRlc1NoYXJlZCA9IHZvaWQgMDtcbiAgYmFzZSA9ICFpbmNsdWRlcyQxKHN0YXRlcywgJyRiYXNlJykgPyBzdHlsZXMgOiBzdHlsZXMuJGJhc2U7XG4gIF9zdHlsZXMuYmFzZSA9IHJlZ2lzdGVyU3R5bGUoYmFzZSwgMCwgZm9yY2VTdHlsZSA9IHRoaXMub3B0aW9ucy5mb3JjZVN0eWxlKTtcblxuICBpZiAoc3BlY2lhbFN0YXRlcy5sZW5ndGgpIHtcbiAgICBfZmxhdHRlbk5lc3RlZFN0YXRlcyA9IGZ1bmN0aW9uIGZsYXR0ZW5OZXN0ZWRTdGF0ZXMoc3R5bGVPYmplY3QsIGNoYWluLCBsZXZlbCkge1xuICAgICAgdmFyIGhhc05vblN0YXRlUHJvcHMsIGksIGxlbiwgb3V0cHV0LCBzdGF0ZSwgc3RhdGVDaGFpbiwgc3RhdGVfLCBzdHlsZUtleXM7XG4gICAgICBzdHlsZUtleXMgPSBPYmplY3Qua2V5cyhzdHlsZU9iamVjdCk7XG4gICAgICBvdXRwdXQgPSB7fTtcbiAgICAgIGhhc05vblN0YXRlUHJvcHMgPSBmYWxzZTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gc3R5bGVLZXlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHN0YXRlID0gc3R5bGVLZXlzW2ldO1xuXG4gICAgICAgIGlmICghaXNTdGF0ZVN0eWxlKHN0YXRlKSkge1xuICAgICAgICAgIGhhc05vblN0YXRlUHJvcHMgPSB0cnVlO1xuICAgICAgICAgIG91dHB1dFtzdGF0ZV0gPSBzdHlsZU9iamVjdFtzdGF0ZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hhaW4ucHVzaChzdGF0ZV8gPSBzdGF0ZS5zbGljZSgxKSk7XG4gICAgICAgICAgc3RhdGVDaGFpbiA9IG5ldyBTdGF0ZUNoYWluJDEoY2hhaW4pO1xuXG4gICAgICAgICAgaWYgKF9zdGF0ZVNoYXJlZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBfc3RhdGVTaGFyZWQgPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX3Byb3ZpZGVkU3RhdGVzU2hhcmVkID09IG51bGwpIHtcbiAgICAgICAgICAgIF9wcm92aWRlZFN0YXRlc1NoYXJlZCA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9wcm92aWRlZFN0YXRlc1NoYXJlZC5wdXNoKHN0YXRlQ2hhaW4pO1xuXG4gICAgICAgICAgaWYgKHN0YXRlWzBdID09PSAnQCcpIHtcbiAgICAgICAgICAgIF9tZWRpYVN0YXRlcy5wdXNoKHN0YXRlXyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3N0eWxlc1tzdGF0ZUNoYWluLnN0cmluZ10gPSByZWdpc3RlclN0eWxlKF9mbGF0dGVuTmVzdGVkU3RhdGVzKHN0eWxlT2JqZWN0W3N0YXRlXSwgY2hhaW4sIGxldmVsICsgMSksIGxldmVsICsgMSwgZm9yY2VTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGhhc05vblN0YXRlUHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gc3BlY2lhbFN0YXRlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgc3RhdGUgPSBzcGVjaWFsU3RhdGVzW2ldO1xuICAgICAgc3RhdGVfID0gc3RhdGUuc2xpY2UoMSk7XG4gICAgICBzdGF0ZVN0eWxlcyA9IF9mbGF0dGVuTmVzdGVkU3RhdGVzKHN0eWxlc1tzdGF0ZV0sIFtzdGF0ZV9dLCAxKTtcblxuICAgICAgaWYgKHN0YXRlU3R5bGVzKSB7XG4gICAgICAgIF9zdHlsZXNbc3RhdGVfXSA9IHJlZ2lzdGVyU3R5bGUoc3RhdGVTdHlsZXMsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgX3N0eWxlczogX3N0eWxlcyxcbiAgICBfbWVkaWFTdGF0ZXM6IF9tZWRpYVN0YXRlcyxcbiAgICBfc3RhdGVTaGFyZWQ6IF9zdGF0ZVNoYXJlZCxcbiAgICBfcHJvdmlkZWRTdGF0ZXM6IF9wcm92aWRlZFN0YXRlcyxcbiAgICBfcHJvdmlkZWRTdGF0ZXNTaGFyZWQ6IF9wcm92aWRlZFN0YXRlc1NoYXJlZFxuICB9O1xufTtcbnZhciBfcGFyc2VUZXh0cyA9IGZ1bmN0aW9uIF9wYXJzZVRleHRzKHRleHRzLCBzdG9yZSkge1xuICB2YXIgX3Byb3ZpZGVkU3RhdGVzLCBfdGV4dHMsIGksIGxlbiwgc3RhdGUsIHN0YXRlcztcblxuICBpZiAoIUlTJDEub2JqZWN0UGxhaW4odGV4dHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RhdGVzID0gT2JqZWN0LmtleXModGV4dHMpLm1hcChmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUuc2xpY2UoMSk7XG4gIH0pO1xuICBfcHJvdmlkZWRTdGF0ZXMgPSBzdGF0ZXMuZmlsdGVyKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZSAhPT0gJ2Jhc2UnO1xuICB9KTtcbiAgX3RleHRzID0gc3RvcmUgfHwge307XG4gIF90ZXh0cyA9IHtcbiAgICBiYXNlOiAnJ1xuICB9O1xuXG4gIGZvciAoaSA9IDAsIGxlbiA9IHN0YXRlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHN0YXRlID0gc3RhdGVzW2ldO1xuICAgIF90ZXh0c1tzdGF0ZV0gPSB0ZXh0c1snJCcgKyBzdGF0ZV07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIF90ZXh0czogX3RleHRzLFxuICAgIF9wcm92aWRlZFN0YXRlczogX3Byb3ZpZGVkU3RhdGVzXG4gIH07XG59O1xudmFyIF9hcHBseU9wdGlvbnMgPSBmdW5jdGlvbiBfYXBwbHlPcHRpb25zKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBldmVudCwgaGFuZGxlciwgbWV0aG9kLCByZWYsIHJlZjEsIHJlZjIsIHZhbHVlO1xuXG4gIGlmIChyZWYgPSB0aGlzLm9wdGlvbnMuaWQgfHwgdGhpcy5vcHRpb25zLnJlZikge1xuICAgIHRoaXMuYXR0cignZGF0YS1yZWYnLCB0aGlzLnJlZiA9IHJlZik7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLmlkKSB7XG4gICAgdGhpcy5lbC5pZCA9IHRoaXMub3B0aW9ucy5pZDtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKSB7XG4gICAgdGhpcy5lbC5jbGFzc05hbWUgPSB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lO1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5zcmMpIHtcbiAgICB0aGlzLmVsLnNyYyA9IHRoaXMub3B0aW9ucy5zcmM7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLmhyZWYpIHtcbiAgICB0aGlzLmVsLmhyZWYgPSB0aGlzLm9wdGlvbnMuaHJlZjtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMudHlwZSkge1xuICAgIHRoaXMuZWwudHlwZSA9IHRoaXMub3B0aW9ucy50eXBlO1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5uYW1lKSB7XG4gICAgdGhpcy5lbC5uYW1lID0gdGhpcy5vcHRpb25zLm5hbWU7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLnZhbHVlKSB7XG4gICAgdGhpcy5lbC52YWx1ZSA9IHRoaXMub3B0aW9ucy52YWx1ZTtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMuc2VsZWN0ZWQpIHtcbiAgICB0aGlzLmVsLnNlbGVjdGVkID0gdGhpcy5vcHRpb25zLnNlbGVjdGVkO1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5jaGVja2VkKSB7XG4gICAgdGhpcy5lbC5jaGVja2VkID0gdGhpcy5vcHRpb25zLmNoZWNrZWQ7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLnByb3BzKSB7XG4gICAgdGhpcy5wcm9wKHRoaXMub3B0aW9ucy5wcm9wcyk7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLmF0dHJzKSB7XG4gICAgdGhpcy5hdHRyKHRoaXMub3B0aW9ucy5hdHRycyk7XG4gIH1cblxuICB0aGlzLl9hcHBseVJlZ2lzdGVyZWRTdHlsZSh0aGlzLl9zdHlsZXMuYmFzZSwgbnVsbCwgbnVsbCwgdGhpcy5vcHRpb25zLnN0eWxlQWZ0ZXJJbnNlcnQpO1xuXG4gIGlmICh0aGlzLl90ZXh0cykge1xuICAgIHRoaXMudGV4dCA9IHRoaXMuX3RleHRzLmJhc2U7XG4gIH1cblxuICB0aGlzLm9uKCdpbnNlcnRlZCcsIENBQ0hFRF9GTl9JTlNFUlRFRCwgZmFsc2UsIHRydWUpO1xuXG4gIGlmICh0aGlzLm9wdGlvbnMuaW52b2tlQ29tcHV0ZXJzT25jZSkge1xuICAgIHRoaXMuX2ludm9rZWRDb21wdXRlcnMgPSB7fTtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMucmVjYWxjT25SZXNpemUpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnJlY2FsY1N0eWxlKCk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLmV2ZW50cykge1xuICAgIHJlZjEgPSB0aGlzLm9wdGlvbnMuZXZlbnRzO1xuXG4gICAgZm9yIChldmVudCBpbiByZWYxKSB7XG4gICAgICBoYW5kbGVyID0gcmVmMVtldmVudF07XG4gICAgICB0aGlzLm9uKGV2ZW50LCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLm1ldGhvZHMpIHtcbiAgICByZWYyID0gdGhpcy5vcHRpb25zLm1ldGhvZHM7XG5cbiAgICBmb3IgKG1ldGhvZCBpbiByZWYyKSB7XG4gICAgICB2YWx1ZSA9IHJlZjJbbWV0aG9kXTtcblxuICAgICAgaWYgKCF0aGlzW21ldGhvZF0pIHtcbiAgICAgICAgaWYgKElTJDEuZnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgdGhpc1ttZXRob2RdID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoSVMkMS5vYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIG1ldGhvZCwge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiB2YWx1ZS5nZXQsXG4gICAgICAgICAgICBzZXQ6IHZhbHVlLnNldFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMudHlwZSAhPT0gJ3RleHQnICYmIElTJDEub2JqZWN0KHRoaXMub3B0aW9ucy50ZXh0KSkge1xuICAgIHRoaXMuYXBwZW5kKF9xdWlja2RvbSgndGV4dCcsIHtcbiAgICAgIHRleHQ6IHRoaXMub3B0aW9ucy50ZXh0XG4gICAgfSkpO1xuICB9XG59O1xudmFyIF9wb3N0Q3JlYXRpb24gPSBmdW5jdGlvbiBfcG9zdENyZWF0aW9uKGRhdGEpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5jb21wdXRlcnMpIHtcbiAgICBpZiAoZGF0YSAmJiB0aGlzLm9wdGlvbnMuZGF0YSkge1xuICAgICAgZGF0YSA9IHByaW1hcnlCdWlsZGVyJDEuY2xvbmUodGhpcy5vcHRpb25zLmRhdGEsIGRhdGEpO1xuICAgIH1cblxuICAgIGRhdGEgfHwgKGRhdGEgPSB0aGlzLm9wdGlvbnMuZGF0YSk7XG4gICAgdGhpcy5hcHBseURhdGEoZGF0YSwgZmFsc2UpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb21wdXRlcnMuX2luaXQpIHtcbiAgICAgIHRoaXMuX3J1bkNvbXB1dGVyKCdfaW5pdCcsIGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMuc3RhdGUpIHtcbiAgICB0aGlzLnN0YXRlKHRoaXMub3B0aW9ucy5zdGF0ZSk7XG4gIH1cbn07XG52YXIgX2F0dGFjaFN0YXRlRXZlbnRzID0gZnVuY3Rpb24gX2F0dGFjaFN0YXRlRXZlbnRzKGZvcmNlKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIHZhciBzdGF0ZXM7XG4gIHN0YXRlcyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5zdGF0ZVRyaWdnZXJzKTtcbiAgc3RhdGVzLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgdmFyIGRpc2FibGVyLCBlbmFibGVyLCB0cmlnZ2VyO1xuICAgIHRyaWdnZXIgPSBfdGhpczIub3B0aW9ucy5zdGF0ZVRyaWdnZXJzW3N0YXRlXTtcblxuICAgIGlmICghaW5jbHVkZXMkMShfdGhpczIuX3Byb3ZpZGVkU3RhdGVzLCBzdGF0ZSkgJiYgIWZvcmNlICYmICF0cmlnZ2VyLmZvcmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZW5hYmxlciA9IElTJDEuc3RyaW5nKHRyaWdnZXIpID8gdHJpZ2dlciA6IHRyaWdnZXIub247XG5cbiAgICBpZiAoSVMkMS5vYmplY3QodHJpZ2dlcikpIHtcbiAgICAgIGRpc2FibGVyID0gdHJpZ2dlci5vZmY7XG4gICAgfVxuXG4gICAgX3RoaXMyLl9saXN0ZW5UbyhlbmFibGVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMyLnN0YXRlKHN0YXRlLCB0cnVlLCB0cmlnZ2VyLmJ1YmJsZXMpO1xuICAgIH0pO1xuXG4gICAgaWYgKGRpc2FibGVyKSB7XG4gICAgICByZXR1cm4gX3RoaXMyLl9saXN0ZW5UbyhkaXNhYmxlciwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLnN0YXRlKHN0YXRlLCBmYWxzZSwgdHJpZ2dlci5idWJibGVzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59O1xudmFyIF9wcm94eVBhcmVudCA9IGZ1bmN0aW9uIF9wcm94eVBhcmVudCgpIHtcbiAgdmFyIHBhcmVudDtcbiAgcGFyZW50ID0gdm9pZCAwO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfcGFyZW50Jywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld1BhcmVudCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBsYXN0UGFyZW50O1xuXG4gICAgICBpZiAocGFyZW50ID0gbmV3UGFyZW50KSB7XG4gICAgICAgIGxhc3RQYXJlbnQgPSB0aGlzLnBhcmVudHMuc2xpY2UoLTEpWzBdO1xuXG4gICAgICAgIGlmIChsYXN0UGFyZW50LnJhdyA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgdGhpcy5fdW5wcm94eVBhcmVudChuZXdQYXJlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmVudC5vbignaW5zZXJ0ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50ID09PSBuZXdQYXJlbnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5fdW5wcm94eVBhcmVudChuZXdQYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG52YXIgX3VucHJveHlQYXJlbnQgPSBmdW5jdGlvbiBfdW5wcm94eVBhcmVudChuZXdQYXJlbnQpIHtcbiAgZGVsZXRlIHRoaXMuX3BhcmVudDtcbiAgdGhpcy5fcGFyZW50ID0gbmV3UGFyZW50O1xuICB0aGlzLmVtaXRQcml2YXRlKCdpbnNlcnRlZCcsIG5ld1BhcmVudCk7XG59O1xuXG5DQUNIRURfRk5fSU5TRVJURUQgPSBmdW5jdGlvbiBDQUNIRURfRk5fSU5TRVJURUQoKSB7XG4gIHZhciBpLCBsZW4sIG1lZGlhU3RhdGVzLCBxdWVyeVN0cmluZywgcmVzdWx0cztcbiAgdGhpcy5faW5zZXJ0ZWQgPSB0aGlzO1xuXG4gIGlmICh0aGlzLm9wdGlvbnMuc3R5bGVBZnRlckluc2VydCkge1xuICAgIHRoaXMucmVjYWxjU3R5bGUoKTtcbiAgfVxuXG4gIGlmICgobWVkaWFTdGF0ZXMgPSB0aGlzLl9tZWRpYVN0YXRlcykgJiYgdGhpcy5fbWVkaWFTdGF0ZXMubGVuZ3RoKSB7XG4gICAgdGhpcy5fbWVkaWFTdGF0ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJlc3VsdHMgPSBbXTtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IG1lZGlhU3RhdGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBxdWVyeVN0cmluZyA9IG1lZGlhU3RhdGVzW2ldO1xuICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuX21lZGlhU3RhdGVzW3F1ZXJ5U3RyaW5nXSA9IE1lZGlhUXVlcnkkMS5yZWdpc3Rlcih0aGlzLCBxdWVyeVN0cmluZykpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG59O1xuXG5mdW5jdGlvbiBpbml0JDEgKFF1aWNrRWxlbWVudCkge1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLl9ub3JtYWxpemVPcHRpb25zID0gX25vcm1hbGl6ZU9wdGlvbnM7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX3BhcnNlU3R5bGVzID0gX3BhcnNlU3R5bGVzO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLl9wYXJzZVRleHRzID0gX3BhcnNlVGV4dHM7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX2FwcGx5T3B0aW9ucyA9IF9hcHBseU9wdGlvbnM7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX3Bvc3RDcmVhdGlvbiA9IF9wb3N0Q3JlYXRpb247XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX2F0dGFjaFN0YXRlRXZlbnRzID0gX2F0dGFjaFN0YXRlRXZlbnRzO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLl9wcm94eVBhcmVudCA9IF9wcm94eVBhcmVudDtcbiAgcmV0dXJuIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX3VucHJveHlQYXJlbnQgPSBfdW5wcm94eVBhcmVudDtcbn1mdW5jdGlvbiBhbGlhc2VzIChRdWlja0VsZW1lbnQpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFF1aWNrRWxlbWVudC5wcm90b3R5cGUsIHtcbiAgICAncmF3Jzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsO1xuICAgICAgfVxuICAgIH0sXG4gICAgJzAnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWw7XG4gICAgICB9XG4gICAgfSxcbiAgICAnY3NzJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ3JlcGxhY2VXaXRoJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2U7XG4gICAgICB9XG4gICAgfSxcbiAgICAncmVtb3ZlTGlzdGVuZXInOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2ZmO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59dmFyIHBhcmVudHNVbnRpbCA9IGZ1bmN0aW9uIHBhcmVudHNVbnRpbChmaWx0ZXIpIHtcbiAgcmV0dXJuIF9nZXRQYXJlbnRzKHRoaXMsIGZpbHRlcik7XG59O1xudmFyIHBhcmVudE1hdGNoaW5nID0gZnVuY3Rpb24gcGFyZW50TWF0Y2hpbmcoZmlsdGVyKSB7XG4gIHZhciBpc1JlZiwgbmV4dFBhcmVudDtcblxuICBpZiAoSVMkMS5mdW5jdGlvbihmaWx0ZXIpIHx8IChpc1JlZiA9IElTJDEuc3RyaW5nKGZpbHRlcikpKSB7XG4gICAgbmV4dFBhcmVudCA9IHRoaXMucGFyZW50O1xuXG4gICAgd2hpbGUgKG5leHRQYXJlbnQpIHtcbiAgICAgIGlmIChpc1JlZikge1xuICAgICAgICBpZiAobmV4dFBhcmVudC5yZWYgPT09IGZpbHRlcikge1xuICAgICAgICAgIHJldHVybiBuZXh0UGFyZW50O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZmlsdGVyKG5leHRQYXJlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuIG5leHRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV4dFBhcmVudCA9IG5leHRQYXJlbnQucGFyZW50O1xuICAgIH1cbiAgfVxufTtcbnZhciBxdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5KHNlbGVjdG9yKSB7XG4gIHJldHVybiBfcXVpY2tkb20odGhpcy5yYXcucXVlcnlTZWxlY3RvcihzZWxlY3RvcikpO1xufTtcbnZhciBxdWVyeUFsbCA9IGZ1bmN0aW9uIHF1ZXJ5QWxsKHNlbGVjdG9yKSB7XG4gIHZhciBpLCBpdGVtLCBsZW4sIG91dHB1dCwgcmVzdWx0O1xuICByZXN1bHQgPSB0aGlzLnJhdy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgb3V0cHV0ID0gW107XG5cbiAgZm9yIChpID0gMCwgbGVuID0gcmVzdWx0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaXRlbSA9IHJlc3VsdFtpXTtcbiAgICBvdXRwdXQucHVzaChpdGVtKTtcbiAgfVxuXG4gIHJldHVybiBfcXVpY2tkb20uYmF0Y2gob3V0cHV0KTtcbn07XG52YXIgX2dldFBhcmVudHMgPSBmdW5jdGlvbiBfZ2V0UGFyZW50cyh0YXJnZXRFbCwgZmlsdGVyKSB7XG4gIHZhciBpc1JlZiwgbmV4dFBhcmVudCwgcGFyZW50cztcblxuICBpZiAoIUlTJDEuZnVuY3Rpb24oZmlsdGVyKSAmJiAhKGlzUmVmID0gSVMkMS5zdHJpbmcoZmlsdGVyKSkpIHtcbiAgICBmaWx0ZXIgPSB2b2lkIDA7XG4gIH1cblxuICBwYXJlbnRzID0gW107XG4gIG5leHRQYXJlbnQgPSB0YXJnZXRFbC5wYXJlbnQ7XG5cbiAgd2hpbGUgKG5leHRQYXJlbnQpIHtcbiAgICBwYXJlbnRzLnB1c2gobmV4dFBhcmVudCk7XG4gICAgbmV4dFBhcmVudCA9IG5leHRQYXJlbnQucGFyZW50O1xuXG4gICAgaWYgKGlzUmVmKSB7XG4gICAgICBpZiAobmV4dFBhcmVudCAmJiBuZXh0UGFyZW50LnJlZiA9PT0gZmlsdGVyKSB7XG4gICAgICAgIG5leHRQYXJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZmlsdGVyKSB7XG4gICAgICBpZiAoZmlsdGVyKG5leHRQYXJlbnQpKSB7XG4gICAgICAgIG5leHRQYXJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJlbnRzO1xufTtcbnZhciBfZ2V0Q2hpbGRSZWZzID0gZnVuY3Rpb24gX2dldENoaWxkUmVmcyh0YXJnZXQsIGZyZXNoQ29weSkge1xuICB2YXIgY2hpbGQsIGNoaWxkUmVmcywgY2hpbGRyZW4sIGVsLCBpLCBsZW4sIHJlZiwgcmVmcztcblxuICBpZiAoZnJlc2hDb3B5IHx8ICF0YXJnZXQuX2NoaWxkUmVmcykge1xuICAgIHRhcmdldC5fY2hpbGRSZWZzID0ge307XG4gIH1cblxuICByZWZzID0gdGFyZ2V0Ll9jaGlsZFJlZnM7XG5cbiAgaWYgKHRhcmdldC5yZWYpIHtcbiAgICByZWZzW3RhcmdldC5yZWZdID0gdGFyZ2V0O1xuICB9XG5cbiAgY2hpbGRyZW4gPSB0YXJnZXQuY2hpbGRyZW47XG5cbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgY2hpbGRSZWZzID0gX2dldENoaWxkUmVmcyhjaGlsZCwgZnJlc2hDb3B5KTtcblxuICAgICAgZm9yIChyZWYgaW4gY2hpbGRSZWZzKSB7XG4gICAgICAgIGVsID0gY2hpbGRSZWZzW3JlZl07XG4gICAgICAgIHJlZnNbcmVmXSB8fCAocmVmc1tyZWZdID0gZWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWZzO1xufTtcbnZhciBfZ2V0SW5kZXhCeVByb3AgPSBmdW5jdGlvbiBfZ2V0SW5kZXhCeVByb3AobWFpbiwgcHJvcCkge1xuICB2YXIgcGFyZW50O1xuXG4gIGlmICghKHBhcmVudCA9IG1haW4ucGFyZW50KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXJlbnQuY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkW3Byb3BdID09PSBtYWluW3Byb3BdO1xuICAgIH0pLmluZGV4T2YobWFpbik7XG4gIH1cbn07XG52YXIgX2ZpbHRlckVsZW1lbnRzID0gZnVuY3Rpb24gX2ZpbHRlckVsZW1lbnRzKGFycmF5KSB7XG4gIHZhciBpLCBpdGVtLCBsZW4sIG91dHB1dDtcblxuICBpZiAoIWFycmF5Lmxlbmd0aCkge1xuICAgIHJldHVybiBhcnJheTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBbXTtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpdGVtID0gYXJyYXlbaV07XG5cbiAgICAgIGlmIChpdGVtLnR5cGUgIT09ICd0ZXh0Jykge1xuICAgICAgICBvdXRwdXQucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG59O1xuZnVuY3Rpb24gdHJhdmVyc2luZyAoUXVpY2tFbGVtZW50KSB7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUucGFyZW50c1VudGlsID0gcGFyZW50c1VudGlsO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnBhcmVudE1hdGNoaW5nID0gcGFyZW50TWF0Y2hpbmc7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUucXVlcnkgPSBxdWVyeTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5xdWVyeUFsbCA9IHF1ZXJ5QWxsO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUXVpY2tFbGVtZW50LnByb3RvdHlwZSwge1xuICAgICdjaGlsZHJlbic6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgY2hpbGQsIGksIGxlbiwgcmVmMTtcblxuICAgICAgICBpZiAodGhpcy5lbC5jaGlsZE5vZGVzLmxlbmd0aCAhPT0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gUmUtY29sbGVjdCBjaGlsZHJlblx0XG4gICAgICAgICAgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoID0gMDsgLy8gRW1wdHkgb3V0IGNoaWxkcmVuIGFycmF5XG5cbiAgICAgICAgICByZWYxID0gdGhpcy5lbC5jaGlsZE5vZGVzO1xuXG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmMS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY2hpbGQgPSByZWYxW2ldO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPCA0KSB7XG4gICAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuLnB1c2goX3F1aWNrZG9tKGNoaWxkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2VsZW1lbnRDaGlsZHJlbic6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX2ZpbHRlckVsZW1lbnRzKHRoaXMuY2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ3BhcmVudCc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAoKCF0aGlzLl9wYXJlbnQgfHwgdGhpcy5fcGFyZW50LmVsICE9PSB0aGlzLmVsLnBhcmVudE5vZGUpICYmICFJUyQxLmRvbURvYyh0aGlzLmVsLnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgdGhpcy5fcGFyZW50ID0gX3F1aWNrZG9tKHRoaXMuZWwucGFyZW50Tm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50O1xuICAgICAgfVxuICAgIH0sXG4gICAgJ3BhcmVudHMnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRQYXJlbnRzKHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ25leHQnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9xdWlja2RvbSh0aGlzLmVsLm5leHRTaWJsaW5nKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICduZXh0RWwnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIF9xdWlja2RvbSh0aGlzLmVsLm5leHRFbGVtZW50U2libGluZyk7XG4gICAgICB9XG4gICAgfSxcbiAgICAnbmV4dEVsQWxsJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfZmlsdGVyRWxlbWVudHModGhpcy5uZXh0QWxsKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICduZXh0QWxsJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBuZXh0U2libGluZywgc2libGluZ3M7XG4gICAgICAgIHNpYmxpbmdzID0gW107XG4gICAgICAgIG5leHRTaWJsaW5nID0gX3F1aWNrZG9tKHRoaXMuZWwubmV4dFNpYmxpbmcpO1xuXG4gICAgICAgIHdoaWxlIChuZXh0U2libGluZykge1xuICAgICAgICAgIHNpYmxpbmdzLnB1c2gobmV4dFNpYmxpbmcpO1xuICAgICAgICAgIG5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcubmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzaWJsaW5ncztcbiAgICAgIH1cbiAgICB9LFxuICAgICdwcmV2Jzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfcXVpY2tkb20odGhpcy5lbC5wcmV2aW91c1NpYmxpbmcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ3ByZXZFbCc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3F1aWNrZG9tKHRoaXMuZWwucHJldmlvdXNFbGVtZW50U2libGluZyk7XG4gICAgICB9XG4gICAgfSxcbiAgICAncHJldkVsQWxsJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfZmlsdGVyRWxlbWVudHModGhpcy5wcmV2QWxsKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdwcmV2QWxsJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBwcmV2U2libGluZywgc2libGluZ3M7XG4gICAgICAgIHNpYmxpbmdzID0gW107XG4gICAgICAgIHByZXZTaWJsaW5nID0gX3F1aWNrZG9tKHRoaXMuZWwucHJldmlvdXNTaWJsaW5nKTtcblxuICAgICAgICB3aGlsZSAocHJldlNpYmxpbmcpIHtcbiAgICAgICAgICBzaWJsaW5ncy5wdXNoKHByZXZTaWJsaW5nKTtcbiAgICAgICAgICBwcmV2U2libGluZyA9IHByZXZTaWJsaW5nLnByZXY7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2libGluZ3M7XG4gICAgICB9XG4gICAgfSxcbiAgICAnc2libGluZ3MnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldkFsbC5yZXZlcnNlKCkuY29uY2F0KHRoaXMubmV4dEFsbCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAnZWxlbWVudFNpYmxpbmdzJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfZmlsdGVyRWxlbWVudHModGhpcy5zaWJsaW5ncyk7XG4gICAgICB9XG4gICAgfSxcbiAgICAnY2hpbGQnOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkUmVmcyB8fCBfZ2V0Q2hpbGRSZWZzKHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2NoaWxkZic6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX2dldENoaWxkUmVmcyh0aGlzLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdmaXJzdENoaWxkJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuWzBdO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2xhc3RDaGlsZCc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgY2hpbGRyZW47XG4gICAgICAgIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2luZGV4Jzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBwYXJlbnQ7XG5cbiAgICAgICAgaWYgKCEocGFyZW50ID0gdGhpcy5wYXJlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAnaW5kZXhUeXBlJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfZ2V0SW5kZXhCeVByb3AodGhpcywgJ3R5cGUnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdpbmRleFJlZic6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX2dldEluZGV4QnlQcm9wKHRoaXMsICdyZWYnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5fcXVpY2tkb20ucXVlcnkgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIHJldHVybiBfcXVpY2tkb20oZG9jdW1lbnQpLnF1ZXJ5KHRhcmdldCk7XG59O1xuXG5fcXVpY2tkb20ucXVlcnlBbGwgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIHJldHVybiBfcXVpY2tkb20oZG9jdW1lbnQpLnF1ZXJ5QWxsKHRhcmdldCk7XG59O3ZhciBEVU1NWV9BUlJBWTtcbkRVTU1ZX0FSUkFZID0gW107XG52YXIgc3RhdGUgPSBmdW5jdGlvbiBzdGF0ZSh0YXJnZXRTdGF0ZSwgdmFsdWUsIGJ1YmJsZXMsIHNvdXJjZSkge1xuICB2YXIgYWN0aXZlU3RhdGVzLCBjaGlsZCwgZGVzaXJlZFZhbHVlLCBpLCBqLCBrZXksIGtleXMsIGxlbiwgcHJvcCwgcmVmLCB0b2dnbGU7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGUuc2xpY2UoKTtcbiAgfVxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKElTJDEuc3RyaW5nKHRhcmdldFN0YXRlKSkge1xuICAgICAgcmV0dXJuIGluY2x1ZGVzJDEodGhpcy5fc3RhdGUsIHRhcmdldFN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKElTJDEub2JqZWN0KHRhcmdldFN0YXRlKSkge1xuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHRhcmdldFN0YXRlKTtcbiAgICAgIGkgPSAtMTtcblxuICAgICAgd2hpbGUgKGtleSA9IGtleXNbKytpXSkge1xuICAgICAgICB0aGlzLnN0YXRlKGtleSwgdGFyZ2V0U3RhdGVba2V5XSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLl9zdGF0ZVBpcGVUYXJnZXQgJiYgc291cmNlICE9PSB0aGlzKSB7XG4gICAgdGhpcy5fc3RhdGVQaXBlVGFyZ2V0LnN0YXRlKHRhcmdldFN0YXRlLCB2YWx1ZSwgYnViYmxlcywgdGhpcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIGlmIChJUyQxLnN0cmluZyh0YXJnZXRTdGF0ZSkpIHtcbiAgICBpZiAodGFyZ2V0U3RhdGVbMF0gPT09ICckJykge1xuICAgICAgdGFyZ2V0U3RhdGUgPSB0YXJnZXRTdGF0ZS5zbGljZSgxKTtcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0U3RhdGUgPT09ICdiYXNlJykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZGVzaXJlZFZhbHVlID0gISF2YWx1ZTsgLy8gQ29udmVydCB0aGUgdmFsdWUgdG8gYSBib29sZWFuXG5cbiAgICBhY3RpdmVTdGF0ZXMgPSB0aGlzLl9nZXRBY3RpdmVTdGF0ZXModGFyZ2V0U3RhdGUsIGZhbHNlKTsgLy8gPT09PSBUb2dnbGUgc3R5bGVzIGZvciB0aGlzIHN0YXRlID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgaWYgKHRoaXMuc3RhdGUodGFyZ2V0U3RhdGUpICE9PSBkZXNpcmVkVmFsdWUpIHtcbiAgICAgIHByb3AgPSB0aGlzLnR5cGUgPT09ICd0ZXh0JyA/ICdUZXh0JyA6ICdTdHlsZSc7XG5cbiAgICAgIGlmIChkZXNpcmVkVmFsdWUpIHtcbiAgICAgICAgLy9pcyBvblxuICAgICAgICB0aGlzLl9zdGF0ZS5wdXNoKHRhcmdldFN0YXRlKTtcblxuICAgICAgICB0b2dnbGUgPSAnT04nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlSXRlbSh0aGlzLl9zdGF0ZSwgdGFyZ2V0U3RhdGUpO1xuICAgICAgICB0b2dnbGUgPSAnT0ZGJztcbiAgICAgIH1cblxuICAgICAgdGhpc1snX3R1cm4nICsgcHJvcCArIHRvZ2dsZV0odGFyZ2V0U3RhdGUsIGFjdGl2ZVN0YXRlcyk7XG4gICAgICB0aGlzLmVtaXRQcml2YXRlKFwic3RhdGVDaGFuZ2U6XCIuY29uY2F0KHRhcmdldFN0YXRlKSwgZGVzaXJlZFZhbHVlKTtcbiAgICB9IC8vID09PT0gUGFzcyBzdGF0ZSB0byBwYXJlbnQvY2hpbGRyZW4gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAgIGlmICghaW5jbHVkZXMkMSh0aGlzLm9wdGlvbnMudW5wYXNzYWJsZVN0YXRlcywgdGFyZ2V0U3RhdGUpKSB7XG4gICAgICBpZiAoYnViYmxlcykge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICB0aGlzLl9wYXJlbnQuc3RhdGUodGFyZ2V0U3RhdGUsIHZhbHVlLCB0cnVlLCBzb3VyY2UgfHwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnBhc3NTdGF0ZVRvQ2hpbGRyZW4pIHtcbiAgICAgICAgcmVmID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgY2hpbGQgPSByZWZbal07XG4gICAgICAgICAgY2hpbGQuc3RhdGUodGFyZ2V0U3RhdGUsIHZhbHVlLCBmYWxzZSwgc291cmNlIHx8IHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG52YXIgdG9nZ2xlU3RhdGUgPSBmdW5jdGlvbiB0b2dnbGVTdGF0ZSh0YXJnZXRTdGF0ZSkge1xuICByZXR1cm4gdGhpcy5zdGF0ZSh0YXJnZXRTdGF0ZSwgIXRoaXMuc3RhdGUodGFyZ2V0U3RhdGUpKTtcbn07XG52YXIgcmVzZXRTdGF0ZSA9IGZ1bmN0aW9uIHJlc2V0U3RhdGUoKSB7XG4gIHZhciBhY3RpdmVTdGF0ZSwgaiwgbGVuLCByZWY7XG4gIHJlZiA9IHRoaXMuX3N0YXRlLnNsaWNlKCk7XG5cbiAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgYWN0aXZlU3RhdGUgPSByZWZbal07XG4gICAgdGhpcy5zdGF0ZShhY3RpdmVTdGF0ZSwgZmFsc2UpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIHBpcGVTdGF0ZSA9IGZ1bmN0aW9uIHBpcGVTdGF0ZSh0YXJnZXRFbCkge1xuICB2YXIgYWN0aXZlU3RhdGUsIGosIGxlbiwgcmVmO1xuXG4gIGlmICh0YXJnZXRFbCkge1xuICAgIHRhcmdldEVsID0gbm9ybWFsaXplRWxlbWVudEFyZyh0YXJnZXRFbCk7XG5cbiAgICBpZiAoSVMkMS5xdWlja0RvbUVsKHRhcmdldEVsKSAmJiB0YXJnZXRFbCAhPT0gdGhpcykge1xuICAgICAgdGhpcy5fc3RhdGVQaXBlVGFyZ2V0ID0gdGFyZ2V0RWw7XG4gICAgICByZWYgPSB0aGlzLl9zdGF0ZTtcblxuICAgICAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIGFjdGl2ZVN0YXRlID0gcmVmW2pdO1xuICAgICAgICB0YXJnZXRFbC5zdGF0ZShhY3RpdmVTdGF0ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHRhcmdldEVsID09PSBmYWxzZSkge1xuICAgIGRlbGV0ZSB0aGlzLl9zdGF0ZVBpcGVUYXJnZXQ7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgX2FwcGx5UmVnaXN0ZXJlZFN0eWxlID0gZnVuY3Rpb24gX2FwcGx5UmVnaXN0ZXJlZFN0eWxlKHRhcmdldFN0eWxlLCBzdXBlcmlvclN0YXRlcywgaW5jbHVkZUJhc2UsIHNraXBGbnMpIHtcbiAgdmFyIGNsYXNzTmFtZSwgZW50cnksIGosIGssIGxlbiwgbGVuMSwgcmVmLCByZWYxLCBzdXBlcmlvclN0eWxlcztcblxuICBpZiAodGFyZ2V0U3R5bGUpIHtcbiAgICByZWYgPSB0YXJnZXRTdHlsZS5jbGFzc05hbWU7XG5cbiAgICBmb3IgKGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIGNsYXNzTmFtZSA9IHJlZltqXTtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoY2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0U3R5bGUuZm5zLmxlbmd0aCAmJiAhc2tpcEZucykge1xuICAgICAgaWYgKHN1cGVyaW9yU3RhdGVzKSB7XG4gICAgICAgIHN1cGVyaW9yU3R5bGVzID0gdGhpcy5fcmVzb2x2ZUZuU3R5bGVzKHN1cGVyaW9yU3RhdGVzLCBpbmNsdWRlQmFzZSk7XG4gICAgICB9XG5cbiAgICAgIHJlZjEgPSB0YXJnZXRTdHlsZS5mbnM7XG5cbiAgICAgIGZvciAoayA9IDAsIGxlbjEgPSByZWYxLmxlbmd0aDsgayA8IGxlbjE7IGsrKykge1xuICAgICAgICBlbnRyeSA9IHJlZjFba107XG5cbiAgICAgICAgaWYgKCEoc3VwZXJpb3JTdHlsZXMgJiYgc3VwZXJpb3JTdHlsZXNbZW50cnlbMF1dKSkge1xuICAgICAgICAgIHRoaXMuc3R5bGUoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnZhciBfcmVtb3ZlUmVnaXN0ZXJlZFN0eWxlID0gZnVuY3Rpb24gX3JlbW92ZVJlZ2lzdGVyZWRTdHlsZSh0YXJnZXRTdHlsZSwgc3VwZXJpb3JTdGF0ZXMsIGluY2x1ZGVCYXNlKSB7XG4gIHZhciBjbGFzc05hbWUsIGVudHJ5LCBqLCBrLCBsZW4sIGxlbjEsIHJlZiwgcmVmMSwgcmVzZXRWYWx1ZSwgc3VwZXJpb3JTdHlsZXM7XG4gIHJlZiA9IHRhcmdldFN0eWxlLmNsYXNzTmFtZTtcblxuICBmb3IgKGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICBjbGFzc05hbWUgPSByZWZbal07XG4gICAgdGhpcy5yZW1vdmVDbGFzcyhjbGFzc05hbWUpO1xuICB9XG5cbiAgaWYgKHRhcmdldFN0eWxlLmZucy5sZW5ndGgpIHtcbiAgICBpZiAoc3VwZXJpb3JTdGF0ZXMpIHtcbiAgICAgIHN1cGVyaW9yU3R5bGVzID0gdGhpcy5fcmVzb2x2ZUZuU3R5bGVzKHN1cGVyaW9yU3RhdGVzLCBpbmNsdWRlQmFzZSk7XG4gICAgfVxuXG4gICAgcmVmMSA9IHRhcmdldFN0eWxlLmZucztcblxuICAgIGZvciAoayA9IDAsIGxlbjEgPSByZWYxLmxlbmd0aDsgayA8IGxlbjE7IGsrKykge1xuICAgICAgZW50cnkgPSByZWYxW2tdO1xuICAgICAgcmVzZXRWYWx1ZSA9IHN1cGVyaW9yU3R5bGVzICYmIHN1cGVyaW9yU3R5bGVzW2VudHJ5WzBdXSB8fCBudWxsO1xuICAgICAgdGhpcy5zdHlsZShlbnRyeVswXSwgcmVzZXRWYWx1ZSk7XG4gICAgfVxuICB9XG59O1xudmFyIF90dXJuU3R5bGVPTiA9IGZ1bmN0aW9uIF90dXJuU3R5bGVPTih0YXJnZXRTdGF0ZSwgYWN0aXZlU3RhdGVzKSB7XG4gIHZhciBqLCBsZW4sIHNoYXJlZFN0YXRlcywgc2tpcEZucywgc3RhdGVDaGFpbjtcbiAgc2tpcEZucyA9IHRoaXMub3B0aW9ucy5zdHlsZUFmdGVySW5zZXJ0ICYmICF0aGlzLl9pbnNlcnRlZDtcblxuICBpZiAodGhpcy5fc3R5bGVzW3RhcmdldFN0YXRlXSkge1xuICAgIHRoaXMuX2FwcGx5UmVnaXN0ZXJlZFN0eWxlKHRoaXMuX3N0eWxlc1t0YXJnZXRTdGF0ZV0sIHRoaXMuX2dldFN1cGVyaW9yU3RhdGVzKHRhcmdldFN0YXRlLCBhY3RpdmVTdGF0ZXMpLCBmYWxzZSwgc2tpcEZucyk7XG4gIH1cblxuICBpZiAodGhpcy5fcHJvdmlkZWRTdGF0ZXNTaGFyZWQpIHtcbiAgICBzaGFyZWRTdGF0ZXMgPSB0aGlzLl9nZXRTaGFyZWRTdGF0ZXModGFyZ2V0U3RhdGUpO1xuXG4gICAgZm9yIChqID0gMCwgbGVuID0gc2hhcmVkU3RhdGVzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICBzdGF0ZUNoYWluID0gc2hhcmVkU3RhdGVzW2pdO1xuXG4gICAgICBpZiAoIWluY2x1ZGVzJDEodGhpcy5fc3RhdGVTaGFyZWQsIHN0YXRlQ2hhaW4uc3RyaW5nKSkge1xuICAgICAgICB0aGlzLl9zdGF0ZVNoYXJlZC5wdXNoKHN0YXRlQ2hhaW4uc3RyaW5nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYXBwbHlSZWdpc3RlcmVkU3R5bGUodGhpcy5fc3R5bGVzW3N0YXRlQ2hhaW4uc3RyaW5nXSwgbnVsbCwgbnVsbCwgc2tpcEZucyk7XG4gICAgfVxuICB9XG59O1xudmFyIF90dXJuU3R5bGVPRkYgPSBmdW5jdGlvbiBfdHVyblN0eWxlT0ZGKHRhcmdldFN0YXRlLCBhY3RpdmVTdGF0ZXMpIHtcbiAgdmFyIGFjdGl2ZVNoYXJlZFN0YXRlcywgaiwgbGVuLCBzaGFyZWRTdGF0ZXMsIHN0YXRlQ2hhaW4sIHRhcmdldFN0eWxlO1xuXG4gIGlmICh0aGlzLl9zdHlsZXNbdGFyZ2V0U3RhdGVdKSB7XG4gICAgdGhpcy5fcmVtb3ZlUmVnaXN0ZXJlZFN0eWxlKHRoaXMuX3N0eWxlc1t0YXJnZXRTdGF0ZV0sIGFjdGl2ZVN0YXRlcywgdHJ1ZSk7XG4gIH1cblxuICBpZiAodGhpcy5fcHJvdmlkZWRTdGF0ZXNTaGFyZWQpIHtcbiAgICBzaGFyZWRTdGF0ZXMgPSB0aGlzLl9nZXRTaGFyZWRTdGF0ZXModGFyZ2V0U3RhdGUpO1xuXG4gICAgaWYgKHNoYXJlZFN0YXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGogPSAwLCBsZW4gPSBzaGFyZWRTdGF0ZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIHN0YXRlQ2hhaW4gPSBzaGFyZWRTdGF0ZXNbal07XG4gICAgICByZW1vdmVJdGVtKHRoaXMuX3N0YXRlU2hhcmVkLCBzdGF0ZUNoYWluLnN0cmluZyk7XG4gICAgICB0YXJnZXRTdHlsZSA9IHRoaXMuX3N0eWxlc1tzdGF0ZUNoYWluLnN0cmluZ107XG5cbiAgICAgIGlmICh0YXJnZXRTdHlsZS5mbnMubGVuZ3RoICYmIHRoaXMuX3N0YXRlU2hhcmVkLmxlbmd0aCAmJiAhYWN0aXZlU2hhcmVkU3RhdGVzKSB7XG4gICAgICAgIGFjdGl2ZVNoYXJlZFN0YXRlcyA9IHRoaXMuX3N0YXRlU2hhcmVkLmZpbHRlcihmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICByZXR1cm4gIWluY2x1ZGVzJDEoc3RhdGUsIHRhcmdldFN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFjdGl2ZVN0YXRlcyA9IGFjdGl2ZVN0YXRlcy5jb25jYXQoYWN0aXZlU2hhcmVkU3RhdGVzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVtb3ZlUmVnaXN0ZXJlZFN0eWxlKHRhcmdldFN0eWxlLCBhY3RpdmVTdGF0ZXMsIHRydWUpO1xuICAgIH1cbiAgfVxufTtcbnZhciBfdHVyblRleHRPTiA9IGZ1bmN0aW9uIF90dXJuVGV4dE9OKHRhcmdldFN0YXRlLCBhY3RpdmVTdGF0ZXMpIHtcbiAgdmFyIHN1cGVyaW9yU3RhdGVzLCB0YXJnZXRUZXh0O1xuXG4gIGlmICh0aGlzLl90ZXh0cyAmJiBJUyQxLnN0cmluZyh0YXJnZXRUZXh0ID0gdGhpcy5fdGV4dHNbdGFyZ2V0U3RhdGVdKSkge1xuICAgIHN1cGVyaW9yU3RhdGVzID0gdGhpcy5fZ2V0U3VwZXJpb3JTdGF0ZXModGFyZ2V0U3RhdGUsIGFjdGl2ZVN0YXRlcyk7XG5cbiAgICBpZiAoIXN1cGVyaW9yU3RhdGVzLmxlbmd0aCkge1xuICAgICAgdGhpcy50ZXh0ID0gdGFyZ2V0VGV4dDtcbiAgICB9XG4gIH1cbn07XG52YXIgX3R1cm5UZXh0T0ZGID0gZnVuY3Rpb24gX3R1cm5UZXh0T0ZGKHRhcmdldFN0YXRlLCBhY3RpdmVTdGF0ZXMpIHtcbiAgdmFyIHRhcmdldFRleHQ7XG5cbiAgaWYgKHRoaXMuX3RleHRzICYmIElTJDEuc3RyaW5nKHRhcmdldFRleHQgPSB0aGlzLl90ZXh0c1t0YXJnZXRTdGF0ZV0pKSB7XG4gICAgYWN0aXZlU3RhdGVzID0gYWN0aXZlU3RhdGVzLmZpbHRlcihmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIHJldHVybiBzdGF0ZSAhPT0gdGFyZ2V0U3RhdGU7XG4gICAgfSk7XG4gICAgdGFyZ2V0VGV4dCA9IHRoaXMuX3RleHRzW2FjdGl2ZVN0YXRlc1thY3RpdmVTdGF0ZXMubGVuZ3RoIC0gMV1dO1xuXG4gICAgaWYgKHRhcmdldFRleHQgPT0gbnVsbCkge1xuICAgICAgdGFyZ2V0VGV4dCA9IHRoaXMuX3RleHRzLmJhc2U7XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0ID0gdGFyZ2V0VGV4dDtcbiAgfVxufTtcbnZhciBfZ2V0QWN0aXZlU3RhdGVzID0gZnVuY3Rpb24gX2dldEFjdGl2ZVN0YXRlcyhzdGF0ZVRvRXhjbHVkZSkge1xuICB2YXIgaW5jbHVkZVNoYXJlZFN0YXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgdmFyIGFjdGl2ZVN0YXRlcywgaiwgbGVuLCBwbGFpblN0YXRlcztcblxuICBpZiAoIXRoaXMuX3Byb3ZpZGVkU3RhdGVzKSB7XG4gICAgcmV0dXJuIERVTU1ZX0FSUkFZO1xuICB9XG5cbiAgYWN0aXZlU3RhdGVzID0gcGxhaW5TdGF0ZXMgPSB0aGlzLl9zdGF0ZTtcblxuICBpZiAoc3RhdGVUb0V4Y2x1ZGUpIHtcbiAgICBwbGFpblN0YXRlcyA9IFtdO1xuXG4gICAgZm9yIChqID0gMCwgbGVuID0gYWN0aXZlU3RhdGVzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICBzdGF0ZSA9IGFjdGl2ZVN0YXRlc1tqXTtcblxuICAgICAgaWYgKHN0YXRlICE9PSBzdGF0ZVRvRXhjbHVkZSkge1xuICAgICAgICBwbGFpblN0YXRlcy5wdXNoKHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIWluY2x1ZGVTaGFyZWRTdGF0ZXMgfHwgIXRoaXMuX3Byb3ZpZGVkU3RhdGVzU2hhcmVkKSB7XG4gICAgcmV0dXJuIHBsYWluU3RhdGVzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwbGFpblN0YXRlcy5jb25jYXQodGhpcy5fc3RhdGVTaGFyZWQpO1xuICB9XG59O1xudmFyIF9nZXRTdXBlcmlvclN0YXRlcyA9IGZ1bmN0aW9uIF9nZXRTdXBlcmlvclN0YXRlcyh0YXJnZXRTdGF0ZSwgYWN0aXZlU3RhdGVzKSB7XG4gIHZhciBjYW5kaWRhdGUsIGosIGxlbiwgc3VwZXJpb3IsIHRhcmdldFN0YXRlSW5kZXg7XG4gIHRhcmdldFN0YXRlSW5kZXggPSB0aGlzLl9wcm92aWRlZFN0YXRlcy5pbmRleE9mKHRhcmdldFN0YXRlKTtcblxuICBpZiAodGFyZ2V0U3RhdGVJbmRleCA9PT0gdGhpcy5fcHJvdmlkZWRTdGF0ZXMubGVuZ3RoIC0gMSkge1xuICAgIHJldHVybiBEVU1NWV9BUlJBWTtcbiAgfVxuXG4gIHN1cGVyaW9yID0gW107XG5cbiAgZm9yIChqID0gMCwgbGVuID0gYWN0aXZlU3RhdGVzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgY2FuZGlkYXRlID0gYWN0aXZlU3RhdGVzW2pdO1xuXG4gICAgaWYgKHRoaXMuX3Byb3ZpZGVkU3RhdGVzLmluZGV4T2YoY2FuZGlkYXRlKSA+IHRhcmdldFN0YXRlSW5kZXgpIHtcbiAgICAgIHN1cGVyaW9yLnB1c2goY2FuZGlkYXRlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VwZXJpb3I7XG59O1xudmFyIF9nZXRTaGFyZWRTdGF0ZXMgPSBmdW5jdGlvbiBfZ2V0U2hhcmVkU3RhdGVzKHRhcmdldFN0YXRlKSB7XG4gIHZhciBhY3RpdmVTdGF0ZXMsIGosIGxlbiwgcmVmLCBzaGFyZWRTdGF0ZXMsIHN0YXRlQ2hhaW47XG4gIGFjdGl2ZVN0YXRlcyA9IHRoaXMuX3N0YXRlO1xuICBzaGFyZWRTdGF0ZXMgPSBbXTtcbiAgcmVmID0gdGhpcy5fcHJvdmlkZWRTdGF0ZXNTaGFyZWQ7XG5cbiAgZm9yIChqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgc3RhdGVDaGFpbiA9IHJlZltqXTtcblxuICAgIGlmIChzdGF0ZUNoYWluLmluY2x1ZGVzKHRhcmdldFN0YXRlKSAmJiBzdGF0ZUNoYWluLmlzQXBwbGljYWJsZSh0YXJnZXRTdGF0ZSwgYWN0aXZlU3RhdGVzKSkge1xuICAgICAgc2hhcmVkU3RhdGVzLnB1c2goc3RhdGVDaGFpbik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNoYXJlZFN0YXRlcztcbn07XG52YXIgX3Jlc29sdmVGblN0eWxlcyA9IGZ1bmN0aW9uIF9yZXNvbHZlRm5TdHlsZXMoc3RhdGVzLCBpbmNsdWRlQmFzZSkge1xuICB2YXIgZW50cnksIGosIGssIGxlbiwgbGVuMSwgb3V0cHV0LCByZWY7XG5cbiAgaWYgKGluY2x1ZGVCYXNlKSB7XG4gICAgc3RhdGVzID0gWydiYXNlJ10uY29uY2F0KHN0YXRlcyk7XG4gIH1cblxuICBvdXRwdXQgPSB7fTtcblxuICBmb3IgKGogPSAwLCBsZW4gPSBzdGF0ZXMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICBzdGF0ZSA9IHN0YXRlc1tqXTtcblxuICAgIGlmICh0aGlzLl9zdHlsZXNbc3RhdGVdICYmIHRoaXMuX3N0eWxlc1tzdGF0ZV0uZm5zLmxlbmd0aCkge1xuICAgICAgcmVmID0gdGhpcy5fc3R5bGVzW3N0YXRlXS5mbnM7XG5cbiAgICAgIGZvciAoayA9IDAsIGxlbjEgPSByZWYubGVuZ3RoOyBrIDwgbGVuMTsgaysrKSB7XG4gICAgICAgIGVudHJ5ID0gcmVmW2tdO1xuICAgICAgICBvdXRwdXRbZW50cnlbMF1dID0gZW50cnlbMV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5mdW5jdGlvbiBzdGF0ZSQxIChRdWlja0VsZW1lbnQpIHtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5zdGF0ZSA9IHN0YXRlO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnRvZ2dsZVN0YXRlID0gdG9nZ2xlU3RhdGU7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUucmVzZXRTdGF0ZSA9IHJlc2V0U3RhdGU7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUucGlwZVN0YXRlID0gcGlwZVN0YXRlO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLl9hcHBseVJlZ2lzdGVyZWRTdHlsZSA9IF9hcHBseVJlZ2lzdGVyZWRTdHlsZTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5fcmVtb3ZlUmVnaXN0ZXJlZFN0eWxlID0gX3JlbW92ZVJlZ2lzdGVyZWRTdHlsZTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5fdHVyblN0eWxlT04gPSBfdHVyblN0eWxlT047XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX3R1cm5TdHlsZU9GRiA9IF90dXJuU3R5bGVPRkY7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX3R1cm5UZXh0T04gPSBfdHVyblRleHRPTjtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5fdHVyblRleHRPRkYgPSBfdHVyblRleHRPRkY7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX2dldEFjdGl2ZVN0YXRlcyA9IF9nZXRBY3RpdmVTdGF0ZXM7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX2dldFN1cGVyaW9yU3RhdGVzID0gX2dldFN1cGVyaW9yU3RhdGVzO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLl9nZXRTaGFyZWRTdGF0ZXMgPSBfZ2V0U2hhcmVkU3RhdGVzO1xuICByZXR1cm4gUXVpY2tFbGVtZW50LnByb3RvdHlwZS5fcmVzb2x2ZUZuU3R5bGVzID0gX3Jlc29sdmVGblN0eWxlcztcbn12YXIgdG9UZW1wbGF0ZSA9IGZ1bmN0aW9uIHRvVGVtcGxhdGUoKSB7XG4gIHJldHVybiBfcXVpY2tkb20udGVtcGxhdGUodGhpcyk7XG59O1xudmFyIGNsb25lID0gZnVuY3Rpb24gY2xvbmUoKSB7XG4gIHZhciBhY3RpdmVTdGF0ZSwgY2FsbGJhY2ssIGNhbGxiYWNrcywgY2hpbGQsIGVsQ2xvbmUsIGV2ZW50TmFtZSwgaSwgaiwgaywgbGVuLCBsZW4xLCBsZW4yLCBuZXdFbCwgb3B0aW9ucywgcmVmLCByZWYxLCByZWYyO1xuICBlbENsb25lID0gdGhpcy5lbC5jbG9uZU5vZGUoZmFsc2UpO1xuICBvcHRpb25zID0gcHJpbWFyeUJ1aWxkZXIkMS5jbG9uZSh0aGlzLm9wdGlvbnMsIHtcbiAgICBleGlzdGluZzogZWxDbG9uZVxuICB9KTtcbiAgbmV3RWwgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnR5cGUsIG9wdGlvbnMpO1xuICByZWYgPSB0aGlzLl9zdGF0ZTtcblxuICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhY3RpdmVTdGF0ZSA9IHJlZltpXTtcbiAgICBuZXdFbC5zdGF0ZShhY3RpdmVTdGF0ZSwgdHJ1ZSk7XG4gIH1cblxuICByZWYxID0gdGhpcy5jaGlsZHJlbjtcblxuICBmb3IgKGogPSAwLCBsZW4xID0gcmVmMS5sZW5ndGg7IGogPCBsZW4xOyBqKyspIHtcbiAgICBjaGlsZCA9IHJlZjFbal07XG4gICAgbmV3RWwuYXBwZW5kKGNoaWxkLmNsb25lKCkpO1xuICB9XG5cbiAgcmVmMiA9IHRoaXMuX2V2ZW50Q2FsbGJhY2tzO1xuXG4gIGZvciAoZXZlbnROYW1lIGluIHJlZjIpIHtcbiAgICBjYWxsYmFja3MgPSByZWYyW2V2ZW50TmFtZV07XG5cbiAgICBmb3IgKGsgPSAwLCBsZW4yID0gY2FsbGJhY2tzLmxlbmd0aDsgayA8IGxlbjI7IGsrKykge1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFja3Nba107XG4gICAgICBuZXdFbC5vbihldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3RWw7XG59O1xudmFyIGFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZCh0YXJnZXRFbCkge1xuICB2YXIgcHJldlBhcmVudDtcblxuICBpZiAodGFyZ2V0RWwpIHtcbiAgICB0YXJnZXRFbCA9IG5vcm1hbGl6ZUVsZW1lbnRBcmcodGFyZ2V0RWwpO1xuXG4gICAgaWYgKElTJDEucXVpY2tEb21FbCh0YXJnZXRFbCkpIHtcbiAgICAgIHByZXZQYXJlbnQgPSB0YXJnZXRFbC5wYXJlbnQ7XG5cbiAgICAgIGlmIChwcmV2UGFyZW50KSB7XG4gICAgICAgIHByZXZQYXJlbnQuX3JlbW92ZUNoaWxkKHRhcmdldEVsKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2hpbGRyZW4ucHVzaCh0YXJnZXRFbCk7XG5cbiAgICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQodGFyZ2V0RWwuZWwpO1xuXG4gICAgICB0YXJnZXRFbC5fcmVmcmVzaFBhcmVudCgpOyAvLyBGb3JjZSByZS1mcmVzaCB0YXJnZXRFbC5fcGFyZW50IHZhbHVlIHRvIHRyaWdnZXIgaW5zZXJ0ZWQgY2FsbGJhY2tcblxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciBhcHBlbmRUbyA9IGZ1bmN0aW9uIGFwcGVuZFRvKHRhcmdldEVsKSB7XG4gIGlmICh0YXJnZXRFbCkge1xuICAgIHRhcmdldEVsID0gbm9ybWFsaXplRWxlbWVudEFyZyh0YXJnZXRFbCk7XG5cbiAgICBpZiAoSVMkMS5xdWlja0RvbUVsKHRhcmdldEVsKSkge1xuICAgICAgdGFyZ2V0RWwuYXBwZW5kKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciBwcmVwZW5kID0gZnVuY3Rpb24gcHJlcGVuZCh0YXJnZXRFbCkge1xuICB2YXIgcHJldlBhcmVudDtcblxuICBpZiAodGFyZ2V0RWwpIHtcbiAgICB0YXJnZXRFbCA9IG5vcm1hbGl6ZUVsZW1lbnRBcmcodGFyZ2V0RWwpO1xuXG4gICAgaWYgKElTJDEucXVpY2tEb21FbCh0YXJnZXRFbCkpIHtcbiAgICAgIHByZXZQYXJlbnQgPSB0YXJnZXRFbC5wYXJlbnQ7XG5cbiAgICAgIGlmIChwcmV2UGFyZW50KSB7XG4gICAgICAgIHByZXZQYXJlbnQuX3JlbW92ZUNoaWxkKHRhcmdldEVsKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2hpbGRyZW4udW5zaGlmdCh0YXJnZXRFbCk7XG5cbiAgICAgIHRoaXMuZWwuaW5zZXJ0QmVmb3JlKHRhcmdldEVsLmVsLCB0aGlzLmVsLmZpcnN0Q2hpbGQpO1xuXG4gICAgICB0YXJnZXRFbC5fcmVmcmVzaFBhcmVudCgpOyAvLyBGb3JjZSByZS1mcmVzaCB0YXJnZXRFbC5fcGFyZW50IHZhbHVlIHRvIHRyaWdnZXIgaW5zZXJ0ZWQgY2FsbGJhY2tcblxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciBwcmVwZW5kVG8gPSBmdW5jdGlvbiBwcmVwZW5kVG8odGFyZ2V0RWwpIHtcbiAgaWYgKHRhcmdldEVsKSB7XG4gICAgdGFyZ2V0RWwgPSBub3JtYWxpemVFbGVtZW50QXJnKHRhcmdldEVsKTtcblxuICAgIGlmIChJUyQxLnF1aWNrRG9tRWwodGFyZ2V0RWwpKSB7XG4gICAgICB0YXJnZXRFbC5wcmVwZW5kKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciBhZnRlciA9IGZ1bmN0aW9uIGFmdGVyKHRhcmdldEVsKSB7XG4gIHZhciBteUluZGV4O1xuXG4gIGlmICh0YXJnZXRFbCAmJiB0aGlzLnBhcmVudCkge1xuICAgIHRhcmdldEVsID0gbm9ybWFsaXplRWxlbWVudEFyZyh0YXJnZXRFbCk7XG5cbiAgICBpZiAoSVMkMS5xdWlja0RvbUVsKHRhcmdldEVsKSkge1xuICAgICAgbXlJbmRleCA9IHRoaXMucGFyZW50Ll9jaGlsZHJlbi5pbmRleE9mKHRoaXMpO1xuXG4gICAgICB0aGlzLnBhcmVudC5fY2hpbGRyZW4uc3BsaWNlKG15SW5kZXggKyAxLCAwLCB0YXJnZXRFbCk7XG5cbiAgICAgIHRoaXMuZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGFyZ2V0RWwuZWwsIHRoaXMuZWwubmV4dFNpYmxpbmcpO1xuXG4gICAgICB0YXJnZXRFbC5fcmVmcmVzaFBhcmVudCgpOyAvLyBGb3JjZSByZS1mcmVzaCB0YXJnZXRFbC5fcGFyZW50IHZhbHVlIHRvIHRyaWdnZXIgaW5zZXJ0ZWQgY2FsbGJhY2tcblxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciBpbnNlcnRBZnRlciA9IGZ1bmN0aW9uIGluc2VydEFmdGVyKHRhcmdldEVsKSB7XG4gIGlmICh0YXJnZXRFbCkge1xuICAgIHRhcmdldEVsID0gbm9ybWFsaXplRWxlbWVudEFyZyh0YXJnZXRFbCk7XG5cbiAgICBpZiAoSVMkMS5xdWlja0RvbUVsKHRhcmdldEVsKSkge1xuICAgICAgdGFyZ2V0RWwuYWZ0ZXIodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIGJlZm9yZSA9IGZ1bmN0aW9uIGJlZm9yZSh0YXJnZXRFbCkge1xuICB2YXIgbXlJbmRleDtcblxuICBpZiAodGFyZ2V0RWwgJiYgdGhpcy5wYXJlbnQpIHtcbiAgICB0YXJnZXRFbCA9IG5vcm1hbGl6ZUVsZW1lbnRBcmcodGFyZ2V0RWwpO1xuXG4gICAgaWYgKElTJDEucXVpY2tEb21FbCh0YXJnZXRFbCkpIHtcbiAgICAgIG15SW5kZXggPSB0aGlzLnBhcmVudC5fY2hpbGRyZW4uaW5kZXhPZih0aGlzKTtcblxuICAgICAgdGhpcy5wYXJlbnQuX2NoaWxkcmVuLnNwbGljZShteUluZGV4LCAwLCB0YXJnZXRFbCk7XG5cbiAgICAgIHRoaXMuZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGFyZ2V0RWwuZWwsIHRoaXMuZWwpO1xuXG4gICAgICB0YXJnZXRFbC5fcmVmcmVzaFBhcmVudCgpOyAvLyBGb3JjZSByZS1mcmVzaCB0YXJnZXRFbC5fcGFyZW50IHZhbHVlIHRvIHRyaWdnZXIgaW5zZXJ0ZWQgY2FsbGJhY2tcblxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciBpbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiBpbnNlcnRCZWZvcmUodGFyZ2V0RWwpIHtcbiAgaWYgKHRhcmdldEVsKSB7XG4gICAgdGFyZ2V0RWwgPSBub3JtYWxpemVFbGVtZW50QXJnKHRhcmdldEVsKTtcblxuICAgIGlmIChJUyQxLnF1aWNrRG9tRWwodGFyZ2V0RWwpKSB7XG4gICAgICB0YXJnZXRFbC5iZWZvcmUodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIGRldGFjaCA9IGZ1bmN0aW9uIGRldGFjaCgpIHtcbiAgdmFyIHJlZjtcblxuICBpZiAoKHJlZiA9IHRoaXMucGFyZW50KSAhPSBudWxsKSB7XG4gICAgcmVmLl9yZW1vdmVDaGlsZCh0aGlzKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciByZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG4gIHZhciBldmVudE5hbWU7XG4gIHRoaXMuZGV0YWNoKCk7XG4gIHRoaXMucmVzZXRTdGF0ZSgpO1xuXG4gIGlmICh0aGlzLl9ldmVudENhbGxiYWNrcykge1xuICAgIGZvciAoZXZlbnROYW1lIGluIHRoaXMuX2V2ZW50Q2FsbGJhY2tzKSB7XG4gICAgICB0aGlzLl9ldmVudENhbGxiYWNrc1tldmVudE5hbWVdLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIGVtcHR5ID0gZnVuY3Rpb24gZW1wdHkoKSB7XG4gIHZhciBjaGlsZCwgaSwgbGVuLCByZWY7XG4gIHJlZiA9IHRoaXMuY2hpbGRyZW4uc2xpY2UoKTtcblxuICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjaGlsZCA9IHJlZltpXTtcblxuICAgIHRoaXMuX3JlbW92ZUNoaWxkKGNoaWxkKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciB3cmFwID0gZnVuY3Rpb24gd3JhcCh0YXJnZXRFbCkge1xuICB2YXIgY3VycmVudFBhcmVudDtcblxuICBpZiAodGFyZ2V0RWwpIHtcbiAgICB0YXJnZXRFbCA9IG5vcm1hbGl6ZUVsZW1lbnRBcmcodGFyZ2V0RWwpO1xuICAgIGN1cnJlbnRQYXJlbnQgPSB0aGlzLnBhcmVudDtcblxuICAgIGlmIChJUyQxLnF1aWNrRG9tRWwodGFyZ2V0RWwpICYmIHRhcmdldEVsICE9PSB0aGlzICYmIHRhcmdldEVsICE9PSB0aGlzLnBhcmVudCkge1xuICAgICAgaWYgKGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgY3VycmVudFBhcmVudC5fcmVtb3ZlQ2hpbGQodGhpcywgIXRhcmdldEVsLnBhcmVudCA/IHRhcmdldEVsIDogdm9pZCAwKTtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0RWwuYXBwZW5kKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciB1bndyYXAgPSBmdW5jdGlvbiB1bndyYXAoKSB7XG4gIHZhciBncmFuZFBhcmVudCwgcGFyZW50LCBwYXJlbnRDaGlsZHJlbiwgcGFyZW50U2libGluZztcbiAgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG5cbiAgaWYgKHBhcmVudCkge1xuICAgIHBhcmVudENoaWxkcmVuID0gX3F1aWNrZG9tLmJhdGNoKHBhcmVudC5jaGlsZHJlbik7XG4gICAgcGFyZW50U2libGluZyA9IHBhcmVudC5uZXh0O1xuICAgIGdyYW5kUGFyZW50ID0gcGFyZW50LnBhcmVudDtcblxuICAgIGlmIChncmFuZFBhcmVudCkge1xuICAgICAgcGFyZW50LmRldGFjaCgpO1xuXG4gICAgICBpZiAocGFyZW50U2libGluZykge1xuICAgICAgICBwYXJlbnRDaGlsZHJlbi5pbnNlcnRCZWZvcmUocGFyZW50U2libGluZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnRDaGlsZHJlbi5hcHBlbmRUbyhncmFuZFBhcmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHRhcmdldEVsKSB7XG4gIHZhciByZWY7XG5cbiAgaWYgKHRhcmdldEVsKSB7XG4gICAgdGFyZ2V0RWwgPSBub3JtYWxpemVFbGVtZW50QXJnKHRhcmdldEVsKTtcblxuICAgIGlmIChJUyQxLnF1aWNrRG9tRWwodGFyZ2V0RWwpICYmIHRhcmdldEVsICE9PSB0aGlzKSB7XG4gICAgICB0YXJnZXRFbC5kZXRhY2goKTtcblxuICAgICAgaWYgKChyZWYgPSB0aGlzLnBhcmVudCkgIT0gbnVsbCkge1xuICAgICAgICByZWYuX3JlbW92ZUNoaWxkKHRoaXMsIHRhcmdldEVsKTtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0RWwuX3JlZnJlc2hQYXJlbnQoKTsgLy8gRm9yY2UgcmUtZnJlc2ggdGFyZ2V0RWwuX3BhcmVudCB2YWx1ZSB0byB0cmlnZ2VyIGluc2VydGVkIGNhbGxiYWNrXG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgaGFzQ2xhc3MgPSBmdW5jdGlvbiBoYXNDbGFzcyh0YXJnZXQpIHtcbiAgcmV0dXJuIGluY2x1ZGVzJDEodGhpcy5jbGFzc0xpc3QsIHRhcmdldCk7XG59O1xudmFyIGFkZENsYXNzID0gZnVuY3Rpb24gYWRkQ2xhc3ModGFyZ2V0KSB7XG4gIHZhciBjbGFzc0xpc3QsIHRhcmdldEluZGV4O1xuICBjbGFzc0xpc3QgPSB0aGlzLmNsYXNzTGlzdDtcbiAgdGFyZ2V0SW5kZXggPSBjbGFzc0xpc3QuaW5kZXhPZih0YXJnZXQpO1xuXG4gIGlmICh0YXJnZXRJbmRleCA9PT0gLTEpIHtcbiAgICBjbGFzc0xpc3QucHVzaCh0YXJnZXQpO1xuICAgIHRoaXMuY2xhc3NOYW1lID0gY2xhc3NMaXN0Lmxlbmd0aCA+IDEgPyBjbGFzc0xpc3Quam9pbignICcpIDogY2xhc3NMaXN0WzBdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIHJlbW92ZUNsYXNzID0gZnVuY3Rpb24gcmVtb3ZlQ2xhc3ModGFyZ2V0KSB7XG4gIHZhciBjbGFzc0xpc3QsIHRhcmdldEluZGV4O1xuICBjbGFzc0xpc3QgPSB0aGlzLmNsYXNzTGlzdDtcbiAgdGFyZ2V0SW5kZXggPSBjbGFzc0xpc3QuaW5kZXhPZih0YXJnZXQpO1xuXG4gIGlmICh0YXJnZXRJbmRleCAhPT0gLTEpIHtcbiAgICBjbGFzc0xpc3Quc3BsaWNlKHRhcmdldEluZGV4LCAxKTtcbiAgICB0aGlzLmNsYXNzTmFtZSA9IGNsYXNzTGlzdC5sZW5ndGggPyBjbGFzc0xpc3Quam9pbignICcpIDogJyc7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgdG9nZ2xlQ2xhc3MgPSBmdW5jdGlvbiB0b2dnbGVDbGFzcyh0YXJnZXQpIHtcbiAgaWYgKHRoaXMuaGFzQ2xhc3ModGFyZ2V0KSkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3ModGFyZ2V0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmFkZENsYXNzKHRhcmdldCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgc2V0UmVmID0gZnVuY3Rpb24gc2V0UmVmKHRhcmdldCkge1xuICB0aGlzLnJlZiA9IHRoaXMub3B0aW9ucy5yZWYgPSB0YXJnZXQ7XG4gIHRoaXMuYXR0cignZGF0YS1yZWYnLCB0YXJnZXQpO1xuICByZXR1cm4gdGhpcztcbn07XG52YXIgX3JlZnJlc2hQYXJlbnQgPSBmdW5jdGlvbiBfcmVmcmVzaFBhcmVudCgpIHtcbiAgcmV0dXJuIHRoaXMucGFyZW50O1xufTtcbnZhciBfcmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiBfcmVtb3ZlQ2hpbGQodGFyZ2V0Q2hpbGQsIHJlcGxhY2VtZW50Q2hpbGQpIHtcbiAgdmFyIGluZGV4T2ZDaGlsZDtcbiAgaW5kZXhPZkNoaWxkID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKHRhcmdldENoaWxkKTtcblxuICBpZiAoaW5kZXhPZkNoaWxkICE9PSAtMSkge1xuICAgIGlmIChyZXBsYWNlbWVudENoaWxkKSB7XG4gICAgICB0aGlzLmVsLnJlcGxhY2VDaGlsZChyZXBsYWNlbWVudENoaWxkLmVsLCB0YXJnZXRDaGlsZC5lbCk7XG5cbiAgICAgIHRoaXMuX2NoaWxkcmVuLnNwbGljZShpbmRleE9mQ2hpbGQsIDEsIHJlcGxhY2VtZW50Q2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVsLnJlbW92ZUNoaWxkKHRhcmdldENoaWxkLmVsKTtcblxuICAgICAgdGhpcy5fY2hpbGRyZW4uc3BsaWNlKGluZGV4T2ZDaGlsZCwgMSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuZnVuY3Rpb24gbWFuaXB1bGF0aW9uIChRdWlja0VsZW1lbnQpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUXVpY2tFbGVtZW50LnByb3RvdHlwZSwge1xuICAgICdodG1sJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLmlubmVySFRNTDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChuZXdWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5pbm5lckhUTUwgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgICd0ZXh0Jzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnRleHRDb250ZW50O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld1ZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnRleHRDb250ZW50ID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfSxcbiAgICAnY2xhc3NOYW1lJzoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN2Zykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2NsYXNzJykgfHwgJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmF3LmNsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld1ZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnN2Zykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2NsYXNzJywgbmV3VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJhdy5jbGFzc05hbWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ2NsYXNzTGlzdCc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgbGlzdDtcbiAgICAgICAgbGlzdCA9IHRoaXMuY2xhc3NOYW1lLnNwbGl0KC9cXHMrLyk7XG5cbiAgICAgICAgaWYgKGxpc3RbbGlzdC5sZW5ndGggLSAxXSA9PT0gJycpIHtcbiAgICAgICAgICBsaXN0LnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3RbMF0gPT09ICcnKSB7XG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS50b1RlbXBsYXRlID0gdG9UZW1wbGF0ZTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5jbG9uZSA9IGNsb25lO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLmFwcGVuZCA9IGFwcGVuZDtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5hcHBlbmRUbyA9IGFwcGVuZFRvO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnByZXBlbmQgPSBwcmVwZW5kO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnByZXBlbmRUbyA9IHByZXBlbmRUbztcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5hZnRlciA9IGFmdGVyO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLmluc2VydEFmdGVyID0gaW5zZXJ0QWZ0ZXI7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuYmVmb3JlID0gYmVmb3JlO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IGluc2VydEJlZm9yZTtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5kZXRhY2ggPSBkZXRhY2g7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlID0gcmVtb3ZlO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLmVtcHR5ID0gZW1wdHk7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUud3JhcCA9IHdyYXA7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUudW53cmFwID0gdW53cmFwO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnJlcGxhY2UgPSByZXBsYWNlO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLmhhc0NsYXNzID0gaGFzQ2xhc3M7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuYWRkQ2xhc3MgPSBhZGRDbGFzcztcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS5yZW1vdmVDbGFzcyA9IHJlbW92ZUNsYXNzO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnRvZ2dsZUNsYXNzID0gdG9nZ2xlQ2xhc3M7XG4gIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuc2V0UmVmID0gc2V0UmVmO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLl9yZWZyZXNoUGFyZW50ID0gX3JlZnJlc2hQYXJlbnQ7XG4gIHJldHVybiBRdWlja0VsZW1lbnQucHJvdG90eXBlLl9yZW1vdmVDaGlsZCA9IF9yZW1vdmVDaGlsZDtcbn12YXIgdXBkYXRlT3B0aW9ucyA9IGZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMob3B0aW9ucykge1xuICBpZiAoSVMkMS5vYmplY3Qob3B0aW9ucykpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgdGhpcy5fbm9ybWFsaXplT3B0aW9ucygpO1xuXG4gICAgdGhpcy5fYXBwbHlPcHRpb25zKHRoaXMub3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgdXBkYXRlU3RhdGVTdHlsZXMgPSBmdW5jdGlvbiB1cGRhdGVTdGF0ZVN0eWxlcyhzdHlsZXMpIHtcbiAgdmFyIGksIGxlbiwgcGFyc2VkLCBzdGF0ZSwgdXBkYXRlZFN0YXRlcztcblxuICBpZiAoSVMkMS5vYmplY3RQbGFpbihzdHlsZXMpKSB7XG4gICAgcHJpbWFyeUJ1aWxkZXIkMS5kZWVwLmNvbmNhdCh0aGlzLCBwYXJzZWQgPSB0aGlzLl9wYXJzZVN0eWxlcyhzdHlsZXMpKTtcblxuICAgIGlmIChwYXJzZWQuX3N0eWxlcykge1xuICAgICAgdXBkYXRlZFN0YXRlcyA9IE9iamVjdC5rZXlzKHBhcnNlZC5fc3R5bGVzKTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gdXBkYXRlZFN0YXRlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzdGF0ZSA9IHVwZGF0ZWRTdGF0ZXNbaV07XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUoc3RhdGUpIHx8IHN0YXRlID09PSAnYmFzZScpIHtcbiAgICAgICAgICB0aGlzLl9hcHBseVJlZ2lzdGVyZWRTdHlsZSh0aGlzLl9zdHlsZXNbc3RhdGVdLCB0aGlzLl9nZXRBY3RpdmVTdGF0ZXMoc3RhdGUpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgdXBkYXRlU3RhdGVUZXh0cyA9IGZ1bmN0aW9uIHVwZGF0ZVN0YXRlVGV4dHModGV4dHMpIHtcbiAgdmFyIHBhcnNlZDtcblxuICBpZiAoSVMkMS5vYmplY3RQbGFpbih0ZXh0cykpIHtcbiAgICBwcmltYXJ5QnVpbGRlciQxLmRlZXAuY29uY2F0KHRoaXMsIHBhcnNlZCA9IHRoaXMuX3BhcnNlVGV4dHModGV4dHMpKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciBhcHBseURhdGEgPSBmdW5jdGlvbiBhcHBseURhdGEoZGF0YSwgcGFzc1Rocm91Z2gpIHtcbiAgdmFyIGNoaWxkLCBjb21wdXRlcnMsIGRlZmF1bHRzLCBpLCBqLCBrZXksIGtleXMsIGxlbiwgbGVuMSwgcmVmO1xuXG4gIGlmICh0aGlzLm9wdGlvbnMucGFzc0RhdGFUb0NoaWxkcmVuICYmIHRoaXMuX2NoaWxkcmVuLmxlbmd0aCAmJiAocGFzc1Rocm91Z2ggIT0gbnVsbCA/IHBhc3NUaHJvdWdoIDogcGFzc1Rocm91Z2ggPSB0cnVlKSkge1xuICAgIHJlZiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjaGlsZCA9IHJlZltpXTtcbiAgICAgIGNoaWxkLmFwcGx5RGF0YShkYXRhKTtcbiAgICB9XG4gIH1cblxuICBpZiAoY29tcHV0ZXJzID0gdGhpcy5vcHRpb25zLmNvbXB1dGVycykge1xuICAgIGRlZmF1bHRzID0gdGhpcy5vcHRpb25zLmRlZmF1bHRzO1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyhjb21wdXRlcnMpO1xuXG4gICAgZm9yIChqID0gMCwgbGVuMSA9IGtleXMubGVuZ3RoOyBqIDwgbGVuMTsgaisrKSB7XG4gICAgICBrZXkgPSBrZXlzW2pdO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmludm9rZUNvbXB1dGVyc09uY2UpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ludm9rZWRDb21wdXRlcnNba2V5XSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faW52b2tlZENvbXB1dGVyc1trZXldID0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEgJiYgZGF0YS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHRoaXMuX3J1bkNvbXB1dGVyKGtleSwgZGF0YVtrZXldLCBkYXRhKTtcbiAgICAgIH0gZWxzZSBpZiAoZGVmYXVsdHMgJiYgZGVmYXVsdHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB0aGlzLl9ydW5Db21wdXRlcihrZXksIGRlZmF1bHRzW2tleV0sIGRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbnZhciBfcnVuQ29tcHV0ZXIgPSBmdW5jdGlvbiBfcnVuQ29tcHV0ZXIoY29tcHV0ZXIsIGFyZywgZGF0YSkge1xuICByZXR1cm4gdGhpcy5vcHRpb25zLmNvbXB1dGVyc1tjb21wdXRlcl0uY2FsbCh0aGlzLCBhcmcsIGRhdGEpO1xufTtcbmZ1bmN0aW9uIGFwcGxpY2F0aW9uIChRdWlja0VsZW1lbnQpIHtcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS51cGRhdGVPcHRpb25zID0gdXBkYXRlT3B0aW9ucztcbiAgUXVpY2tFbGVtZW50LnByb3RvdHlwZS51cGRhdGVTdGF0ZVN0eWxlcyA9IHVwZGF0ZVN0YXRlU3R5bGVzO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLnVwZGF0ZVN0YXRlVGV4dHMgPSB1cGRhdGVTdGF0ZVRleHRzO1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLmFwcGx5RGF0YSA9IGFwcGx5RGF0YTtcbiAgcmV0dXJuIFF1aWNrRWxlbWVudC5wcm90b3R5cGUuX3J1bkNvbXB1dGVyID0gX3J1bkNvbXB1dGVyO1xufXZhciBhdHRyID0gZnVuY3Rpb24gYXR0cih0YXJnZXQsIG5ld1ZhbHVlKSB7XG4gIHZhciBpLCBrZXksIGtleXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsLmdldEF0dHJpYnV0ZSh0YXJnZXQpO1xuICAgIH1cblxuICAgIGlmIChJUyQxLm9iamVjdCh0YXJnZXQpKSB7XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXModGFyZ2V0KTtcbiAgICAgIGkgPSAtMTtcblxuICAgICAgd2hpbGUgKGtleSA9IGtleXNbKytpXSkge1xuICAgICAgICB0aGlzLmF0dHIoa2V5LCB0YXJnZXRba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKG5ld1ZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKHRhcmdldCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUodGFyZ2V0LCBuZXdWYWx1ZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG52YXIgcHJvcCA9IGZ1bmN0aW9uIHByb3AodGFyZ2V0LCBuZXdWYWx1ZSkge1xuICB2YXIgaSwga2V5LCBrZXlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbFt0YXJnZXRdO1xuICAgIH1cblxuICAgIGlmIChJUyQxLm9iamVjdCh0YXJnZXQpKSB7XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXModGFyZ2V0KTtcbiAgICAgIGkgPSAtMTtcblxuICAgICAgd2hpbGUgKGtleSA9IGtleXNbKytpXSkge1xuICAgICAgICB0aGlzLnByb3Aoa2V5LCB0YXJnZXRba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuZWxbdGFyZ2V0XSA9IG5ld1ZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuZnVuY3Rpb24gYXR0cmlidXRlc0FuZFByb3BlcnRpZXMgKFF1aWNrRWxlbWVudCkge1xuICBRdWlja0VsZW1lbnQucHJvdG90eXBlLmF0dHIgPSBhdHRyO1xuICByZXR1cm4gUXVpY2tFbGVtZW50LnByb3RvdHlwZS5wcm9wID0gcHJvcDtcbn12YXIgUXVpY2tFbGVtZW50JDEsIHN2Z05hbWVzcGFjZTtcbnN2Z05hbWVzcGFjZSA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG52YXIgUXVpY2tFbGVtZW50JDIgPSBRdWlja0VsZW1lbnQkMSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIFF1aWNrRWxlbWVudCA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFF1aWNrRWxlbWVudCh0eXBlLCBvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUXVpY2tFbGVtZW50KTtcblxuICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICBRdWlja0VsZW1lbnQuY291bnQrKztcblxuICAgICAgaWYgKHRoaXMudHlwZVswXSA9PT0gJyonKSB7XG4gICAgICAgIHRoaXMuc3ZnID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbCA9IHRoaXMub3B0aW9ucy5leGlzdGluZyB8fCAodGhpcy50eXBlID09PSAndGV4dCcgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0eXBlb2YgdGhpcy5vcHRpb25zLnRleHQgPT09ICdzdHJpbmcnID8gdGhpcy5vcHRpb25zLnRleHQgOiAnJykgOiB0aGlzLnN2ZyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmdOYW1lc3BhY2UsIHRoaXMudHlwZS5zbGljZSgxKSkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMudHlwZSkpO1xuXG4gICAgICBpZiAodGhpcy50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQgPSB0aGlzLnByZXBlbmQgPSB0aGlzLmF0dHIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIH0gLy8gQF90ZXh0cyA9IHt9ICMgZGVmaW5lZCBjb25kaXRpb25hbGx5XG5cblxuICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX3N0eWxlcyA9IHt9O1xuICAgICAgdGhpcy5fc3RhdGUgPSBbXTtcbiAgICAgIHRoaXMuX2NoaWxkcmVuID0gW107IC8vIEBfcHJvdmlkZWRTdGF0ZXMgPSBbXVx0XHRcdFx0IyBkZWZpbmVkIGNvbmRpdGlvbmFsbHlcbiAgICAgIC8vIEBfcHJvdmlkZWRTdGF0ZXNTaGFyZWQgPSBbXVx0XHQjIGRlZmluZWQgY29uZGl0aW9uYWxseVxuICAgICAgLy8gQF9ldmVudENhbGxiYWNrcyA9IHtfX3JlZnM6e319XHQjIGRlZmluZWQgY29uZGl0aW9uYWxseVxuXG4gICAgICB0aGlzLl9ub3JtYWxpemVPcHRpb25zKCk7XG5cbiAgICAgIHRoaXMuX2FwcGx5T3B0aW9ucygpO1xuXG4gICAgICB0aGlzLl9hdHRhY2hTdGF0ZUV2ZW50cygpO1xuXG4gICAgICB0aGlzLl9wcm94eVBhcmVudCgpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmV4aXN0aW5nKSB7XG4gICAgICAgIHRoaXMuX3JlZnJlc2hQYXJlbnQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbC5fcXVpY2tFbGVtZW50ID0gdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoUXVpY2tFbGVtZW50LCBbe1xuICAgICAga2V5OiBcInRvSlNPTlwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgdmFyIGNoaWxkLCBjaGlsZHJlbiwgaSwgbGVuLCBvdXRwdXQ7XG4gICAgICAgIG91dHB1dCA9IFt0aGlzLnR5cGUsIHByaW1hcnlCdWlsZGVyJDEuY2xvbmUua2V5cyhlbGVtZW50KSh0aGlzLm9wdGlvbnMpXTtcbiAgICAgICAgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICBvdXRwdXQucHVzaChjaGlsZC50b0pTT04oKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBRdWlja0VsZW1lbnQ7XG4gIH0oKTtcbiAgUXVpY2tFbGVtZW50LmNvdW50ID0gMDtcbiAgcmV0dXJuIFF1aWNrRWxlbWVudDtcbn0uY2FsbCh1bmRlZmluZWQpO1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuaWYgKFF1aWNrRWxlbWVudCQxLm5hbWUgPT0gbnVsbCkge1xuICBRdWlja0VsZW1lbnQkMS5uYW1lID0gJ1F1aWNrRWxlbWVudCc7XG59XG5pbml0JDEoUXVpY2tFbGVtZW50JDEpO1xuYWxpYXNlcyhRdWlja0VsZW1lbnQkMSk7XG50cmF2ZXJzaW5nKFF1aWNrRWxlbWVudCQxKTtcbmV2ZW50cyhRdWlja0VsZW1lbnQkMSk7XG5zdGF0ZSQxKFF1aWNrRWxlbWVudCQxKTtcbnN0eWxlJDEoUXVpY2tFbGVtZW50JDEpO1xubWFuaXB1bGF0aW9uKFF1aWNrRWxlbWVudCQxKTtcbmFwcGxpY2F0aW9uKFF1aWNrRWxlbWVudCQxKTtcbmF0dHJpYnV0ZXNBbmRQcm9wZXJ0aWVzKFF1aWNrRWxlbWVudCQxKTt2YXIgc2NoZW1hID0ge1xuICB0eXBlOiAnZGl2JyxcbiAgcmVmOiB2b2lkIDAsXG4gIG9wdGlvbnM6IHt9LFxuICBjaGlsZHJlbjogW11cbn07XG52YXIgbWF0Y2hlc1NjaGVtYSA9IGZ1bmN0aW9uIG1hdGNoZXNTY2hlbWEob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0LnR5cGUgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBvYmplY3QucmVmICE9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2Ygb2JqZWN0Lm9wdGlvbnMgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBvYmplY3QuY2hpbGRyZW4gIT09ICd1bmRlZmluZWQnO1xufTt2YXIgUEFSU0VfRVJST1JfUFJFRklYLCBwYXJzZVRyZWU7XG5QQVJTRV9FUlJPUl9QUkVGSVggPSAnVGVtcGxhdGUgUGFyc2UgRXJyb3I6IGV4cGVjdGVkJztcbnZhciBwYXJzZVRyZWUkMSA9IHBhcnNlVHJlZSA9IGZ1bmN0aW9uIHBhcnNlVHJlZSh0cmVlLCBwYXJzZUNoaWxkcmVuKSB7XG4gIHZhciBvdXRwdXQ7XG5cbiAgc3dpdGNoIChmYWxzZSkge1xuICAgIGNhc2UgIUlTJDEuYXJyYXkodHJlZSk6XG4gICAgICBvdXRwdXQgPSB7fTtcblxuICAgICAgaWYgKCFJUyQxLnN0cmluZyh0cmVlWzBdKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIi5jb25jYXQoUEFSU0VfRVJST1JfUFJFRklYLCBcIiBzdHJpbmcgZm9yICd0eXBlJywgZ290ICdcIikuY29uY2F0KFN0cmluZyh0cmVlWzBdKSwgXCInXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dC50eXBlID0gdHJlZVswXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMSAmJiAhSVMkMS5vYmplY3QodHJlZVsxXSkgJiYgdHJlZVsxXSAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIi5jb25jYXQoUEFSU0VfRVJST1JfUFJFRklYLCBcIiBvYmplY3QgZm9yICdvcHRpb25zJywgZ290ICdcIikuY29uY2F0KFN0cmluZyh0cmVlWzFdKSwgXCInXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dC5vcHRpb25zID0gdHJlZVsxXSA/IHByaW1hcnlCdWlsZGVyJDEuZGVlcC5jbG9uZSh0cmVlWzFdKSA6IHNjaGVtYS5vcHRpb25zO1xuXG4gICAgICAgIGlmICh0cmVlWzFdKSB7XG4gICAgICAgICAgb3V0cHV0LnJlZiA9IHRyZWVbMV0uaWQgfHwgdHJlZVsxXS5yZWY7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb3V0cHV0LmNoaWxkcmVuID0gdHJlZS5zbGljZSgyKTtcblxuICAgICAgaWYgKHBhcnNlQ2hpbGRyZW4gPT09IGZhbHNlKSB7XG4gICAgICAgIGlmICh0cmVlLmxlbmd0aCA9PT0gMyAmJiBJUyQxLm9iamVjdFBsYWluKHRyZWVbMl0pICYmICFJUyQxLnRlbXBsYXRlKHRyZWVbMl0pKSB7XG4gICAgICAgICAgb3V0cHV0LmNoaWxkcmVuID0gdHJlZVsyXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0LmNoaWxkcmVuID0gb3V0cHV0LmNoaWxkcmVuLm1hcChxdWlja2RvbS50ZW1wbGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRwdXQ7XG5cbiAgICBjYXNlICEoSVMkMS5zdHJpbmcodHJlZSkgfHwgSVMkMS5kb21UZXh0KHRyZWUpKTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIHRleHQ6IHRyZWUudGV4dENvbnRlbnQgfHwgdHJlZVxuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogc2NoZW1hLmNoaWxkcmVuXG4gICAgICB9O1xuXG4gICAgY2FzZSAhSVMkMS5kb21FbCh0cmVlKTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHRyZWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgcmVmOiB0cmVlLmlkLFxuICAgICAgICBvcHRpb25zOiBwcmltYXJ5QnVpbGRlciQxLmNsb25lLmtleXModGVtcGxhdGUpKHRyZWUpLFxuICAgICAgICBjaGlsZHJlbjogc2NoZW1hLmNoaWxkcmVuLm1hcC5jYWxsKHRyZWUuY2hpbGROb2RlcywgcXVpY2tkb20udGVtcGxhdGUpXG4gICAgICB9O1xuXG4gICAgY2FzZSAhSVMkMS5xdWlja0RvbUVsKHRyZWUpOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdHJlZS50eXBlLFxuICAgICAgICByZWY6IHRyZWUucmVmLFxuICAgICAgICBvcHRpb25zOiBwcmltYXJ5QnVpbGRlciQxLmNsb25lLmRlZXAubm90S2V5cyhbJ3JlbGF0ZWRJbnN0YW5jZScsICdyZWxhdGVkJ10pKHRyZWUub3B0aW9ucyksXG4gICAgICAgIGNoaWxkcmVuOiB0cmVlLmNoaWxkcmVuLm1hcChxdWlja2RvbS50ZW1wbGF0ZSlcbiAgICAgIH07XG5cbiAgICBjYXNlICFJUyQxLnRlbXBsYXRlKHRyZWUpOlxuICAgICAgcmV0dXJuIHRyZWU7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KFBBUlNFX0VSUk9SX1BSRUZJWCwgXCIgKGFycmF5IHx8IHN0cmluZyB8fCBkb21FbCB8fCBxdWlja0RvbUVsIHx8IHRlbXBsYXRlKSwgZ290IFwiKS5jb25jYXQoU3RyaW5nKHRyZWUpKSk7XG4gIH1cbn07dmFyIE5PVF9ERUVQX0tFWVMsIE5PVF9LRVlTLCBfZXh0ZW5kQnlSZWYsIGV4dGVuZFRlbXBsYXRlO1xuTk9UX0RFRVBfS0VZUyA9IFsncmVsYXRlZEluc3RhbmNlJywgJ3JlbGF0ZWQnLCAnZGF0YSddO1xuTk9UX0tFWVMgPSBbJ2NoaWxkcmVuJywgJ19jaGlsZFJlZnMnXTtcbnZhciBleHRlbmRUZW1wbGF0ZSQxID0gZXh0ZW5kVGVtcGxhdGUgPSBmdW5jdGlvbiBleHRlbmRUZW1wbGF0ZShjdXJyZW50T3B0cywgbmV3T3B0cywgZ2xvYmFsT3B0cykge1xuICB2YXIgY3VycmVudENoaWxkLCBjdXJyZW50Q2hpbGRyZW4sIGdsb2JhbE9wdHNUcmFuc2Zvcm0sIGluZGV4LCBtYXhMZW5ndGgsIG5lZWRzVGVtcGxhdGVXcmFwLCBuZXdDaGlsZCwgbmV3Q2hpbGRQcm9jZXNzZWQsIG5ld0NoaWxkcmVuLCBub0NoYW5nZXMsIG91dHB1dCwgcmVmLCByZW1haW5pbmdOZXdDaGlsZHJlbjtcblxuICBpZiAoZ2xvYmFsT3B0cykge1xuICAgIGdsb2JhbE9wdHNUcmFuc2Zvcm0gPSB7XG4gICAgICBvcHRpb25zOiBmdW5jdGlvbiBvcHRpb25zKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHByaW1hcnlCdWlsZGVyJDEob3B0cywgZ2xvYmFsT3B0cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGlmIChJUyQxLmFycmF5KG5ld09wdHMpKSB7XG4gICAgbmV3T3B0cyA9IHBhcnNlVHJlZSQxKG5ld09wdHMsIGZhbHNlKTtcbiAgfSBlbHNlIGlmIChuZXdPcHRzICYmICFtYXRjaGVzU2NoZW1hKG5ld09wdHMpKSB7XG4gICAgbmV3T3B0cyA9IHtcbiAgICAgIG9wdGlvbnM6IG5ld09wdHNcbiAgICB9O1xuICB9XG5cbiAgb3V0cHV0ID0gcHJpbWFyeUJ1aWxkZXIkMS5kZWVwLm51bGxEZWxldGVzLm5vdEtleXMoTk9UX0tFWVMpLm5vdERlZXAoTk9UX0RFRVBfS0VZUykudHJhbnNmb3JtKGdsb2JhbE9wdHNUcmFuc2Zvcm0pLmNsb25lKGN1cnJlbnRPcHRzLCBuZXdPcHRzKTtcbiAgY3VycmVudENoaWxkcmVuID0gY3VycmVudE9wdHMuY2hpbGRyZW47XG4gIG5ld0NoaWxkcmVuID0gKG5ld09wdHMgIT0gbnVsbCA/IG5ld09wdHMuY2hpbGRyZW4gOiB2b2lkIDApIHx8IFtdO1xuICBvdXRwdXQuY2hpbGRyZW4gPSBbXTtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICBpZiAoSVMkMS5hcnJheShuZXdDaGlsZHJlbikpIHtcbiAgICBtYXhMZW5ndGggPSBNYXRoLm1heChjdXJyZW50Q2hpbGRyZW4ubGVuZ3RoLCBuZXdDaGlsZHJlbi5sZW5ndGgpO1xuICAgIGluZGV4ID0gLTE7XG5cbiAgICB3aGlsZSAoKytpbmRleCAhPT0gbWF4TGVuZ3RoKSB7XG4gICAgICBuZWVkc1RlbXBsYXRlV3JhcCA9IG5vQ2hhbmdlcyA9IGZhbHNlO1xuICAgICAgY3VycmVudENoaWxkID0gY3VycmVudENoaWxkcmVuW2luZGV4XTtcbiAgICAgIG5ld0NoaWxkID0gbmV3Q2hpbGRyZW5baW5kZXhdO1xuXG4gICAgICBuZXdDaGlsZFByb2Nlc3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICAgIGNhc2UgIUlTJDEudGVtcGxhdGUobmV3Q2hpbGQpOlxuICAgICAgICAgICAgcmV0dXJuIG5ld0NoaWxkO1xuXG4gICAgICAgICAgY2FzZSAhSVMkMS5hcnJheShuZXdDaGlsZCk6XG4gICAgICAgICAgICByZXR1cm4gbmVlZHNUZW1wbGF0ZVdyYXAgPSBwYXJzZVRyZWUkMShuZXdDaGlsZCk7XG5cbiAgICAgICAgICBjYXNlICFJUyQxLnN0cmluZyhuZXdDaGlsZCk6XG4gICAgICAgICAgICByZXR1cm4gbmVlZHNUZW1wbGF0ZVdyYXAgPSB7XG4gICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHRleHQ6IG5ld0NoaWxkXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICBjYXNlICEoIW5ld0NoaWxkICYmICFnbG9iYWxPcHRzKTpcbiAgICAgICAgICAgIHJldHVybiBub0NoYW5nZXMgPSB0cnVlO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBuZWVkc1RlbXBsYXRlV3JhcCA9IG5ld0NoaWxkIHx8IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0oKTtcblxuICAgICAgaWYgKG5vQ2hhbmdlcykge1xuICAgICAgICBuZXdDaGlsZFByb2Nlc3NlZCA9IGN1cnJlbnRDaGlsZDtcbiAgICAgIH0gZWxzZSBpZiAobmVlZHNUZW1wbGF0ZVdyYXApIHtcbiAgICAgICAgbmV3Q2hpbGRQcm9jZXNzZWQgPSBjdXJyZW50Q2hpbGQgPyBjdXJyZW50Q2hpbGQuZXh0ZW5kKG5ld0NoaWxkUHJvY2Vzc2VkLCBnbG9iYWxPcHRzKSA6IG5ldyBRdWlja1RlbXBsYXRlJDEocHJpbWFyeUJ1aWxkZXIkMS5jbG9uZShzY2hlbWEsIG5ld0NoaWxkUHJvY2Vzc2VkKSk7XG4gICAgICB9XG5cbiAgICAgIG91dHB1dC5jaGlsZHJlbi5wdXNoKG5ld0NoaWxkUHJvY2Vzc2VkKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoSVMkMS5vYmplY3QobmV3Q2hpbGRyZW4pKSB7XG4gICAgbmV3Q2hpbGRyZW4gPSBwcmltYXJ5QnVpbGRlciQxLmFsbG93TnVsbC5jbG9uZShuZXdDaGlsZHJlbik7XG4gICAgb3V0cHV0LmNoaWxkcmVuID0gX2V4dGVuZEJ5UmVmKG5ld0NoaWxkcmVuLCBjdXJyZW50Q2hpbGRyZW4sIGdsb2JhbE9wdHMpO1xuICAgIHJlbWFpbmluZ05ld0NoaWxkcmVuID0gbmV3Q2hpbGRyZW47XG5cbiAgICBmb3IgKHJlZiBpbiByZW1haW5pbmdOZXdDaGlsZHJlbikge1xuICAgICAgbmV3Q2hpbGQgPSByZW1haW5pbmdOZXdDaGlsZHJlbltyZWZdO1xuICAgICAgbmV3Q2hpbGRQcm9jZXNzZWQgPSBJUyQxLm9iamVjdFBsYWluKG5ld0NoaWxkKSAmJiAhSVMkMS50ZW1wbGF0ZShuZXdDaGlsZCkgPyBuZXdDaGlsZCA6IHBhcnNlVHJlZSQxKG5ld0NoaWxkKTtcbiAgICAgIG91dHB1dC5jaGlsZHJlbi5wdXNoKG5ldyBRdWlja1RlbXBsYXRlJDEobmV3Q2hpbGRQcm9jZXNzZWQpKTtcbiAgICAgIGRlbGV0ZSByZW1haW5pbmdOZXdDaGlsZHJlbltyZWZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG5fZXh0ZW5kQnlSZWYgPSBmdW5jdGlvbiBleHRlbmRCeVJlZihuZXdDaGlsZHJlblJlZnMsIGN1cnJlbnRDaGlsZHJlbiwgZ2xvYmFsT3B0cykge1xuICB2YXIgY3VycmVudENoaWxkLCBpLCBsZW4sIG5ld0NoaWxkLCBuZXdDaGlsZFByb2Nlc3NlZCwgb3V0cHV0O1xuXG4gIGlmICghY3VycmVudENoaWxkcmVuLmxlbmd0aCkge1xuICAgIHJldHVybiBjdXJyZW50Q2hpbGRyZW47XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0gW107XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBjdXJyZW50Q2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRDaGlsZHJlbltpXTtcbiAgICAgIG5ld0NoaWxkID0gbmV3Q2hpbGRyZW5SZWZzW2N1cnJlbnRDaGlsZC5yZWZdO1xuXG4gICAgICBpZiAobmV3Q2hpbGQpIHtcbiAgICAgICAgbmV3Q2hpbGRQcm9jZXNzZWQgPSBjdXJyZW50Q2hpbGQuZXh0ZW5kKG5ld0NoaWxkLCBnbG9iYWxPcHRzKTtcbiAgICAgICAgZGVsZXRlIG5ld0NoaWxkcmVuUmVmc1tjdXJyZW50Q2hpbGQucmVmXTtcbiAgICAgIH0gZWxzZSBpZiAobmV3Q2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIG5ld0NoaWxkcmVuUmVmc1tjdXJyZW50Q2hpbGQucmVmXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdDaGlsZFByb2Nlc3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICAgICAgICBjYXNlICFnbG9iYWxPcHRzOlxuICAgICAgICAgICAgICByZXR1cm4gY3VycmVudENoaWxkLmV4dGVuZChudWxsLCBnbG9iYWxPcHRzKTtcblxuICAgICAgICAgICAgY2FzZSAhT2JqZWN0LmtleXMobmV3Q2hpbGRyZW5SZWZzKS5sZW5ndGg6XG4gICAgICAgICAgICAgIHJldHVybiBjdXJyZW50Q2hpbGQuZXh0ZW5kKCk7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBjdXJyZW50Q2hpbGQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KCk7XG4gICAgICB9XG5cbiAgICAgIG5ld0NoaWxkUHJvY2Vzc2VkLmNoaWxkcmVuID0gX2V4dGVuZEJ5UmVmKG5ld0NoaWxkcmVuUmVmcywgbmV3Q2hpbGRQcm9jZXNzZWQuY2hpbGRyZW4pO1xuICAgICAgb3V0cHV0LnB1c2gobmV3Q2hpbGRQcm9jZXNzZWQpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbn07dmFyIFF1aWNrVGVtcGxhdGU7XG52YXIgUXVpY2tUZW1wbGF0ZSQxID0gUXVpY2tUZW1wbGF0ZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFF1aWNrVGVtcGxhdGUoY29uZmlnLCBpc1RyZWUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUXVpY2tUZW1wbGF0ZSk7XG5cbiAgICBpZiAoSVMkMS50ZW1wbGF0ZShjb25maWcpKSB7XG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cblxuICAgIGNvbmZpZyA9IGlzVHJlZSA/IHBhcnNlVHJlZSQxKGNvbmZpZykgOiBjb25maWc7XG4gICAgcHJpbWFyeUJ1aWxkZXIkMSh0aGlzLCBjb25maWcpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFF1aWNrVGVtcGxhdGUsIFt7XG4gICAga2V5OiBcImV4dGVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRlbmQobmV3VmFsdWVzLCBnbG9iYWxPcHRzKSB7XG4gICAgICByZXR1cm4gbmV3IFF1aWNrVGVtcGxhdGUoZXh0ZW5kVGVtcGxhdGUkMSh0aGlzLCBuZXdWYWx1ZXMsIGdsb2JhbE9wdHMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3Bhd25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3Bhd24obmV3VmFsdWVzLCBnbG9iYWxPcHRzLCBkYXRhKSB7XG4gICAgICB2YXIgY2hpbGQsIGNoaWxkRGF0YSwgY2hpbGRyZW4sIGVsZW1lbnQsIGksIGxlbiwgb3B0aW9ucywgdHlwZTtcblxuICAgICAgaWYgKG5ld1ZhbHVlcyAmJiBuZXdWYWx1ZXMuZGF0YSkge1xuICAgICAgICBkYXRhID0gbmV3VmFsdWVzLmRhdGE7XG5cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKG5ld1ZhbHVlcykubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgbmV3VmFsdWVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobmV3VmFsdWVzIHx8IGdsb2JhbE9wdHMpIHtcbiAgICAgICAgdmFyIF9leHRlbmRUZW1wbGF0ZSA9IGV4dGVuZFRlbXBsYXRlJDEodGhpcywgbmV3VmFsdWVzLCBnbG9iYWxPcHRzKTtcblxuICAgICAgICBvcHRpb25zID0gX2V4dGVuZFRlbXBsYXRlLm9wdGlvbnM7XG4gICAgICAgIGNoaWxkcmVuID0gX2V4dGVuZFRlbXBsYXRlLmNoaWxkcmVuO1xuICAgICAgICB0eXBlID0gX2V4dGVuZFRlbXBsYXRlLnR5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgICAgIHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICAgIG9wdGlvbnMgPSBwcmltYXJ5QnVpbGRlciQxLmNsb25lKG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50ID0gX3F1aWNrZG9tLmNyZWF0ZShbdHlwZSwgb3B0aW9uc10pO1xuXG4gICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgY2hpbGREYXRhID0gb3B0aW9ucy5wYXNzRGF0YVRvQ2hpbGRyZW4gPyBkYXRhIHx8IG9wdGlvbnMuZGF0YSA6IHZvaWQgMDtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgZWxlbWVudC5hcHBlbmQoY2hpbGQuc3Bhd24obnVsbCwgbnVsbCwgY2hpbGREYXRhKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWxlbWVudC5fcG9zdENyZWF0aW9uKGRhdGEpO1xuXG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUXVpY2tUZW1wbGF0ZTtcbn0oKTtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbmlmIChRdWlja1RlbXBsYXRlLm5hbWUgPT0gbnVsbCkge1xuICBRdWlja1RlbXBsYXRlLm5hbWUgPSAnUXVpY2tUZW1wbGF0ZSc7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWlja1RlbXBsYXRlLnByb3RvdHlwZSwgJ2NoaWxkJywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRSZWZzIHx8IF9nZXRDaGlsZFJlZnModGhpcyk7XG4gIH1cbn0pO1xuXG5fcXVpY2tkb20udGVtcGxhdGUgPSBmdW5jdGlvbiAodHJlZSkge1xuICByZXR1cm4gbmV3IFF1aWNrVGVtcGxhdGUodHJlZSwgdHJ1ZSk7XG59O1xuXG5fcXVpY2tkb20uaXNUZW1wbGF0ZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgcmV0dXJuIElTJDEudGVtcGxhdGUodGFyZ2V0KTtcbn07dmFyIFF1aWNrQmF0Y2g7XG52YXIgUXVpY2tCYXRjaCQxID0gUXVpY2tCYXRjaCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFF1aWNrQmF0Y2goZWxlbWVudHMsIHJldHVyblJlc3VsdHMxKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFF1aWNrQmF0Y2gpO1xuXG4gICAgdGhpcy5yZXR1cm5SZXN1bHRzID0gcmV0dXJuUmVzdWx0czE7XG4gICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiBfcXVpY2tkb20oZWwpO1xuICAgIH0pO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFF1aWNrQmF0Y2gsIFt7XG4gICAga2V5OiBcInJldmVyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmV2ZXJzZSgpIHtcbiAgICAgIHRoaXMuZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzLnJldmVyc2UoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXR1cm5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JldHVybihyZXR1cm5OZXh0KSB7XG4gICAgICBpZiAocmV0dXJuTmV4dCkge1xuICAgICAgICB0aGlzLnJldHVyblJlc3VsdHMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RSZXN1bHRzO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBRdWlja0JhdGNoO1xufSgpO1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuaWYgKFF1aWNrQmF0Y2gubmFtZSA9PSBudWxsKSB7XG4gIFF1aWNrQmF0Y2gubmFtZSA9ICdRdWlja0JhdGNoJztcbn1cblxuT2JqZWN0LmtleXMoUXVpY2tFbGVtZW50JDIucHJvdG90eXBlKS5jb25jYXQoJ2NzcycsICdyZXBsYWNlV2l0aCcsICdodG1sJywgJ3RleHQnKS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgcmV0dXJuIFF1aWNrQmF0Y2gucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICB2YXIgZWxlbWVudCwgcmVzdWx0cztcblxuICAgIHJlc3VsdHMgPSB0aGlzLmxhc3RSZXN1bHRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGksIGxlbiwgcmVmLCByZXN1bHRzMTtcbiAgICAgIHJlZiA9IHRoaXMuZWxlbWVudHM7XG4gICAgICByZXN1bHRzMSA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZWxlbWVudCA9IHJlZltpXTtcblxuICAgICAgICBpZiAobWV0aG9kID09PSAnaHRtbCcgfHwgbWV0aG9kID09PSAndGV4dCcpIHtcbiAgICAgICAgICBpZiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHJlc3VsdHMxLnB1c2goZWxlbWVudFttZXRob2RdID0gbmV3VmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRzMS5wdXNoKGVsZW1lbnRbbWV0aG9kXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfZWxlbWVudDtcblxuICAgICAgICAgIHJlc3VsdHMxLnB1c2goKF9lbGVtZW50ID0gZWxlbWVudClbbWV0aG9kXS5hcHBseShfZWxlbWVudCwgYXJndW1lbnRzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdHMxO1xuICAgIH0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIGlmICh0aGlzLnJldHVyblJlc3VsdHMpIHtcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG59KTtcblxuX3F1aWNrZG9tLmJhdGNoID0gZnVuY3Rpb24gKGVsZW1lbnRzLCByZXR1cm5SZXN1bHRzKSB7XG4gIGlmICghSVMkMS5pdGVyYWJsZShlbGVtZW50cykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYXRjaDogZXhwZWN0ZWQgYW4gaXRlcmFibGUsIGdvdCBcIi5jb25jYXQoU3RyaW5nKGVsZW1lbnRzKSkpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBRdWlja0JhdGNoKGVsZW1lbnRzLCByZXR1cm5SZXN1bHRzKTtcbn07dmFyIHZlcnNpb24kMiA9IFwiMS4wLjkyXCI7dmFyIFNIT1JUQ1VUUywgaSwgbGVuLCBzaG9ydGN1dDtcblNIT1JUQ1VUUyA9IFsnbGluazphJywgJ2FuY2hvcjphJywgJ2EnLCAndGV4dCcsICdkaXYnLCAnc3BhbicsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZWFkZXInLCAnZm9vdGVyJywgJ3NlY3Rpb24nLCAnYnV0dG9uJywgJ2JyJywgJ3VsJywgJ29sJywgJ2xpJywgJ2ZpZWxkc2V0JywgJ2lucHV0JywgJ3RleHRhcmVhJywgJ3NlbGVjdCcsICdvcHRpb24nLCAnZm9ybScsICdmcmFtZScsICdocicsICdpZnJhbWUnLCAnaW1nJywgJ3BpY3R1cmUnLCAnbWFpbicsICduYXYnLCAnbWV0YScsICdvYmplY3QnLCAncHJlJywgJ3N0eWxlJywgJ3RhYmxlJywgJ3Rib2R5JywgJ3RoJywgJ3RyJywgJ3RkJywgJ3Rmb290JywgLy8gJ3RlbXBsYXRlJ1xuJ3ZpZGVvJ107XG5cbmZvciAoaSA9IDAsIGxlbiA9IFNIT1JUQ1VUUy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICBzaG9ydGN1dCA9IFNIT1JUQ1VUU1tpXTtcblxuICAoZnVuY3Rpb24gKHNob3J0Y3V0KSB7XG4gICAgdmFyIHByb3AsIHNwbGl0LCB0eXBlO1xuICAgIHByb3AgPSB0eXBlID0gc2hvcnRjdXQ7XG5cbiAgICBpZiAoaW5jbHVkZXMkMShzaG9ydGN1dCwgJzonKSkge1xuICAgICAgc3BsaXQgPSBzaG9ydGN1dC5zcGxpdCgnOicpO1xuICAgICAgcHJvcCA9IHNwbGl0WzBdO1xuICAgICAgdHlwZSA9IHNwbGl0WzFdO1xuICAgIH1cblxuICAgIHJldHVybiBfcXVpY2tkb21bcHJvcF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3F1aWNrZG9tLmFwcGx5KHZvaWQgMCwgW3R5cGVdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgfTtcbiAgfSkoc2hvcnRjdXQpO1xufWluaXQoUXVpY2tFbGVtZW50JDIsIFF1aWNrV2luZG93JDIpO1xuX3F1aWNrZG9tLlF1aWNrRWxlbWVudCA9IFF1aWNrRWxlbWVudCQyO1xuX3F1aWNrZG9tLlF1aWNrVGVtcGxhdGUgPSBRdWlja1RlbXBsYXRlJDE7XG5fcXVpY2tkb20uUXVpY2tXaW5kb3cgPSBRdWlja1dpbmRvdyQyO1xuX3F1aWNrZG9tLlF1aWNrQmF0Y2ggPSBRdWlja0JhdGNoJDE7XG5fcXVpY2tkb20udmVyc2lvbiA9IHZlcnNpb24kMjtcbl9xdWlja2RvbS5DU1MgPSBpbmRleDtcbnZhciBxdWlja2RvbSA9IF9xdWlja2RvbTsgLy8gZXhwb3J0IHtxdWlja2RvbSBhcyBkZWZhdWx0LCBRdWlja0VsZW1lbnQsIFF1aWNrVGVtcGxhdGUsIFF1aWNrV2luZG93LCBRdWlja0JhdGNofVxuZXhwb3J0IGRlZmF1bHQgcXVpY2tkb207IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufXZhciBfZXh0ZW5kLCBpc0FycmF5LCBpc09iamVjdCwgX3Nob3VsZERlZXBFeHRlbmQ7XG5cbmlzQXJyYXkgPSBmdW5jdGlvbiBpc0FycmF5KHRhcmdldCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh0YXJnZXQpO1xufTtcblxuaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdCh0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGFyZ2V0KSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgfHwgaXNBcnJheSh0YXJnZXQpO1xufTtcblxuX3Nob3VsZERlZXBFeHRlbmQgPSBmdW5jdGlvbiBzaG91bGREZWVwRXh0ZW5kKG9wdGlvbnMsIHRhcmdldCwgcGFyZW50S2V5KSB7XG4gIGlmIChvcHRpb25zLmRlZXApIHtcbiAgICBpZiAob3B0aW9ucy5ub3REZWVwKSB7XG4gICAgICByZXR1cm4gIW9wdGlvbnMubm90RGVlcFt0YXJnZXRdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5kZWVwT25seSkge1xuICAgIHJldHVybiBvcHRpb25zLmRlZXBPbmx5W3RhcmdldF0gfHwgcGFyZW50S2V5ICYmIF9zaG91bGREZWVwRXh0ZW5kKG9wdGlvbnMsIHBhcmVudEtleSk7XG4gIH1cbn07IC8vIGVsc2UgZmFsc2VcblxuXG52YXIgZXh0ZW5kID0gX2V4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZChvcHRpb25zLCB0YXJnZXQsIHNvdXJjZXMsIHBhcmVudEtleSkge1xuICB2YXIgaSwga2V5LCBsZW4sIHNvdXJjZSwgc291cmNlVmFsdWUsIHN1YlRhcmdldCwgdGFyZ2V0VmFsdWU7XG5cbiAgaWYgKCF0YXJnZXQgfHwgX3R5cGVvZih0YXJnZXQpICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGFyZ2V0ID0ge307XG4gIH1cblxuICBmb3IgKGkgPSAwLCBsZW4gPSBzb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgc291cmNlID0gc291cmNlc1tpXTtcblxuICAgIGlmIChzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIHNvdXJjZVZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgIHRhcmdldFZhbHVlID0gdGFyZ2V0W2tleV07XG5cbiAgICAgICAgaWYgKHNvdXJjZVZhbHVlID09PSB0YXJnZXQgfHwgc291cmNlVmFsdWUgPT09IHZvaWQgMCB8fCBzb3VyY2VWYWx1ZSA9PT0gbnVsbCAmJiAhb3B0aW9ucy5hbGxvd051bGwgJiYgIW9wdGlvbnMubnVsbERlbGV0ZXMgfHwgb3B0aW9ucy5rZXlzICYmICFvcHRpb25zLmtleXNba2V5XSB8fCBvcHRpb25zLm5vdEtleXMgJiYgb3B0aW9ucy5ub3RLZXlzW2tleV0gfHwgb3B0aW9ucy5vd24gJiYgIXNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpIHx8IG9wdGlvbnMuZ2xvYmFsRmlsdGVyICYmICFvcHRpb25zLmdsb2JhbEZpbHRlcihzb3VyY2VWYWx1ZSwga2V5LCBzb3VyY2UpIHx8IG9wdGlvbnMuZmlsdGVycyAmJiBvcHRpb25zLmZpbHRlcnNba2V5XSAmJiAhb3B0aW9ucy5maWx0ZXJzW2tleV0oc291cmNlVmFsdWUsIGtleSwgc291cmNlKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNvdXJjZVZhbHVlID09PSBudWxsICYmIG9wdGlvbnMubnVsbERlbGV0ZXMpIHtcbiAgICAgICAgICBkZWxldGUgdGFyZ2V0W2tleV07XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5nbG9iYWxUcmFuc2Zvcm0pIHtcbiAgICAgICAgICBzb3VyY2VWYWx1ZSA9IG9wdGlvbnMuZ2xvYmFsVHJhbnNmb3JtKHNvdXJjZVZhbHVlLCBrZXksIHNvdXJjZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy50cmFuc2Zvcm1zICYmIG9wdGlvbnMudHJhbnNmb3Jtc1trZXldKSB7XG4gICAgICAgICAgc291cmNlVmFsdWUgPSBvcHRpb25zLnRyYW5zZm9ybXNba2V5XShzb3VyY2VWYWx1ZSwga2V5LCBzb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgICAgIGNhc2UgIShvcHRpb25zLmNvbmNhdCAmJiBpc0FycmF5KHNvdXJjZVZhbHVlKSAmJiBpc0FycmF5KHRhcmdldFZhbHVlKSk6XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHRhcmdldFZhbHVlLmNvbmNhdChzb3VyY2VWYWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgIShfc2hvdWxkRGVlcEV4dGVuZChvcHRpb25zLCBrZXksIHBhcmVudEtleSkgJiYgaXNPYmplY3Qoc291cmNlVmFsdWUpKTpcbiAgICAgICAgICAgIHN1YlRhcmdldCA9IGlzT2JqZWN0KHRhcmdldFZhbHVlKSA/IHRhcmdldFZhbHVlIDogaXNBcnJheShzb3VyY2VWYWx1ZSkgPyBbXSA6IHt9O1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBfZXh0ZW5kKG9wdGlvbnMsIHN1YlRhcmdldCwgW3NvdXJjZVZhbHVlXSwga2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTt2YXIgdmVyc2lvbiA9IFwiMS43LjRcIjt2YXIgbW9kaWZpZXJzLCBuZXdCdWlsZGVyLCBub3JtYWxpemVLZXlzLCBwcmltYXJ5QnVpbGRlcjtcblxubm9ybWFsaXplS2V5cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUtleXMoa2V5cykge1xuICB2YXIgaSwga2V5LCBsZW4sIG91dHB1dDtcblxuICBpZiAoa2V5cykge1xuICAgIG91dHB1dCA9IHt9O1xuXG4gICAgaWYgKF90eXBlb2Yoa2V5cykgIT09ICdvYmplY3QnKSB7XG4gICAgICBvdXRwdXRba2V5c10gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5cykpIHtcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKGtleXMpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIG91dHB1dFtrZXldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG59O1xuXG5uZXdCdWlsZGVyID0gZnVuY3Rpb24gbmV3QnVpbGRlcihpc0Jhc2UpIHtcbiAgdmFyIF9idWlsZGVyO1xuXG4gIF9idWlsZGVyID0gZnVuY3Rpb24gYnVpbGRlcih0YXJnZXQpIHtcbiAgICB2YXIgdGhlVGFyZ2V0O1xuICAgIHZhciAkX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsICRfaSA9IC0xLCBzb3VyY2VzID0gbmV3IEFycmF5KCRfbGVuKTsgd2hpbGUgKCsrJF9pIDwgJF9sZW4pIHNvdXJjZXNbJF9pXSA9IGFyZ3VtZW50c1skX2ldO1xuXG4gICAgaWYgKF9idWlsZGVyLm9wdGlvbnMudGFyZ2V0KSB7XG4gICAgICB0aGVUYXJnZXQgPSBfYnVpbGRlci5vcHRpb25zLnRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhlVGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgc291cmNlcy5zaGlmdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBleHRlbmQoX2J1aWxkZXIub3B0aW9ucywgdGhlVGFyZ2V0LCBzb3VyY2VzKTtcbiAgfTtcblxuICBpZiAoaXNCYXNlKSB7XG4gICAgX2J1aWxkZXIuaXNCYXNlID0gdHJ1ZTtcbiAgfVxuXG4gIF9idWlsZGVyLm9wdGlvbnMgPSB7fTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX2J1aWxkZXIsIG1vZGlmaWVycyk7XG4gIHJldHVybiBfYnVpbGRlcjtcbn07XG5cbm1vZGlmaWVycyA9IHtcbiAgJ2RlZXAnOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgXztcblxuICAgICAgXyA9IHRoaXMuaXNCYXNlID8gbmV3QnVpbGRlcigpIDogdGhpcztcbiAgICAgIF8ub3B0aW9ucy5kZWVwID0gdHJ1ZTtcbiAgICAgIHJldHVybiBfO1xuICAgIH1cbiAgfSxcbiAgJ293bic6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfO1xuXG4gICAgICBfID0gdGhpcy5pc0Jhc2UgPyBuZXdCdWlsZGVyKCkgOiB0aGlzO1xuICAgICAgXy5vcHRpb25zLm93biA9IHRydWU7XG4gICAgICByZXR1cm4gXztcbiAgICB9XG4gIH0sXG4gICdhbGxvd051bGwnOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgXztcblxuICAgICAgXyA9IHRoaXMuaXNCYXNlID8gbmV3QnVpbGRlcigpIDogdGhpcztcbiAgICAgIF8ub3B0aW9ucy5hbGxvd051bGwgPSB0cnVlO1xuICAgICAgcmV0dXJuIF87XG4gICAgfVxuICB9LFxuICAnbnVsbERlbGV0ZXMnOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgXztcblxuICAgICAgXyA9IHRoaXMuaXNCYXNlID8gbmV3QnVpbGRlcigpIDogdGhpcztcbiAgICAgIF8ub3B0aW9ucy5udWxsRGVsZXRlcyA9IHRydWU7XG4gICAgICByZXR1cm4gXztcbiAgICB9XG4gIH0sXG4gICdjb25jYXQnOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgXztcblxuICAgICAgXyA9IHRoaXMuaXNCYXNlID8gbmV3QnVpbGRlcigpIDogdGhpcztcbiAgICAgIF8ub3B0aW9ucy5jb25jYXQgPSB0cnVlO1xuICAgICAgcmV0dXJuIF87XG4gICAgfVxuICB9LFxuICAnY2xvbmUnOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgXztcblxuICAgICAgXyA9IHRoaXMuaXNCYXNlID8gbmV3QnVpbGRlcigpIDogdGhpcztcbiAgICAgIF8ub3B0aW9ucy50YXJnZXQgPSB7fTtcbiAgICAgIHJldHVybiBfO1xuICAgIH1cbiAgfSxcbiAgJ25vdERlZXAnOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgXztcblxuICAgICAgXyA9IHRoaXMuaXNCYXNlID8gbmV3QnVpbGRlcigpIDogdGhpcztcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICBfLm9wdGlvbnMubm90RGVlcCA9IG5vcm1hbGl6ZUtleXMoa2V5cyk7XG4gICAgICAgIHJldHVybiBfO1xuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gICdkZWVwT25seSc6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfO1xuXG4gICAgICBfID0gdGhpcy5pc0Jhc2UgPyBuZXdCdWlsZGVyKCkgOiB0aGlzO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgIF8ub3B0aW9ucy5kZWVwT25seSA9IG5vcm1hbGl6ZUtleXMoa2V5cyk7XG4gICAgICAgIHJldHVybiBfO1xuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gICdrZXlzJzoge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF87XG5cbiAgICAgIF8gPSB0aGlzLmlzQmFzZSA/IG5ld0J1aWxkZXIoKSA6IHRoaXM7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgXy5vcHRpb25zLmtleXMgPSBub3JtYWxpemVLZXlzKGtleXMpO1xuICAgICAgICByZXR1cm4gXztcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICAnbm90S2V5cyc6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfO1xuXG4gICAgICBfID0gdGhpcy5pc0Jhc2UgPyBuZXdCdWlsZGVyKCkgOiB0aGlzO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgIF8ub3B0aW9ucy5ub3RLZXlzID0gbm9ybWFsaXplS2V5cyhrZXlzKTtcbiAgICAgICAgcmV0dXJuIF87XG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgJ3RyYW5zZm9ybSc6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfO1xuXG4gICAgICBfID0gdGhpcy5pc0Jhc2UgPyBuZXdCdWlsZGVyKCkgOiB0aGlzO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBfLm9wdGlvbnMuZ2xvYmFsVHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgICB9IGVsc2UgaWYgKHRyYW5zZm9ybSAmJiBfdHlwZW9mKHRyYW5zZm9ybSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgXy5vcHRpb25zLnRyYW5zZm9ybXMgPSB0cmFuc2Zvcm07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gXztcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICAnZmlsdGVyJzoge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIF87XG5cbiAgICAgIF8gPSB0aGlzLmlzQmFzZSA/IG5ld0J1aWxkZXIoKSA6IHRoaXM7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIF8ub3B0aW9ucy5nbG9iYWxGaWx0ZXIgPSBmaWx0ZXI7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsdGVyICYmIF90eXBlb2YoZmlsdGVyKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBfLm9wdGlvbnMuZmlsdGVycyA9IGZpbHRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbn07XG5wcmltYXJ5QnVpbGRlciA9IG5ld0J1aWxkZXIodHJ1ZSk7XG5wcmltYXJ5QnVpbGRlci52ZXJzaW9uID0gdmVyc2lvbjtcbnZhciBwcmltYXJ5QnVpbGRlciQxID0gcHJpbWFyeUJ1aWxkZXI7ZXhwb3J0IGRlZmF1bHQgcHJpbWFyeUJ1aWxkZXIkMTsiLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IChwcm9taXNlLCBvbkZpbmFsbHkpID0+IHtcblx0b25GaW5hbGx5ID0gb25GaW5hbGx5IHx8ICgoKSA9PiB7fSk7XG5cblx0cmV0dXJuIHByb21pc2UudGhlbihcblx0XHR2YWwgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG5cdFx0XHRyZXNvbHZlKG9uRmluYWxseSgpKTtcblx0XHR9KS50aGVuKCgpID0+IHZhbCksXG5cdFx0ZXJyID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuXHRcdFx0cmVzb2x2ZShvbkZpbmFsbHkoKSk7XG5cdFx0fSkudGhlbigoKSA9PiB7XG5cdFx0XHR0aHJvdyBlcnI7XG5cdFx0fSlcblx0KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBwRmluYWxseSA9IHJlcXVpcmUoJ3AtZmluYWxseScpO1xuXG5jbGFzcyBUaW1lb3V0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcblx0XHRzdXBlcihtZXNzYWdlKTtcblx0XHR0aGlzLm5hbWUgPSAnVGltZW91dEVycm9yJztcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9taXNlLCBtcywgZmFsbGJhY2spID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0aWYgKHR5cGVvZiBtcyAhPT0gJ251bWJlcicgfHwgbXMgPCAwKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYG1zYCB0byBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuXHR9XG5cblx0Y29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRpZiAodHlwZW9mIGZhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRyZXNvbHZlKGZhbGxiYWNrKCkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IG1lc3NhZ2UgPSB0eXBlb2YgZmFsbGJhY2sgPT09ICdzdHJpbmcnID8gZmFsbGJhY2sgOiBgUHJvbWlzZSB0aW1lZCBvdXQgYWZ0ZXIgJHttc30gbWlsbGlzZWNvbmRzYDtcblx0XHRjb25zdCBlcnIgPSBmYWxsYmFjayBpbnN0YW5jZW9mIEVycm9yID8gZmFsbGJhY2sgOiBuZXcgVGltZW91dEVycm9yKG1lc3NhZ2UpO1xuXG5cdFx0cmVqZWN0KGVycik7XG5cdH0sIG1zKTtcblxuXHRwRmluYWxseShcblx0XHRwcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KSxcblx0XHQoKSA9PiB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGltZXIpO1xuXHRcdH1cblx0KTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cy5UaW1lb3V0RXJyb3IgPSBUaW1lb3V0RXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBwVGltZW91dCA9IHJlcXVpcmUoJ3AtdGltZW91dCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChlbWl0dGVyLCBldmVudCwgb3B0cykgPT4ge1xuXHRsZXQgY2FuY2VsO1xuXG5cdGNvbnN0IHJldCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdG9wdHMgPSB7ZmlsdGVyOiBvcHRzfTtcblx0XHR9XG5cblx0XHRvcHRzID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0XHRyZWplY3Rpb25FdmVudHM6IFsnZXJyb3InXSxcblx0XHRcdG11bHRpQXJnczogZmFsc2Vcblx0XHR9LCBvcHRzKTtcblxuXHRcdGxldCBhZGRMaXN0ZW5lciA9IGVtaXR0ZXIub24gfHwgZW1pdHRlci5hZGRMaXN0ZW5lciB8fCBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXI7XG5cdFx0bGV0IHJlbW92ZUxpc3RlbmVyID0gZW1pdHRlci5vZmYgfHwgZW1pdHRlci5yZW1vdmVMaXN0ZW5lciB8fCBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cblx0XHRpZiAoIWFkZExpc3RlbmVyIHx8ICFyZW1vdmVMaXN0ZW5lcikge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRW1pdHRlciBpcyBub3QgY29tcGF0aWJsZScpO1xuXHRcdH1cblxuXHRcdGFkZExpc3RlbmVyID0gYWRkTGlzdGVuZXIuYmluZChlbWl0dGVyKTtcblx0XHRyZW1vdmVMaXN0ZW5lciA9IHJlbW92ZUxpc3RlbmVyLmJpbmQoZW1pdHRlcik7XG5cblx0XHRjb25zdCByZXNvbHZlSGFuZGxlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0aWYgKG9wdHMubXVsdGlBcmdzKSB7XG5cdFx0XHRcdHZhbHVlID0gW10uc2xpY2UuYXBwbHkoYXJndW1lbnRzKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdHMuZmlsdGVyICYmICFvcHRzLmZpbHRlcih2YWx1ZSkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjYW5jZWwoKTtcblx0XHRcdHJlc29sdmUodmFsdWUpO1xuXHRcdH07XG5cblx0XHRjb25zdCByZWplY3RIYW5kbGVyID0gZnVuY3Rpb24gKHJlYXNvbikge1xuXHRcdFx0Y2FuY2VsKCk7XG5cblx0XHRcdGlmIChvcHRzLm11bHRpQXJncykge1xuXHRcdFx0XHRyZWplY3QoW10uc2xpY2UuYXBwbHkoYXJndW1lbnRzKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZWplY3QocmVhc29uKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Y2FuY2VsID0gKCkgPT4ge1xuXHRcdFx0cmVtb3ZlTGlzdGVuZXIoZXZlbnQsIHJlc29sdmVIYW5kbGVyKTtcblxuXHRcdFx0Zm9yIChjb25zdCByZWplY3Rpb25FdmVudCBvZiBvcHRzLnJlamVjdGlvbkV2ZW50cykge1xuXHRcdFx0XHRyZW1vdmVMaXN0ZW5lcihyZWplY3Rpb25FdmVudCwgcmVqZWN0SGFuZGxlcik7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGFkZExpc3RlbmVyKGV2ZW50LCByZXNvbHZlSGFuZGxlcik7XG5cblx0XHRmb3IgKGNvbnN0IHJlamVjdGlvbkV2ZW50IG9mIG9wdHMucmVqZWN0aW9uRXZlbnRzKSB7XG5cdFx0XHRhZGRMaXN0ZW5lcihyZWplY3Rpb25FdmVudCwgcmVqZWN0SGFuZGxlcik7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXQuY2FuY2VsID0gY2FuY2VsO1xuXG5cdGlmICh0eXBlb2Ygb3B0cy50aW1lb3V0ID09PSAnbnVtYmVyJykge1xuXHRcdHJldHVybiBwVGltZW91dChyZXQsIG9wdHMudGltZW91dCk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY3JlYXRlRW5kQnJlYWsodmFsdWUpIHtcblx0dmFyIGluc3RhbmNlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuXHRpbnN0YW5jZS52YWx1ZSA9IHZhbHVlO1xuXHRpbnN0YW5jZS5fX2lzRW5kQnJlYWsgPSB0cnVlO1xuXHRyZXR1cm4gaW5zdGFuY2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbCkge1xuXHR2YXIgZXJyID0gY3JlYXRlRW5kQnJlYWsodmFsKTtcblx0dGhyb3cgZXJyO1xufTtcblxubW9kdWxlLmV4cG9ydHMuZW5kID0gZnVuY3Rpb24gKGVycikge1xuXHRpZiAoZXJyLl9faXNFbmRCcmVhaykge1xuXHRcdHJldHVybiBlcnIudmFsdWU7XG5cdH1cblxuXHR0aHJvdyBlcnI7XG59O1xuIiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59dmFyIGRlZmluZWQgPSBmdW5jdGlvbiBkZWZpbmVkKHN1YmplY3QpIHtcbiAgcmV0dXJuIHN1YmplY3QgIT09IHZvaWQgMDtcbn07XG52YXIgYXJyYXkgPSBmdW5jdGlvbiBhcnJheShzdWJqZWN0KSB7XG4gIHJldHVybiBzdWJqZWN0IGluc3RhbmNlb2YgQXJyYXk7XG59O1xudmFyIG9iamVjdCA9IGZ1bmN0aW9uIG9iamVjdChzdWJqZWN0KSB7XG4gIHJldHVybiBfdHlwZW9mKHN1YmplY3QpID09PSAnb2JqZWN0JyAmJiBzdWJqZWN0OyAvLyAybmQgY2hlY2sgaXMgdG8gdGVzdCBhZ2FpbnN0ICdudWxsJyB2YWx1ZXNcbn07XG52YXIgb2JqZWN0UGxhaW4gPSBmdW5jdGlvbiBvYmplY3RQbGFpbihzdWJqZWN0KSB7XG4gIHJldHVybiBvYmplY3Qoc3ViamVjdCkgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN1YmplY3QpID09PSAnW29iamVjdCBPYmplY3RdJyAmJiBzdWJqZWN0LmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG59O1xudmFyIHN0cmluZyA9IGZ1bmN0aW9uIHN0cmluZyhzdWJqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygc3ViamVjdCA9PT0gJ3N0cmluZyc7XG59O1xudmFyIG51bWJlciA9IGZ1bmN0aW9uIG51bWJlcihzdWJqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygc3ViamVjdCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHN1YmplY3QpO1xufTtcbnZhciBudW1iZXJMb29zZSA9IGZ1bmN0aW9uIG51bWJlckxvb3NlKHN1YmplY3QpIHtcbiAgcmV0dXJuIG51bWJlcihzdWJqZWN0KSB8fCBzdHJpbmcoc3ViamVjdCkgJiYgbnVtYmVyKE51bWJlcihzdWJqZWN0KSk7XG59O1xudmFyIGl0ZXJhYmxlID0gZnVuY3Rpb24gaXRlcmFibGUoc3ViamVjdCkge1xuICByZXR1cm4gb2JqZWN0KHN1YmplY3QpICYmIG51bWJlcihzdWJqZWN0Lmxlbmd0aCk7XG59O1xudmFyIGZ1bmN0aW9uXyA9IGZ1bmN0aW9uIGZ1bmN0aW9uXyhzdWJqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygc3ViamVjdCA9PT0gJ2Z1bmN0aW9uJztcbn07dmFyIG5hdGl2ZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7ZGVmaW5lZDogZGVmaW5lZCxhcnJheTogYXJyYXksb2JqZWN0OiBvYmplY3Qsb2JqZWN0UGxhaW46IG9iamVjdFBsYWluLHN0cmluZzogc3RyaW5nLG51bWJlcjogbnVtYmVyLG51bWJlckxvb3NlOiBudW1iZXJMb29zZSxpdGVyYWJsZTogaXRlcmFibGUsZnVuY3Rpb25fOiBmdW5jdGlvbl99KTt2YXIgZG9tRG9jID0gZnVuY3Rpb24gZG9tRG9jKHN1YmplY3QpIHtcbiAgcmV0dXJuIHN1YmplY3QgJiYgc3ViamVjdC5ub2RlVHlwZSA9PT0gOTtcbn07XG52YXIgZG9tRWwgPSBmdW5jdGlvbiBkb21FbChzdWJqZWN0KSB7XG4gIHJldHVybiBzdWJqZWN0ICYmIHN1YmplY3Qubm9kZVR5cGUgPT09IDE7XG59O1xudmFyIGRvbVRleHQgPSBmdW5jdGlvbiBkb21UZXh0KHN1YmplY3QpIHtcbiAgcmV0dXJuIHN1YmplY3QgJiYgc3ViamVjdC5ub2RlVHlwZSA9PT0gMztcbn07XG52YXIgZG9tTm9kZSA9IGZ1bmN0aW9uIGRvbU5vZGUoc3ViamVjdCkge1xuICByZXR1cm4gZG9tRWwoc3ViamVjdCkgfHwgZG9tVGV4dChzdWJqZWN0KTtcbn07XG52YXIgZG9tVGV4dGFyZWEgPSBmdW5jdGlvbiBkb21UZXh0YXJlYShzdWJqZWN0KSB7XG4gIHJldHVybiBzdWJqZWN0ICYmIHN1YmplY3Qubm9kZU5hbWUgPT09ICdURVhUQVJFQSc7XG59O1xudmFyIGRvbUlucHV0ID0gZnVuY3Rpb24gZG9tSW5wdXQoc3ViamVjdCkge1xuICByZXR1cm4gc3ViamVjdCAmJiBzdWJqZWN0Lm5vZGVOYW1lID09PSAnSU5QVVQnO1xufTtcbnZhciBkb21TZWxlY3QgPSBmdW5jdGlvbiBkb21TZWxlY3Qoc3ViamVjdCkge1xuICByZXR1cm4gc3ViamVjdCAmJiBzdWJqZWN0Lm5vZGVOYW1lID09PSAnU0VMRUNUJztcbn07XG52YXIgZG9tRmllbGQgPSBmdW5jdGlvbiBkb21GaWVsZChzdWJqZWN0KSB7XG4gIHJldHVybiBkb21JbnB1dChzdWJqZWN0KSB8fCBkb21UZXh0YXJlYShzdWJqZWN0KSB8fCBkb21TZWxlY3Qoc3ViamVjdCk7XG59O3ZhciBkb20gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7ZG9tRG9jOiBkb21Eb2MsZG9tRWw6IGRvbUVsLGRvbVRleHQ6IGRvbVRleHQsZG9tTm9kZTogZG9tTm9kZSxkb21UZXh0YXJlYTogZG9tVGV4dGFyZWEsZG9tSW5wdXQ6IGRvbUlucHV0LGRvbVNlbGVjdDogZG9tU2VsZWN0LGRvbUZpZWxkOiBkb21GaWVsZH0pO3ZhciBBVkFJTF9TRVRTLCBDaGVja3M7XG5BVkFJTF9TRVRTID0ge1xuICBuYXRpdmVzOiBuYXRpdmVzLFxuICBkb206IGRvbVxufTtcblxuQ2hlY2tzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgX2NyZWF0ZUNsYXNzKENoZWNrcywgW3tcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICAgIHZhciBhcmdzO1xuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBDaGVja3MoYXJncyk7XG4gICAgfVxuICB9XSk7XG5cbiAgZnVuY3Rpb24gQ2hlY2tzKHNldHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2hlY2tzKTtcblxuICAgIHZhciBpLCBsZW4sIHNldDtcblxuICAgIGlmIChzZXRzID09IG51bGwpIHtcbiAgICAgIHNldHMgPSBbJ25hdGl2ZXMnXTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBzZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzZXQgPSBzZXRzW2ldO1xuXG4gICAgICBpZiAoQVZBSUxfU0VUU1tzZXRdKSB7XG4gICAgICAgIHRoaXMubG9hZChBVkFJTF9TRVRTW3NldF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDaGVja3MsIFt7XG4gICAga2V5OiBcImxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZChzZXQpIHtcbiAgICAgIHZhciBrZXksIHZhbHVlO1xuXG4gICAgICBpZiAoQVZBSUxfU0VUUy5uYXRpdmVzLnN0cmluZyhzZXQpKSB7XG4gICAgICAgIHNldCA9IEFWQUlMX1NFVFNbc2V0XTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFBVkFJTF9TRVRTLm5hdGl2ZXMub2JqZWN0UGxhaW4oc2V0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZvciAoa2V5IGluIHNldCkge1xuICAgICAgICB2YWx1ZSA9IHNldFtrZXldO1xuXG4gICAgICAgIGlmIChrZXkgPT09ICdmdW5jdGlvbl8nKSB7XG4gICAgICAgICAga2V5ID0gJ2Z1bmN0aW9uJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDaGVja3M7XG59KCk7XG5cbnZhciBpbmRleCA9IENoZWNrcy5wcm90b3R5cGUuY3JlYXRlKCk7ZXhwb3J0IGRlZmF1bHQgaW5kZXg7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodHlwZSkge1xuICB2YXIgdHlwZXNcbiAgaWYgKCB0eXBlICYmICgndHJhbnNpdGlvbicgPT09IHR5cGUgfHwgJ3RyYW5zJyA9PT0gdHlwZSkgKSB7XG4gICAgdHlwZXMgPSB7XG4gICAgICAnT1RyYW5zaXRpb24nOiAgICAgICdvVHJhbnNpdGlvbkVuZCcsXG4gICAgICAnV2Via2l0VHJhbnNpdGlvbic6ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICAgICdNb3pUcmFuc2l0aW9uJzogICAgJ3RyYW5zaXRpb25lbmQnLFxuICAgICAgJ3RyYW5zaXRpb24nOiAgICAgICAndHJhbnNpdGlvbmVuZCdcbiAgICB9XG4gIH1cbiAgZWxzZSB7IC8vIGFuaW1hdGlvbiBpcyBkZWZhdWx0XG4gICAgdHlwZXMgPSB7XG4gICAgICAnT0FuaW1hdGlvbic6ICAgICAgJ29BbmltYXRpb25FbmQnLFxuICAgICAgJ1dlYmtpdEFuaW1hdGlvbic6ICd3ZWJraXRBbmltYXRpb25FbmQnLFxuICAgICAgJ01vekFuaW1hdGlvbic6ICAgICdhbmltYXRpb25lbmQnLFxuICAgICAgJ2FuaW1hdGlvbic6ICAgICAgICdhbmltYXRpb25lbmQnXG4gICAgfVxuICB9XG4gIHZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZmFrZScpXG4gIHJldHVybiBPYmplY3Qua2V5cyh0eXBlcykucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCB0cmFucykge1xuICAgIHJldHVybiB1bmRlZmluZWQgIT09IGVsZW0uc3R5bGVbdHJhbnNdPyB0eXBlc1t0cmFuc106IHByZXZcbiAgfSwgJycpXG59XG4iLCIvKipcbiAqIGV2ZW50LWxpdGUuanMgLSBMaWdodC13ZWlnaHQgRXZlbnRFbWl0dGVyIChsZXNzIHRoYW4gMUtCIHdoZW4gZ3ppcHBlZClcbiAqXG4gKiBAY29weXJpZ2h0IFl1c3VrZSBLYXdhc2FraVxuICogQGxpY2Vuc2UgTUlUXG4gKiBAY29uc3RydWN0b3JcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2thd2FuZXQvZXZlbnQtbGl0ZVxuICogQHNlZSBodHRwOi8va2F3YW5ldC5naXRodWIuaW8vZXZlbnQtbGl0ZS9FdmVudExpdGUuaHRtbFxuICogQGV4YW1wbGVcbiAqIHZhciBFdmVudExpdGUgPSByZXF1aXJlKFwiZXZlbnQtbGl0ZVwiKTtcbiAqXG4gKiBmdW5jdGlvbiBNeUNsYXNzKCkgey4uLn0gICAgICAgICAgICAgLy8geW91ciBjbGFzc1xuICpcbiAqIEV2ZW50TGl0ZS5taXhpbihNeUNsYXNzLnByb3RvdHlwZSk7ICAvLyBpbXBvcnQgZXZlbnQgbWV0aG9kc1xuICpcbiAqIHZhciBvYmogPSBuZXcgTXlDbGFzcygpO1xuICogb2JqLm9uKFwiZm9vXCIsIGZ1bmN0aW9uKCkgey4uLn0pOyAgICAgLy8gYWRkIGV2ZW50IGxpc3RlbmVyXG4gKiBvYmoub25jZShcImJhclwiLCBmdW5jdGlvbigpIHsuLi59KTsgICAvLyBhZGQgb25lLXRpbWUgZXZlbnQgbGlzdGVuZXJcbiAqIG9iai5lbWl0KFwiZm9vXCIpOyAgICAgICAgICAgICAgICAgICAgIC8vIGRpc3BhdGNoIGV2ZW50XG4gKiBvYmouZW1pdChcImJhclwiKTsgICAgICAgICAgICAgICAgICAgICAvLyBkaXNwYXRjaCBhbm90aGVyIGV2ZW50XG4gKiBvYmoub2ZmKFwiZm9vXCIpOyAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgZXZlbnQgbGlzdGVuZXJcbiAqL1xuXG5mdW5jdGlvbiBFdmVudExpdGUoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFdmVudExpdGUpKSByZXR1cm4gbmV3IEV2ZW50TGl0ZSgpO1xufVxuXG4oZnVuY3Rpb24oRXZlbnRMaXRlKSB7XG4gIC8vIGV4cG9ydCB0aGUgY2xhc3MgZm9yIG5vZGUuanNcbiAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBtb2R1bGUpIG1vZHVsZS5leHBvcnRzID0gRXZlbnRMaXRlO1xuXG4gIC8vIHByb3BlcnR5IG5hbWUgdG8gaG9sZCBsaXN0ZW5lcnNcbiAgdmFyIExJU1RFTkVSUyA9IFwibGlzdGVuZXJzXCI7XG5cbiAgLy8gbWV0aG9kcyB0byBleHBvcnRcbiAgdmFyIG1ldGhvZHMgPSB7XG4gICAgb246IG9uLFxuICAgIG9uY2U6IG9uY2UsXG4gICAgb2ZmOiBvZmYsXG4gICAgZW1pdDogZW1pdFxuICB9O1xuXG4gIC8vIG1peGluIHRvIHNlbGZcbiAgbWl4aW4oRXZlbnRMaXRlLnByb3RvdHlwZSk7XG5cbiAgLy8gZXhwb3J0IG1peGluIGZ1bmN0aW9uXG4gIEV2ZW50TGl0ZS5taXhpbiA9IG1peGluO1xuXG4gIC8qKlxuICAgKiBJbXBvcnQgb24oKSwgb25jZSgpLCBvZmYoKSBhbmQgZW1pdCgpIG1ldGhvZHMgaW50byB0YXJnZXQgb2JqZWN0LlxuICAgKlxuICAgKiBAZnVuY3Rpb24gRXZlbnRMaXRlLm1peGluXG4gICAqIEBwYXJhbSB0YXJnZXQge1Byb3RvdHlwZX1cbiAgICovXG5cbiAgZnVuY3Rpb24gbWl4aW4odGFyZ2V0KSB7XG4gICAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIHRhcmdldFtrZXldID0gbWV0aG9kc1trZXldO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBldmVudCBsaXN0ZW5lci5cbiAgICpcbiAgICogQGZ1bmN0aW9uIEV2ZW50TGl0ZS5wcm90b3R5cGUub25cbiAgICogQHBhcmFtIHR5cGUge3N0cmluZ31cbiAgICogQHBhcmFtIGZ1bmMge0Z1bmN0aW9ufVxuICAgKiBAcmV0dXJucyB7RXZlbnRMaXRlfSBTZWxmIGZvciBtZXRob2QgY2hhaW5pbmdcbiAgICovXG5cbiAgZnVuY3Rpb24gb24odHlwZSwgZnVuYykge1xuICAgIGdldExpc3RlbmVycyh0aGlzLCB0eXBlKS5wdXNoKGZ1bmMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBvbmUtdGltZSBldmVudCBsaXN0ZW5lci5cbiAgICpcbiAgICogQGZ1bmN0aW9uIEV2ZW50TGl0ZS5wcm90b3R5cGUub25jZVxuICAgKiBAcGFyYW0gdHlwZSB7c3RyaW5nfVxuICAgKiBAcGFyYW0gZnVuYyB7RnVuY3Rpb259XG4gICAqIEByZXR1cm5zIHtFdmVudExpdGV9IFNlbGYgZm9yIG1ldGhvZCBjaGFpbmluZ1xuICAgKi9cblxuICBmdW5jdGlvbiBvbmNlKHR5cGUsIGZ1bmMpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgd3JhcC5vcmlnaW5hbExpc3RlbmVyID0gZnVuYztcbiAgICBnZXRMaXN0ZW5lcnModGhhdCwgdHlwZSkucHVzaCh3cmFwKTtcbiAgICByZXR1cm4gdGhhdDtcblxuICAgIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgICBvZmYuY2FsbCh0aGF0LCB0eXBlLCB3cmFwKTtcbiAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gRXZlbnRMaXRlLnByb3RvdHlwZS5vZmZcbiAgICogQHBhcmFtIFt0eXBlXSB7c3RyaW5nfVxuICAgKiBAcGFyYW0gW2Z1bmNdIHtGdW5jdGlvbn1cbiAgICogQHJldHVybnMge0V2ZW50TGl0ZX0gU2VsZiBmb3IgbWV0aG9kIGNoYWluaW5nXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9mZih0eXBlLCBmdW5jKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciBsaXN0bmVycztcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGRlbGV0ZSB0aGF0W0xJU1RFTkVSU107XG4gICAgfSBlbHNlIGlmICghZnVuYykge1xuICAgICAgbGlzdG5lcnMgPSB0aGF0W0xJU1RFTkVSU107XG4gICAgICBpZiAobGlzdG5lcnMpIHtcbiAgICAgICAgZGVsZXRlIGxpc3RuZXJzW3R5cGVdO1xuICAgICAgICBpZiAoIU9iamVjdC5rZXlzKGxpc3RuZXJzKS5sZW5ndGgpIHJldHVybiBvZmYuY2FsbCh0aGF0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdG5lcnMgPSBnZXRMaXN0ZW5lcnModGhhdCwgdHlwZSwgdHJ1ZSk7XG4gICAgICBpZiAobGlzdG5lcnMpIHtcbiAgICAgICAgbGlzdG5lcnMgPSBsaXN0bmVycy5maWx0ZXIobmUpO1xuICAgICAgICBpZiAoIWxpc3RuZXJzLmxlbmd0aCkgcmV0dXJuIG9mZi5jYWxsKHRoYXQsIHR5cGUpO1xuICAgICAgICB0aGF0W0xJU1RFTkVSU11bdHlwZV0gPSBsaXN0bmVycztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoYXQ7XG5cbiAgICBmdW5jdGlvbiBuZSh0ZXN0KSB7XG4gICAgICByZXR1cm4gdGVzdCAhPT0gZnVuYyAmJiB0ZXN0Lm9yaWdpbmFsTGlzdGVuZXIgIT09IGZ1bmM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoICh0cmlnZ2VyKSBhbiBldmVudC5cbiAgICpcbiAgICogQGZ1bmN0aW9uIEV2ZW50TGl0ZS5wcm90b3R5cGUuZW1pdFxuICAgKiBAcGFyYW0gdHlwZSB7c3RyaW5nfVxuICAgKiBAcGFyYW0gW3ZhbHVlXSB7Kn1cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgd2hlbiBhIGxpc3RlbmVyIHJlY2VpdmVkIHRoZSBldmVudFxuICAgKi9cblxuICBmdW5jdGlvbiBlbWl0KHR5cGUsIHZhbHVlKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBnZXRMaXN0ZW5lcnModGhhdCwgdHlwZSwgdHJ1ZSk7XG4gICAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgYXJnbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZiAoYXJnbGVuID09PSAxKSB7XG4gICAgICBsaXN0ZW5lcnMuZm9yRWFjaCh6ZXJvYXJnKTtcbiAgICB9IGVsc2UgaWYgKGFyZ2xlbiA9PT0gMikge1xuICAgICAgbGlzdGVuZXJzLmZvckVhY2gob25lYXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgbGlzdGVuZXJzLmZvckVhY2gobW9yZWFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gISFsaXN0ZW5lcnMubGVuZ3RoO1xuXG4gICAgZnVuY3Rpb24gemVyb2FyZyhmdW5jKSB7XG4gICAgICBmdW5jLmNhbGwodGhhdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25lYXJnKGZ1bmMpIHtcbiAgICAgIGZ1bmMuY2FsbCh0aGF0LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9yZWFyZ3MoZnVuYykge1xuICAgICAgZnVuYy5hcHBseSh0aGF0LCBhcmdzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cblxuICBmdW5jdGlvbiBnZXRMaXN0ZW5lcnModGhhdCwgdHlwZSwgcmVhZG9ubHkpIHtcbiAgICBpZiAocmVhZG9ubHkgJiYgIXRoYXRbTElTVEVORVJTXSkgcmV0dXJuO1xuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGF0W0xJU1RFTkVSU10gfHwgKHRoYXRbTElTVEVORVJTXSA9IHt9KTtcbiAgICByZXR1cm4gbGlzdGVuZXJzW3R5cGVdIHx8IChsaXN0ZW5lcnNbdHlwZV0gPSBbXSk7XG4gIH1cblxufSkoRXZlbnRMaXRlKTtcbiIsImltcG9ydCBET00gZnJvbSdxdWlja2RvbSc7aW1wb3J0IGV4dGVuZCBmcm9tJ3NtYXJ0LWV4dGVuZCc7aW1wb3J0IHByb21pc2VFdmVudCBmcm9tJ3AtZXZlbnQnO2ltcG9ydCBwcm9taXNlQnJlYWsgZnJvbSdwcm9taXNlLWJyZWFrJztpbXBvcnQgSVNfIGZyb20nQGRhbmllbGthbGVuL2lzJztpbXBvcnQgZGV0ZWN0QW5pbWF0aW9uIGZyb20nZGV0ZWN0LWFuaW1hdGlvbi1lbmQtaGVscGVyJztpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20nZXZlbnQtbGl0ZSc7dmFyIElTO1xuSVMgPSBJU18uY3JlYXRlKCduYXRpdmVzJyk7XG5JUy5sb2FkKHtcbiAgJ2RvbUVsJzogRE9NLmlzRWwsXG4gICdxdWlja0VsJzogRE9NLmlzUXVpY2tFbCxcbiAgJ3RlbXBsYXRlJzogRE9NLmlzVGVtcGxhdGVcbn0pO1xudmFyIElTJDEgPSBJUzt2YXIgcG9wdXAgPSBET00udGVtcGxhdGUoWydkaXYnLCB7XG4gIHJlZjogJ3BvcHVwJyxcbiAgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB6SW5kZXg6IDFlNCxcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMCxcbiAgICB3aWR0aDogJzEwMHZ3JyxcbiAgICBoZWlnaHQ6IDAsXG4gICAgbWluSGVpZ2h0OiAnMTAwJScsXG4gICAgdmlzaWJpbGl0eTogJ2hpZGRlbicsXG4gICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgIHRyYW5zaXRpb246IGZ1bmN0aW9uIChwb3B1cCkge1xuICAgICAgcmV0dXJuIGBhbGwgMC4wMDFzIGxpbmVhciAke3BvcHVwLnNldHRpbmdzLmFuaW1hdGlvbiArIDF9bXNgO1xuICAgIH0sXG4gICAgJG9wZW46IHtcbiAgICAgIHRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdhbGwgMC4wMDFzIGxpbmVhciAwcyc7XG4gICAgICB9LFxuICAgICAgdmlzaWJpbGl0eTogJ3Zpc2libGUnLFxuICAgICAgb3ZlcmZsb3c6ICd2aXNpYmxlJyxcbiAgICAgIGhlaWdodDogJ2F1dG8nXG4gICAgfVxuICB9XG59XSk7XG52YXIgb3ZlcmxheSA9IERPTS50ZW1wbGF0ZShbJ2RpdicsIHtcbiAgcmVmOiAnb3ZlcmxheScsXG4gIHN0eWxlOiB7XG4gICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgekluZGV4OiAxLFxuICAgIGxlZnQ6IDAsXG4gICAgdG9wOiAwLFxuICAgIHdpZHRoOiAnMTAwdncnLFxuICAgIG1pbkhlaWdodDogJzEwMHZoJyxcbiAgICBvcGFjaXR5OiAwLFxuICAgIGJhY2tncm91bmRDb2xvcjogZnVuY3Rpb24gKHBvcHVwKSB7XG4gICAgICByZXR1cm4gcG9wdXAuc2V0dGluZ3Mub3ZlcmxheUNvbG9yO1xuICAgIH0sXG4gICAgdHJhbnNpdGlvbjogZnVuY3Rpb24gKHBvcHVwKSB7XG4gICAgICByZXR1cm4gYG9wYWNpdHkgJHtwb3B1cC5zZXR0aW5ncy5hbmltYXRpb259bXNgO1xuICAgIH0sXG4gICAgJG9wZW46IHtcbiAgICAgIG9wYWNpdHk6IDFcbiAgICB9XG4gIH1cbn1dKTtcbnZhciBjb250ZW50ID0gRE9NLnRlbXBsYXRlKFsnZGl2Jywge1xuICByZWY6ICdjb250ZW50JyxcbiAgc3R5bGU6IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB6SW5kZXg6IDIsXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgbWF4V2lkdGg6ICcxMDAlJyxcbiAgICBtYXJnaW46ICcwIGF1dG8nLFxuICAgIHBhZGRpbmc6IGZ1bmN0aW9uIChwb3B1cCkge1xuICAgICAgcmV0dXJuIHBvcHVwLnNldHRpbmdzLmNvbnRlbnRQYWRkaW5nO1xuICAgIH0sXG4gICAgb3BhY2l0eTogMCxcbiAgICB0cmFuc2l0aW9uOiBmdW5jdGlvbiAocG9wdXApIHtcbiAgICAgIHZhciBkdXJhdGlvbjtcbiAgICAgIGR1cmF0aW9uID0gcG9wdXAuc2V0dGluZ3MuYW5pbWF0aW9uO1xuICAgICAgcmV0dXJuIGB0cmFuc2Zvcm0gJHtkdXJhdGlvbn1tcywgLXdlYmtpdC10cmFuc2Zvcm0gJHtkdXJhdGlvbn1tcywgb3BhY2l0eSAke2R1cmF0aW9ufW1zYDtcbiAgICB9LFxuICAgICRvcGVuOiB7XG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgXzogMFxuICAgIH0sXG4gICAgJGNlbnRlclBsYWNlbWVudDoge1xuICAgICAgbGVmdDogJzUwJScsXG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKC01MCUpJ1xuICAgIH0sXG4gICAgJHRvcFBsYWNlbWVudDoge1xuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogJzUwJScsXG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoLTEwMCUpJyxcbiAgICAgICRvcGVuOiB7XG4gICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWSgwKScsXG4gICAgICAgIF86IDFcbiAgICAgIH1cbiAgICB9LFxuICAgICRib3R0b21QbGFjZW1lbnQ6IHtcbiAgICAgIGJvdHRvbTogMCxcbiAgICAgIGxlZnQ6ICc1MCUnLFxuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtNTAlKSB0cmFuc2xhdGVZKDEwMCUpJyxcbiAgICAgICRvcGVuOiB7XG4gICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWSgwKScsXG4gICAgICAgIF86IDJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVyczoge1xuICAgIHBsYWNlbWVudDogZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUoYCR7cGxhY2VtZW50fVBsYWNlbWVudGAsIHRydWUpO1xuICAgIH0sXG4gICAgY29udGVudDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGVuZChjb250ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGV2ZW50czoge1xuICAgICdzdGF0ZUNoYW5nZTp2aXNpYmxlJzogZnVuY3Rpb24gKHZpc2libGUpIHtcbiAgICAgIGlmICh2aXNpYmxlICYmIERPTSh0aGlzKS5yZWxhdGVkLnNldHRpbmdzLnBsYWNlbWVudCA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgcmV0dXJuIERPTSh0aGlzKS5yZWxhdGVkLmFsaWduVG9DZW50ZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1dKTtcbnZhciBjbG9zZSA9IERPTS50ZW1wbGF0ZShbJ2RpdicsIHtcbiAgcmVmOiAnY2xvc2UnLFxuICBzdHlsZToge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIGRpc3BsYXk6IGZ1bmN0aW9uIChwb3B1cCkge1xuICAgICAgaWYgKHBvcHVwLnNldHRpbmdzLmNsb3NlLnNob3cpIHtcbiAgICAgICAgcmV0dXJuICdibG9jayc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ25vbmUnO1xuICAgICAgfVxuICAgIH0sXG4gICAgdG9wOiBmdW5jdGlvbiAocG9wdXApIHtcbiAgICAgIGlmIChwb3B1cC5zZXR0aW5ncy5jbG9zZS5pbnNpZGUpIHtcbiAgICAgICAgcmV0dXJuIHBvcHVwLnNldHRpbmdzLmNsb3NlLnBhZGRpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcG9wdXAuc2V0dGluZ3MuY2xvc2Uuc2l6ZSAqIDIuNSAqIC0xO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmlnaHQ6IGZ1bmN0aW9uIChwb3B1cCkge1xuICAgICAgaWYgKHBvcHVwLnNldHRpbmdzLmNsb3NlLmluc2lkZSkge1xuICAgICAgICByZXR1cm4gcG9wdXAuc2V0dGluZ3MuY2xvc2UucGFkZGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH0sXG4gICAgd2lkdGg6IGZ1bmN0aW9uIChwb3B1cCkge1xuICAgICAgcmV0dXJuIHBvcHVwLnNldHRpbmdzLmNsb3NlLnNpemU7XG4gICAgfSxcbiAgICBoZWlnaHQ6IGZ1bmN0aW9uIChwb3B1cCkge1xuICAgICAgcmV0dXJuIHBvcHVwLnNldHRpbmdzLmNsb3NlLnNpemU7XG4gICAgfSxcbiAgICBjb2xvcjogZnVuY3Rpb24gKHBvcHVwKSB7XG4gICAgICByZXR1cm4gcG9wdXAuc2V0dGluZ3MuY2xvc2UuY29sb3I7XG4gICAgfVxuICB9XG59LCBbJypzdmcnLCB7XG4gIGF0dHJzOiB7XG4gICAgdmlld0JveDogXCIwIDAgNDkyIDQ5MlwiXG4gIH0sXG4gIHN0eWxlOiB7XG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBoZWlnaHQ6ICcxMDAlJ1xuICB9XG59LCBbJypwYXRoJywge1xuICBhdHRyczoge1xuICAgIGQ6ICdNMzAwLjIgMjQ2TDQ4NC4xIDYyYzUuMS01LjEgNy45LTExLjggNy45LTE5IDAtNy4yLTIuOC0xNC03LjktMTlMNDY4IDcuOWMtNS4xLTUuMS0xMS44LTcuOS0xOS03LjkgLTcuMiAwLTE0IDIuOC0xOSA3LjlMMjQ2IDE5MS44IDYyIDcuOWMtNS4xLTUuMS0xMS44LTcuOS0xOS03LjkgLTcuMiAwLTE0IDIuOC0xOSA3LjlMNy45IDI0Yy0xMC41IDEwLjUtMTAuNSAyNy42IDAgMzguMUwxOTEuOCAyNDYgNy45IDQzMGMtNS4xIDUuMS03LjkgMTEuOC03LjkgMTkgMCA3LjIgMi44IDE0IDcuOSAxOWwxNi4xIDE2LjFjNS4xIDUuMSAxMS44IDcuOSAxOSA3LjkgNy4yIDAgMTQtMi44IDE5LTcuOWwxODQtMTg0IDE4NCAxODRjNS4xIDUuMSAxMS44IDcuOSAxOSA3LjloMGM3LjIgMCAxNC0yLjggMTktNy45bDE2LjEtMTYuMWM1LjEtNS4xIDcuOS0xMS44IDcuOS0xOSAwLTcuMi0yLjgtMTQtNy45LTE5TDMwMC4yIDI0NnonXG4gIH0sXG4gIHN0eWxlOiB7XG4gICAgZmlsbDogZnVuY3Rpb24gKHBvcHVwKSB7XG4gICAgICByZXR1cm4gcG9wdXAuc2V0dGluZ3MuY2xvc2UuY29sb3I7XG4gICAgfVxuICB9XG59XV1dKTtcbnZhciBib2R5V3JhcHBlciA9IERPTS50ZW1wbGF0ZShbJ2RpdicsIHtcbiAgaWQ6ICdib2R5V3JhcHBlcicsXG4gIHBhc3NTdGF0ZVRvQ2hpbGRyZW46IGZhbHNlLFxuICBzdHlsZToge1xuICAgICRvcGVuOiB7XG4gICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICB0b3A6ICcwJ1xuICAgIH1cbiAgfVxufV0pO1xudmFyIGh0bWwgPSBET00udGVtcGxhdGUoWydkaXYnLCB7XG4gIGNvbXB1dGVyczoge1xuICAgIGh0bWw6IGZ1bmN0aW9uIChodG1sKSB7XG4gICAgICByZXR1cm4gdGhpcy5odG1sID0gaHRtbDtcbiAgICB9XG4gIH1cbn1dKTt2YXIgdGVtcGxhdGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe3BvcHVwOiBwb3B1cCxvdmVybGF5OiBvdmVybGF5LGNvbnRlbnQ6IGNvbnRlbnQsY2xvc2U6IGNsb3NlLGJvZHlXcmFwcGVyOiBib2R5V3JhcHBlcixodG1sOiBodG1sfSk7dmFyIGV4dGVuZFNldHRpbmdzID0gZnVuY3Rpb24gKGRlZmF1bHRzLCBzZXR0aW5ncykge1xuICByZXR1cm4gZXh0ZW5kLmZpbHRlcih7XG4gICAgcGxhY2VtZW50OiBJUyQxLnN0cmluZyxcbiAgICB0ZW1wbGF0ZTogSVMkMS5vYmplY3RQbGFpbixcbiAgICBjb25kaXRpb246IElTJDEuZnVuY3Rpb24sXG4gICAgYW5pbWF0aW9uOiBJUyQxLm51bWJlcixcbiAgICBvdmVybGF5Q29sb3I6IElTJDEuc3RyaW5nLFxuICAgIG9wZW46IElTJDEub2JqZWN0UGxhaW4sXG4gICAgY2xvc2U6IElTJDEub2JqZWN0UGxhaW4sXG4gICAgdHJpZ2dlcnM6IElTJDEub2JqZWN0UGxhaW5cbiAgfSkuY2xvbmUuZGVlcC5ub3REZWVwKCdjb250ZW50JykoZGVmYXVsdHMsIHNldHRpbmdzKTtcbn07XG52YXIgc2NoZWR1bGVTY3JvbGxSZXNldCA9IGZ1bmN0aW9uIChzY2hlZHVsZU5leHQpIHtcbiAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHdpbmRvdy5zY3JvbGwoMCwgMCk7XG5cbiAgICBpZiAoc2NoZWR1bGVOZXh0KSB7XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzY2hlZHVsZVNjcm9sbFJlc2V0KCk7XG4gICAgICB9LCBzY2hlZHVsZU5leHQpO1xuICAgIH1cbiAgfSk7XG59O1xudmFyIHRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBkZXRlY3RBbmltYXRpb24oJ3RyYW5zaXRpb24nKTtcbn07XG52YXIgc2Nyb2xsT2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gd2luZG93LnNjcm9sbFkgLSBkb2N1bWVudE9mZnNldCgpO1xufTtcbnZhciBkb2N1bWVudE9mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlZjtcbiAgcmV0dXJuICgoKHJlZiA9IGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpICE9IG51bGwgPyByZWYudG9wIDogdm9pZCAwKSB8fCAwKSArIHdpbmRvdy5zY3JvbGxZO1xufTtcbnZhciB2aXNpYmlsaXR5QXBpS2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgc3dpdGNoIChmYWxzZSkge1xuICAgIGNhc2UgIUlTJDEuZGVmaW5lZChkb2N1bWVudC5oaWRkZW4pOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGlkZGVuOiAnaGlkZGVuJyxcbiAgICAgICAgdmlzaWJpbGl0eWNoYW5nZTogJ3Zpc2liaWxpdHljaGFuZ2UnXG4gICAgICB9O1xuXG4gICAgY2FzZSAhSVMkMS5kZWZpbmVkKGRvY3VtZW50Lm1zSGlkZGVuKTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhpZGRlbjogJ21zSGlkZGVuJyxcbiAgICAgICAgdmlzaWJpbGl0eWNoYW5nZTogJ21zdmlzaWJpbGl0eWNoYW5nZSdcbiAgICAgIH07XG5cbiAgICBjYXNlICFJUyQxLmRlZmluZWQoZG9jdW1lbnQud2Via2l0SGlkZGVuKTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhpZGRlbjogJ3dlYmtpdEhpZGRlbicsXG4gICAgICAgIHZpc2liaWxpdHljaGFuZ2U6ICd3ZWJraXR2aXNpYmlsaXR5Y2hhbmdlJ1xuICAgICAgfTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4ge307XG4gIH1cbn07dmFyIHJlZjtcbnZhciBpc0lFID0gZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbnZhciBpc0lFMTEgPSB3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQ7XG52YXIgaXNFZGdlID0gL0VkZ2UvLnRlc3QoKChyZWYgPSB3aW5kb3cubmF2aWdhdG9yKSAhPSBudWxsID8gcmVmLnVzZXJBZ2VudCA6IHZvaWQgMCkgfHwgJycpO3ZhciBQb3B1cCwgYm9keTtcbmJvZHkgPSBET00oZG9jdW1lbnQuYm9keSk7XG5cblBvcHVwID0gZnVuY3Rpb24gKCkge1xuICBjbGFzcyBQb3B1cCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgc3RhdGljIHdyYXBCb2R5KCkge1xuICAgICAgdmFyIGJvZHlDaGlsZHJlbiwgY2hpbGQsIGksIGxlbiwgcmVmMTtcblxuICAgICAgaWYgKCEoKHJlZjEgPSB0aGlzLmJvZHlXcmFwcGVyKSAhPSBudWxsID8gcmVmMS5wYXJlbnQgOiB2b2lkIDApKSB7XG4gICAgICAgIHRoaXMuYm9keVdyYXBwZXIgPSBib2R5V3JhcHBlci5zcGF3bigpO1xuICAgICAgICBib2R5Q2hpbGRyZW4gPSBib2R5LmNoaWxkcmVuLnNsaWNlKCk7XG4gICAgICAgIHRoaXMuYm9keVdyYXBwZXIucHJlcGVuZFRvKGJvZHkpO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGJvZHlDaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGNoaWxkID0gYm9keUNoaWxkcmVuW2ldO1xuICAgICAgICAgIHRoaXMuYm9keVdyYXBwZXIuYXBwZW5kKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyB1bndyYXBCb2R5KCkge1xuICAgICAgdmFyIGJvZHlDaGlsZHJlbiwgY2hpbGQsIGksIGxlbjtcblxuICAgICAgaWYgKHRoaXMuYm9keVdyYXBwZXIpIHtcbiAgICAgICAgYm9keUNoaWxkcmVuID0gdGhpcy5ib2R5V3JhcHBlci5jaGlsZHJlbi5zbGljZSgpO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGJvZHlDaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGNoaWxkID0gYm9keUNoaWxkcmVuW2ldO1xuICAgICAgICAgIGJvZHkuYXBwZW5kKGNoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYm9keVdyYXBwZXIucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJvZHlXcmFwcGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZGVzdHJveUFsbCgpIHtcbiAgICAgIHZhciBpLCBpbnN0YW5jZSwgaW5zdGFuY2VzLCBsZW47XG4gICAgICBpbnN0YW5jZXMgPSB0aGlzLmluc3RhbmNlcy5zbGljZSgpO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBpbnN0YW5jZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaV07XG4gICAgICAgIGluc3RhbmNlLmRlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMudW53cmFwQm9keSgpO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzLCBkZWZhdWx0cywgdGVtcGxhdGUxKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlMTtcbiAgICAgIHRoaXMuc2V0dGluZ3MgPSBleHRlbmRTZXR0aW5ncyhkZWZhdWx0cywgc2V0dGluZ3MpO1xuICAgICAgdGhpcy5pZCA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDFlNSkudG9TdHJpbmcoMTYpO1xuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgb3BlbjogZmFsc2UsXG4gICAgICAgIGRlc3Ryb3llZDogZmFsc2UsXG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgY291bnQ6IDBcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gRE9NKHRoaXMuc2V0dGluZ3MuY29udGVudCk7XG4gICAgICB9XG5cbiAgICAgIFBvcHVwLmluc3RhbmNlcy5wdXNoKHRoaXMpO1xuICAgICAgUG9wdXAud3JhcEJvZHkoKTtcblxuICAgICAgdGhpcy5fY3JlYXRlRWxlbWVudHMoKTtcblxuICAgICAgdGhpcy5fYXR0YWNoQmluZGluZ3MoKTtcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudGVtcGxhdGUgJiYgdHlwZW9mIHRoaXMuc2V0dGluZ3MudGVtcGxhdGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRoaXMuX2FwcGx5VGVtcGxhdGUoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbC5wcmVwZW5kVG8oYm9keSk7XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLm9wZW4pIHtcbiAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2NyZWF0ZUVsZW1lbnRzKCkge1xuICAgICAgdmFyIGNsb3NlJCQxLCBjb25maWcsIGNvbnRlbnQkJDEsIGRhdGEsIG92ZXJsYXkkJDE7XG4gICAgICBkYXRhID0ge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgY29udGVudDogdGhpcy5jb250ZW50LFxuICAgICAgICAgIHBsYWNlbWVudDogdGhpcy5zZXR0aW5ncy5wbGFjZW1lbnRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgcmVsYXRlZEluc3RhbmNlOiB0aGlzXG4gICAgICB9O1xuICAgICAgdGhpcy5lbCA9IHRoaXMudGVtcGxhdGUucG9wdXAuc3Bhd24oZGF0YSwgY29uZmlnKTtcbiAgICAgIG92ZXJsYXkkJDEgPSB0aGlzLnRlbXBsYXRlLm92ZXJsYXkuc3Bhd24oZGF0YSwgY29uZmlnKS5hcHBlbmRUbyh0aGlzLmVsKTtcbiAgICAgIGNvbnRlbnQkJDEgPSB0aGlzLnRlbXBsYXRlLmNvbnRlbnQuc3Bhd24oZGF0YSwgY29uZmlnKS5hcHBlbmRUbyh0aGlzLmVsKTtcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY2xvc2Uuc2hvdykge1xuICAgICAgICByZXR1cm4gY2xvc2UkJDEgPSB0aGlzLnRlbXBsYXRlLmNsb3NlLnNwYXduKGRhdGEsIGNvbmZpZykuYXBwZW5kVG8oY29udGVudCQkMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2FwcGx5VGVtcGxhdGUoKSB7XG4gICAgICB2YXIgY3VzdG9tLCByZWY7XG4gICAgICBjdXN0b20gPSB0aGlzLnNldHRpbmdzLnRlbXBsYXRlO1xuXG4gICAgICBmb3IgKHJlZiBpbiB0aGlzLmVsLmNoaWxkKSB7XG4gICAgICAgIGlmIChjdXN0b21bcmVmXSkge1xuICAgICAgICAgIHRoaXMuZWwuY2hpbGRbcmVmXS51cGRhdGVPcHRpb25zKGN1c3RvbVtyZWZdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIF9hdHRhY2hCaW5kaW5ncygpIHtcbiAgICAgIHZhciBjbG9zZSQkMSwgaGlkZGVuLCByZWYxLCByZWYyLCB2aXNpYmlsaXR5Y2hhbmdlO1xuICAgICAgY2xvc2UkJDEgPSB0aGlzLmNsb3NlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmVsLmNoaWxkLm92ZXJsYXkub24oJ21vdXNldXAgdG91Y2hlbmQnLCBjbG9zZSQkMSk7XG5cbiAgICAgIGlmICgocmVmMSA9IHRoaXMuZWwuY2hpbGQuY2xvc2UpICE9IG51bGwpIHtcbiAgICAgICAgcmVmMS5vbignbW91c2V1cCB0b3VjaGVuZCcsIGNsb3NlJCQxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MucGxhY2VtZW50ID09PSAnY2VudGVyJykge1xuICAgICAgICBET00od2luZG93KS5vbihgcmVzaXplLiR7dGhpcy5pZH1gLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUub3Blbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWxpZ25Ub0NlbnRlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnRyaWdnZXJzLmNsb3NlLmVzYykge1xuICAgICAgICBET00oZG9jdW1lbnQpLm9uKGBrZXl1cC4ke3RoaXMuaWR9YCwgZXZlbnQgPT4ge1xuICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSAyNyAmJiB0aGlzLnN0YXRlLm9wZW4pIHtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudHJpZ2dlcnMub3Blbi52aXNpYmlsaXR5KSB7XG4gICAgICAgICh7XG4gICAgICAgICAgdmlzaWJpbGl0eWNoYW5nZSxcbiAgICAgICAgICBoaWRkZW5cbiAgICAgICAgfSA9IHZpc2liaWxpdHlBcGlLZXlzKCkpO1xuICAgICAgICBET00oZG9jdW1lbnQpLm9uKGAke3Zpc2liaWxpdHljaGFuZ2V9LiR7dGhpcy5pZH1gLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKGRvY3VtZW50W2hpZGRlbl0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wZW4oJ3Zpc2liaWxpdHknKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy50cmlnZ2Vycy5vcGVuLmV4aXRJbnRlbnQpIHtcbiAgICAgICAgRE9NKGRvY3VtZW50KS5vbihgbW91c2VsZWF2ZS4ke3RoaXMuaWR9YCwgZXZlbnQgPT4ge1xuICAgICAgICAgIHZhciBiYXNlLCB0aHJlc2hvbGQ7XG4gICAgICAgICAgYmFzZSA9IGlzSUUgfHwgaXNJRTExIHx8IGlzRWRnZSA/IDExMCA6IDA7XG4gICAgICAgICAgdGhyZXNob2xkID0gdGhpcy5zZXR0aW5ncy55VGhyZXNob2xkICsgYmFzZTtcblxuICAgICAgICAgIGlmIChldmVudC5jbGllbnRZIDw9IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BlbignZXhpdEludGVudCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnRyaWdnZXJzLm9wZW4ubmF2aWdhdGlvbiAmJiAoKHJlZjIgPSB3aW5kb3cuaGlzdG9yeSkgIT0gbnVsbCA/IHJlZjIucHVzaFN0YXRlIDogdm9pZCAwKSkge1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoe1xuICAgICAgICAgIGlkOiAncXVpY2twb3B1cC1vcmlnaW4nXG4gICAgICAgIH0sICcnLCAnJyk7XG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSh7XG4gICAgICAgICAgaWQ6ICdxdWlja3BvcHVwJ1xuICAgICAgICB9LCAnJywgJycpO1xuICAgICAgICByZXR1cm4gRE9NKHdpbmRvdykub24oYHBvcHN0YXRlLiR7dGhpcy5pZH1gLCBldmVudCA9PiB7XG4gICAgICAgICAgaWYgKGV2ZW50LnN0YXRlLnN0YXRlLmlkID09PSAncXVpY2twb3B1cC1vcmlnaW4nICYmIHRoaXMub3BlbignbmF2aWdhdGlvbicpKSA7IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5LmJhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9kZXRhY2hCaW5kaW5ncygpIHtcbiAgICAgIHZhciBoaWRkZW4sIHJlZjEsIHZpc2liaWxpdHljaGFuZ2U7XG4gICAgICB0aGlzLmVsLmNoaWxkLm92ZXJsYXkub2ZmKCk7XG5cbiAgICAgIGlmICgocmVmMSA9IHRoaXMuZWwuY2hpbGQuY2xvc2UpICE9IG51bGwpIHtcbiAgICAgICAgcmVmMS5vZmYoKTtcbiAgICAgIH1cblxuICAgICAgKHtcbiAgICAgICAgdmlzaWJpbGl0eWNoYW5nZSxcbiAgICAgICAgaGlkZGVuXG4gICAgICB9ID0gdmlzaWJpbGl0eUFwaUtleXMoKSk7XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnBsYWNlbWVudCA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgRE9NKHdpbmRvdykub2ZmKGByZXNpemUuJHt0aGlzLmlkfWApO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy50cmlnZ2Vycy5vcGVuLm5hdmlnYXRpb24pIHtcbiAgICAgICAgRE9NKHdpbmRvdykub2ZmKGBwb3BzdGF0ZS4ke3RoaXMuaWR9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnRyaWdnZXJzLm9wZW4uZXhpdEludGVudCkge1xuICAgICAgICBET00oZG9jdW1lbnQpLm9mZihgbW91c2VsZWF2ZS4ke3RoaXMuaWR9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnRyaWdnZXJzLm9wZW4udmlzaWJpbGl0eSkge1xuICAgICAgICBET00oZG9jdW1lbnQpLm9mZihgJHt2aXNpYmlsaXR5Y2hhbmdlfS4ke3RoaXMuaWR9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnRyaWdnZXJzLmNsb3NlLmVzYykge1xuICAgICAgICByZXR1cm4gRE9NKGRvY3VtZW50KS5vZmYoYGtleXVwLiR7dGhpcy5pZH1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfdGhyb3dEZXN0cm95ZWQoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGF0dGVtcHQgdG8gb3BlcmF0ZSBhIGRlc3Ryb3llZCBwb3B1cCBpbnN0YW5jZVwiKTtcbiAgICB9XG5cbiAgICBzZXRDb250ZW50KHRhcmdldCkge1xuICAgICAgdGhpcy5jb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICAgICAgY2FzZSAhSVMkMS5xdWlja0VsKHRhcmdldCk6XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuXG4gICAgICAgICAgY2FzZSAhSVMkMS5kb21FbCh0YXJnZXQpOlxuICAgICAgICAgICAgcmV0dXJuIERPTSh0YXJnZXQpO1xuXG4gICAgICAgICAgY2FzZSAhSVMkMS50ZW1wbGF0ZSh0YXJnZXQpOlxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5zcGF3bigpO1xuXG4gICAgICAgICAgY2FzZSAhSVMkMS5zdHJpbmcodGFyZ2V0KTpcbiAgICAgICAgICAgIHJldHVybiBodG1sLnNwYXduKHtcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGh0bWw6IHRhcmdldFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdGFyZ2V0IHByb3ZpZGVkIHRvIFBvcHVwOjpzZXRDb250ZW50KCknKTtcbiAgICAgICAgfVxuICAgICAgfSgpO1xuXG4gICAgICBpZiAodGhpcy5lbC5jaGlsZC5jb250ZW50LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5jaGlsZC5jb250ZW50LmNoaWxkcmVuWzFdLnJlcGxhY2VXaXRoKHRoaXMuY29udGVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5jaGlsZC5jb250ZW50LmFwcGVuZCh0aGlzLmNvbnRlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFsaWduVG9DZW50ZXIoKSB7XG4gICAgICB2YXIgY29udGVudEhlaWdodCwgb2Zmc2V0LCB3aW5kb3dIZWlnaHQ7XG4gICAgICBjb250ZW50SGVpZ2h0ID0gdGhpcy5lbC5jaGlsZC5jb250ZW50LnJhdy5jbGllbnRIZWlnaHQ7XG4gICAgICB3aW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgICAgIGlmIChjb250ZW50SGVpZ2h0ID49IHdpbmRvd0hlaWdodCAtIDgwKSB7XG4gICAgICAgIG9mZnNldCA9IHdpbmRvdy5pbm5lcldpZHRoID4gNzM2ID8gMTAwIDogNjA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgPSAod2luZG93SGVpZ2h0IC0gY29udGVudEhlaWdodCkgLyAyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5lbC5jaGlsZC5jb250ZW50LnN0eWxlKCdtYXJnaW4nLCBgJHtvZmZzZXR9cHggYXV0b2ApO1xuICAgIH1cblxuICAgIG9wZW4odHJpZ2dlck5hbWUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZGVzdHJveWVkKSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dEZXN0cm95ZWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLm9wZW4gfHwgUG9wdXAuaGFzT3BlbiAmJiAhdGhpcy5zZXR0aW5ncy5mb3JjZU9wZW4gfHwgKyt0aGlzLnN0YXRlLmNvdW50ID49IHRoaXMuc2V0dGluZ3Mub3BlbkxpbWl0IHx8IHdpbmRvdy5pbm5lcldpZHRoIDwgdGhpcy5zZXR0aW5ncy50cmlnZ2Vycy5vcGVuLm1pbldpZHRoIHx8IHRoaXMuc2V0dGluZ3MuY29uZGl0aW9uICYmICF0aGlzLnNldHRpbmdzLmNvbmRpdGlvbigpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb21pc2VCcmVhaygpO1xuICAgICAgICB9XG4gICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgdmFyIG9wZW5Qb3B1cHM7XG4gICAgICAgIHRoaXMuZW1pdCgnYmVmb3Jlb3BlbicsIHRyaWdnZXJOYW1lKTtcblxuICAgICAgICBpZiAoIVBvcHVwLmhhc09wZW4pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5vZmZzZXQgPSBzY3JvbGxPZmZzZXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcGVuUG9wdXBzID0gUG9wdXAuaW5zdGFuY2VzLmZpbHRlcihwb3B1cCQkMSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcG9wdXAkJDEgIT09IHRoaXMgJiYgcG9wdXAkJDEuc3RhdGUub3BlbjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwob3BlblBvcHVwcy5tYXAocG9wdXAkJDEgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5vZmZzZXQgPSBwb3B1cCQkMS5zdGF0ZS5vZmZzZXQ7XG4gICAgICAgICAgICByZXR1cm4gcG9wdXAkJDEuY2xvc2UodHJ1ZSk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgdmFyIHByb21pc2U7XG4gICAgICAgIHNjaGVkdWxlU2Nyb2xsUmVzZXQoNSk7XG4gICAgICAgIFBvcHVwLmJvZHlXcmFwcGVyLnN0YXRlKCdvcGVuJywgdHJ1ZSk7XG4gICAgICAgIFBvcHVwLmJvZHlXcmFwcGVyLnN0eWxlKCd0b3AnLCB0aGlzLnN0YXRlLm9mZnNldCAqIC0xKTtcbiAgICAgICAgdGhpcy5lbC5zdGF0ZSgnb3BlbicsIHRydWUpO1xuICAgICAgICB0aGlzLnN0YXRlLm9wZW4gPSBQb3B1cC5oYXNPcGVuID0gdHJ1ZTtcblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5wbGFjZW1lbnQgPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGhpcy5hbGlnblRvQ2VudGVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVtaXQoJ29wZW4nLCB0cmlnZ2VyTmFtZSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLmFuaW1hdGlvbiB8fCAhUG9wdXAudHJhbnNpdGlvbkVuZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2ZpbmlzaG9wZW4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZUV2ZW50KHRoaXMsICdmaW5pc2hvcGVuJyk7XG4gICAgICAgICAgdGhpcy5lbC5jaGlsZC5jb250ZW50Lm9uKFBvcHVwLnRyYW5zaXRpb25FbmQsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMuZWwuY2hpbGQuY29udGVudC5yYXcpIHtcbiAgICAgICAgICAgICAgdGhpcy5lbWl0KCdmaW5pc2hvcGVuJyk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmVsLmNoaWxkLmNvbnRlbnQub2ZmKFBvcHVwLnRyYW5zaXRpb25FbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaChwcm9taXNlQnJlYWsuZW5kKS50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjbG9zZShwcmV2ZW50UmVzZXQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLm9wZW4pIHtcbiAgICAgICAgICByZXR1cm4gcHJvbWlzZUJyZWFrKCk7XG4gICAgICAgIH1cbiAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICB2YXIgcHJvbWlzZTtcbiAgICAgICAgdGhpcy5lbWl0KCdiZWZvcmVjbG9zZScpO1xuXG4gICAgICAgIGlmIChwcmV2ZW50UmVzZXQgIT09IHRydWUpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHZhciByZWYxLCByZWYyO1xuXG4gICAgICAgICAgICBpZiAoIVBvcHVwLmhhc09wZW4pIHtcbiAgICAgICAgICAgICAgaWYgKChyZWYxID0gUG9wdXAuYm9keVdyYXBwZXIpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZWYxLnN0YXRlKCdvcGVuJywgZmFsc2UpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKChyZWYyID0gUG9wdXAuYm9keVdyYXBwZXIpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZWYyLnN0eWxlKCd0b3AnLCBudWxsKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuc2Nyb2xsKDAsIHRoaXMuc3RhdGUub2Zmc2V0ICsgZG9jdW1lbnRPZmZzZXQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgUG9wdXAuaGFzT3BlbiA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbC5zdGF0ZSgnb3BlbicsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5vcGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcblxuICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3MuYW5pbWF0aW9uIHx8ICFQb3B1cC50cmFuc2l0aW9uRW5kKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnZmluaXNoY2xvc2UnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZUV2ZW50KHRoaXMsICdmaW5pc2hjbG9zZScpO1xuICAgICAgICAgIHRoaXMuZWwuY2hpbGQuY29udGVudC5vbihQb3B1cC50cmFuc2l0aW9uRW5kLCBldmVudCA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLmVsLmNoaWxkLmNvbnRlbnQucmF3KSB7XG4gICAgICAgICAgICAgIHRoaXMuZW1pdCgnZmluaXNoY2xvc2UnKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWwuY2hpbGQuY29udGVudC5vZmYoUG9wdXAudHJhbnNpdGlvbkVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKHByb21pc2VCcmVhay5lbmQpLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dEZXN0cm95ZWQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jbG9zZSgpO1xuXG4gICAgICB0aGlzLl9kZXRhY2hCaW5kaW5ncygpO1xuXG4gICAgICB0aGlzLmVsLnJlbW92ZSgpO1xuICAgICAgUG9wdXAuaW5zdGFuY2VzLnNwbGljZShQb3B1cC5pbnN0YW5jZXMuaW5kZXhPZih0aGlzKSwgMSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgfVxuICBQb3B1cC5pbnN0YW5jZXMgPSBbXTtcbiAgUG9wdXAuaGFzT3BlbiA9IGZhbHNlO1xuICBQb3B1cC5ib2R5V3JhcHBlciA9IG51bGw7XG4gIFBvcHVwLnRyYW5zaXRpb25FbmQgPSB0cmFuc2l0aW9uRW5kKCk7XG4gIHJldHVybiBQb3B1cDtcbn0uY2FsbCh1bmRlZmluZWQpO1xuXG52YXIgUG9wdXAkMSA9IFBvcHVwO3ZhciBkZWZhdWx0cyA9IHtcbiAgcGxhY2VtZW50OiAnY2VudGVyJyxcbiAgb3BlbjogZmFsc2UsXG4gIGZvcmNlT3BlbjogZmFsc2UsXG4gIHRlbXBsYXRlOiBudWxsLFxuICBjb25kaXRpb246IG51bGwsXG4gIGFuaW1hdGlvbjogMzAwLFxuICBjb250ZW50UGFkZGluZzogMCxcbiAgeVRocmVzaG9sZDogMTUsXG4gIG9wZW5MaW1pdDogMmUzMDgsXG4gIG92ZXJsYXlDb2xvcjogJ3JnYmEoMCwwLDAsMC44OCknLFxuICBjbG9zZToge1xuICAgIHNob3c6IGZhbHNlLFxuICAgIHBhZGRpbmc6IDIwLFxuICAgIGluc2lkZTogZmFsc2UsXG4gICAgc2l6ZTogMjJcbiAgfSxcbiAgdHJpZ2dlcnM6IHtcbiAgICBvcGVuOiB7XG4gICAgICBuYXZpZ2F0aW9uOiBmYWxzZSxcbiAgICAgIHZpc2liaWxpdHk6IGZhbHNlLFxuICAgICAgZXhpdEludGVudDogZmFsc2VcbiAgICB9LFxuICAgIGNsb3NlOiB7XG4gICAgICBlc2M6IHRydWVcbiAgICB9XG4gIH1cbn07dmFyIHZlcnNpb24gPSBcIjEuMC4wXCI7dmFyIG5ld0J1aWxkZXIsIHF1aWNrcG9wdXA7XG5cbm5ld0J1aWxkZXIgPSBmdW5jdGlvbiAoZGVmYXVsdHMkJDEsIHRlbXBsYXRlcykge1xuICB2YXIgYnVpbGRlcjtcblxuICBidWlsZGVyID0gZnVuY3Rpb24gKGFyZykge1xuXG4gICAgc3dpdGNoIChmYWxzZSkge1xuICAgICAgY2FzZSBhcmd1bWVudHMubGVuZ3RoICE9PSAwOlxuICAgICAgICByZXR1cm4gbmV3IFBvcHVwJDEobnVsbCwgZGVmYXVsdHMkJDEsIHRlbXBsYXRlcyk7XG5cbiAgICAgIGNhc2UgdHlwZW9mIGFyZyAhPT0gJ3N0cmluZyc6XG4gICAgICAgIHJldHVybiBuZXcgUG9wdXAkMSh7XG4gICAgICAgICAgY29udGVudDogaHRtbC5zcGF3bih7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIGh0bWw6IGFyZ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0sIGRlZmF1bHRzJCQxLCB0ZW1wbGF0ZXMpO1xuXG4gICAgICBjYXNlICFET00uaXNFbChhcmcpOlxuICAgICAgY2FzZSAhRE9NLmlzUXVpY2tFbChhcmcpOlxuICAgICAgICByZXR1cm4gbmV3IFBvcHVwJDEoe1xuICAgICAgICAgIGNvbnRlbnQ6IGFyZ1xuICAgICAgICB9LCBkZWZhdWx0cyQkMSwgdGVtcGxhdGVzKTtcblxuICAgICAgY2FzZSAhRE9NLmlzVGVtcGxhdGUoYXJnKTpcbiAgICAgICAgcmV0dXJuIG5ldyBQb3B1cCQxKHtcbiAgICAgICAgICBjb250ZW50OiBhcmcuc3Bhd24oKVxuICAgICAgICB9LCBkZWZhdWx0cyQkMSwgdGVtcGxhdGVzKTtcblxuICAgICAgY2FzZSAhKGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0Jyk6XG4gICAgICAgIHJldHVybiBuZXcgUG9wdXAkMShhcmcsIGRlZmF1bHRzJCQxLCB0ZW1wbGF0ZXMpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQgcHJvdmlkZWQgdG8gUXVpY2tQb3B1cCcpO1xuICAgIH1cbiAgfTtcblxuICBidWlsZGVyLmNvbmZpZyA9IGZ1bmN0aW9uIChuZXdTZXR0aW5ncywgbmV3VGVtcGxhdGVzKSB7XG4gICAgdmFyIG5hbWUkJDEsIG91dHB1dFNldHRpbmdzLCBvdXRwdXRUZW1wbGF0ZXMsIHRlbXBsYXRlO1xuXG4gICAgaWYgKCFJUyQxLm9iamVjdChuZXdTZXR0aW5ncykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUXVpY2tQb3B1cCBDb25maWc6IGludmFsaWQgY29uZmlnIG9iamVjdCBwcm92aWRlZCAke1N0cmluZyhuZXdTZXR0aW5ncyl9YCk7XG4gICAgfVxuXG4gICAgb3V0cHV0U2V0dGluZ3MgPSBleHRlbmQuY2xvbmUuZGVlcChkZWZhdWx0cyQkMSwgbmV3U2V0dGluZ3MpO1xuXG4gICAgaWYgKCFJUyQxLm9iamVjdChuZXdUZW1wbGF0ZXMpKSB7XG4gICAgICBvdXRwdXRUZW1wbGF0ZXMgPSB0ZW1wbGF0ZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dFRlbXBsYXRlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIGZvciAobmFtZSQkMSBpbiB0ZW1wbGF0ZXMpIHtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZXNbbmFtZSQkMV07XG5cbiAgICAgICAgaWYgKG5ld1RlbXBsYXRlc1tuYW1lJCQxXSkge1xuICAgICAgICAgIG91dHB1dFRlbXBsYXRlc1tuYW1lJCQxXSA9IHRlbXBsYXRlLmV4dGVuZChuZXdUZW1wbGF0ZXNbbmFtZSQkMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dHB1dFRlbXBsYXRlc1tuYW1lJCQxXSA9IHRlbXBsYXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0J1aWxkZXIob3V0cHV0U2V0dGluZ3MsIG91dHB1dFRlbXBsYXRlcyk7XG4gIH07XG5cbiAgYnVpbGRlci53cmFwQm9keSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUG9wdXAkMS53cmFwQm9keSgpO1xuICB9O1xuXG4gIGJ1aWxkZXIudW53cmFwQm9keSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUG9wdXAkMS51bndyYXBCb2R5KCk7XG4gIH07XG5cbiAgYnVpbGRlci5kZXN0cm95QWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBQb3B1cCQxLmRlc3Ryb3lBbGwoKTtcbiAgfTtcblxuICBidWlsZGVyLnZlcnNpb24gPSB2ZXJzaW9uO1xuICBidWlsZGVyLmRlZmF1bHRzID0gZGVmYXVsdHMkJDE7XG4gIGJ1aWxkZXIudGVtcGxhdGVzID0gdGVtcGxhdGVzO1xuICByZXR1cm4gYnVpbGRlcjtcbn07XG5cbnF1aWNrcG9wdXAgPSBuZXdCdWlsZGVyKGRlZmF1bHRzLCB0ZW1wbGF0ZXMpO1xudmFyIHF1aWNrcG9wdXAkMSA9IHF1aWNrcG9wdXA7ZXhwb3J0IGRlZmF1bHQgcXVpY2twb3B1cCQxOyIsImltcG9ydCBkZXRlY3RBbmltYXRpb24gZnJvbSAnZGV0ZWN0LWFuaW1hdGlvbi1lbmQtaGVscGVyJ1xuaW1wb3J0IERPTSBmcm9tICdxdWlja2RvbSdcblxuZXhwb3J0IHN1cHBvcnRzQW5pbWF0aW9uID0gKCktPiAhIWRldGVjdEFuaW1hdGlvbigpXG5cbmV4cG9ydCB0cmFuc2l0aW9uRW5kID0gKCktPiBkZXRlY3RBbmltYXRpb24oJ3RyYW5zaXRpb24nKVxuXG5leHBvcnQgcmVzdGFydFNhbmRib3ggPSAoKS0+XG5cdHdpbmRvdy5zYW5kYm94LnJlbW92ZSgpIGlmIHdpbmRvdy5zYW5kYm94XG5cdHdpbmRvdy5zYW5kYm94ID0gRE9NLmRpdiBpZDonc2FuZGJveCcsIHN0eWxlOlxuXHRcdGJvcmRlcjogJzFweCBzb2xpZCdcblx0XHRwYWRkaW5nOiAyMFxuXHRcdGJveFNpemluZzogJ2JvcmRlci1ib3gnXG5cdFxuXHR3aW5kb3cuc2FuZGJveC5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KSIsIi8qIVxuICogYXNzZXJ0aW9uLWVycm9yXG4gKiBDb3B5cmlnaHQoYykgMjAxMyBKYWtlIEx1ZXIgPGpha2VAcXVhbGlhbmN5LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBvbmUgb2JqZWN0IHRvIGFub3RoZXIgZXhjbHVkaW5nIGFueSBvcmlnaW5hbGx5XG4gKiBsaXN0ZWQuIFJldHVybmVkIGZ1bmN0aW9uIHdpbGwgY3JlYXRlIGEgbmV3IGB7fWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4Y2x1ZGVkIHByb3BlcnRpZXMgLi4uXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBleGNsdWRlICgpIHtcbiAgdmFyIGV4Y2x1ZGVzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gIGZ1bmN0aW9uIGV4Y2x1ZGVQcm9wcyAocmVzLCBvYmopIHtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKCF+ZXhjbHVkZXMuaW5kZXhPZihrZXkpKSByZXNba2V5XSA9IG9ialtrZXldO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGV4dGVuZEV4Y2x1ZGUgKCkge1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gICAgICAsIGkgPSAwXG4gICAgICAsIHJlcyA9IHt9O1xuXG4gICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBleGNsdWRlUHJvcHMocmVzLCBhcmdzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xufTtcblxuLyohXG4gKiBQcmltYXJ5IEV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFzc2VydGlvbkVycm9yO1xuXG4vKipcbiAqICMjIyBBc3NlcnRpb25FcnJvclxuICpcbiAqIEFuIGV4dGVuc2lvbiBvZiB0aGUgSmF2YVNjcmlwdCBgRXJyb3JgIGNvbnN0cnVjdG9yIGZvclxuICogYXNzZXJ0aW9uIGFuZCB2YWxpZGF0aW9uIHNjZW5hcmlvcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgdG8gaW5jbHVkZSAob3B0aW9uYWwpXG4gKiBAcGFyYW0ge2NhbGxlZX0gc3RhcnQgc3RhY2sgZnVuY3Rpb24gKG9wdGlvbmFsKVxuICovXG5cbmZ1bmN0aW9uIEFzc2VydGlvbkVycm9yIChtZXNzYWdlLCBfcHJvcHMsIHNzZikge1xuICB2YXIgZXh0ZW5kID0gZXhjbHVkZSgnbmFtZScsICdtZXNzYWdlJywgJ3N0YWNrJywgJ2NvbnN0cnVjdG9yJywgJ3RvSlNPTicpXG4gICAgLCBwcm9wcyA9IGV4dGVuZChfcHJvcHMgfHwge30pO1xuXG4gIC8vIGRlZmF1bHQgdmFsdWVzXG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1Vuc3BlY2lmaWVkIEFzc2VydGlvbkVycm9yJztcbiAgdGhpcy5zaG93RGlmZiA9IGZhbHNlO1xuXG4gIC8vIGNvcHkgZnJvbSBwcm9wZXJ0aWVzXG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHRoaXNba2V5XSA9IHByb3BzW2tleV07XG4gIH1cblxuICAvLyBjYXB0dXJlIHN0YWNrIHRyYWNlXG4gIHNzZiA9IHNzZiB8fCBBc3NlcnRpb25FcnJvcjtcbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgc3NmKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICB0aGlzLnN0YWNrID0gZS5zdGFjaztcbiAgICB9XG4gIH1cbn1cblxuLyohXG4gKiBJbmhlcml0IGZyb20gRXJyb3IucHJvdG90eXBlXG4gKi9cblxuQXNzZXJ0aW9uRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuXG4vKiFcbiAqIFN0YXRpY2FsbHkgc2V0IG5hbWVcbiAqL1xuXG5Bc3NlcnRpb25FcnJvci5wcm90b3R5cGUubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG5cbi8qIVxuICogRW5zdXJlIGNvcnJlY3QgY29uc3RydWN0b3JcbiAqL1xuXG5Bc3NlcnRpb25FcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBc3NlcnRpb25FcnJvcjtcblxuLyoqXG4gKiBBbGxvdyBlcnJvcnMgdG8gYmUgY29udmVydGVkIHRvIEpTT04gZm9yIHN0YXRpYyB0cmFuc2Zlci5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluY2x1ZGUgc3RhY2sgKGRlZmF1bHQ6IGB0cnVlYClcbiAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHRoYXQgY2FuIGJlIGBKU09OLnN0cmluZ2lmeWBcbiAqL1xuXG5Bc3NlcnRpb25FcnJvci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKHN0YWNrKSB7XG4gIHZhciBleHRlbmQgPSBleGNsdWRlKCdjb25zdHJ1Y3RvcicsICd0b0pTT04nLCAnc3RhY2snKVxuICAgICwgcHJvcHMgPSBleHRlbmQoeyBuYW1lOiB0aGlzLm5hbWUgfSwgdGhpcyk7XG5cbiAgLy8gaW5jbHVkZSBzdGFjayBpZiBleGlzdHMgYW5kIG5vdCB0dXJuZWQgb2ZmXG4gIGlmIChmYWxzZSAhPT0gc3RhY2sgJiYgdGhpcy5zdGFjaykge1xuICAgIHByb3BzLnN0YWNrID0gdGhpcy5zdGFjaztcbiAgfVxuXG4gIHJldHVybiBwcm9wcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qICFcbiAqIENoYWkgLSBwYXRodmFsIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2dpY2FscGFyYWRveC9maWx0clxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmhhc1Byb3BlcnR5KG9iamVjdCwgbmFtZSlcbiAqXG4gKiBUaGlzIGFsbG93cyBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgb3duXG4gKiBvciBpbmhlcml0ZWQgZnJvbSBwcm90b3R5cGUgY2hhaW4gbmFtZWQgcHJvcGVydHkuXG4gKlxuICogQmFzaWNhbGx5IGRvZXMgdGhlIHNhbWUgdGhpbmcgYXMgdGhlIGBpbmBcbiAqIG9wZXJhdG9yIGJ1dCB3b3JrcyBwcm9wZXJseSB3aXRoIG51bGwvdW5kZWZpbmVkIHZhbHVlc1xuICogYW5kIG90aGVyIHByaW1pdGl2ZXMuXG4gKlxuICogICAgIHZhciBvYmogPSB7XG4gKiAgICAgICAgIGFycjogWydhJywgJ2InLCAnYyddXG4gKiAgICAgICAsIHN0cjogJ0hlbGxvJ1xuICogICAgIH1cbiAqXG4gKiBUaGUgZm9sbG93aW5nIHdvdWxkIGJlIHRoZSByZXN1bHRzLlxuICpcbiAqICAgICBoYXNQcm9wZXJ0eShvYmosICdzdHInKTsgIC8vIHRydWVcbiAqICAgICBoYXNQcm9wZXJ0eShvYmosICdjb25zdHJ1Y3RvcicpOyAgLy8gdHJ1ZVxuICogICAgIGhhc1Byb3BlcnR5KG9iaiwgJ2JhcicpOyAgLy8gZmFsc2VcbiAqXG4gKiAgICAgaGFzUHJvcGVydHkob2JqLnN0ciwgJ2xlbmd0aCcpOyAvLyB0cnVlXG4gKiAgICAgaGFzUHJvcGVydHkob2JqLnN0ciwgMSk7ICAvLyB0cnVlXG4gKiAgICAgaGFzUHJvcGVydHkob2JqLnN0ciwgNSk7ICAvLyBmYWxzZVxuICpcbiAqICAgICBoYXNQcm9wZXJ0eShvYmouYXJyLCAnbGVuZ3RoJyk7ICAvLyB0cnVlXG4gKiAgICAgaGFzUHJvcGVydHkob2JqLmFyciwgMik7ICAvLyB0cnVlXG4gKiAgICAgaGFzUHJvcGVydHkob2JqLmFyciwgMyk7ICAvLyBmYWxzZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfFN5bWJvbH0gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59IHdoZXRoZXIgaXQgZXhpc3RzXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBoYXNQcm9wZXJ0eVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBoYXNQcm9wZXJ0eShvYmosIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRoZSBgaW5gIG9wZXJhdG9yIGRvZXMgbm90IHdvcmsgd2l0aCBwcmltaXRpdmVzLlxuICByZXR1cm4gbmFtZSBpbiBPYmplY3Qob2JqKTtcbn1cblxuLyogIVxuICogIyMgcGFyc2VQYXRoKHBhdGgpXG4gKlxuICogSGVscGVyIGZ1bmN0aW9uIHVzZWQgdG8gcGFyc2Ugc3RyaW5nIG9iamVjdFxuICogcGF0aHMuIFVzZSBpbiBjb25qdW5jdGlvbiB3aXRoIGBpbnRlcm5hbEdldFBhdGhWYWx1ZWAuXG4gKlxuICogICAgICB2YXIgcGFyc2VkID0gcGFyc2VQYXRoKCdteW9iamVjdC5wcm9wZXJ0eS5zdWJwcm9wJyk7XG4gKlxuICogIyMjIFBhdGhzOlxuICpcbiAqICogQ2FuIGJlIGluZmluaXRlbHkgZGVlcCBhbmQgbmVzdGVkLlxuICogKiBBcnJheXMgYXJlIGFsc28gdmFsaWQgdXNpbmcgdGhlIGZvcm1hbCBgbXlvYmplY3QuZG9jdW1lbnRbM10ucHJvcGVydHlgLlxuICogKiBMaXRlcmFsIGRvdHMgYW5kIGJyYWNrZXRzIChub3QgZGVsaW1pdGVyKSBtdXN0IGJlIGJhY2tzbGFzaC1lc2NhcGVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBwYXJzZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gIHZhciBzdHIgPSBwYXRoLnJlcGxhY2UoLyhbXlxcXFxdKVxcWy9nLCAnJDEuWycpO1xuICB2YXIgcGFydHMgPSBzdHIubWF0Y2goLyhcXFxcXFwufFteLl0rPykrL2cpO1xuICByZXR1cm4gcGFydHMubWFwKGZ1bmN0aW9uIG1hcE1hdGNoZXModmFsdWUpIHtcbiAgICB2YXIgcmVnZXhwID0gL15cXFsoXFxkKylcXF0kLztcbiAgICB2YXIgbUFyciA9IHJlZ2V4cC5leGVjKHZhbHVlKTtcbiAgICB2YXIgcGFyc2VkID0gbnVsbDtcbiAgICBpZiAobUFycikge1xuICAgICAgcGFyc2VkID0geyBpOiBwYXJzZUZsb2F0KG1BcnJbMV0pIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlZCA9IHsgcDogdmFsdWUucmVwbGFjZSgvXFxcXChbLlxcW1xcXV0pL2csICckMScpIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfSk7XG59XG5cbi8qICFcbiAqICMjIGludGVybmFsR2V0UGF0aFZhbHVlKG9iaiwgcGFyc2VkWywgcGF0aERlcHRoXSlcbiAqXG4gKiBIZWxwZXIgY29tcGFuaW9uIGZ1bmN0aW9uIGZvciBgLnBhcnNlUGF0aGAgdGhhdCByZXR1cm5zXG4gKiB0aGUgdmFsdWUgbG9jYXRlZCBhdCB0aGUgcGFyc2VkIGFkZHJlc3MuXG4gKlxuICogICAgICB2YXIgdmFsdWUgPSBnZXRQYXRoVmFsdWUob2JqLCBwYXJzZWQpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdG8gc2VhcmNoIGFnYWluc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJzZWQgZGVmaW5pdGlvbiBmcm9tIGBwYXJzZVBhdGhgLlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlcHRoIChuZXN0aW5nIGxldmVsKSBvZiB0aGUgcHJvcGVydHkgd2Ugd2FudCB0byByZXRyaWV2ZVxuICogQHJldHVybnMge09iamVjdHxVbmRlZmluZWR9IHZhbHVlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpbnRlcm5hbEdldFBhdGhWYWx1ZShvYmosIHBhcnNlZCwgcGF0aERlcHRoKSB7XG4gIHZhciB0ZW1wb3JhcnlWYWx1ZSA9IG9iajtcbiAgdmFyIHJlcyA9IG51bGw7XG4gIHBhdGhEZXB0aCA9ICh0eXBlb2YgcGF0aERlcHRoID09PSAndW5kZWZpbmVkJyA/IHBhcnNlZC5sZW5ndGggOiBwYXRoRGVwdGgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aERlcHRoOyBpKyspIHtcbiAgICB2YXIgcGFydCA9IHBhcnNlZFtpXTtcbiAgICBpZiAodGVtcG9yYXJ5VmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgcGFydC5wID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0ZW1wb3JhcnlWYWx1ZSA9IHRlbXBvcmFyeVZhbHVlW3BhcnQuaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wb3JhcnlWYWx1ZSA9IHRlbXBvcmFyeVZhbHVlW3BhcnQucF07XG4gICAgICB9XG5cbiAgICAgIGlmIChpID09PSAocGF0aERlcHRoIC0gMSkpIHtcbiAgICAgICAgcmVzID0gdGVtcG9yYXJ5VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuLyogIVxuICogIyMgaW50ZXJuYWxTZXRQYXRoVmFsdWUob2JqLCB2YWx1ZSwgcGFyc2VkKVxuICpcbiAqIENvbXBhbmlvbiBmdW5jdGlvbiBmb3IgYHBhcnNlUGF0aGAgdGhhdCBzZXRzXG4gKiB0aGUgdmFsdWUgbG9jYXRlZCBhdCBhIHBhcnNlZCBhZGRyZXNzLlxuICpcbiAqICBpbnRlcm5hbFNldFBhdGhWYWx1ZShvYmosICd2YWx1ZScsIHBhcnNlZCk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBzZWFyY2ggYW5kIGRlZmluZSBvblxuICogQHBhcmFtIHsqfSB2YWx1ZSB0byB1c2UgdXBvbiBzZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJzZWQgZGVmaW5pdGlvbiBmcm9tIGBwYXJzZVBhdGhgXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpbnRlcm5hbFNldFBhdGhWYWx1ZShvYmosIHZhbCwgcGFyc2VkKSB7XG4gIHZhciB0ZW1wT2JqID0gb2JqO1xuICB2YXIgcGF0aERlcHRoID0gcGFyc2VkLmxlbmd0aDtcbiAgdmFyIHBhcnQgPSBudWxsO1xuICAvLyBIZXJlIHdlIGl0ZXJhdGUgdGhyb3VnaCBldmVyeSBwYXJ0IG9mIHRoZSBwYXRoXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aERlcHRoOyBpKyspIHtcbiAgICB2YXIgcHJvcE5hbWUgPSBudWxsO1xuICAgIHZhciBwcm9wVmFsID0gbnVsbDtcbiAgICBwYXJ0ID0gcGFyc2VkW2ldO1xuXG4gICAgLy8gSWYgaXQncyB0aGUgbGFzdCBwYXJ0IG9mIHRoZSBwYXRoLCB3ZSBzZXQgdGhlICdwcm9wTmFtZScgdmFsdWUgd2l0aCB0aGUgcHJvcGVydHkgbmFtZVxuICAgIGlmIChpID09PSAocGF0aERlcHRoIC0gMSkpIHtcbiAgICAgIHByb3BOYW1lID0gdHlwZW9mIHBhcnQucCA9PT0gJ3VuZGVmaW5lZCcgPyBwYXJ0LmkgOiBwYXJ0LnA7XG4gICAgICAvLyBOb3cgd2Ugc2V0IHRoZSBwcm9wZXJ0eSB3aXRoIHRoZSBuYW1lIGhlbGQgYnkgJ3Byb3BOYW1lJyBvbiBvYmplY3Qgd2l0aCB0aGUgZGVzaXJlZCB2YWxcbiAgICAgIHRlbXBPYmpbcHJvcE5hbWVdID0gdmFsO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcnQucCAhPT0gJ3VuZGVmaW5lZCcgJiYgdGVtcE9ialtwYXJ0LnBdKSB7XG4gICAgICB0ZW1wT2JqID0gdGVtcE9ialtwYXJ0LnBdO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcnQuaSAhPT0gJ3VuZGVmaW5lZCcgJiYgdGVtcE9ialtwYXJ0LmldKSB7XG4gICAgICB0ZW1wT2JqID0gdGVtcE9ialtwYXJ0LmldO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGUgb2JqIGRvZXNuJ3QgaGF2ZSB0aGUgcHJvcGVydHkgd2UgY3JlYXRlIG9uZSB3aXRoIHRoYXQgbmFtZSB0byBkZWZpbmUgaXRcbiAgICAgIHZhciBuZXh0ID0gcGFyc2VkW2kgKyAxXTtcbiAgICAgIC8vIEhlcmUgd2Ugc2V0IHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB3aGljaCB3aWxsIGJlIGRlZmluZWRcbiAgICAgIHByb3BOYW1lID0gdHlwZW9mIHBhcnQucCA9PT0gJ3VuZGVmaW5lZCcgPyBwYXJ0LmkgOiBwYXJ0LnA7XG4gICAgICAvLyBIZXJlIHdlIGRlY2lkZSBpZiB0aGlzIHByb3BlcnR5IHdpbGwgYmUgYW4gYXJyYXkgb3IgYSBuZXcgb2JqZWN0XG4gICAgICBwcm9wVmFsID0gdHlwZW9mIG5leHQucCA9PT0gJ3VuZGVmaW5lZCcgPyBbXSA6IHt9O1xuICAgICAgdGVtcE9ialtwcm9wTmFtZV0gPSBwcm9wVmFsO1xuICAgICAgdGVtcE9iaiA9IHRlbXBPYmpbcHJvcE5hbWVdO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqICMjIyAuZ2V0UGF0aEluZm8ob2JqZWN0LCBwYXRoKVxuICpcbiAqIFRoaXMgYWxsb3dzIHRoZSByZXRyaWV2YWwgb2YgcHJvcGVydHkgaW5mbyBpbiBhblxuICogb2JqZWN0IGdpdmVuIGEgc3RyaW5nIHBhdGguXG4gKlxuICogVGhlIHBhdGggaW5mbyBjb25zaXN0cyBvZiBhbiBvYmplY3Qgd2l0aCB0aGVcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICogcGFyZW50IC0gVGhlIHBhcmVudCBvYmplY3Qgb2YgdGhlIHByb3BlcnR5IHJlZmVyZW5jZWQgYnkgYHBhdGhgXG4gKiAqIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZmluYWwgcHJvcGVydHksIGEgbnVtYmVyIGlmIGl0IHdhcyBhbiBhcnJheSBpbmRleGVyXG4gKiAqIHZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSwgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2UgYHVuZGVmaW5lZGBcbiAqICogZXhpc3RzIC0gV2hldGhlciB0aGUgcHJvcGVydHkgZXhpc3RzIG9yIG5vdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBpbmZvXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBnZXRQYXRoSW5mb1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBnZXRQYXRoSW5mbyhvYmosIHBhdGgpIHtcbiAgdmFyIHBhcnNlZCA9IHBhcnNlUGF0aChwYXRoKTtcbiAgdmFyIGxhc3QgPSBwYXJzZWRbcGFyc2VkLmxlbmd0aCAtIDFdO1xuICB2YXIgaW5mbyA9IHtcbiAgICBwYXJlbnQ6IHBhcnNlZC5sZW5ndGggPiAxID8gaW50ZXJuYWxHZXRQYXRoVmFsdWUob2JqLCBwYXJzZWQsIHBhcnNlZC5sZW5ndGggLSAxKSA6IG9iaixcbiAgICBuYW1lOiBsYXN0LnAgfHwgbGFzdC5pLFxuICAgIHZhbHVlOiBpbnRlcm5hbEdldFBhdGhWYWx1ZShvYmosIHBhcnNlZCksXG4gIH07XG4gIGluZm8uZXhpc3RzID0gaGFzUHJvcGVydHkoaW5mby5wYXJlbnQsIGluZm8ubmFtZSk7XG5cbiAgcmV0dXJuIGluZm87XG59XG5cbi8qKlxuICogIyMjIC5nZXRQYXRoVmFsdWUob2JqZWN0LCBwYXRoKVxuICpcbiAqIFRoaXMgYWxsb3dzIHRoZSByZXRyaWV2YWwgb2YgdmFsdWVzIGluIGFuXG4gKiBvYmplY3QgZ2l2ZW4gYSBzdHJpbmcgcGF0aC5cbiAqXG4gKiAgICAgdmFyIG9iaiA9IHtcbiAqICAgICAgICAgcHJvcDE6IHtcbiAqICAgICAgICAgICAgIGFycjogWydhJywgJ2InLCAnYyddXG4gKiAgICAgICAgICAgLCBzdHI6ICdIZWxsbydcbiAqICAgICAgICAgfVxuICogICAgICAgLCBwcm9wMjoge1xuICogICAgICAgICAgICAgYXJyOiBbIHsgbmVzdGVkOiAnVW5pdmVyc2UnIH0gXVxuICogICAgICAgICAgICwgc3RyOiAnSGVsbG8gYWdhaW4hJ1xuICogICAgICAgICB9XG4gKiAgICAgfVxuICpcbiAqIFRoZSBmb2xsb3dpbmcgd291bGQgYmUgdGhlIHJlc3VsdHMuXG4gKlxuICogICAgIGdldFBhdGhWYWx1ZShvYmosICdwcm9wMS5zdHInKTsgLy8gSGVsbG9cbiAqICAgICBnZXRQYXRoVmFsdWUob2JqLCAncHJvcDEuYXR0WzJdJyk7IC8vIGJcbiAqICAgICBnZXRQYXRoVmFsdWUob2JqLCAncHJvcDIuYXJyWzBdLm5lc3RlZCcpOyAvLyBVbml2ZXJzZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB2YWx1ZSBvciBgdW5kZWZpbmVkYFxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgZ2V0UGF0aFZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGdldFBhdGhWYWx1ZShvYmosIHBhdGgpIHtcbiAgdmFyIGluZm8gPSBnZXRQYXRoSW5mbyhvYmosIHBhdGgpO1xuICByZXR1cm4gaW5mby52YWx1ZTtcbn1cblxuLyoqXG4gKiAjIyMgLnNldFBhdGhWYWx1ZShvYmplY3QsIHBhdGgsIHZhbHVlKVxuICpcbiAqIERlZmluZSB0aGUgdmFsdWUgaW4gYW4gb2JqZWN0IGF0IGEgZ2l2ZW4gc3RyaW5nIHBhdGguXG4gKlxuICogYGBganNcbiAqIHZhciBvYmogPSB7XG4gKiAgICAgcHJvcDE6IHtcbiAqICAgICAgICAgYXJyOiBbJ2EnLCAnYicsICdjJ11cbiAqICAgICAgICwgc3RyOiAnSGVsbG8nXG4gKiAgICAgfVxuICogICAsIHByb3AyOiB7XG4gKiAgICAgICAgIGFycjogWyB7IG5lc3RlZDogJ1VuaXZlcnNlJyB9IF1cbiAqICAgICAgICwgc3RyOiAnSGVsbG8gYWdhaW4hJ1xuICogICAgIH1cbiAqIH07XG4gKiBgYGBcbiAqXG4gKiBUaGUgZm9sbG93aW5nIHdvdWxkIGJlIGFjY2VwdGFibGUuXG4gKlxuICogYGBganNcbiAqIHZhciBwcm9wZXJ0aWVzID0gcmVxdWlyZSgndGVhLXByb3BlcnRpZXMnKTtcbiAqIHByb3BlcnRpZXMuc2V0KG9iaiwgJ3Byb3AxLnN0cicsICdIZWxsbyBVbml2ZXJzZSEnKTtcbiAqIHByb3BlcnRpZXMuc2V0KG9iaiwgJ3Byb3AxLmFyclsyXScsICdCJyk7XG4gKiBwcm9wZXJ0aWVzLnNldChvYmosICdwcm9wMi5hcnJbMF0ubmVzdGVkLnZhbHVlJywgeyBoZWxsbzogJ3VuaXZlcnNlJyB9KTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2V0UGF0aFZhbHVlKG9iaiwgcGF0aCwgdmFsKSB7XG4gIHZhciBwYXJzZWQgPSBwYXJzZVBhdGgocGF0aCk7XG4gIGludGVybmFsU2V0UGF0aFZhbHVlKG9iaiwgdmFsLCBwYXJzZWQpO1xuICByZXR1cm4gb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaGFzUHJvcGVydHk6IGhhc1Byb3BlcnR5LFxuICBnZXRQYXRoSW5mbzogZ2V0UGF0aEluZm8sXG4gIGdldFBhdGhWYWx1ZTogZ2V0UGF0aFZhbHVlLFxuICBzZXRQYXRoVmFsdWU6IHNldFBhdGhWYWx1ZSxcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBmbGFnIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAuZmxhZyhvYmplY3QsIGtleSwgW3ZhbHVlXSlcbiAqXG4gKiBHZXQgb3Igc2V0IGEgZmxhZyB2YWx1ZSBvbiBhbiBvYmplY3QuIElmIGFcbiAqIHZhbHVlIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgc2V0LCBlbHNlIGl0IHdpbGxcbiAqIHJldHVybiB0aGUgY3VycmVudGx5IHNldCB2YWx1ZSBvciBgdW5kZWZpbmVkYCBpZlxuICogdGhlIHZhbHVlIGlzIG5vdCBzZXQuXG4gKlxuICogICAgIHV0aWxzLmZsYWcodGhpcywgJ2ZvbycsICdiYXInKTsgLy8gc2V0dGVyXG4gKiAgICAgdXRpbHMuZmxhZyh0aGlzLCAnZm9vJyk7IC8vIGdldHRlciwgcmV0dXJucyBgYmFyYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgY29uc3RydWN0ZWQgQXNzZXJ0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZSAob3B0aW9uYWwpXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBmbGFnXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZsYWcob2JqLCBrZXksIHZhbHVlKSB7XG4gIHZhciBmbGFncyA9IG9iai5fX2ZsYWdzIHx8IChvYmouX19mbGFncyA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIGZsYWdzW2tleV0gPSB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmxhZ3Nba2V5XTtcbiAgfVxufTtcbiIsIi8qIVxuICogQ2hhaSAtIHRlc3QgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBmbGFnID0gcmVxdWlyZSgnLi9mbGFnJyk7XG5cbi8qKlxuICogIyMjIC50ZXN0KG9iamVjdCwgZXhwcmVzc2lvbilcbiAqXG4gKiBUZXN0IGFuZCBvYmplY3QgZm9yIGV4cHJlc3Npb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAoY29uc3RydWN0ZWQgQXNzZXJ0aW9uKVxuICogQHBhcmFtIHtBcmd1bWVudHN9IGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZS5hc3NlcnQgYXJndW1lbnRzXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSB0ZXN0XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXN0KG9iaiwgYXJncykge1xuICB2YXIgbmVnYXRlID0gZmxhZyhvYmosICduZWdhdGUnKVxuICAgICwgZXhwciA9IGFyZ3NbMF07XG4gIHJldHVybiBuZWdhdGUgPyAhZXhwciA6IGV4cHI7XG59O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuXHQoZ2xvYmFsLnR5cGVEZXRlY3QgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbi8qICFcbiAqIHR5cGUtZGV0ZWN0XG4gKiBDb3B5cmlnaHQoYykgMjAxMyBqYWtlIGx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG52YXIgcHJvbWlzZUV4aXN0cyA9IHR5cGVvZiBQcm9taXNlID09PSAnZnVuY3Rpb24nO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xudmFyIGdsb2JhbE9iamVjdCA9IHR5cGVvZiBzZWxmID09PSAnb2JqZWN0JyA/IHNlbGYgOiBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaWQtYmxhY2tsaXN0XG5cbnZhciBzeW1ib2xFeGlzdHMgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJztcbnZhciBtYXBFeGlzdHMgPSB0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJztcbnZhciBzZXRFeGlzdHMgPSB0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJztcbnZhciB3ZWFrTWFwRXhpc3RzID0gdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnO1xudmFyIHdlYWtTZXRFeGlzdHMgPSB0eXBlb2YgV2Vha1NldCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgZGF0YVZpZXdFeGlzdHMgPSB0eXBlb2YgRGF0YVZpZXcgIT09ICd1bmRlZmluZWQnO1xudmFyIHN5bWJvbEl0ZXJhdG9yRXhpc3RzID0gc3ltYm9sRXhpc3RzICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgIT09ICd1bmRlZmluZWQnO1xudmFyIHN5bWJvbFRvU3RyaW5nVGFnRXhpc3RzID0gc3ltYm9sRXhpc3RzICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgIT09ICd1bmRlZmluZWQnO1xudmFyIHNldEVudHJpZXNFeGlzdHMgPSBzZXRFeGlzdHMgJiYgdHlwZW9mIFNldC5wcm90b3R5cGUuZW50cmllcyA9PT0gJ2Z1bmN0aW9uJztcbnZhciBtYXBFbnRyaWVzRXhpc3RzID0gbWFwRXhpc3RzICYmIHR5cGVvZiBNYXAucHJvdG90eXBlLmVudHJpZXMgPT09ICdmdW5jdGlvbic7XG52YXIgc2V0SXRlcmF0b3JQcm90b3R5cGUgPSBzZXRFbnRyaWVzRXhpc3RzICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgU2V0KCkuZW50cmllcygpKTtcbnZhciBtYXBJdGVyYXRvclByb3RvdHlwZSA9IG1hcEVudHJpZXNFeGlzdHMgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBNYXAoKS5lbnRyaWVzKCkpO1xudmFyIGFycmF5SXRlcmF0b3JFeGlzdHMgPSBzeW1ib2xJdGVyYXRvckV4aXN0cyAmJiB0eXBlb2YgQXJyYXkucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG52YXIgYXJyYXlJdGVyYXRvclByb3RvdHlwZSA9IGFycmF5SXRlcmF0b3JFeGlzdHMgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSk7XG52YXIgc3RyaW5nSXRlcmF0b3JFeGlzdHMgPSBzeW1ib2xJdGVyYXRvckV4aXN0cyAmJiB0eXBlb2YgU3RyaW5nLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xudmFyIHN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlID0gc3RyaW5nSXRlcmF0b3JFeGlzdHMgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKCcnW1N5bWJvbC5pdGVyYXRvcl0oKSk7XG52YXIgdG9TdHJpbmdMZWZ0U2xpY2VMZW5ndGggPSA4O1xudmFyIHRvU3RyaW5nUmlnaHRTbGljZUxlbmd0aCA9IC0xO1xuLyoqXG4gKiAjIyMgdHlwZU9mIChvYmopXG4gKlxuICogVXNlcyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AgdG8gZGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGFuIG9iamVjdCxcbiAqIG5vcm1hbGlzaW5nIGJlaGF2aW91ciBhY3Jvc3MgZW5naW5lIHZlcnNpb25zICYgd2VsbCBvcHRpbWlzZWQuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IG9iamVjdCB0eXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiB0eXBlRGV0ZWN0KG9iaikge1xuICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAgKiBQcmU6XG4gICAqICAgc3RyaW5nIGxpdGVyYWwgICAgIHggMywwMzksMDM1IG9wcy9zZWMgwrExLjYyJSAoNzggcnVucyBzYW1wbGVkKVxuICAgKiAgIGJvb2xlYW4gbGl0ZXJhbCAgICB4IDEsNDI0LDEzOCBvcHMvc2VjIMKxNC41NCUgKDc1IHJ1bnMgc2FtcGxlZClcbiAgICogICBudW1iZXIgbGl0ZXJhbCAgICAgeCAxLDY1MywxNTMgb3BzL3NlYyDCsTEuOTElICg4MiBydW5zIHNhbXBsZWQpXG4gICAqICAgdW5kZWZpbmVkICAgICAgICAgIHggOSw5NzgsNjYwIG9wcy9zZWMgwrExLjkyJSAoNzUgcnVucyBzYW1wbGVkKVxuICAgKiAgIGZ1bmN0aW9uICAgICAgICAgICB4IDIsNTU2LDc2OSBvcHMvc2VjIMKxMS43MyUgKDc3IHJ1bnMgc2FtcGxlZClcbiAgICogUG9zdDpcbiAgICogICBzdHJpbmcgbGl0ZXJhbCAgICAgeCAzOCw1NjQsNzk2IG9wcy9zZWMgwrExLjE1JSAoNzkgcnVucyBzYW1wbGVkKVxuICAgKiAgIGJvb2xlYW4gbGl0ZXJhbCAgICB4IDMxLDE0OCw5NDAgb3BzL3NlYyDCsTEuMTAlICg3OSBydW5zIHNhbXBsZWQpXG4gICAqICAgbnVtYmVyIGxpdGVyYWwgICAgIHggMzIsNjc5LDMzMCBvcHMvc2VjIMKxMS45MCUgKDc4IHJ1bnMgc2FtcGxlZClcbiAgICogICB1bmRlZmluZWQgICAgICAgICAgeCAzMiwzNjMsMzY4IG9wcy9zZWMgwrExLjA3JSAoODIgcnVucyBzYW1wbGVkKVxuICAgKiAgIGZ1bmN0aW9uICAgICAgICAgICB4IDMxLDI5Niw4NzAgb3BzL3NlYyDCsTAuOTYlICg4MyBydW5zIHNhbXBsZWQpXG4gICAqL1xuICB2YXIgdHlwZW9mT2JqID0gdHlwZW9mIG9iajtcbiAgaWYgKHR5cGVvZk9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdHlwZW9mT2JqO1xuICB9XG5cbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgICogUHJlOlxuICAgKiAgIG51bGwgICAgICAgICAgICAgICB4IDI4LDY0NSw3NjUgb3BzL3NlYyDCsTEuMTclICg4MiBydW5zIHNhbXBsZWQpXG4gICAqIFBvc3Q6XG4gICAqICAgbnVsbCAgICAgICAgICAgICAgIHggMzYsNDI4LDk2MiBvcHMvc2VjIMKxMS4zNyUgKDg0IHJ1bnMgc2FtcGxlZClcbiAgICovXG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9XG5cbiAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2luZG93KWBgXG4gICAqICAtIE5vZGUgPT09IFwiW29iamVjdCBnbG9iYWxdXCJcbiAgICogIC0gQ2hyb21lID09PSBcIltvYmplY3QgZ2xvYmFsXVwiXG4gICAqICAtIEZpcmVmb3ggPT09IFwiW29iamVjdCBXaW5kb3ddXCJcbiAgICogIC0gUGhhbnRvbUpTID09PSBcIltvYmplY3QgV2luZG93XVwiXG4gICAqICAtIFNhZmFyaSA9PT0gXCJbb2JqZWN0IFdpbmRvd11cIlxuICAgKiAgLSBJRSAxMSA9PT0gXCJbb2JqZWN0IFdpbmRvd11cIlxuICAgKiAgLSBJRSBFZGdlID09PSBcIltvYmplY3QgV2luZG93XVwiXG4gICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGhpcylgYFxuICAgKiAgLSBDaHJvbWUgV29ya2VyID09PSBcIltvYmplY3QgZ2xvYmFsXVwiXG4gICAqICAtIEZpcmVmb3ggV29ya2VyID09PSBcIltvYmplY3QgRGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGVdXCJcbiAgICogIC0gU2FmYXJpIFdvcmtlciA9PT0gXCJbb2JqZWN0IERlZGljYXRlZFdvcmtlckdsb2JhbFNjb3BlXVwiXG4gICAqICAtIElFIDExIFdvcmtlciA9PT0gXCJbb2JqZWN0IFdvcmtlckdsb2JhbFNjb3BlXVwiXG4gICAqICAtIElFIEVkZ2UgV29ya2VyID09PSBcIltvYmplY3QgV29ya2VyR2xvYmFsU2NvcGVdXCJcbiAgICovXG4gIGlmIChvYmogPT09IGdsb2JhbE9iamVjdCkge1xuICAgIHJldHVybiAnZ2xvYmFsJztcbiAgfVxuXG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICAqIFByZTpcbiAgICogICBhcnJheSBsaXRlcmFsICAgICAgeCAyLDg4OCwzNTIgb3BzL3NlYyDCsTAuNjclICg4MiBydW5zIHNhbXBsZWQpXG4gICAqIFBvc3Q6XG4gICAqICAgYXJyYXkgbGl0ZXJhbCAgICAgIHggMjIsNDc5LDY1MCBvcHMvc2VjIMKxMC45NiUgKDgxIHJ1bnMgc2FtcGxlZClcbiAgICovXG4gIGlmIChcbiAgICBBcnJheS5pc0FycmF5KG9iaikgJiZcbiAgICAoc3ltYm9sVG9TdHJpbmdUYWdFeGlzdHMgPT09IGZhbHNlIHx8ICEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIG9iaikpXG4gICkge1xuICAgIHJldHVybiAnQXJyYXknO1xuICB9XG5cbiAgLy8gTm90IGNhY2hpbmcgZXhpc3RlbmNlIG9mIGB3aW5kb3dgIGFuZCByZWxhdGVkIHByb3BlcnRpZXMgZHVlIHRvIHBvdGVudGlhbFxuICAvLyBmb3IgYHdpbmRvd2AgdG8gYmUgdW5zZXQgYmVmb3JlIHRlc3RzIGluIHF1YXNpLWJyb3dzZXIgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93ICE9PSBudWxsKSB7XG4gICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICogKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Jyb3dzZXJzLmh0bWwjbG9jYXRpb24pXG4gICAgICogV2hhdFdHIEhUTUwkNy43LjMgLSBUaGUgYExvY2F0aW9uYCBpbnRlcmZhY2VcbiAgICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHdpbmRvdy5sb2NhdGlvbilgYFxuICAgICAqICAtIElFIDw9MTEgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICAgKiAgLSBJRSBFZGdlIDw9MTMgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIHdpbmRvdy5sb2NhdGlvbiA9PT0gJ29iamVjdCcgJiYgb2JqID09PSB3aW5kb3cubG9jYXRpb24pIHtcbiAgICAgIHJldHVybiAnTG9jYXRpb24nO1xuICAgIH1cblxuICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAqIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNkb2N1bWVudClcbiAgICAgKiBXaGF0V0cgSFRNTCQzLjEuMSAtIFRoZSBgRG9jdW1lbnRgIG9iamVjdFxuICAgICAqIE5vdGU6IE1vc3QgYnJvd3NlcnMgY3VycmVudGx5IGFkaGVyIHRvIHRoZSBXM0MgRE9NIExldmVsIDIgc3BlY1xuICAgICAqICAgICAgIChodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTItSFRNTC9odG1sLmh0bWwjSUQtMjY4MDkyNjgpXG4gICAgICogICAgICAgd2hpY2ggc3VnZ2VzdHMgdGhhdCBicm93c2VycyBzaG91bGQgdXNlIEhUTUxUYWJsZUNlbGxFbGVtZW50IGZvclxuICAgICAqICAgICAgIGJvdGggVEQgYW5kIFRIIGVsZW1lbnRzLiBXaGF0V0cgc2VwYXJhdGVzIHRoZXNlLlxuICAgICAqICAgICAgIFdoYXRXRyBIVE1MIHN0YXRlczpcbiAgICAgKiAgICAgICAgID4gRm9yIGhpc3RvcmljYWwgcmVhc29ucywgV2luZG93IG9iamVjdHMgbXVzdCBhbHNvIGhhdmUgYVxuICAgICAqICAgICAgICAgPiB3cml0YWJsZSwgY29uZmlndXJhYmxlLCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lZFxuICAgICAqICAgICAgICAgPiBIVE1MRG9jdW1lbnQgd2hvc2UgdmFsdWUgaXMgdGhlIERvY3VtZW50IGludGVyZmFjZSBvYmplY3QuXG4gICAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkb2N1bWVudClgYFxuICAgICAqICAtIENocm9tZSA9PT0gXCJbb2JqZWN0IEhUTUxEb2N1bWVudF1cIlxuICAgICAqICAtIEZpcmVmb3ggPT09IFwiW29iamVjdCBIVE1MRG9jdW1lbnRdXCJcbiAgICAgKiAgLSBTYWZhcmkgPT09IFwiW29iamVjdCBIVE1MRG9jdW1lbnRdXCJcbiAgICAgKiAgLSBJRSA8PTEwID09PSBcIltvYmplY3QgRG9jdW1lbnRdXCJcbiAgICAgKiAgLSBJRSAxMSA9PT0gXCJbb2JqZWN0IEhUTUxEb2N1bWVudF1cIlxuICAgICAqICAtIElFIEVkZ2UgPD0xMyA9PT0gXCJbb2JqZWN0IEhUTUxEb2N1bWVudF1cIlxuICAgICAqL1xuICAgIGlmICh0eXBlb2Ygd2luZG93LmRvY3VtZW50ID09PSAnb2JqZWN0JyAmJiBvYmogPT09IHdpbmRvdy5kb2N1bWVudCkge1xuICAgICAgcmV0dXJuICdEb2N1bWVudCc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cubmF2aWdhdG9yID09PSAnb2JqZWN0Jykge1xuICAgICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICAgKiAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvd2ViYXBwYXBpcy5odG1sI21pbWV0eXBlYXJyYXkpXG4gICAgICAgKiBXaGF0V0cgSFRNTCQ4LjYuMS41IC0gUGx1Z2lucyAtIEludGVyZmFjZSBNaW1lVHlwZUFycmF5XG4gICAgICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5hdmlnYXRvci5taW1lVHlwZXMpYGBcbiAgICAgICAqICAtIElFIDw9MTAgPT09IFwiW29iamVjdCBNU01pbWVUeXBlc0NvbGxlY3Rpb25dXCJcbiAgICAgICAqL1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cubmF2aWdhdG9yLm1pbWVUeXBlcyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICBvYmogPT09IHdpbmRvdy5uYXZpZ2F0b3IubWltZVR5cGVzKSB7XG4gICAgICAgIHJldHVybiAnTWltZVR5cGVBcnJheSc7XG4gICAgICB9XG5cbiAgICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAgICogKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3dlYmFwcGFwaXMuaHRtbCNwbHVnaW5hcnJheSlcbiAgICAgICAqIFdoYXRXRyBIVE1MJDguNi4xLjUgLSBQbHVnaW5zIC0gSW50ZXJmYWNlIFBsdWdpbkFycmF5XG4gICAgICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5hdmlnYXRvci5wbHVnaW5zKWBgXG4gICAgICAgKiAgLSBJRSA8PTEwID09PSBcIltvYmplY3QgTVNQbHVnaW5zQ29sbGVjdGlvbl1cIlxuICAgICAgICovXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdy5uYXZpZ2F0b3IucGx1Z2lucyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICBvYmogPT09IHdpbmRvdy5uYXZpZ2F0b3IucGx1Z2lucykge1xuICAgICAgICByZXR1cm4gJ1BsdWdpbkFycmF5JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoKHR5cGVvZiB3aW5kb3cuSFRNTEVsZW1lbnQgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgdHlwZW9mIHdpbmRvdy5IVE1MRWxlbWVudCA9PT0gJ29iamVjdCcpICYmXG4gICAgICAgIG9iaiBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MRWxlbWVudCkge1xuICAgICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICAqIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS93ZWJhcHBhcGlzLmh0bWwjcGx1Z2luYXJyYXkpXG4gICAgICAqIFdoYXRXRyBIVE1MJDQuNC40IC0gVGhlIGBibG9ja3F1b3RlYCBlbGVtZW50IC0gSW50ZXJmYWNlIGBIVE1MUXVvdGVFbGVtZW50YFxuICAgICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Jsb2NrcXVvdGUnKSlgYFxuICAgICAgKiAgLSBJRSA8PTEwID09PSBcIltvYmplY3QgSFRNTEJsb2NrRWxlbWVudF1cIlxuICAgICAgKi9cbiAgICAgIGlmIChvYmoudGFnTmFtZSA9PT0gJ0JMT0NLUVVPVEUnKSB7XG4gICAgICAgIHJldHVybiAnSFRNTFF1b3RlRWxlbWVudCc7XG4gICAgICB9XG5cbiAgICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAgICogKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI2h0bWx0YWJsZWRhdGFjZWxsZWxlbWVudClcbiAgICAgICAqIFdoYXRXRyBIVE1MJDQuOS45IC0gVGhlIGB0ZGAgZWxlbWVudCAtIEludGVyZmFjZSBgSFRNTFRhYmxlRGF0YUNlbGxFbGVtZW50YFxuICAgICAgICogTm90ZTogTW9zdCBicm93c2VycyBjdXJyZW50bHkgYWRoZXIgdG8gdGhlIFczQyBET00gTGV2ZWwgMiBzcGVjXG4gICAgICAgKiAgICAgICAoaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUhUTUwvaHRtbC5odG1sI0lELTgyOTE1MDc1KVxuICAgICAgICogICAgICAgd2hpY2ggc3VnZ2VzdHMgdGhhdCBicm93c2VycyBzaG91bGQgdXNlIEhUTUxUYWJsZUNlbGxFbGVtZW50IGZvclxuICAgICAgICogICAgICAgYm90aCBURCBhbmQgVEggZWxlbWVudHMuIFdoYXRXRyBzZXBhcmF0ZXMgdGhlc2UuXG4gICAgICAgKiBUZXN0OiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKSlcbiAgICAgICAqICAtIENocm9tZSA9PT0gXCJbb2JqZWN0IEhUTUxUYWJsZUNlbGxFbGVtZW50XVwiXG4gICAgICAgKiAgLSBGaXJlZm94ID09PSBcIltvYmplY3QgSFRNTFRhYmxlQ2VsbEVsZW1lbnRdXCJcbiAgICAgICAqICAtIFNhZmFyaSA9PT0gXCJbb2JqZWN0IEhUTUxUYWJsZUNlbGxFbGVtZW50XVwiXG4gICAgICAgKi9cbiAgICAgIGlmIChvYmoudGFnTmFtZSA9PT0gJ1REJykge1xuICAgICAgICByZXR1cm4gJ0hUTUxUYWJsZURhdGFDZWxsRWxlbWVudCc7XG4gICAgICB9XG5cbiAgICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAgICogKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI2h0bWx0YWJsZWhlYWRlcmNlbGxlbGVtZW50KVxuICAgICAgICogV2hhdFdHIEhUTUwkNC45LjkgLSBUaGUgYHRkYCBlbGVtZW50IC0gSW50ZXJmYWNlIGBIVE1MVGFibGVIZWFkZXJDZWxsRWxlbWVudGBcbiAgICAgICAqIE5vdGU6IE1vc3QgYnJvd3NlcnMgY3VycmVudGx5IGFkaGVyIHRvIHRoZSBXM0MgRE9NIExldmVsIDIgc3BlY1xuICAgICAgICogICAgICAgKGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1IVE1ML2h0bWwuaHRtbCNJRC04MjkxNTA3NSlcbiAgICAgICAqICAgICAgIHdoaWNoIHN1Z2dlc3RzIHRoYXQgYnJvd3NlcnMgc2hvdWxkIHVzZSBIVE1MVGFibGVDZWxsRWxlbWVudCBmb3JcbiAgICAgICAqICAgICAgIGJvdGggVEQgYW5kIFRIIGVsZW1lbnRzLiBXaGF0V0cgc2VwYXJhdGVzIHRoZXNlLlxuICAgICAgICogVGVzdDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RoJykpXG4gICAgICAgKiAgLSBDaHJvbWUgPT09IFwiW29iamVjdCBIVE1MVGFibGVDZWxsRWxlbWVudF1cIlxuICAgICAgICogIC0gRmlyZWZveCA9PT0gXCJbb2JqZWN0IEhUTUxUYWJsZUNlbGxFbGVtZW50XVwiXG4gICAgICAgKiAgLSBTYWZhcmkgPT09IFwiW29iamVjdCBIVE1MVGFibGVDZWxsRWxlbWVudF1cIlxuICAgICAgICovXG4gICAgICBpZiAob2JqLnRhZ05hbWUgPT09ICdUSCcpIHtcbiAgICAgICAgcmV0dXJuICdIVE1MVGFibGVIZWFkZXJDZWxsRWxlbWVudCc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgKiBQcmU6XG4gICogICBGbG9hdDY0QXJyYXkgICAgICAgeCA2MjUsNjQ0IG9wcy9zZWMgwrExLjU4JSAoODAgcnVucyBzYW1wbGVkKVxuICAqICAgRmxvYXQzMkFycmF5ICAgICAgIHggMSwyNzksODUyIG9wcy9zZWMgwrEyLjkxJSAoNzcgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDMyQXJyYXkgICAgICAgIHggMSwxNzgsMTg1IG9wcy9zZWMgwrExLjk1JSAoODMgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDE2QXJyYXkgICAgICAgIHggMSwwMDgsMzgwIG9wcy9zZWMgwrEyLjI1JSAoODAgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDhBcnJheSAgICAgICAgIHggMSwxMjgsMDQwIG9wcy9zZWMgwrEyLjExJSAoODEgcnVucyBzYW1wbGVkKVxuICAqICAgSW50MzJBcnJheSAgICAgICAgIHggMSwxNzAsMTE5IG9wcy9zZWMgwrEyLjg4JSAoODAgcnVucyBzYW1wbGVkKVxuICAqICAgSW50MTZBcnJheSAgICAgICAgIHggMSwxNzYsMzQ4IG9wcy9zZWMgwrE1Ljc5JSAoODYgcnVucyBzYW1wbGVkKVxuICAqICAgSW50OEFycmF5ICAgICAgICAgIHggMSwwNTgsNzA3IG9wcy9zZWMgwrE0Ljk0JSAoNzcgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDhDbGFtcGVkQXJyYXkgIHggMSwxMTAsNjMzIG9wcy9zZWMgwrE0LjIwJSAoODAgcnVucyBzYW1wbGVkKVxuICAqIFBvc3Q6XG4gICogICBGbG9hdDY0QXJyYXkgICAgICAgeCA3LDEwNSw2NzEgb3BzL3NlYyDCsTEzLjQ3JSAoNjQgcnVucyBzYW1wbGVkKVxuICAqICAgRmxvYXQzMkFycmF5ICAgICAgIHggNSw4ODcsOTEyIG9wcy9zZWMgwrExLjQ2JSAoODIgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDMyQXJyYXkgICAgICAgIHggNiw0OTEsNjYxIG9wcy9zZWMgwrExLjc2JSAoNzkgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDE2QXJyYXkgICAgICAgIHggNiw1NTksNzk1IG9wcy9zZWMgwrExLjY3JSAoODIgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDhBcnJheSAgICAgICAgIHggNiw0NjMsOTY2IG9wcy9zZWMgwrExLjQzJSAoODUgcnVucyBzYW1wbGVkKVxuICAqICAgSW50MzJBcnJheSAgICAgICAgIHggNSw2NDEsODQxIG9wcy9zZWMgwrEzLjQ5JSAoODEgcnVucyBzYW1wbGVkKVxuICAqICAgSW50MTZBcnJheSAgICAgICAgIHggNiw1ODMsNTExIG9wcy9zZWMgwrExLjk4JSAoODAgcnVucyBzYW1wbGVkKVxuICAqICAgSW50OEFycmF5ICAgICAgICAgIHggNiw2MDYsMDc4IG9wcy9zZWMgwrExLjc0JSAoODEgcnVucyBzYW1wbGVkKVxuICAqICAgVWludDhDbGFtcGVkQXJyYXkgIHggNiw2MDIsMjI0IG9wcy9zZWMgwrExLjc3JSAoODMgcnVucyBzYW1wbGVkKVxuICAqL1xuICB2YXIgc3RyaW5nVGFnID0gKHN5bWJvbFRvU3RyaW5nVGFnRXhpc3RzICYmIG9ialtTeW1ib2wudG9TdHJpbmdUYWddKTtcbiAgaWYgKHR5cGVvZiBzdHJpbmdUYWcgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHN0cmluZ1RhZztcbiAgfVxuXG4gIHZhciBvYmpQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgKiBQcmU6XG4gICogICByZWdleCBsaXRlcmFsICAgICAgeCAxLDc3MiwzODUgb3BzL3NlYyDCsTEuODUlICg3NyBydW5zIHNhbXBsZWQpXG4gICogICByZWdleCBjb25zdHJ1Y3RvciAgeCAyLDE0Myw2MzQgb3BzL3NlYyDCsTIuNDYlICg3OCBydW5zIHNhbXBsZWQpXG4gICogUG9zdDpcbiAgKiAgIHJlZ2V4IGxpdGVyYWwgICAgICB4IDMsOTI4LDAwOSBvcHMvc2VjIMKxMC42NSUgKDc4IHJ1bnMgc2FtcGxlZClcbiAgKiAgIHJlZ2V4IGNvbnN0cnVjdG9yICB4IDMsOTMxLDEwOCBvcHMvc2VjIMKxMC41OCUgKDg0IHJ1bnMgc2FtcGxlZClcbiAgKi9cbiAgaWYgKG9ialByb3RvdHlwZSA9PT0gUmVnRXhwLnByb3RvdHlwZSkge1xuICAgIHJldHVybiAnUmVnRXhwJztcbiAgfVxuXG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICogUHJlOlxuICAqICAgZGF0ZSAgICAgICAgICAgICAgIHggMiwxMzAsMDc0IG9wcy9zZWMgwrE0LjQyJSAoNjggcnVucyBzYW1wbGVkKVxuICAqIFBvc3Q6XG4gICogICBkYXRlICAgICAgICAgICAgICAgeCAzLDk1Myw3Nzkgb3BzL3NlYyDCsTEuMzUlICg3NyBydW5zIHNhbXBsZWQpXG4gICovXG4gIGlmIChvYmpQcm90b3R5cGUgPT09IERhdGUucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuICdEYXRlJztcbiAgfVxuXG4gIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgKiAoaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC9pbmRleC5odG1sI3NlYy1wcm9taXNlLnByb3RvdHlwZS1AQHRvc3RyaW5ndGFnKVxuICAgKiBFUzYkMjUuNC41LjQgLSBQcm9taXNlLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSBzaG91bGQgYmUgXCJQcm9taXNlXCI6XG4gICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUHJvbWlzZS5yZXNvbHZlKCkpYGBcbiAgICogIC0gQ2hyb21lIDw9NDcgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICogIC0gRWRnZSA8PTIwID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAqICAtIEZpcmVmb3ggMjktTGF0ZXN0ID09PSBcIltvYmplY3QgUHJvbWlzZV1cIlxuICAgKiAgLSBTYWZhcmkgNy4xLUxhdGVzdCA9PT0gXCJbb2JqZWN0IFByb21pc2VdXCJcbiAgICovXG4gIGlmIChwcm9taXNlRXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gUHJvbWlzZS5wcm90b3R5cGUpIHtcbiAgICByZXR1cm4gJ1Byb21pc2UnO1xuICB9XG5cbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgKiBQcmU6XG4gICogICBzZXQgICAgICAgICAgICAgICAgeCAyLDIyMiwxODYgb3BzL3NlYyDCsTEuMzElICg4MiBydW5zIHNhbXBsZWQpXG4gICogUG9zdDpcbiAgKiAgIHNldCAgICAgICAgICAgICAgICB4IDQsNTQ1LDg3OSBvcHMvc2VjIMKxMS4xMyUgKDgzIHJ1bnMgc2FtcGxlZClcbiAgKi9cbiAgaWYgKHNldEV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IFNldC5wcm90b3R5cGUpIHtcbiAgICByZXR1cm4gJ1NldCc7XG4gIH1cblxuICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAqIFByZTpcbiAgKiAgIG1hcCAgICAgICAgICAgICAgICB4IDIsMzk2LDg0MiBvcHMvc2VjIMKxMS41OSUgKDgxIHJ1bnMgc2FtcGxlZClcbiAgKiBQb3N0OlxuICAqICAgbWFwICAgICAgICAgICAgICAgIHggNCwxODMsOTQ1IG9wcy9zZWMgwrE2LjU5JSAoODIgcnVucyBzYW1wbGVkKVxuICAqL1xuICBpZiAobWFwRXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gTWFwLnByb3RvdHlwZSkge1xuICAgIHJldHVybiAnTWFwJztcbiAgfVxuXG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICogUHJlOlxuICAqICAgd2Vha3NldCAgICAgICAgICAgIHggMSwzMjMsMjIwIG9wcy9zZWMgwrEyLjE3JSAoNzYgcnVucyBzYW1wbGVkKVxuICAqIFBvc3Q6XG4gICogICB3ZWFrc2V0ICAgICAgICAgICAgeCA0LDIzNyw1MTAgb3BzL3NlYyDCsTIuMDElICg3NyBydW5zIHNhbXBsZWQpXG4gICovXG4gIGlmICh3ZWFrU2V0RXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gV2Vha1NldC5wcm90b3R5cGUpIHtcbiAgICByZXR1cm4gJ1dlYWtTZXQnO1xuICB9XG5cbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgKiBQcmU6XG4gICogICB3ZWFrbWFwICAgICAgICAgICAgeCAxLDUwMCwyNjAgb3BzL3NlYyDCsTIuMDIlICg3OCBydW5zIHNhbXBsZWQpXG4gICogUG9zdDpcbiAgKiAgIHdlYWttYXAgICAgICAgICAgICB4IDMsODgxLDM4NCBvcHMvc2VjIMKxMS40NSUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgKi9cbiAgaWYgKHdlYWtNYXBFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBXZWFrTWFwLnByb3RvdHlwZSkge1xuICAgIHJldHVybiAnV2Vha01hcCc7XG4gIH1cblxuICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICogKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvaW5kZXguaHRtbCNzZWMtZGF0YXZpZXcucHJvdG90eXBlLUBAdG9zdHJpbmd0YWcpXG4gICAqIEVTNiQyNC4yLjQuMjEgLSBEYXRhVmlldy5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gc2hvdWxkIGJlIFwiRGF0YVZpZXdcIjpcbiAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSlgYFxuICAgKiAgLSBFZGdlIDw9MTMgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICovXG4gIGlmIChkYXRhVmlld0V4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IERhdGFWaWV3LnByb3RvdHlwZSkge1xuICAgIHJldHVybiAnRGF0YVZpZXcnO1xuICB9XG5cbiAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAqIChodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wL2luZGV4Lmh0bWwjc2VjLSVtYXBpdGVyYXRvcnByb3RvdHlwZSUtQEB0b3N0cmluZ3RhZylcbiAgICogRVM2JDIzLjEuNS4yLjIgLSAlTWFwSXRlcmF0b3JQcm90b3R5cGUlW0BAdG9TdHJpbmdUYWddIHNob3VsZCBiZSBcIk1hcCBJdGVyYXRvclwiOlxuICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ldyBNYXAoKS5lbnRyaWVzKCkpYGBcbiAgICogIC0gRWRnZSA8PTEzID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAqL1xuICBpZiAobWFwRXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gbWFwSXRlcmF0b3JQcm90b3R5cGUpIHtcbiAgICByZXR1cm4gJ01hcCBJdGVyYXRvcic7XG4gIH1cblxuICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICogKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvaW5kZXguaHRtbCNzZWMtJXNldGl0ZXJhdG9ycHJvdG90eXBlJS1AQHRvc3RyaW5ndGFnKVxuICAgKiBFUzYkMjMuMi41LjIuMiAtICVTZXRJdGVyYXRvclByb3RvdHlwZSVbQEB0b1N0cmluZ1RhZ10gc2hvdWxkIGJlIFwiU2V0IEl0ZXJhdG9yXCI6XG4gICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3IFNldCgpLmVudHJpZXMoKSlgYFxuICAgKiAgLSBFZGdlIDw9MTMgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgICovXG4gIGlmIChzZXRFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBzZXRJdGVyYXRvclByb3RvdHlwZSkge1xuICAgIHJldHVybiAnU2V0IEl0ZXJhdG9yJztcbiAgfVxuXG4gIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgKiAoaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC9pbmRleC5odG1sI3NlYy0lYXJyYXlpdGVyYXRvcnByb3RvdHlwZSUtQEB0b3N0cmluZ3RhZylcbiAgICogRVM2JDIyLjEuNS4yLjIgLSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSVbQEB0b1N0cmluZ1RhZ10gc2hvdWxkIGJlIFwiQXJyYXkgSXRlcmF0b3JcIjpcbiAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChbXVtTeW1ib2wuaXRlcmF0b3JdKCkpYGBcbiAgICogIC0gRWRnZSA8PTEzID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAqL1xuICBpZiAoYXJyYXlJdGVyYXRvckV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IGFycmF5SXRlcmF0b3JQcm90b3R5cGUpIHtcbiAgICByZXR1cm4gJ0FycmF5IEl0ZXJhdG9yJztcbiAgfVxuXG4gIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgKiAoaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC9pbmRleC5odG1sI3NlYy0lc3RyaW5naXRlcmF0b3Jwcm90b3R5cGUlLUBAdG9zdHJpbmd0YWcpXG4gICAqIEVTNiQyMS4xLjUuMi4yIC0gJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJVtAQHRvU3RyaW5nVGFnXSBzaG91bGQgYmUgXCJTdHJpbmcgSXRlcmF0b3JcIjpcbiAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCgnJ1tTeW1ib2wuaXRlcmF0b3JdKCkpYGBcbiAgICogIC0gRWRnZSA8PTEzID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAqL1xuICBpZiAoc3RyaW5nSXRlcmF0b3JFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBzdHJpbmdJdGVyYXRvclByb3RvdHlwZSkge1xuICAgIHJldHVybiAnU3RyaW5nIEl0ZXJhdG9yJztcbiAgfVxuXG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICogUHJlOlxuICAqICAgb2JqZWN0IGZyb20gbnVsbCAgIHggMiw0MjQsMzIwIG9wcy9zZWMgwrExLjY3JSAoNzYgcnVucyBzYW1wbGVkKVxuICAqIFBvc3Q6XG4gICogICBvYmplY3QgZnJvbSBudWxsICAgeCA1LDgzOCwwMDAgb3BzL3NlYyDCsTAuOTklICg4NCBydW5zIHNhbXBsZWQpXG4gICovXG4gIGlmIChvYmpQcm90b3R5cGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ09iamVjdCc7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0XG4gICAgLnByb3RvdHlwZVxuICAgIC50b1N0cmluZ1xuICAgIC5jYWxsKG9iailcbiAgICAuc2xpY2UodG9TdHJpbmdMZWZ0U2xpY2VMZW5ndGgsIHRvU3RyaW5nUmlnaHRTbGljZUxlbmd0aCk7XG59XG5cbnJldHVybiB0eXBlRGV0ZWN0O1xuXG59KSkpO1xuIiwiLyohXG4gKiBDaGFpIC0gZXhwZWN0VHlwZXMgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC5leHBlY3RUeXBlcyhvYmosIHR5cGVzKVxuICpcbiAqIEVuc3VyZXMgdGhhdCB0aGUgb2JqZWN0IGJlaW5nIHRlc3RlZCBhZ2FpbnN0IGlzIG9mIGEgdmFsaWQgdHlwZS5cbiAqXG4gKiAgICAgdXRpbHMuZXhwZWN0VHlwZXModGhpcywgWydhcnJheScsICdvYmplY3QnLCAnc3RyaW5nJ10pO1xuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IG9iaiBjb25zdHJ1Y3RlZCBBc3NlcnRpb25cbiAqIEBwYXJhbSB7QXJyYXl9IHR5cGUgQSBsaXN0IG9mIGFsbG93ZWQgdHlwZXMgZm9yIHRoaXMgYXNzZXJ0aW9uXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBleHBlY3RUeXBlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG52YXIgQXNzZXJ0aW9uRXJyb3IgPSByZXF1aXJlKCdhc3NlcnRpb24tZXJyb3InKTtcbnZhciBmbGFnID0gcmVxdWlyZSgnLi9mbGFnJyk7XG52YXIgdHlwZSA9IHJlcXVpcmUoJ3R5cGUtZGV0ZWN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXhwZWN0VHlwZXMob2JqLCB0eXBlcykge1xuICB2YXIgZmxhZ01zZyA9IGZsYWcob2JqLCAnbWVzc2FnZScpO1xuICB2YXIgc3NmaSA9IGZsYWcob2JqLCAnc3NmaScpO1xuXG4gIGZsYWdNc2cgPSBmbGFnTXNnID8gZmxhZ01zZyArICc6ICcgOiAnJztcblxuICBvYmogPSBmbGFnKG9iaiwgJ29iamVjdCcpO1xuICB0eXBlcyA9IHR5cGVzLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gdC50b0xvd2VyQ2FzZSgpOyB9KTtcbiAgdHlwZXMuc29ydCgpO1xuXG4gIC8vIFRyYW5zZm9ybXMgWydsb3JlbScsICdpcHN1bSddIGludG8gJ2EgbG9yZW0sIG9yIGFuIGlwc3VtJ1xuICB2YXIgc3RyID0gdHlwZXMubWFwKGZ1bmN0aW9uICh0LCBpbmRleCkge1xuICAgIHZhciBhcnQgPSB+WyAnYScsICdlJywgJ2knLCAnbycsICd1JyBdLmluZGV4T2YodC5jaGFyQXQoMCkpID8gJ2FuJyA6ICdhJztcbiAgICB2YXIgb3IgPSB0eXBlcy5sZW5ndGggPiAxICYmIGluZGV4ID09PSB0eXBlcy5sZW5ndGggLSAxID8gJ29yICcgOiAnJztcbiAgICByZXR1cm4gb3IgKyBhcnQgKyAnICcgKyB0O1xuICB9KS5qb2luKCcsICcpO1xuXG4gIHZhciBvYmpUeXBlID0gdHlwZShvYmopLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKCF0eXBlcy5zb21lKGZ1bmN0aW9uIChleHBlY3RlZCkgeyByZXR1cm4gb2JqVHlwZSA9PT0gZXhwZWN0ZWQ7IH0pKSB7XG4gICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKFxuICAgICAgZmxhZ01zZyArICdvYmplY3QgdGVzdGVkIG11c3QgYmUgJyArIHN0ciArICcsIGJ1dCAnICsgb2JqVHlwZSArICcgZ2l2ZW4nLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgc3NmaVxuICAgICk7XG4gIH1cbn07XG4iLCIvKiFcbiAqIENoYWkgLSBnZXRBY3R1YWwgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC5nZXRBY3R1YWwob2JqZWN0LCBbYWN0dWFsXSlcbiAqXG4gKiBSZXR1cm5zIHRoZSBgYWN0dWFsYCB2YWx1ZSBmb3IgYW4gQXNzZXJ0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgKGNvbnN0cnVjdGVkIEFzc2VydGlvbilcbiAqIEBwYXJhbSB7QXJndW1lbnRzfSBjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUuYXNzZXJ0IGFyZ3VtZW50c1xuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgZ2V0QWN0dWFsXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRBY3R1YWwob2JqLCBhcmdzKSB7XG4gIHJldHVybiBhcmdzLmxlbmd0aCA+IDQgPyBhcmdzWzRdIDogb2JqLl9vYmo7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiAhXG4gKiBDaGFpIC0gZ2V0RnVuY05hbWUgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNiBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC5nZXRGdW5jTmFtZShjb25zdHJ1Y3RvckZuKVxuICpcbiAqIFJldHVybnMgdGhlIG5hbWUgb2YgYSBmdW5jdGlvbi5cbiAqIFdoZW4gYSBub24tZnVuY3Rpb24gaW5zdGFuY2UgaXMgcGFzc2VkLCByZXR1cm5zIGBudWxsYC5cbiAqIFRoaXMgYWxzbyBpbmNsdWRlcyBhIHBvbHlmaWxsIGZ1bmN0aW9uIGlmIGBhRnVuYy5uYW1lYCBpcyBub3QgZGVmaW5lZC5cbiAqXG4gKiBAbmFtZSBnZXRGdW5jTmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY3RcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxudmFyIHRvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZ1bmN0aW9uTmFtZU1hdGNoID0gL1xccypmdW5jdGlvbig/Olxcc3xcXHMqXFwvXFwqW14oPzoqXFwvKV0rXFwqXFwvXFxzKikqKFteXFxzXFwoXFwvXSspLztcbmZ1bmN0aW9uIGdldEZ1bmNOYW1lKGFGdW5jKSB7XG4gIGlmICh0eXBlb2YgYUZ1bmMgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBuYW1lID0gJyc7XG4gIGlmICh0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlLm5hbWUgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBhRnVuYy5uYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEhlcmUgd2UgcnVuIGEgcG9seWZpbGwgaWYgRnVuY3Rpb24gZG9lcyBub3Qgc3VwcG9ydCB0aGUgYG5hbWVgIHByb3BlcnR5IGFuZCBpZiBhRnVuYy5uYW1lIGlzIG5vdCBkZWZpbmVkXG4gICAgdmFyIG1hdGNoID0gdG9TdHJpbmcuY2FsbChhRnVuYykubWF0Y2goZnVuY3Rpb25OYW1lTWF0Y2gpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgbmFtZSA9IG1hdGNoWzFdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB3ZSd2ZSBnb3QgYSBgbmFtZWAgcHJvcGVydHkgd2UganVzdCB1c2UgaXRcbiAgICBuYW1lID0gYUZ1bmMubmFtZTtcbiAgfVxuXG4gIHJldHVybiBuYW1lO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEZ1bmNOYW1lO1xuIiwiLyohXG4gKiBDaGFpIC0gZ2V0UHJvcGVydGllcyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmdldFByb3BlcnRpZXMob2JqZWN0KVxuICpcbiAqIFRoaXMgYWxsb3dzIHRoZSByZXRyaWV2YWwgb2YgcHJvcGVydHkgbmFtZXMgb2YgYW4gb2JqZWN0LCBlbnVtZXJhYmxlIG9yIG5vdCxcbiAqIGluaGVyaXRlZCBvciBub3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHJldHVybnMge0FycmF5fVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgZ2V0UHJvcGVydGllc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFByb3BlcnRpZXMob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpO1xuXG4gIGZ1bmN0aW9uIGFkZFByb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgaWYgKHJlc3VsdC5pbmRleE9mKHByb3BlcnR5KSA9PT0gLTEpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHByb3BlcnR5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgd2hpbGUgKHByb3RvICE9PSBudWxsKSB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pLmZvckVhY2goYWRkUHJvcGVydHkpO1xuICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gZ2V0RW51bWVyYWJsZVByb3BlcnRpZXMgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC5nZXRFbnVtZXJhYmxlUHJvcGVydGllcyhvYmplY3QpXG4gKlxuICogVGhpcyBhbGxvd3MgdGhlIHJldHJpZXZhbCBvZiBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdCxcbiAqIGluaGVyaXRlZCBvciBub3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHJldHVybnMge0FycmF5fVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgZ2V0RW51bWVyYWJsZVByb3BlcnRpZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRFbnVtZXJhYmxlUHJvcGVydGllcyhvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBuYW1lIGluIG9iamVjdCkge1xuICAgIHJlc3VsdC5wdXNoKG5hbWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyoqXG4gICAqICMjIyBjb25maWcuaW5jbHVkZVN0YWNrXG4gICAqXG4gICAqIFVzZXIgY29uZmlndXJhYmxlIHByb3BlcnR5LCBpbmZsdWVuY2VzIHdoZXRoZXIgc3RhY2sgdHJhY2VcbiAgICogaXMgaW5jbHVkZWQgaW4gQXNzZXJ0aW9uIGVycm9yIG1lc3NhZ2UuIERlZmF1bHQgb2YgZmFsc2VcbiAgICogc3VwcHJlc3NlcyBzdGFjayB0cmFjZSBpbiB0aGUgZXJyb3IgbWVzc2FnZS5cbiAgICpcbiAgICogICAgIGNoYWkuY29uZmlnLmluY2x1ZGVTdGFjayA9IHRydWU7ICAvLyBlbmFibGUgc3RhY2sgb24gZXJyb3JcbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBpbmNsdWRlU3RhY2s6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiAjIyMgY29uZmlnLnNob3dEaWZmXG4gICAqXG4gICAqIFVzZXIgY29uZmlndXJhYmxlIHByb3BlcnR5LCBpbmZsdWVuY2VzIHdoZXRoZXIgb3Igbm90XG4gICAqIHRoZSBgc2hvd0RpZmZgIGZsYWcgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSB0aHJvd25cbiAgICogQXNzZXJ0aW9uRXJyb3JzLiBgZmFsc2VgIHdpbGwgYWx3YXlzIGJlIGBmYWxzZWA7IGB0cnVlYFxuICAgKiB3aWxsIGJlIHRydWUgd2hlbiB0aGUgYXNzZXJ0aW9uIGhhcyByZXF1ZXN0ZWQgYSBkaWZmXG4gICAqIGJlIHNob3duLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHNob3dEaWZmOiB0cnVlLFxuXG4gIC8qKlxuICAgKiAjIyMgY29uZmlnLnRydW5jYXRlVGhyZXNob2xkXG4gICAqXG4gICAqIFVzZXIgY29uZmlndXJhYmxlIHByb3BlcnR5LCBzZXRzIGxlbmd0aCB0aHJlc2hvbGQgZm9yIGFjdHVhbCBhbmRcbiAgICogZXhwZWN0ZWQgdmFsdWVzIGluIGFzc2VydGlvbiBlcnJvcnMuIElmIHRoaXMgdGhyZXNob2xkIGlzIGV4Y2VlZGVkLCBmb3JcbiAgICogZXhhbXBsZSBmb3IgbGFyZ2UgZGF0YSBzdHJ1Y3R1cmVzLCB0aGUgdmFsdWUgaXMgcmVwbGFjZWQgd2l0aCBzb21ldGhpbmdcbiAgICogbGlrZSBgWyBBcnJheSgzKSBdYCBvciBgeyBPYmplY3QgKHByb3AxLCBwcm9wMikgfWAuXG4gICAqXG4gICAqIFNldCBpdCB0byB6ZXJvIGlmIHlvdSB3YW50IHRvIGRpc2FibGUgdHJ1bmNhdGluZyBhbHRvZ2V0aGVyLlxuICAgKlxuICAgKiBUaGlzIGlzIGVzcGVjaWFsbHkgdXNlcmZ1bCB3aGVuIGRvaW5nIGFzc2VydGlvbnMgb24gYXJyYXlzOiBoYXZpbmcgdGhpc1xuICAgKiBzZXQgdG8gYSByZWFzb25hYmxlIGxhcmdlIHZhbHVlIG1ha2VzIHRoZSBmYWlsdXJlIG1lc3NhZ2VzIHJlYWRpbHlcbiAgICogaW5zcGVjdGFibGUuXG4gICAqXG4gICAqICAgICBjaGFpLmNvbmZpZy50cnVuY2F0ZVRocmVzaG9sZCA9IDA7ICAvLyBkaXNhYmxlIHRydW5jYXRpbmdcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHRydW5jYXRlVGhyZXNob2xkOiA0MCxcblxuICAvKipcbiAgICogIyMjIGNvbmZpZy51c2VQcm94eVxuICAgKlxuICAgKiBVc2VyIGNvbmZpZ3VyYWJsZSBwcm9wZXJ0eSwgZGVmaW5lcyBpZiBjaGFpIHdpbGwgdXNlIGEgUHJveHkgdG8gdGhyb3dcbiAgICogYW4gZXJyb3Igd2hlbiBhIG5vbi1leGlzdGVudCBwcm9wZXJ0eSBpcyByZWFkLCB3aGljaCBwcm90ZWN0cyB1c2Vyc1xuICAgKiBmcm9tIHR5cG9zIHdoZW4gdXNpbmcgcHJvcGVydHktYmFzZWQgYXNzZXJ0aW9ucy5cbiAgICpcbiAgICogU2V0IGl0IHRvIGZhbHNlIGlmIHlvdSB3YW50IHRvIGRpc2FibGUgdGhpcyBmZWF0dXJlLlxuICAgKlxuICAgKiAgICAgY2hhaS5jb25maWcudXNlUHJveHkgPSBmYWxzZTsgIC8vIGRpc2FibGUgdXNlIG9mIFByb3h5XG4gICAqXG4gICAqIFRoaXMgZmVhdHVyZSBpcyBhdXRvbWF0aWNhbGx5IGRpc2FibGVkIHJlZ2FyZGxlc3Mgb2YgdGhpcyBjb25maWcgdmFsdWVcbiAgICogaW4gZW52aXJvbm1lbnRzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBwcm94aWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHVzZVByb3h5OiB0cnVlLFxuXG4gIC8qKlxuICAgKiAjIyMgY29uZmlnLnByb3h5RXhjbHVkZWRLZXlzXG4gICAqXG4gICAqIFVzZXIgY29uZmlndXJhYmxlIHByb3BlcnR5LCBkZWZpbmVzIHdoaWNoIHByb3BlcnRpZXMgc2hvdWxkIGJlIGlnbm9yZWRcbiAgICogaW5zdGVhZCBvZiB0aHJvd2luZyBhbiBlcnJvciBpZiB0aGV5IGRvIG5vdCBleGlzdCBvbiB0aGUgYXNzZXJ0aW9uLlxuICAgKiBUaGlzIGlzIG9ubHkgYXBwbGllZCBpZiB0aGUgZW52aXJvbm1lbnQgQ2hhaSBpcyBydW5uaW5nIGluIHN1cHBvcnRzIHByb3hpZXMgYW5kXG4gICAqIGlmIHRoZSBgdXNlUHJveHlgIGNvbmZpZ3VyYXRpb24gc2V0dGluZyBpcyBlbmFibGVkLlxuICAgKiBCeSBkZWZhdWx0LCBgdGhlbmAgYW5kIGBpbnNwZWN0YCB3aWxsIG5vdCB0aHJvdyBhbiBlcnJvciBpZiB0aGV5IGRvIG5vdCBleGlzdCBvbiB0aGVcbiAgICogYXNzZXJ0aW9uIG9iamVjdCBiZWNhdXNlIHRoZSBgLmluc3BlY3RgIHByb3BlcnR5IGlzIHJlYWQgYnkgYHV0aWwuaW5zcGVjdGAgKGZvciBleGFtcGxlLCB3aGVuXG4gICAqIHVzaW5nIGBjb25zb2xlLmxvZ2Agb24gdGhlIGFzc2VydGlvbiBvYmplY3QpIGFuZCBgLnRoZW5gIGlzIG5lY2Vzc2FyeSBmb3IgcHJvbWlzZSB0eXBlLWNoZWNraW5nLlxuICAgKlxuICAgKiAgICAgLy8gQnkgZGVmYXVsdCB0aGVzZSBrZXlzIHdpbGwgbm90IHRocm93IGFuIGVycm9yIGlmIHRoZXkgZG8gbm90IGV4aXN0IG9uIHRoZSBhc3NlcnRpb24gb2JqZWN0XG4gICAqICAgICBjaGFpLmNvbmZpZy5wcm94eUV4Y2x1ZGVkS2V5cyA9IFsndGhlbicsICdpbnNwZWN0J107XG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHByb3h5RXhjbHVkZWRLZXlzOiBbJ3RoZW4nLCAnY2F0Y2gnLCAnaW5zcGVjdCcsICd0b0pTT04nXVxufTtcbiIsIi8vIFRoaXMgaXMgKGFsbW9zdCkgZGlyZWN0bHkgZnJvbSBOb2RlLmpzIHV0aWxzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvYmxvYi9mOGMzMzVkMGNhZjQ3ZjE2ZDMxNDEzZjg5YWEyOGVkYTM4NzhlM2FhL2xpYi91dGlsLmpzXG5cbnZhciBnZXROYW1lID0gcmVxdWlyZSgnZ2V0LWZ1bmMtbmFtZScpO1xudmFyIGdldFByb3BlcnRpZXMgPSByZXF1aXJlKCcuL2dldFByb3BlcnRpZXMnKTtcbnZhciBnZXRFbnVtZXJhYmxlUHJvcGVydGllcyA9IHJlcXVpcmUoJy4vZ2V0RW51bWVyYWJsZVByb3BlcnRpZXMnKTtcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnNwZWN0O1xuXG4vKipcbiAqICMjIyAuaW5zcGVjdChvYmosIFtzaG93SGlkZGVuXSwgW2RlcHRoXSwgW2NvbG9yc10pXG4gKlxuICogRWNob2VzIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcmllcyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtCb29sZWFufSBzaG93SGlkZGVuIEZsYWcgdGhhdCBzaG93cyBoaWRkZW4gKG5vdCBlbnVtZXJhYmxlKVxuICogICAgcHJvcGVydGllcyBvZiBvYmplY3RzLiBEZWZhdWx0IGlzIGZhbHNlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlcHRoIERlcHRoIGluIHdoaWNoIHRvIGRlc2NlbmQgaW4gb2JqZWN0LiBEZWZhdWx0IGlzIDIuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNvbG9ycyBGbGFnIHRvIHR1cm4gb24gQU5TSSBlc2NhcGUgY29kZXMgdG8gY29sb3IgdGhlXG4gKiAgICBvdXRwdXQuIERlZmF1bHQgaXMgZmFsc2UgKG5vIGNvbG9yaW5nKS5cbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGluc3BlY3RcbiAqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMpIHtcbiAgdmFyIGN0eCA9IHtcbiAgICBzaG93SGlkZGVuOiBzaG93SGlkZGVuLFxuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0cjsgfVxuICB9O1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosICh0eXBlb2YgZGVwdGggPT09ICd1bmRlZmluZWQnID8gMiA6IGRlcHRoKSk7XG59XG5cbi8vIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaXMgYSBET00gZWxlbWVudC5cbnZhciBpc0RPTUVsZW1lbnQgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmplY3QgJiZcbiAgICAgIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICAnbm9kZVR5cGUnIGluIG9iamVjdCAmJlxuICAgICAgb2JqZWN0Lm5vZGVUeXBlID09PSAxICYmXG4gICAgICB0eXBlb2Ygb2JqZWN0Lm5vZGVOYW1lID09PSAnc3RyaW5nJztcbiAgfVxufTtcblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuaW5zcGVjdCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAodHlwZW9mIHJldCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBJZiB0aGlzIGlzIGEgRE9NIGVsZW1lbnQsIHRyeSB0byBnZXQgdGhlIG91dGVyIEhUTUwuXG4gIGlmIChpc0RPTUVsZW1lbnQodmFsdWUpKSB7XG4gICAgaWYgKCdvdXRlckhUTUwnIGluIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUub3V0ZXJIVE1MO1xuICAgICAgLy8gVGhpcyB2YWx1ZSBkb2VzIG5vdCBoYXZlIGFuIG91dGVySFRNTCBhdHRyaWJ1dGUsXG4gICAgICAvLyAgIGl0IGNvdWxkIHN0aWxsIGJlIGFuIFhNTCBlbGVtZW50XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEF0dGVtcHQgdG8gc2VyaWFsaXplIGl0XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZG9jdW1lbnQueG1sVmVyc2lvbikge1xuICAgICAgICAgIHZhciB4bWxTZXJpYWxpemVyID0gbmV3IFhNTFNlcmlhbGl6ZXIoKTtcbiAgICAgICAgICByZXR1cm4geG1sU2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZyh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRmlyZWZveCAxMS0gZG8gbm90IHN1cHBvcnQgb3V0ZXJIVE1MXG4gICAgICAgICAgLy8gICBJdCBkb2VzLCBob3dldmVyLCBzdXBwb3J0IGlubmVySFRNTFxuICAgICAgICAgIC8vICAgVXNlIHRoZSBmb2xsb3dpbmcgdG8gcmVuZGVyIHRoZSBlbGVtZW50XG4gICAgICAgICAgdmFyIG5zID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucywgJ18nKTtcblxuICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh2YWx1ZS5jbG9uZU5vZGUoZmFsc2UpKTtcbiAgICAgICAgICB2YXIgaHRtbCA9IGNvbnRhaW5lci5pbm5lckhUTUxcbiAgICAgICAgICAgIC5yZXBsYWNlKCc+PCcsICc+JyArIHZhbHVlLmlubmVySFRNTCArICc8Jyk7XG4gICAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgIHJldHVybiBodG1sO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSBhIG5vbi1uYXRpdmUgRE9NIGltcGxlbWVudGF0aW9uLFxuICAgICAgICAvLyAgIGNvbnRpbnVlIHdpdGggdGhlIG5vcm1hbCBmbG93OlxuICAgICAgICAvLyAgIHByaW50aW5nIHRoZSBlbGVtZW50IGFzIGlmIGl0IGlzIGFuIG9iamVjdC5cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciB2aXNpYmxlS2V5cyA9IGdldEVudW1lcmFibGVQcm9wZXJ0aWVzKHZhbHVlKTtcbiAgdmFyIGtleXMgPSBjdHguc2hvd0hpZGRlbiA/IGdldFByb3BlcnRpZXModmFsdWUpIDogdmlzaWJsZUtleXM7XG5cbiAgdmFyIG5hbWUsIG5hbWVTdWZmaXg7XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0LlxuICAvLyBJbiBJRSwgZXJyb3JzIGhhdmUgYSBzaW5nbGUgYHN0YWNrYCBwcm9wZXJ0eSwgb3IgaWYgdGhleSBhcmUgdmFuaWxsYSBgRXJyb3JgLFxuICAvLyBhIGBzdGFja2AgcGx1cyBgZGVzY3JpcHRpb25gIHByb3BlcnR5OyBpZ25vcmUgdGhvc2UgZm9yIGNvbnNpc3RlbmN5LlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgfHwgKGlzRXJyb3IodmFsdWUpICYmIChcbiAgICAgIChrZXlzLmxlbmd0aCA9PT0gMSAmJiBrZXlzWzBdID09PSAnc3RhY2snKSB8fFxuICAgICAgKGtleXMubGVuZ3RoID09PSAyICYmIGtleXNbMF0gPT09ICdkZXNjcmlwdGlvbicgJiYga2V5c1sxXSA9PT0gJ3N0YWNrJylcbiAgICAgKSkpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBuYW1lID0gZ2V0TmFtZSh2YWx1ZSk7XG4gICAgICBuYW1lU3VmZml4ID0gbmFtZSA/ICc6ICcgKyBuYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lU3VmZml4ICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJ1xuICAgICwgYXJyYXkgPSBmYWxzZVxuICAgICwgdHlwZWRBcnJheSA9IGZhbHNlXG4gICAgLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIGlmIChpc1R5cGVkQXJyYXkodmFsdWUpKSB7XG4gICAgdHlwZWRBcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG5hbWUgPSBnZXROYW1lKHZhbHVlKTtcbiAgICBuYW1lU3VmZml4ID0gbmFtZSA/ICc6ICcgKyBuYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG5hbWVTdWZmaXggKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSBpZiAodHlwZWRBcnJheSkge1xuICAgIHJldHVybiBmb3JtYXRUeXBlZEFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuXG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBpZiAodmFsdWUgPT09IDAgJiYgKDEvdmFsdWUpID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCctMCcsICdudW1iZXInKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuXG4gICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSh2YWx1ZS50b1N0cmluZygpLCAnc3ltYm9sJyk7XG4gIH1cbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cblxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFR5cGVkQXJyYXkodmFsdWUpIHtcbiAgdmFyIHN0ciA9ICdbICc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgIGlmIChzdHIubGVuZ3RoID49IGNvbmZpZy50cnVuY2F0ZVRocmVzaG9sZCAtIDcpIHtcbiAgICAgIHN0ciArPSAnLi4uJztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBzdHIgKz0gdmFsdWVbaV0gKyAnLCAnO1xuICB9XG4gIHN0ciArPSAnIF0nO1xuXG4gIC8vIFJlbW92aW5nIHRyYWlsaW5nIGAsIGAgaWYgdGhlIGFycmF5IHdhcyBub3QgdHJ1bmNhdGVkXG4gIGlmIChzdHIuaW5kZXhPZignLCAgXScpICE9PSAtMSkge1xuICAgIHN0ciA9IHN0ci5yZXBsYWNlKCcsICBdJywgJyBdJyk7XG4gIH1cblxuICByZXR1cm4gc3RyO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lO1xuICB2YXIgcHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpO1xuICB2YXIgc3RyO1xuXG4gIGlmIChwcm9wRGVzY3JpcHRvcikge1xuICAgIGlmIChwcm9wRGVzY3JpcHRvci5nZXQpIHtcbiAgICAgIGlmIChwcm9wRGVzY3JpcHRvci5zZXQpIHtcbiAgICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvcERlc2NyaXB0b3Iuc2V0KSB7XG4gICAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2aXNpYmxlS2V5cy5pbmRleE9mKGtleSkgPCAwKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKHZhbHVlW2tleV0pIDwgMCkge1xuICAgICAgaWYgKHJlY3Vyc2VUaW1lcyA9PT0gbnVsbCkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlW2tleV0sIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZVtrZXldLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIHJldHVybiBwcmV2ICsgY3VyLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuZnVuY3Rpb24gaXNUeXBlZEFycmF5KGFyKSB7XG4gIC8vIFVuZm9ydHVuYXRlbHkgdGhlcmUncyBubyB3YXkgdG8gY2hlY2sgaWYgYW4gb2JqZWN0IGlzIGEgVHlwZWRBcnJheVxuICAvLyBXZSBoYXZlIHRvIGNoZWNrIGlmIGl0J3Mgb25lIG9mIHRoZXNlIHR5cGVzXG4gIHJldHVybiAodHlwZW9mIGFyID09PSAnb2JqZWN0JyAmJiAvXFx3K0FycmF5XSQvLnRlc3Qob2JqZWN0VG9TdHJpbmcoYXIpKSk7XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpIHx8XG4gICAgICAgICAodHlwZW9mIGFyID09PSAnb2JqZWN0JyAmJiBvYmplY3RUb1N0cmluZyhhcikgPT09ICdbb2JqZWN0IEFycmF5XScpO1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gdHlwZW9mIHJlID09PSAnb2JqZWN0JyAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gdHlwZW9mIGQgPT09ICdvYmplY3QnICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gdHlwZW9mIGUgPT09ICdvYmplY3QnICYmIG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nO1xufVxuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iLCIvKiFcbiAqIENoYWkgLSBmbGFnIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgaW5zcGVjdCA9IHJlcXVpcmUoJy4vaW5zcGVjdCcpO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xuXG4vKipcbiAqICMjIyAub2JqRGlzcGxheShvYmplY3QpXG4gKlxuICogRGV0ZXJtaW5lcyBpZiBhbiBvYmplY3Qgb3IgYW4gYXJyYXkgbWF0Y2hlc1xuICogY3JpdGVyaWEgdG8gYmUgaW5zcGVjdGVkIGluLWxpbmUgZm9yIGVycm9yXG4gKiBtZXNzYWdlcyBvciBzaG91bGQgYmUgdHJ1bmNhdGVkLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGphdmFzY3JpcHQgb2JqZWN0IHRvIGluc3BlY3RcbiAqIEBuYW1lIG9iakRpc3BsYXlcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBvYmpEaXNwbGF5KG9iaikge1xuICB2YXIgc3RyID0gaW5zcGVjdChvYmopXG4gICAgLCB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG5cbiAgaWYgKGNvbmZpZy50cnVuY2F0ZVRocmVzaG9sZCAmJiBzdHIubGVuZ3RoID49IGNvbmZpZy50cnVuY2F0ZVRocmVzaG9sZCkge1xuICAgIGlmICh0eXBlID09PSAnW29iamVjdCBGdW5jdGlvbl0nKSB7XG4gICAgICByZXR1cm4gIW9iai5uYW1lIHx8IG9iai5uYW1lID09PSAnJ1xuICAgICAgICA/ICdbRnVuY3Rpb25dJ1xuICAgICAgICA6ICdbRnVuY3Rpb246ICcgKyBvYmoubmFtZSArICddJztcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHJldHVybiAnWyBBcnJheSgnICsgb2JqLmxlbmd0aCArICcpIF0nO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKVxuICAgICAgICAsIGtzdHIgPSBrZXlzLmxlbmd0aCA+IDJcbiAgICAgICAgICA/IGtleXMuc3BsaWNlKDAsIDIpLmpvaW4oJywgJykgKyAnLCAuLi4nXG4gICAgICAgICAgOiBrZXlzLmpvaW4oJywgJyk7XG4gICAgICByZXR1cm4gJ3sgT2JqZWN0ICgnICsga3N0ciArICcpIH0nO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gbWVzc2FnZSBjb21wb3NpdGlvbiB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIGZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKVxuICAsIGdldEFjdHVhbCA9IHJlcXVpcmUoJy4vZ2V0QWN0dWFsJylcbiAgLCBvYmpEaXNwbGF5ID0gcmVxdWlyZSgnLi9vYmpEaXNwbGF5Jyk7XG5cbi8qKlxuICogIyMjIC5nZXRNZXNzYWdlKG9iamVjdCwgbWVzc2FnZSwgbmVnYXRlTWVzc2FnZSlcbiAqXG4gKiBDb25zdHJ1Y3QgdGhlIGVycm9yIG1lc3NhZ2UgYmFzZWQgb24gZmxhZ3NcbiAqIGFuZCB0ZW1wbGF0ZSB0YWdzLiBUZW1wbGF0ZSB0YWdzIHdpbGwgcmV0dXJuXG4gKiBhIHN0cmluZ2lmaWVkIGluc3BlY3Rpb24gb2YgdGhlIG9iamVjdCByZWZlcmVuY2VkLlxuICpcbiAqIE1lc3NhZ2UgdGVtcGxhdGUgdGFnczpcbiAqIC0gYCN7dGhpc31gIGN1cnJlbnQgYXNzZXJ0ZWQgb2JqZWN0XG4gKiAtIGAje2FjdH1gIGFjdHVhbCB2YWx1ZVxuICogLSBgI3tleHB9YCBleHBlY3RlZCB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgKGNvbnN0cnVjdGVkIEFzc2VydGlvbilcbiAqIEBwYXJhbSB7QXJndW1lbnRzfSBjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUuYXNzZXJ0IGFyZ3VtZW50c1xuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgZ2V0TWVzc2FnZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldE1lc3NhZ2Uob2JqLCBhcmdzKSB7XG4gIHZhciBuZWdhdGUgPSBmbGFnKG9iaiwgJ25lZ2F0ZScpXG4gICAgLCB2YWwgPSBmbGFnKG9iaiwgJ29iamVjdCcpXG4gICAgLCBleHBlY3RlZCA9IGFyZ3NbM11cbiAgICAsIGFjdHVhbCA9IGdldEFjdHVhbChvYmosIGFyZ3MpXG4gICAgLCBtc2cgPSBuZWdhdGUgPyBhcmdzWzJdIDogYXJnc1sxXVxuICAgICwgZmxhZ01zZyA9IGZsYWcob2JqLCAnbWVzc2FnZScpO1xuXG4gIGlmKHR5cGVvZiBtc2cgPT09IFwiZnVuY3Rpb25cIikgbXNnID0gbXNnKCk7XG4gIG1zZyA9IG1zZyB8fCAnJztcbiAgbXNnID0gbXNnXG4gICAgLnJlcGxhY2UoLyNcXHt0aGlzXFx9L2csIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9iakRpc3BsYXkodmFsKTsgfSlcbiAgICAucmVwbGFjZSgvI1xce2FjdFxcfS9nLCBmdW5jdGlvbiAoKSB7IHJldHVybiBvYmpEaXNwbGF5KGFjdHVhbCk7IH0pXG4gICAgLnJlcGxhY2UoLyNcXHtleHBcXH0vZywgZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JqRGlzcGxheShleHBlY3RlZCk7IH0pO1xuXG4gIHJldHVybiBmbGFnTXNnID8gZmxhZ01zZyArICc6ICcgKyBtc2cgOiBtc2c7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gdHJhbnNmZXJGbGFncyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLnRyYW5zZmVyRmxhZ3MoYXNzZXJ0aW9uLCBvYmplY3QsIGluY2x1ZGVBbGwgPSB0cnVlKVxuICpcbiAqIFRyYW5zZmVyIGFsbCB0aGUgZmxhZ3MgZm9yIGBhc3NlcnRpb25gIHRvIGBvYmplY3RgLiBJZlxuICogYGluY2x1ZGVBbGxgIGlzIHNldCB0byBgZmFsc2VgLCB0aGVuIHRoZSBiYXNlIENoYWlcbiAqIGFzc2VydGlvbiBmbGFncyAobmFtZWx5IGBvYmplY3RgLCBgc3NmaWAsIGBsb2NrU3NmaWAsXG4gKiBhbmQgYG1lc3NhZ2VgKSB3aWxsIG5vdCBiZSB0cmFuc2ZlcnJlZC5cbiAqXG4gKlxuICogICAgIHZhciBuZXdBc3NlcnRpb24gPSBuZXcgQXNzZXJ0aW9uKCk7XG4gKiAgICAgdXRpbHMudHJhbnNmZXJGbGFncyhhc3NlcnRpb24sIG5ld0Fzc2VydGlvbik7XG4gKlxuICogICAgIHZhciBhbm90aGVyQXNzZXJ0aW9uID0gbmV3IEFzc2VydGlvbihteU9iaik7XG4gKiAgICAgdXRpbHMudHJhbnNmZXJGbGFncyhhc3NlcnRpb24sIGFub3RoZXJBc3NlcnRpb24sIGZhbHNlKTtcbiAqXG4gKiBAcGFyYW0ge0Fzc2VydGlvbn0gYXNzZXJ0aW9uIHRoZSBhc3NlcnRpb24gdG8gdHJhbnNmZXIgdGhlIGZsYWdzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdGhlIG9iamVjdCB0byB0cmFuc2ZlciB0aGUgZmxhZ3MgdG87IHVzdWFsbHkgYSBuZXcgYXNzZXJ0aW9uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluY2x1ZGVBbGxcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIHRyYW5zZmVyRmxhZ3NcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJhbnNmZXJGbGFncyhhc3NlcnRpb24sIG9iamVjdCwgaW5jbHVkZUFsbCkge1xuICB2YXIgZmxhZ3MgPSBhc3NlcnRpb24uX19mbGFncyB8fCAoYXNzZXJ0aW9uLl9fZmxhZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcblxuICBpZiAoIW9iamVjdC5fX2ZsYWdzKSB7XG4gICAgb2JqZWN0Ll9fZmxhZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG5cbiAgaW5jbHVkZUFsbCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDMgPyBpbmNsdWRlQWxsIDogdHJ1ZTtcblxuICBmb3IgKHZhciBmbGFnIGluIGZsYWdzKSB7XG4gICAgaWYgKGluY2x1ZGVBbGwgfHxcbiAgICAgICAgKGZsYWcgIT09ICdvYmplY3QnICYmIGZsYWcgIT09ICdzc2ZpJyAmJiBmbGFnICE9PSAnbG9ja1NzZmknICYmIGZsYWcgIT0gJ21lc3NhZ2UnKSkge1xuICAgICAgb2JqZWN0Ll9fZmxhZ3NbZmxhZ10gPSBmbGFnc1tmbGFnXTtcbiAgICB9XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG4vKiBnbG9iYWxzIFN5bWJvbDogZmFsc2UsIFVpbnQ4QXJyYXk6IGZhbHNlLCBXZWFrTWFwOiBmYWxzZSAqL1xuLyohXG4gKiBkZWVwLWVxbFxuICogQ29weXJpZ2h0KGMpIDIwMTMgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgdHlwZSA9IHJlcXVpcmUoJ3R5cGUtZGV0ZWN0Jyk7XG5mdW5jdGlvbiBGYWtlTWFwKCkge1xuICB0aGlzLl9rZXkgPSAnY2hhaS9kZWVwLWVxbF9fJyArIE1hdGgucmFuZG9tKCkgKyBEYXRlLm5vdygpO1xufVxuXG5GYWtlTWFwLnByb3RvdHlwZSA9IHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXRNYXAoa2V5KSB7XG4gICAgcmV0dXJuIGtleVt0aGlzLl9rZXldO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldE1hcChrZXksIHZhbHVlKSB7XG4gICAgaWYgKE9iamVjdC5pc0V4dGVuc2libGUoa2V5KSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGtleSwgdGhpcy5fa2V5LCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgfSk7XG4gICAgfVxuICB9LFxufTtcblxudmFyIE1lbW9pemVNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBGYWtlTWFwO1xuLyohXG4gKiBDaGVjayB0byBzZWUgaWYgdGhlIE1lbW9pemVNYXAgaGFzIHJlY29yZGVkIGEgcmVzdWx0IG9mIHRoZSB0d28gb3BlcmFuZHNcbiAqXG4gKiBAcGFyYW0ge01peGVkfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWl4ZWR9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWVtb2l6ZU1hcH0gbWVtb2l6ZU1hcFxuICogQHJldHVybnMge0Jvb2xlYW58bnVsbH0gcmVzdWx0XG4qL1xuZnVuY3Rpb24gbWVtb2l6ZUNvbXBhcmUobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBtZW1vaXplTWFwKSB7XG4gIC8vIFRlY2huaWNhbGx5LCBXZWFrTWFwIGtleXMgY2FuICpvbmx5KiBiZSBvYmplY3RzLCBub3QgcHJpbWl0aXZlcy5cbiAgaWYgKCFtZW1vaXplTWFwIHx8IGlzUHJpbWl0aXZlKGxlZnRIYW5kT3BlcmFuZCkgfHwgaXNQcmltaXRpdmUocmlnaHRIYW5kT3BlcmFuZCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbGVmdEhhbmRNYXAgPSBtZW1vaXplTWFwLmdldChsZWZ0SGFuZE9wZXJhbmQpO1xuICBpZiAobGVmdEhhbmRNYXApIHtcbiAgICB2YXIgcmVzdWx0ID0gbGVmdEhhbmRNYXAuZ2V0KHJpZ2h0SGFuZE9wZXJhbmQpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKiFcbiAqIFNldCB0aGUgcmVzdWx0IG9mIHRoZSBlcXVhbGl0eSBpbnRvIHRoZSBNZW1vaXplTWFwXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01peGVkfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01lbW9pemVNYXB9IG1lbW9pemVNYXBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVzdWx0XG4qL1xuZnVuY3Rpb24gbWVtb2l6ZVNldChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG1lbW9pemVNYXAsIHJlc3VsdCkge1xuICAvLyBUZWNobmljYWxseSwgV2Vha01hcCBrZXlzIGNhbiAqb25seSogYmUgb2JqZWN0cywgbm90IHByaW1pdGl2ZXMuXG4gIGlmICghbWVtb2l6ZU1hcCB8fCBpc1ByaW1pdGl2ZShsZWZ0SGFuZE9wZXJhbmQpIHx8IGlzUHJpbWl0aXZlKHJpZ2h0SGFuZE9wZXJhbmQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBsZWZ0SGFuZE1hcCA9IG1lbW9pemVNYXAuZ2V0KGxlZnRIYW5kT3BlcmFuZCk7XG4gIGlmIChsZWZ0SGFuZE1hcCkge1xuICAgIGxlZnRIYW5kTWFwLnNldChyaWdodEhhbmRPcGVyYW5kLCByZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIGxlZnRIYW5kTWFwID0gbmV3IE1lbW9pemVNYXAoKTtcbiAgICBsZWZ0SGFuZE1hcC5zZXQocmlnaHRIYW5kT3BlcmFuZCwgcmVzdWx0KTtcbiAgICBtZW1vaXplTWFwLnNldChsZWZ0SGFuZE9wZXJhbmQsIGxlZnRIYW5kTWFwKTtcbiAgfVxufVxuXG4vKiFcbiAqIFByaW1hcnkgRXhwb3J0XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZWVwRXF1YWw7XG5tb2R1bGUuZXhwb3J0cy5NZW1vaXplTWFwID0gTWVtb2l6ZU1hcDtcblxuLyoqXG4gKiBBc3NlcnQgZGVlcGx5IG5lc3RlZCBzYW1lVmFsdWUgZXF1YWxpdHkgYmV0d2VlbiB0d28gb2JqZWN0cyBvZiBhbnkgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWl4ZWR9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gKG9wdGlvbmFsKSBBZGRpdGlvbmFsIG9wdGlvbnNcbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmNvbXBhcmF0b3JdIChvcHRpb25hbCkgT3ZlcnJpZGUgZGVmYXVsdCBhbGdvcml0aG0sIGRldGVybWluaW5nIGN1c3RvbSBlcXVhbGl0eS5cbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLm1lbW9pemVdIChvcHRpb25hbCkgUHJvdmlkZSBhIGN1c3RvbSBtZW1vaXphdGlvbiBvYmplY3Qgd2hpY2ggd2lsbCBjYWNoZSB0aGUgcmVzdWx0cyBvZlxuICAgIGNvbXBsZXggb2JqZWN0cyBmb3IgYSBzcGVlZCBib29zdC4gQnkgcGFzc2luZyBgZmFsc2VgIHlvdSBjYW4gZGlzYWJsZSBtZW1vaXphdGlvbiwgYnV0IHRoaXMgd2lsbCBjYXVzZSBjaXJjdWxhclxuICAgIHJlZmVyZW5jZXMgdG8gYmxvdyB0aGUgc3RhY2suXG4gKiBAcmV0dXJuIHtCb29sZWFufSBlcXVhbCBtYXRjaFxuICovXG5mdW5jdGlvbiBkZWVwRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKSB7XG4gIC8vIElmIHdlIGhhdmUgYSBjb21wYXJhdG9yLCB3ZSBjYW4ndCBhc3N1bWUgYW55dGhpbmc7IHNvIGJhaWwgdG8gaXRzIGNoZWNrIGZpcnN0LlxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNvbXBhcmF0b3IpIHtcbiAgICByZXR1cm4gZXh0ZW5zaXZlRGVlcEVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucyk7XG4gIH1cblxuICB2YXIgc2ltcGxlUmVzdWx0ID0gc2ltcGxlRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kKTtcbiAgaWYgKHNpbXBsZVJlc3VsdCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBzaW1wbGVSZXN1bHQ7XG4gIH1cblxuICAvLyBEZWVwZXIgY29tcGFyaXNvbnMgYXJlIHB1c2hlZCB0aHJvdWdoIHRvIGEgbGFyZ2VyIGZ1bmN0aW9uXG4gIHJldHVybiBleHRlbnNpdmVEZWVwRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBNYW55IGNvbXBhcmlzb25zIGNhbiBiZSBjYW5jZWxlZCBvdXQgZWFybHkgdmlhIHNpbXBsZSBlcXVhbGl0eSBvciBwcmltaXRpdmUgY2hlY2tzLlxuICogQHBhcmFtIHtNaXhlZH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01peGVkfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcmV0dXJuIHtCb29sZWFufG51bGx9IGVxdWFsIG1hdGNoXG4gKi9cbmZ1bmN0aW9uIHNpbXBsZUVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCkge1xuICAvLyBFcXVhbCByZWZlcmVuY2VzIChleGNlcHQgZm9yIE51bWJlcnMpIGNhbiBiZSByZXR1cm5lZCBlYXJseVxuICBpZiAobGVmdEhhbmRPcGVyYW5kID09PSByaWdodEhhbmRPcGVyYW5kKSB7XG4gICAgLy8gSGFuZGxlICstMCBjYXNlc1xuICAgIHJldHVybiBsZWZ0SGFuZE9wZXJhbmQgIT09IDAgfHwgMSAvIGxlZnRIYW5kT3BlcmFuZCA9PT0gMSAvIHJpZ2h0SGFuZE9wZXJhbmQ7XG4gIH1cblxuICAvLyBoYW5kbGUgTmFOIGNhc2VzXG4gIGlmIChcbiAgICBsZWZ0SGFuZE9wZXJhbmQgIT09IGxlZnRIYW5kT3BlcmFuZCAmJiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIHJpZ2h0SGFuZE9wZXJhbmQgIT09IHJpZ2h0SGFuZE9wZXJhbmQgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBBbnl0aGluZyB0aGF0IGlzIG5vdCBhbiAnb2JqZWN0JywgaS5lLiBzeW1ib2xzLCBmdW5jdGlvbnMsIGJvb2xlYW5zLCBudW1iZXJzLFxuICAvLyBzdHJpbmdzLCBhbmQgdW5kZWZpbmVkLCBjYW4gYmUgY29tcGFyZWQgYnkgcmVmZXJlbmNlLlxuICBpZiAoaXNQcmltaXRpdmUobGVmdEhhbmRPcGVyYW5kKSB8fCBpc1ByaW1pdGl2ZShyaWdodEhhbmRPcGVyYW5kKSkge1xuICAgIC8vIEVhc3kgb3V0IGIvYyBpdCB3b3VsZCBoYXZlIHBhc3NlZCB0aGUgZmlyc3QgZXF1YWxpdHkgY2hlY2tcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qIVxuICogVGhlIG1haW4gbG9naWMgb2YgdGhlIGBkZWVwRXF1YWxgIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtNaXhlZH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAob3B0aW9uYWwpIEFkZGl0aW9uYWwgb3B0aW9uc1xuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMuY29tcGFyYXRvcl0gKG9wdGlvbmFsKSBPdmVycmlkZSBkZWZhdWx0IGFsZ29yaXRobSwgZGV0ZXJtaW5pbmcgY3VzdG9tIGVxdWFsaXR5LlxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMubWVtb2l6ZV0gKG9wdGlvbmFsKSBQcm92aWRlIGEgY3VzdG9tIG1lbW9pemF0aW9uIG9iamVjdCB3aGljaCB3aWxsIGNhY2hlIHRoZSByZXN1bHRzIG9mXG4gICAgY29tcGxleCBvYmplY3RzIGZvciBhIHNwZWVkIGJvb3N0LiBCeSBwYXNzaW5nIGBmYWxzZWAgeW91IGNhbiBkaXNhYmxlIG1lbW9pemF0aW9uLCBidXQgdGhpcyB3aWxsIGNhdXNlIGNpcmN1bGFyXG4gICAgcmVmZXJlbmNlcyB0byBibG93IHRoZSBzdGFjay5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGVxdWFsIG1hdGNoXG4qL1xuZnVuY3Rpb24gZXh0ZW5zaXZlRGVlcEVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5tZW1vaXplID0gb3B0aW9ucy5tZW1vaXplID09PSBmYWxzZSA/IGZhbHNlIDogb3B0aW9ucy5tZW1vaXplIHx8IG5ldyBNZW1vaXplTWFwKCk7XG4gIHZhciBjb21wYXJhdG9yID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvbXBhcmF0b3I7XG5cbiAgLy8gQ2hlY2sgaWYgYSBtZW1vaXplZCByZXN1bHQgZXhpc3RzLlxuICB2YXIgbWVtb2l6ZVJlc3VsdExlZnQgPSBtZW1vaXplQ29tcGFyZShsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMubWVtb2l6ZSk7XG4gIGlmIChtZW1vaXplUmVzdWx0TGVmdCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBtZW1vaXplUmVzdWx0TGVmdDtcbiAgfVxuICB2YXIgbWVtb2l6ZVJlc3VsdFJpZ2h0ID0gbWVtb2l6ZUNvbXBhcmUocmlnaHRIYW5kT3BlcmFuZCwgbGVmdEhhbmRPcGVyYW5kLCBvcHRpb25zLm1lbW9pemUpO1xuICBpZiAobWVtb2l6ZVJlc3VsdFJpZ2h0ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIG1lbW9pemVSZXN1bHRSaWdodDtcbiAgfVxuXG4gIC8vIElmIGEgY29tcGFyYXRvciBpcyBwcmVzZW50LCB1c2UgaXQuXG4gIGlmIChjb21wYXJhdG9yKSB7XG4gICAgdmFyIGNvbXBhcmF0b3JSZXN1bHQgPSBjb21wYXJhdG9yKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCk7XG4gICAgLy8gQ29tcGFyYXRvcnMgbWF5IHJldHVybiBudWxsLCBpbiB3aGljaCBjYXNlIHdlIHdhbnQgdG8gZ28gYmFjayB0byBkZWZhdWx0IGJlaGF2aW9yLlxuICAgIGlmIChjb21wYXJhdG9yUmVzdWx0ID09PSBmYWxzZSB8fCBjb21wYXJhdG9yUmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICBtZW1vaXplU2V0KGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucy5tZW1vaXplLCBjb21wYXJhdG9yUmVzdWx0KTtcbiAgICAgIHJldHVybiBjb21wYXJhdG9yUmVzdWx0O1xuICAgIH1cbiAgICAvLyBUbyBhbGxvdyBjb21wYXJhdG9ycyB0byBvdmVycmlkZSAqYW55KiBiZWhhdmlvciwgd2UgcmFuIHRoZW0gZmlyc3QuIFNpbmNlIGl0IGRpZG4ndCBkZWNpZGVcbiAgICAvLyB3aGF0IHRvIGRvLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0byByZXR1cm4gdGhlIGJhc2ljIHRlc3RzIGZpcnN0IGJlZm9yZSB3ZSBtb3ZlIG9uLlxuICAgIHZhciBzaW1wbGVSZXN1bHQgPSBzaW1wbGVFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQpO1xuICAgIGlmIChzaW1wbGVSZXN1bHQgIT09IG51bGwpIHtcbiAgICAgIC8vIERvbid0IG1lbW9pemUgdGhpcywgaXQgdGFrZXMgbG9uZ2VyIHRvIHNldC9yZXRyaWV2ZSB0aGFuIHRvIGp1c3QgY29tcGFyZS5cbiAgICAgIHJldHVybiBzaW1wbGVSZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxlZnRIYW5kVHlwZSA9IHR5cGUobGVmdEhhbmRPcGVyYW5kKTtcbiAgaWYgKGxlZnRIYW5kVHlwZSAhPT0gdHlwZShyaWdodEhhbmRPcGVyYW5kKSkge1xuICAgIG1lbW9pemVTZXQobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zLm1lbW9pemUsIGZhbHNlKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZW1wb3JhcmlseSBzZXQgdGhlIG9wZXJhbmRzIGluIHRoZSBtZW1vaXplIG9iamVjdCB0byBwcmV2ZW50IGJsb3dpbmcgdGhlIHN0YWNrXG4gIG1lbW9pemVTZXQobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zLm1lbW9pemUsIHRydWUpO1xuXG4gIHZhciByZXN1bHQgPSBleHRlbnNpdmVEZWVwRXF1YWxCeVR5cGUobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBsZWZ0SGFuZFR5cGUsIG9wdGlvbnMpO1xuICBtZW1vaXplU2V0KGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucy5tZW1vaXplLCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBleHRlbnNpdmVEZWVwRXF1YWxCeVR5cGUobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBsZWZ0SGFuZFR5cGUsIG9wdGlvbnMpIHtcbiAgc3dpdGNoIChsZWZ0SGFuZFR5cGUpIHtcbiAgICBjYXNlICdTdHJpbmcnOlxuICAgIGNhc2UgJ051bWJlcic6XG4gICAgY2FzZSAnQm9vbGVhbic6XG4gICAgY2FzZSAnRGF0ZSc6XG4gICAgICAvLyBJZiB0aGVzZSB0eXBlcyBhcmUgdGhlaXIgaW5zdGFuY2UgdHlwZXMgKGUuZy4gYG5ldyBOdW1iZXJgKSB0aGVuIHJlLWRlZXBFcXVhbCBhZ2FpbnN0IHRoZWlyIHZhbHVlc1xuICAgICAgcmV0dXJuIGRlZXBFcXVhbChsZWZ0SGFuZE9wZXJhbmQudmFsdWVPZigpLCByaWdodEhhbmRPcGVyYW5kLnZhbHVlT2YoKSk7XG4gICAgY2FzZSAnUHJvbWlzZSc6XG4gICAgY2FzZSAnU3ltYm9sJzpcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgY2FzZSAnV2Vha01hcCc6XG4gICAgY2FzZSAnV2Vha1NldCc6XG4gICAgY2FzZSAnRXJyb3InOlxuICAgICAgcmV0dXJuIGxlZnRIYW5kT3BlcmFuZCA9PT0gcmlnaHRIYW5kT3BlcmFuZDtcbiAgICBjYXNlICdBcmd1bWVudHMnOlxuICAgIGNhc2UgJ0ludDhBcnJheSc6XG4gICAgY2FzZSAnVWludDhBcnJheSc6XG4gICAgY2FzZSAnVWludDhDbGFtcGVkQXJyYXknOlxuICAgIGNhc2UgJ0ludDE2QXJyYXknOlxuICAgIGNhc2UgJ1VpbnQxNkFycmF5JzpcbiAgICBjYXNlICdJbnQzMkFycmF5JzpcbiAgICBjYXNlICdVaW50MzJBcnJheSc6XG4gICAgY2FzZSAnRmxvYXQzMkFycmF5JzpcbiAgICBjYXNlICdGbG9hdDY0QXJyYXknOlxuICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgIHJldHVybiBpdGVyYWJsZUVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucyk7XG4gICAgY2FzZSAnUmVnRXhwJzpcbiAgICAgIHJldHVybiByZWdleHBFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQpO1xuICAgIGNhc2UgJ0dlbmVyYXRvcic6XG4gICAgICByZXR1cm4gZ2VuZXJhdG9yRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKTtcbiAgICBjYXNlICdEYXRhVmlldyc6XG4gICAgICByZXR1cm4gaXRlcmFibGVFcXVhbChuZXcgVWludDhBcnJheShsZWZ0SGFuZE9wZXJhbmQuYnVmZmVyKSwgbmV3IFVpbnQ4QXJyYXkocmlnaHRIYW5kT3BlcmFuZC5idWZmZXIpLCBvcHRpb25zKTtcbiAgICBjYXNlICdBcnJheUJ1ZmZlcic6XG4gICAgICByZXR1cm4gaXRlcmFibGVFcXVhbChuZXcgVWludDhBcnJheShsZWZ0SGFuZE9wZXJhbmQpLCBuZXcgVWludDhBcnJheShyaWdodEhhbmRPcGVyYW5kKSwgb3B0aW9ucyk7XG4gICAgY2FzZSAnU2V0JzpcbiAgICAgIHJldHVybiBlbnRyaWVzRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKTtcbiAgICBjYXNlICdNYXAnOlxuICAgICAgcmV0dXJuIGVudHJpZXNFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gb2JqZWN0RXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKTtcbiAgfVxufVxuXG4vKiFcbiAqIENvbXBhcmUgdHdvIFJlZ3VsYXIgRXhwcmVzc2lvbnMgZm9yIGVxdWFsaXR5LlxuICpcbiAqIEBwYXJhbSB7UmVnRXhwfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7UmVnRXhwfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiByZWdleHBFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQpIHtcbiAgcmV0dXJuIGxlZnRIYW5kT3BlcmFuZC50b1N0cmluZygpID09PSByaWdodEhhbmRPcGVyYW5kLnRvU3RyaW5nKCk7XG59XG5cbi8qIVxuICogQ29tcGFyZSB0d28gU2V0cy9NYXBzIGZvciBlcXVhbGl0eS4gRmFzdGVyIHRoYW4gb3RoZXIgZXF1YWxpdHkgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7U2V0fSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7U2V0fSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIChPcHRpb25hbClcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIGVudHJpZXNFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpIHtcbiAgLy8gSUUxMSBkb2Vzbid0IHN1cHBvcnQgU2V0I2VudHJpZXMgb3IgU2V0I0BAaXRlcmF0b3IsIHNvIHdlIG5lZWQgbWFudWFsbHkgcG9wdWxhdGUgdXNpbmcgU2V0I2ZvckVhY2hcbiAgaWYgKGxlZnRIYW5kT3BlcmFuZC5zaXplICE9PSByaWdodEhhbmRPcGVyYW5kLnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGxlZnRIYW5kT3BlcmFuZC5zaXplID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIGxlZnRIYW5kSXRlbXMgPSBbXTtcbiAgdmFyIHJpZ2h0SGFuZEl0ZW1zID0gW107XG4gIGxlZnRIYW5kT3BlcmFuZC5mb3JFYWNoKGZ1bmN0aW9uIGdhdGhlckVudHJpZXMoa2V5LCB2YWx1ZSkge1xuICAgIGxlZnRIYW5kSXRlbXMucHVzaChbIGtleSwgdmFsdWUgXSk7XG4gIH0pO1xuICByaWdodEhhbmRPcGVyYW5kLmZvckVhY2goZnVuY3Rpb24gZ2F0aGVyRW50cmllcyhrZXksIHZhbHVlKSB7XG4gICAgcmlnaHRIYW5kSXRlbXMucHVzaChbIGtleSwgdmFsdWUgXSk7XG4gIH0pO1xuICByZXR1cm4gaXRlcmFibGVFcXVhbChsZWZ0SGFuZEl0ZW1zLnNvcnQoKSwgcmlnaHRIYW5kSXRlbXMuc29ydCgpLCBvcHRpb25zKTtcbn1cblxuLyohXG4gKiBTaW1wbGUgZXF1YWxpdHkgZm9yIGZsYXQgaXRlcmFibGUgb2JqZWN0cyBzdWNoIGFzIEFycmF5cywgVHlwZWRBcnJheXMgb3IgTm9kZS5qcyBidWZmZXJzLlxuICpcbiAqIEBwYXJhbSB7SXRlcmFibGV9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtJdGVyYWJsZX0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAoT3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBpdGVyYWJsZUVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucykge1xuICB2YXIgbGVuZ3RoID0gbGVmdEhhbmRPcGVyYW5kLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCAhPT0gcmlnaHRIYW5kT3BlcmFuZC5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBpbmRleCA9IC0xO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChkZWVwRXF1YWwobGVmdEhhbmRPcGVyYW5kW2luZGV4XSwgcmlnaHRIYW5kT3BlcmFuZFtpbmRleF0sIG9wdGlvbnMpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyohXG4gKiBTaW1wbGUgZXF1YWxpdHkgZm9yIGdlbmVyYXRvciBvYmplY3RzIHN1Y2ggYXMgdGhvc2UgcmV0dXJuZWQgYnkgZ2VuZXJhdG9yIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7SXRlcmFibGV9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gKE9wdGlvbmFsKVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gZ2VuZXJhdG9yRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKSB7XG4gIHJldHVybiBpdGVyYWJsZUVxdWFsKGdldEdlbmVyYXRvckVudHJpZXMobGVmdEhhbmRPcGVyYW5kKSwgZ2V0R2VuZXJhdG9yRW50cmllcyhyaWdodEhhbmRPcGVyYW5kKSwgb3B0aW9ucyk7XG59XG5cbi8qIVxuICogRGV0ZXJtaW5lIGlmIHRoZSBnaXZlbiBvYmplY3QgaGFzIGFuIEBAaXRlcmF0b3IgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBvYmplY3QgaGFzIGFuIEBAaXRlcmF0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGhhc0l0ZXJhdG9yRnVuY3Rpb24odGFyZ2V0KSB7XG4gIHJldHVybiB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgdGFyZ2V0W1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG59XG5cbi8qIVxuICogR2V0cyBhbGwgaXRlcmF0b3IgZW50cmllcyBmcm9tIHRoZSBnaXZlbiBPYmplY3QuIElmIHRoZSBPYmplY3QgaGFzIG5vIEBAaXRlcmF0b3IgZnVuY3Rpb24sIHJldHVybnMgYW4gZW1wdHkgYXJyYXkuXG4gKiBUaGlzIHdpbGwgY29uc3VtZSB0aGUgaXRlcmF0b3IgLSB3aGljaCBjb3VsZCBoYXZlIHNpZGUgZWZmZWN0cyBkZXBlbmRpbmcgb24gdGhlIEBAaXRlcmF0b3IgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHJldHVybnMge0FycmF5fSBhbiBhcnJheSBvZiBlbnRyaWVzIGZyb20gdGhlIEBAaXRlcmF0b3IgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JFbnRyaWVzKHRhcmdldCkge1xuICBpZiAoaGFzSXRlcmF0b3JGdW5jdGlvbih0YXJnZXQpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnZXRHZW5lcmF0b3JFbnRyaWVzKHRhcmdldFtTeW1ib2wuaXRlcmF0b3JdKCkpO1xuICAgIH0gY2F0Y2ggKGl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtdO1xufVxuXG4vKiFcbiAqIEdldHMgYWxsIGVudHJpZXMgZnJvbSBhIEdlbmVyYXRvci4gVGhpcyB3aWxsIGNvbnN1bWUgdGhlIGdlbmVyYXRvciAtIHdoaWNoIGNvdWxkIGhhdmUgc2lkZSBlZmZlY3RzLlxuICpcbiAqIEBwYXJhbSB7R2VuZXJhdG9yfSB0YXJnZXRcbiAqIEByZXR1cm5zIHtBcnJheX0gYW4gYXJyYXkgb2YgZW50cmllcyBmcm9tIHRoZSBHZW5lcmF0b3IuXG4gKi9cbmZ1bmN0aW9uIGdldEdlbmVyYXRvckVudHJpZXMoZ2VuZXJhdG9yKSB7XG4gIHZhciBnZW5lcmF0b3JSZXN1bHQgPSBnZW5lcmF0b3IubmV4dCgpO1xuICB2YXIgYWNjdW11bGF0b3IgPSBbIGdlbmVyYXRvclJlc3VsdC52YWx1ZSBdO1xuICB3aGlsZSAoZ2VuZXJhdG9yUmVzdWx0LmRvbmUgPT09IGZhbHNlKSB7XG4gICAgZ2VuZXJhdG9yUmVzdWx0ID0gZ2VuZXJhdG9yLm5leHQoKTtcbiAgICBhY2N1bXVsYXRvci5wdXNoKGdlbmVyYXRvclJlc3VsdC52YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG4vKiFcbiAqIEdldHMgYWxsIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUga2V5cyBmcm9tIGEgdGFyZ2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEByZXR1cm5zIHtBcnJheX0gYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBrZXlzIGZyb20gdGhlIHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gZ2V0RW51bWVyYWJsZUtleXModGFyZ2V0KSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiB0YXJnZXQpIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cblxuLyohXG4gKiBEZXRlcm1pbmVzIGlmIHR3byBvYmplY3RzIGhhdmUgbWF0Y2hpbmcgdmFsdWVzLCBnaXZlbiBhIHNldCBvZiBrZXlzLiBEZWZlcnMgdG8gZGVlcEVxdWFsIGZvciB0aGUgZXF1YWxpdHkgY2hlY2sgb2ZcbiAqIGVhY2gga2V5LiBJZiBhbnkgdmFsdWUgb2YgdGhlIGdpdmVuIGtleSBpcyBub3QgZXF1YWwsIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBmYWxzZSAoZWFybHkpLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtNaXhlZH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtBcnJheX0ga2V5cyBBbiBhcnJheSBvZiBrZXlzIHRvIGNvbXBhcmUgdGhlIHZhbHVlcyBvZiBsZWZ0SGFuZE9wZXJhbmQgYW5kIHJpZ2h0SGFuZE9wZXJhbmQgYWdhaW5zdFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAoT3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuZnVuY3Rpb24ga2V5c0VxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwga2V5cywgb3B0aW9ucykge1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGRlZXBFcXVhbChsZWZ0SGFuZE9wZXJhbmRba2V5c1tpXV0sIHJpZ2h0SGFuZE9wZXJhbmRba2V5c1tpXV0sIG9wdGlvbnMpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyohXG4gKiBSZWN1cnNpdmVseSBjaGVjayB0aGUgZXF1YWxpdHkgb2YgdHdvIE9iamVjdHMuIE9uY2UgYmFzaWMgc2FtZW5lc3MgaGFzIGJlZW4gZXN0YWJsaXNoZWQgaXQgd2lsbCBkZWZlciB0byBgZGVlcEVxdWFsYFxuICogZm9yIGVhY2ggZW51bWVyYWJsZSBrZXkgaW4gdGhlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWl4ZWR9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gKE9wdGlvbmFsKVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gb2JqZWN0RXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKSB7XG4gIHZhciBsZWZ0SGFuZEtleXMgPSBnZXRFbnVtZXJhYmxlS2V5cyhsZWZ0SGFuZE9wZXJhbmQpO1xuICB2YXIgcmlnaHRIYW5kS2V5cyA9IGdldEVudW1lcmFibGVLZXlzKHJpZ2h0SGFuZE9wZXJhbmQpO1xuICBpZiAobGVmdEhhbmRLZXlzLmxlbmd0aCAmJiBsZWZ0SGFuZEtleXMubGVuZ3RoID09PSByaWdodEhhbmRLZXlzLmxlbmd0aCkge1xuICAgIGxlZnRIYW5kS2V5cy5zb3J0KCk7XG4gICAgcmlnaHRIYW5kS2V5cy5zb3J0KCk7XG4gICAgaWYgKGl0ZXJhYmxlRXF1YWwobGVmdEhhbmRLZXlzLCByaWdodEhhbmRLZXlzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGtleXNFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIGxlZnRIYW5kS2V5cywgb3B0aW9ucyk7XG4gIH1cblxuICB2YXIgbGVmdEhhbmRFbnRyaWVzID0gZ2V0SXRlcmF0b3JFbnRyaWVzKGxlZnRIYW5kT3BlcmFuZCk7XG4gIHZhciByaWdodEhhbmRFbnRyaWVzID0gZ2V0SXRlcmF0b3JFbnRyaWVzKHJpZ2h0SGFuZE9wZXJhbmQpO1xuICBpZiAobGVmdEhhbmRFbnRyaWVzLmxlbmd0aCAmJiBsZWZ0SGFuZEVudHJpZXMubGVuZ3RoID09PSByaWdodEhhbmRFbnRyaWVzLmxlbmd0aCkge1xuICAgIGxlZnRIYW5kRW50cmllcy5zb3J0KCk7XG4gICAgcmlnaHRIYW5kRW50cmllcy5zb3J0KCk7XG4gICAgcmV0dXJuIGl0ZXJhYmxlRXF1YWwobGVmdEhhbmRFbnRyaWVzLCByaWdodEhhbmRFbnRyaWVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChsZWZ0SGFuZEtleXMubGVuZ3RoID09PSAwICYmXG4gICAgICBsZWZ0SGFuZEVudHJpZXMubGVuZ3RoID09PSAwICYmXG4gICAgICByaWdodEhhbmRLZXlzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgcmlnaHRIYW5kRW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyohXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGFyZ3VtZW50IGlzIGEgcHJpbWl0aXZlLlxuICpcbiAqIFRoaXMgaW50ZW50aW9uYWxseSByZXR1cm5zIHRydWUgZm9yIGFsbCBvYmplY3RzIHRoYXQgY2FuIGJlIGNvbXBhcmVkIGJ5IHJlZmVyZW5jZSxcbiAqIGluY2x1ZGluZyBmdW5jdGlvbnMgYW5kIHN5bWJvbHMuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jztcbn1cbiIsInZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKTtcblxuLyohXG4gKiBDaGFpIC0gaXNQcm94eUVuYWJsZWQgaGVscGVyXG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmlzUHJveHlFbmFibGVkKClcbiAqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY2hlY2sgaWYgQ2hhaSdzIHByb3h5IHByb3RlY3Rpb24gZmVhdHVyZSBpcyBlbmFibGVkLiBJZlxuICogcHJveGllcyBhcmUgdW5zdXBwb3J0ZWQgb3IgZGlzYWJsZWQgdmlhIHRoZSB1c2VyJ3MgQ2hhaSBjb25maWcsIHRoZW4gcmV0dXJuXG4gKiBmYWxzZS4gT3RoZXJ3aXNlLCByZXR1cm4gdHJ1ZS5cbiAqXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBpc1Byb3h5RW5hYmxlZFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNQcm94eUVuYWJsZWQoKSB7XG4gIHJldHVybiBjb25maWcudXNlUHJveHkgJiZcbiAgICB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGFkZFByb3BlcnR5IHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgY2hhaSA9IHJlcXVpcmUoJy4uLy4uL2NoYWknKTtcbnZhciBmbGFnID0gcmVxdWlyZSgnLi9mbGFnJyk7XG52YXIgaXNQcm94eUVuYWJsZWQgPSByZXF1aXJlKCcuL2lzUHJveHlFbmFibGVkJyk7XG52YXIgdHJhbnNmZXJGbGFncyA9IHJlcXVpcmUoJy4vdHJhbnNmZXJGbGFncycpO1xuXG4vKipcbiAqICMjIyAuYWRkUHJvcGVydHkoY3R4LCBuYW1lLCBnZXR0ZXIpXG4gKlxuICogQWRkcyBhIHByb3BlcnR5IHRvIHRoZSBwcm90b3R5cGUgb2YgYW4gb2JqZWN0LlxuICpcbiAqICAgICB1dGlscy5hZGRQcm9wZXJ0eShjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdmb28nLCBmdW5jdGlvbiAoKSB7XG4gKiAgICAgICB2YXIgb2JqID0gdXRpbHMuZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gKiAgICAgICBuZXcgY2hhaS5Bc3NlcnRpb24ob2JqKS50by5iZS5pbnN0YW5jZW9mKEZvbyk7XG4gKiAgICAgfSk7XG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZm9vJywgZm4pO1xuICpcbiAqIFRoZW4gY2FuIGJlIHVzZWQgYXMgYW55IG90aGVyIGFzc2VydGlvbi5cbiAqXG4gKiAgICAgZXhwZWN0KG15Rm9vKS50by5iZS5mb287XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3QgdG8gd2hpY2ggdGhlIHByb3BlcnR5IGlzIGFkZGVkXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiBwcm9wZXJ0eSB0byBhZGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlciBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBuYW1lXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBhZGRQcm9wZXJ0eVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFkZFByb3BlcnR5KGN0eCwgbmFtZSwgZ2V0dGVyKSB7XG4gIGdldHRlciA9IGdldHRlciA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKCkge30gOiBnZXR0ZXI7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwgbmFtZSxcbiAgICB7IGdldDogZnVuY3Rpb24gcHJvcGVydHlHZXR0ZXIoKSB7XG4gICAgICAgIC8vIFNldHRpbmcgdGhlIGBzc2ZpYCBmbGFnIHRvIGBwcm9wZXJ0eUdldHRlcmAgY2F1c2VzIHRoaXMgZnVuY3Rpb24gdG9cbiAgICAgICAgLy8gYmUgdGhlIHN0YXJ0aW5nIHBvaW50IGZvciByZW1vdmluZyBpbXBsZW1lbnRhdGlvbiBmcmFtZXMgZnJvbSB0aGVcbiAgICAgICAgLy8gc3RhY2sgdHJhY2Ugb2YgYSBmYWlsZWQgYXNzZXJ0aW9uLlxuICAgICAgICAvL1xuICAgICAgICAvLyBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gdXNlIHRoaXMgZnVuY3Rpb24gYXMgdGhlIHN0YXJ0aW5nIHBvaW50IGlmXG4gICAgICAgIC8vIHRoZSBgbG9ja1NzZmlgIGZsYWcgaXNuJ3Qgc2V0IGFuZCBwcm94eSBwcm90ZWN0aW9uIGlzIGRpc2FibGVkLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiB0aGUgYGxvY2tTc2ZpYCBmbGFnIGlzIHNldCwgdGhlbiBlaXRoZXIgdGhpcyBhc3NlcnRpb24gaGFzIGJlZW5cbiAgICAgICAgLy8gb3ZlcndyaXR0ZW4gYnkgYW5vdGhlciBhc3NlcnRpb24sIG9yIHRoaXMgYXNzZXJ0aW9uIGlzIGJlaW5nIGludm9rZWRcbiAgICAgICAgLy8gZnJvbSBpbnNpZGUgb2YgYW5vdGhlciBhc3NlcnRpb24uIEluIHRoZSBmaXJzdCBjYXNlLCB0aGUgYHNzZmlgIGZsYWdcbiAgICAgICAgLy8gaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgdGhlIG92ZXJ3cml0aW5nIGFzc2VydGlvbi4gSW4gdGhlIHNlY29uZFxuICAgICAgICAvLyBjYXNlLCB0aGUgYHNzZmlgIGZsYWcgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgdGhlIG91dGVyIGFzc2VydGlvbi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgcHJveHkgcHJvdGVjdGlvbiBpcyBlbmFibGVkLCB0aGVuIHRoZSBgc3NmaWAgZmxhZyBoYXMgYWxyZWFkeSBiZWVuXG4gICAgICAgIC8vIHNldCBieSB0aGUgcHJveHkgZ2V0dGVyLlxuICAgICAgICBpZiAoIWlzUHJveHlFbmFibGVkKCkgJiYgIWZsYWcodGhpcywgJ2xvY2tTc2ZpJykpIHtcbiAgICAgICAgICBmbGFnKHRoaXMsICdzc2ZpJywgcHJvcGVydHlHZXR0ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IGdldHRlci5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICB2YXIgbmV3QXNzZXJ0aW9uID0gbmV3IGNoYWkuQXNzZXJ0aW9uKCk7XG4gICAgICAgIHRyYW5zZmVyRmxhZ3ModGhpcywgbmV3QXNzZXJ0aW9uKTtcbiAgICAgICAgcmV0dXJuIG5ld0Fzc2VydGlvbjtcbiAgICAgIH1cbiAgICAsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn07XG4iLCJ2YXIgZm5MZW5ndGhEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihmdW5jdGlvbiAoKSB7fSwgJ2xlbmd0aCcpO1xuXG4vKiFcbiAqIENoYWkgLSBhZGRMZW5ndGhHdWFyZCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmFkZExlbmd0aEd1YXJkKGZuLCBhc3NlcnRpb25OYW1lLCBpc0NoYWluYWJsZSlcbiAqXG4gKiBEZWZpbmUgYGxlbmd0aGAgYXMgYSBnZXR0ZXIgb24gdGhlIGdpdmVuIHVuaW52b2tlZCBtZXRob2QgYXNzZXJ0aW9uLiBUaGVcbiAqIGdldHRlciBhY3RzIGFzIGEgZ3VhcmQgYWdhaW5zdCBjaGFpbmluZyBgbGVuZ3RoYCBkaXJlY3RseSBvZmYgb2YgYW4gdW5pbnZva2VkXG4gKiBtZXRob2QgYXNzZXJ0aW9uLCB3aGljaCBpcyBhIHByb2JsZW0gYmVjYXVzZSBpdCByZWZlcmVuY2VzIGBmdW5jdGlvbmAnc1xuICogYnVpbHQtaW4gYGxlbmd0aGAgcHJvcGVydHkgaW5zdGVhZCBvZiBDaGFpJ3MgYGxlbmd0aGAgYXNzZXJ0aW9uLiBXaGVuIHRoZVxuICogZ2V0dGVyIGNhdGNoZXMgdGhlIHVzZXIgbWFraW5nIHRoaXMgbWlzdGFrZSwgaXQgdGhyb3dzIGFuIGVycm9yIHdpdGggYVxuICogaGVscGZ1bCBtZXNzYWdlLlxuICpcbiAqIFRoZXJlIGFyZSB0d28gd2F5cyBpbiB3aGljaCB0aGlzIG1pc3Rha2UgY2FuIGJlIG1hZGUuIFRoZSBmaXJzdCB3YXkgaXMgYnlcbiAqIGNoYWluaW5nIHRoZSBgbGVuZ3RoYCBhc3NlcnRpb24gZGlyZWN0bHkgb2ZmIG9mIGFuIHVuaW52b2tlZCBjaGFpbmFibGVcbiAqIG1ldGhvZC4gSW4gdGhpcyBjYXNlLCBDaGFpIHN1Z2dlc3RzIHRoYXQgdGhlIHVzZXIgdXNlIGBsZW5ndGhPZmAgaW5zdGVhZC4gVGhlXG4gKiBzZWNvbmQgd2F5IGlzIGJ5IGNoYWluaW5nIHRoZSBgbGVuZ3RoYCBhc3NlcnRpb24gZGlyZWN0bHkgb2ZmIG9mIGFuIHVuaW52b2tlZFxuICogbm9uLWNoYWluYWJsZSBtZXRob2QuIE5vbi1jaGFpbmFibGUgbWV0aG9kcyBtdXN0IGJlIGludm9rZWQgcHJpb3IgdG9cbiAqIGNoYWluaW5nLiBJbiB0aGlzIGNhc2UsIENoYWkgc3VnZ2VzdHMgdGhhdCB0aGUgdXNlciBjb25zdWx0IHRoZSBkb2NzIGZvciB0aGVcbiAqIGdpdmVuIGFzc2VydGlvbi5cbiAqXG4gKiBJZiB0aGUgYGxlbmd0aGAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIGlzIHVuY29uZmlndXJhYmxlLCB0aGVuIHJldHVybiBgZm5gXG4gKiB3aXRob3V0IG1vZGlmaWNhdGlvbi5cbiAqXG4gKiBOb3RlIHRoYXQgaW4gRVM2LCB0aGUgZnVuY3Rpb24ncyBgbGVuZ3RoYCBwcm9wZXJ0eSBpcyBjb25maWd1cmFibGUsIHNvIG9uY2VcbiAqIHN1cHBvcnQgZm9yIGxlZ2FjeSBlbnZpcm9ubWVudHMgaXMgZHJvcHBlZCwgQ2hhaSdzIGBsZW5ndGhgIHByb3BlcnR5IGNhblxuICogcmVwbGFjZSB0aGUgYnVpbHQtaW4gZnVuY3Rpb24ncyBgbGVuZ3RoYCBwcm9wZXJ0eSwgYW5kIHRoaXMgbGVuZ3RoIGd1YXJkIHdpbGxcbiAqIG5vIGxvbmdlciBiZSBuZWNlc3NhcnkuIEluIHRoZSBtZWFuIHRpbWUsIG1haW50YWluaW5nIGNvbnNpc3RlbmN5IGFjcm9zcyBhbGxcbiAqIGVudmlyb25tZW50cyBpcyB0aGUgcHJpb3JpdHkuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7U3RyaW5nfSBhc3NlcnRpb25OYW1lXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQ2hhaW5hYmxlXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBhZGRMZW5ndGhHdWFyZFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYWRkTGVuZ3RoR3VhcmQgKGZuLCBhc3NlcnRpb25OYW1lLCBpc0NoYWluYWJsZSkge1xuICBpZiAoIWZuTGVuZ3RoRGVzYy5jb25maWd1cmFibGUpIHJldHVybiBmbjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sICdsZW5ndGgnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNDaGFpbmFibGUpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgQ2hhaSBwcm9wZXJ0eTogJyArIGFzc2VydGlvbk5hbWUgKyAnLmxlbmd0aC4gRHVlJyArXG4gICAgICAgICAgJyB0byBhIGNvbXBhdGliaWxpdHkgaXNzdWUsIFwibGVuZ3RoXCIgY2Fubm90IGRpcmVjdGx5IGZvbGxvdyBcIicgK1xuICAgICAgICAgIGFzc2VydGlvbk5hbWUgKyAnXCIuIFVzZSBcIicgKyBhc3NlcnRpb25OYW1lICsgJy5sZW5ndGhPZlwiIGluc3RlYWQuJyk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIENoYWkgcHJvcGVydHk6ICcgKyBhc3NlcnRpb25OYW1lICsgJy5sZW5ndGguIFNlZScgK1xuICAgICAgICAnIGRvY3MgZm9yIHByb3BlciB1c2FnZSBvZiBcIicgKyBhc3NlcnRpb25OYW1lICsgJ1wiLicpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGZuO1xufTtcbiIsInZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKTtcbnZhciBmbGFnID0gcmVxdWlyZSgnLi9mbGFnJyk7XG52YXIgZ2V0UHJvcGVydGllcyA9IHJlcXVpcmUoJy4vZ2V0UHJvcGVydGllcycpO1xudmFyIGlzUHJveHlFbmFibGVkID0gcmVxdWlyZSgnLi9pc1Byb3h5RW5hYmxlZCcpO1xuXG4vKiFcbiAqIENoYWkgLSBwcm94aWZ5IHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAucHJveGlmeShvYmplY3QpXG4gKlxuICogUmV0dXJuIGEgcHJveHkgb2YgZ2l2ZW4gb2JqZWN0IHRoYXQgdGhyb3dzIGFuIGVycm9yIHdoZW4gYSBub24tZXhpc3RlbnRcbiAqIHByb3BlcnR5IGlzIHJlYWQuIEJ5IGRlZmF1bHQsIHRoZSByb290IGNhdXNlIGlzIGFzc3VtZWQgdG8gYmUgYSBtaXNzcGVsbGVkXG4gKiBwcm9wZXJ0eSwgYW5kIHRodXMgYW4gYXR0ZW1wdCBpcyBtYWRlIHRvIG9mZmVyIGEgcmVhc29uYWJsZSBzdWdnZXN0aW9uIGZyb21cbiAqIHRoZSBsaXN0IG9mIGV4aXN0aW5nIHByb3BlcnRpZXMuIEhvd2V2ZXIsIGlmIGEgbm9uQ2hhaW5hYmxlTWV0aG9kTmFtZSBpc1xuICogcHJvdmlkZWQsIHRoZW4gdGhlIHJvb3QgY2F1c2UgaXMgaW5zdGVhZCBhIGZhaWx1cmUgdG8gaW52b2tlIGEgbm9uLWNoYWluYWJsZVxuICogbWV0aG9kIHByaW9yIHRvIHJlYWRpbmcgdGhlIG5vbi1leGlzdGVudCBwcm9wZXJ0eS5cbiAqXG4gKiBJZiBwcm94aWVzIGFyZSB1bnN1cHBvcnRlZCBvciBkaXNhYmxlZCB2aWEgdGhlIHVzZXIncyBDaGFpIGNvbmZpZywgdGhlblxuICogcmV0dXJuIG9iamVjdCB3aXRob3V0IG1vZGlmaWNhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30gbm9uQ2hhaW5hYmxlTWV0aG9kTmFtZVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgcHJveGlmeVxuICovXG5cbnZhciBidWlsdGlucyA9IFsnX19mbGFncycsICdfX21ldGhvZHMnLCAnX29iaicsICdhc3NlcnQnXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwcm94aWZ5KG9iaiwgbm9uQ2hhaW5hYmxlTWV0aG9kTmFtZSkge1xuICBpZiAoIWlzUHJveHlFbmFibGVkKCkpIHJldHVybiBvYmo7XG5cbiAgcmV0dXJuIG5ldyBQcm94eShvYmosIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIHByb3h5R2V0dGVyKHRhcmdldCwgcHJvcGVydHkpIHtcbiAgICAgIC8vIFRoaXMgY2hlY2sgaXMgaGVyZSBiZWNhdXNlIHdlIHNob3VsZCBub3QgdGhyb3cgZXJyb3JzIG9uIFN5bWJvbCBwcm9wZXJ0aWVzXG4gICAgICAvLyBzdWNoIGFzIGBTeW1ib2wudG9TdHJpbmdUYWdgLlxuICAgICAgLy8gVGhlIHZhbHVlcyBmb3Igd2hpY2ggYW4gZXJyb3Igc2hvdWxkIGJlIHRocm93biBjYW4gYmUgY29uZmlndXJlZCB1c2luZ1xuICAgICAgLy8gdGhlIGBjb25maWcucHJveHlFeGNsdWRlZEtleXNgIHNldHRpbmcuXG4gICAgICBpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgIGNvbmZpZy5wcm94eUV4Y2x1ZGVkS2V5cy5pbmRleE9mKHByb3BlcnR5KSA9PT0gLTEgJiZcbiAgICAgICAgICAhUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgLy8gU3BlY2lhbCBtZXNzYWdlIGZvciBpbnZhbGlkIHByb3BlcnR5IGFjY2VzcyBvZiBub24tY2hhaW5hYmxlIG1ldGhvZHMuXG4gICAgICAgIGlmIChub25DaGFpbmFibGVNZXRob2ROYW1lKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgQ2hhaSBwcm9wZXJ0eTogJyArIG5vbkNoYWluYWJsZU1ldGhvZE5hbWUgKyAnLicgK1xuICAgICAgICAgICAgcHJvcGVydHkgKyAnLiBTZWUgZG9jcyBmb3IgcHJvcGVyIHVzYWdlIG9mIFwiJyArXG4gICAgICAgICAgICBub25DaGFpbmFibGVNZXRob2ROYW1lICsgJ1wiLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIHByb3BlcnR5IGlzIHJlYXNvbmFibHkgY2xvc2UgdG8gYW4gZXhpc3RpbmcgQ2hhaSBwcm9wZXJ0eSxcbiAgICAgICAgLy8gc3VnZ2VzdCB0aGF0IHByb3BlcnR5IHRvIHRoZSB1c2VyLiBPbmx5IHN1Z2dlc3QgcHJvcGVydGllcyB3aXRoIGFcbiAgICAgICAgLy8gZGlzdGFuY2UgbGVzcyB0aGFuIDQuXG4gICAgICAgIHZhciBzdWdnZXN0aW9uID0gbnVsbDtcbiAgICAgICAgdmFyIHN1Z2dlc3Rpb25EaXN0YW5jZSA9IDQ7XG4gICAgICAgIGdldFByb3BlcnRpZXModGFyZ2V0KS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJlxuICAgICAgICAgICAgYnVpbHRpbnMuaW5kZXhPZihwcm9wKSA9PT0gLTFcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBkaXN0ID0gc3RyaW5nRGlzdGFuY2VDYXBwZWQoXG4gICAgICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICAgICAgICBwcm9wLFxuICAgICAgICAgICAgICBzdWdnZXN0aW9uRGlzdGFuY2VcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoZGlzdCA8IHN1Z2dlc3Rpb25EaXN0YW5jZSkge1xuICAgICAgICAgICAgICBzdWdnZXN0aW9uID0gcHJvcDtcbiAgICAgICAgICAgICAgc3VnZ2VzdGlvbkRpc3RhbmNlID0gZGlzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzdWdnZXN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgQ2hhaSBwcm9wZXJ0eTogJyArIHByb3BlcnR5ICtcbiAgICAgICAgICAgICcuIERpZCB5b3UgbWVhbiBcIicgKyBzdWdnZXN0aW9uICsgJ1wiPycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIENoYWkgcHJvcGVydHk6ICcgKyBwcm9wZXJ0eSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVXNlIHRoaXMgcHJveHkgZ2V0dGVyIGFzIHRoZSBzdGFydGluZyBwb2ludCBmb3IgcmVtb3ZpbmcgaW1wbGVtZW50YXRpb25cbiAgICAgIC8vIGZyYW1lcyBmcm9tIHRoZSBzdGFjayB0cmFjZSBvZiBhIGZhaWxlZCBhc3NlcnRpb24uIEZvciBwcm9wZXJ0eVxuICAgICAgLy8gYXNzZXJ0aW9ucywgdGhpcyBwcmV2ZW50cyB0aGUgcHJveHkgZ2V0dGVyIGZyb20gc2hvd2luZyB1cCBpbiB0aGUgc3RhY2tcbiAgICAgIC8vIHRyYWNlIHNpbmNlIGl0J3MgaW52b2tlZCBiZWZvcmUgdGhlIHByb3BlcnR5IGdldHRlci4gRm9yIG1ldGhvZCBhbmRcbiAgICAgIC8vIGNoYWluYWJsZSBtZXRob2QgYXNzZXJ0aW9ucywgdGhpcyBmbGFnIHdpbGwgZW5kIHVwIGdldHRpbmcgY2hhbmdlZCB0b1xuICAgICAgLy8gdGhlIG1ldGhvZCB3cmFwcGVyLCB3aGljaCBpcyBnb29kIHNpbmNlIHRoaXMgZnJhbWUgd2lsbCBubyBsb25nZXIgYmUgaW5cbiAgICAgIC8vIHRoZSBzdGFjayBvbmNlIHRoZSBtZXRob2QgaXMgaW52b2tlZC4gTm90ZSB0aGF0IENoYWkgYnVpbHRpbiBhc3NlcnRpb25cbiAgICAgIC8vIHByb3BlcnRpZXMgc3VjaCBhcyBgX19mbGFnc2AgYXJlIHNraXBwZWQgc2luY2UgdGhpcyBpcyBvbmx5IG1lYW50IHRvXG4gICAgICAvLyBjYXB0dXJlIHRoZSBzdGFydGluZyBwb2ludCBvZiBhbiBhc3NlcnRpb24uIFRoaXMgc3RlcCBpcyBhbHNvIHNraXBwZWRcbiAgICAgIC8vIGlmIHRoZSBgbG9ja1NzZmlgIGZsYWcgaXMgc2V0LCB0aHVzIGluZGljYXRpbmcgdGhhdCB0aGlzIGFzc2VydGlvbiBpc1xuICAgICAgLy8gYmVpbmcgY2FsbGVkIGZyb20gd2l0aGluIGFub3RoZXIgYXNzZXJ0aW9uLiBJbiB0aGF0IGNhc2UsIHRoZSBgc3NmaWBcbiAgICAgIC8vIGZsYWcgaXMgYWxyZWFkeSBzZXQgdG8gdGhlIG91dGVyIGFzc2VydGlvbidzIHN0YXJ0aW5nIHBvaW50LlxuICAgICAgaWYgKGJ1aWx0aW5zLmluZGV4T2YocHJvcGVydHkpID09PSAtMSAmJiAhZmxhZyh0YXJnZXQsICdsb2NrU3NmaScpKSB7XG4gICAgICAgIGZsYWcodGFyZ2V0LCAnc3NmaScsIHByb3h5R2V0dGVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcGVydHkpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqICMgc3RyaW5nRGlzdGFuY2VDYXBwZWQoc3RyQSwgc3RyQiwgY2FwKVxuICogUmV0dXJuIHRoZSBMZXZlbnNodGVpbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byBzdHJpbmdzLCBidXQgbm8gbW9yZSB0aGFuIGNhcC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJBXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyQlxuICogQHBhcmFtIHtudW1iZXJ9IG51bWJlclxuICogQHJldHVybiB7bnVtYmVyfSBtaW4oc3RyaW5nIGRpc3RhbmNlIGJldHdlZW4gc3RyQSBhbmQgc3RyQiwgY2FwKVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc3RyaW5nRGlzdGFuY2VDYXBwZWQoc3RyQSwgc3RyQiwgY2FwKSB7XG4gIGlmIChNYXRoLmFicyhzdHJBLmxlbmd0aCAtIHN0ckIubGVuZ3RoKSA+PSBjYXApIHtcbiAgICByZXR1cm4gY2FwO1xuICB9XG5cbiAgdmFyIG1lbW8gPSBbXTtcbiAgLy8gYG1lbW9gIGlzIGEgdHdvLWRpbWVuc2lvbmFsIGFycmF5IGNvbnRhaW5pbmcgZGlzdGFuY2VzLlxuICAvLyBtZW1vW2ldW2pdIGlzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHN0ckEuc2xpY2UoMCwgaSkgYW5kXG4gIC8vIHN0ckIuc2xpY2UoMCwgaikuXG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IHN0ckEubGVuZ3RoOyBpKyspIHtcbiAgICBtZW1vW2ldID0gQXJyYXkoc3RyQi5sZW5ndGggKyAxKS5maWxsKDApO1xuICAgIG1lbW9baV1bMF0gPSBpO1xuICB9XG4gIGZvciAodmFyIGogPSAwOyBqIDwgc3RyQi5sZW5ndGg7IGorKykge1xuICAgIG1lbW9bMF1bal0gPSBqO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gc3RyQS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaCA9IHN0ckEuY2hhckNvZGVBdChpIC0gMSk7XG4gICAgZm9yICh2YXIgaiA9IDE7IGogPD0gc3RyQi5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKE1hdGguYWJzKGkgLSBqKSA+PSBjYXApIHtcbiAgICAgICAgbWVtb1tpXVtqXSA9IGNhcDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBtZW1vW2ldW2pdID0gTWF0aC5taW4oXG4gICAgICAgIG1lbW9baSAtIDFdW2pdICsgMSxcbiAgICAgICAgbWVtb1tpXVtqIC0gMV0gKyAxLFxuICAgICAgICBtZW1vW2kgLSAxXVtqIC0gMV0gK1xuICAgICAgICAgIChjaCA9PT0gc3RyQi5jaGFyQ29kZUF0KGogLSAxKSA/IDAgOiAxKVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWVtb1tzdHJBLmxlbmd0aF1bc3RyQi5sZW5ndGhdO1xufVxuIiwiLyohXG4gKiBDaGFpIC0gYWRkTWV0aG9kIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgYWRkTGVuZ3RoR3VhcmQgPSByZXF1aXJlKCcuL2FkZExlbmd0aEd1YXJkJyk7XG52YXIgY2hhaSA9IHJlcXVpcmUoJy4uLy4uL2NoYWknKTtcbnZhciBmbGFnID0gcmVxdWlyZSgnLi9mbGFnJyk7XG52YXIgcHJveGlmeSA9IHJlcXVpcmUoJy4vcHJveGlmeScpO1xudmFyIHRyYW5zZmVyRmxhZ3MgPSByZXF1aXJlKCcuL3RyYW5zZmVyRmxhZ3MnKTtcblxuLyoqXG4gKiAjIyMgLmFkZE1ldGhvZChjdHgsIG5hbWUsIG1ldGhvZClcbiAqXG4gKiBBZGRzIGEgbWV0aG9kIHRvIHRoZSBwcm90b3R5cGUgb2YgYW4gb2JqZWN0LlxuICpcbiAqICAgICB1dGlscy5hZGRNZXRob2QoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCAnZm9vJywgZnVuY3Rpb24gKHN0cikge1xuICogICAgICAgdmFyIG9iaiA9IHV0aWxzLmZsYWcodGhpcywgJ29iamVjdCcpO1xuICogICAgICAgbmV3IGNoYWkuQXNzZXJ0aW9uKG9iaikudG8uYmUuZXF1YWwoc3RyKTtcbiAqICAgICB9KTtcbiAqXG4gKiBDYW4gYWxzbyBiZSBhY2Nlc3NlZCBkaXJlY3RseSBmcm9tIGBjaGFpLkFzc2VydGlvbmAuXG4gKlxuICogICAgIGNoYWkuQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZm9vJywgZm4pO1xuICpcbiAqIFRoZW4gY2FuIGJlIHVzZWQgYXMgYW55IG90aGVyIGFzc2VydGlvbi5cbiAqXG4gKiAgICAgZXhwZWN0KGZvb1N0cikudG8uYmUuZm9vKCdiYXInKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IG9iamVjdCB0byB3aGljaCB0aGUgbWV0aG9kIGlzIGFkZGVkXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiBtZXRob2QgdG8gYWRkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2QgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgbmFtZVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgYWRkTWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYWRkTWV0aG9kKGN0eCwgbmFtZSwgbWV0aG9kKSB7XG4gIHZhciBtZXRob2RXcmFwcGVyID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFNldHRpbmcgdGhlIGBzc2ZpYCBmbGFnIHRvIGBtZXRob2RXcmFwcGVyYCBjYXVzZXMgdGhpcyBmdW5jdGlvbiB0byBiZSB0aGVcbiAgICAvLyBzdGFydGluZyBwb2ludCBmb3IgcmVtb3ZpbmcgaW1wbGVtZW50YXRpb24gZnJhbWVzIGZyb20gdGhlIHN0YWNrIHRyYWNlIG9mXG4gICAgLy8gYSBmYWlsZWQgYXNzZXJ0aW9uLlxuICAgIC8vXG4gICAgLy8gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIHVzZSB0aGlzIGZ1bmN0aW9uIGFzIHRoZSBzdGFydGluZyBwb2ludCBpZiB0aGVcbiAgICAvLyBgbG9ja1NzZmlgIGZsYWcgaXNuJ3Qgc2V0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlIGBsb2NrU3NmaWAgZmxhZyBpcyBzZXQsIHRoZW4gZWl0aGVyIHRoaXMgYXNzZXJ0aW9uIGhhcyBiZWVuXG4gICAgLy8gb3ZlcndyaXR0ZW4gYnkgYW5vdGhlciBhc3NlcnRpb24sIG9yIHRoaXMgYXNzZXJ0aW9uIGlzIGJlaW5nIGludm9rZWQgZnJvbVxuICAgIC8vIGluc2lkZSBvZiBhbm90aGVyIGFzc2VydGlvbi4gSW4gdGhlIGZpcnN0IGNhc2UsIHRoZSBgc3NmaWAgZmxhZyBoYXNcbiAgICAvLyBhbHJlYWR5IGJlZW4gc2V0IGJ5IHRoZSBvdmVyd3JpdGluZyBhc3NlcnRpb24uIEluIHRoZSBzZWNvbmQgY2FzZSwgdGhlXG4gICAgLy8gYHNzZmlgIGZsYWcgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgdGhlIG91dGVyIGFzc2VydGlvbi5cbiAgICBpZiAoIWZsYWcodGhpcywgJ2xvY2tTc2ZpJykpIHtcbiAgICAgIGZsYWcodGhpcywgJ3NzZmknLCBtZXRob2RXcmFwcGVyKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIHZhciBuZXdBc3NlcnRpb24gPSBuZXcgY2hhaS5Bc3NlcnRpb24oKTtcbiAgICB0cmFuc2ZlckZsYWdzKHRoaXMsIG5ld0Fzc2VydGlvbik7XG4gICAgcmV0dXJuIG5ld0Fzc2VydGlvbjtcbiAgfTtcblxuICBhZGRMZW5ndGhHdWFyZChtZXRob2RXcmFwcGVyLCBuYW1lLCBmYWxzZSk7XG4gIGN0eFtuYW1lXSA9IHByb3hpZnkobWV0aG9kV3JhcHBlciwgbmFtZSk7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gb3ZlcndyaXRlUHJvcGVydHkgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbnZhciBjaGFpID0gcmVxdWlyZSgnLi4vLi4vY2hhaScpO1xudmFyIGZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKTtcbnZhciBpc1Byb3h5RW5hYmxlZCA9IHJlcXVpcmUoJy4vaXNQcm94eUVuYWJsZWQnKTtcbnZhciB0cmFuc2ZlckZsYWdzID0gcmVxdWlyZSgnLi90cmFuc2ZlckZsYWdzJyk7XG5cbi8qKlxuICogIyMjIC5vdmVyd3JpdGVQcm9wZXJ0eShjdHgsIG5hbWUsIGZuKVxuICpcbiAqIE92ZXJ3cml0ZXMgYW4gYWxyZWFkeSBleGlzdGluZyBwcm9wZXJ0eSBnZXR0ZXIgYW5kIHByb3ZpZGVzXG4gKiBhY2Nlc3MgdG8gcHJldmlvdXMgdmFsdWUuIE11c3QgcmV0dXJuIGZ1bmN0aW9uIHRvIHVzZSBhcyBnZXR0ZXIuXG4gKlxuICogICAgIHV0aWxzLm92ZXJ3cml0ZVByb3BlcnR5KGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgJ29rJywgZnVuY3Rpb24gKF9zdXBlcikge1xuICogICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgdmFyIG9iaiA9IHV0aWxzLmZsYWcodGhpcywgJ29iamVjdCcpO1xuICogICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgRm9vKSB7XG4gKiAgICAgICAgICAgbmV3IGNoYWkuQXNzZXJ0aW9uKG9iai5uYW1lKS50by5lcXVhbCgnYmFyJyk7XG4gKiAgICAgICAgIH0gZWxzZSB7XG4gKiAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gKiAgICAgICAgIH1cbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5vdmVyd3JpdGVQcm9wZXJ0eSgnZm9vJywgZm4pO1xuICpcbiAqIFRoZW4gY2FuIGJlIHVzZWQgYXMgYW55IG90aGVyIGFzc2VydGlvbi5cbiAqXG4gKiAgICAgZXhwZWN0KG15Rm9vKS50by5iZS5vaztcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IG9iamVjdCB3aG9zZSBwcm9wZXJ0eSBpcyB0byBiZSBvdmVyd3JpdHRlblxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgcHJvcGVydHkgdG8gb3ZlcndyaXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZ2V0dGVyIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIG5hbWVcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIG92ZXJ3cml0ZVByb3BlcnR5XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gb3ZlcndyaXRlUHJvcGVydHkoY3R4LCBuYW1lLCBnZXR0ZXIpIHtcbiAgdmFyIF9nZXQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGN0eCwgbmFtZSlcbiAgICAsIF9zdXBlciA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIGlmIChfZ2V0ICYmICdmdW5jdGlvbicgPT09IHR5cGVvZiBfZ2V0LmdldClcbiAgICBfc3VwZXIgPSBfZ2V0LmdldFxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIG5hbWUsXG4gICAgeyBnZXQ6IGZ1bmN0aW9uIG92ZXJ3cml0aW5nUHJvcGVydHlHZXR0ZXIoKSB7XG4gICAgICAgIC8vIFNldHRpbmcgdGhlIGBzc2ZpYCBmbGFnIHRvIGBvdmVyd3JpdGluZ1Byb3BlcnR5R2V0dGVyYCBjYXVzZXMgdGhpc1xuICAgICAgICAvLyBmdW5jdGlvbiB0byBiZSB0aGUgc3RhcnRpbmcgcG9pbnQgZm9yIHJlbW92aW5nIGltcGxlbWVudGF0aW9uIGZyYW1lc1xuICAgICAgICAvLyBmcm9tIHRoZSBzdGFjayB0cmFjZSBvZiBhIGZhaWxlZCBhc3NlcnRpb24uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byB1c2UgdGhpcyBmdW5jdGlvbiBhcyB0aGUgc3RhcnRpbmcgcG9pbnQgaWZcbiAgICAgICAgLy8gdGhlIGBsb2NrU3NmaWAgZmxhZyBpc24ndCBzZXQgYW5kIHByb3h5IHByb3RlY3Rpb24gaXMgZGlzYWJsZWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIHRoZSBgbG9ja1NzZmlgIGZsYWcgaXMgc2V0LCB0aGVuIGVpdGhlciB0aGlzIGFzc2VydGlvbiBoYXMgYmVlblxuICAgICAgICAvLyBvdmVyd3JpdHRlbiBieSBhbm90aGVyIGFzc2VydGlvbiwgb3IgdGhpcyBhc3NlcnRpb24gaXMgYmVpbmcgaW52b2tlZFxuICAgICAgICAvLyBmcm9tIGluc2lkZSBvZiBhbm90aGVyIGFzc2VydGlvbi4gSW4gdGhlIGZpcnN0IGNhc2UsIHRoZSBgc3NmaWAgZmxhZ1xuICAgICAgICAvLyBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSB0aGUgb3ZlcndyaXRpbmcgYXNzZXJ0aW9uLiBJbiB0aGUgc2Vjb25kXG4gICAgICAgIC8vIGNhc2UsIHRoZSBgc3NmaWAgZmxhZyBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSB0aGUgb3V0ZXIgYXNzZXJ0aW9uLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiBwcm94eSBwcm90ZWN0aW9uIGlzIGVuYWJsZWQsIHRoZW4gdGhlIGBzc2ZpYCBmbGFnIGhhcyBhbHJlYWR5IGJlZW5cbiAgICAgICAgLy8gc2V0IGJ5IHRoZSBwcm94eSBnZXR0ZXIuXG4gICAgICAgIGlmICghaXNQcm94eUVuYWJsZWQoKSAmJiAhZmxhZyh0aGlzLCAnbG9ja1NzZmknKSkge1xuICAgICAgICAgIGZsYWcodGhpcywgJ3NzZmknLCBvdmVyd3JpdGluZ1Byb3BlcnR5R2V0dGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldHRpbmcgdGhlIGBsb2NrU3NmaWAgZmxhZyB0byBgdHJ1ZWAgcHJldmVudHMgdGhlIG92ZXJ3cml0dGVuXG4gICAgICAgIC8vIGFzc2VydGlvbiBmcm9tIGNoYW5naW5nIHRoZSBgc3NmaWAgZmxhZy4gQnkgdGhpcyBwb2ludCwgdGhlIGBzc2ZpYFxuICAgICAgICAvLyBmbGFnIGlzIGFscmVhZHkgc2V0IHRvIHRoZSBjb3JyZWN0IHN0YXJ0aW5nIHBvaW50IGZvciB0aGlzIGFzc2VydGlvbi5cbiAgICAgICAgdmFyIG9yaWdMb2NrU3NmaSA9IGZsYWcodGhpcywgJ2xvY2tTc2ZpJyk7XG4gICAgICAgIGZsYWcodGhpcywgJ2xvY2tTc2ZpJywgdHJ1ZSk7XG4gICAgICAgIHZhciByZXN1bHQgPSBnZXR0ZXIoX3N1cGVyKS5jYWxsKHRoaXMpO1xuICAgICAgICBmbGFnKHRoaXMsICdsb2NrU3NmaScsIG9yaWdMb2NrU3NmaSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdBc3NlcnRpb24gPSBuZXcgY2hhaS5Bc3NlcnRpb24oKTtcbiAgICAgICAgdHJhbnNmZXJGbGFncyh0aGlzLCBuZXdBc3NlcnRpb24pO1xuICAgICAgICByZXR1cm4gbmV3QXNzZXJ0aW9uO1xuICAgICAgfVxuICAgICwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIG92ZXJ3cml0ZU1ldGhvZCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxudmFyIGFkZExlbmd0aEd1YXJkID0gcmVxdWlyZSgnLi9hZGRMZW5ndGhHdWFyZCcpO1xudmFyIGNoYWkgPSByZXF1aXJlKCcuLi8uLi9jaGFpJyk7XG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xudmFyIHByb3hpZnkgPSByZXF1aXJlKCcuL3Byb3hpZnknKTtcbnZhciB0cmFuc2ZlckZsYWdzID0gcmVxdWlyZSgnLi90cmFuc2ZlckZsYWdzJyk7XG5cbi8qKlxuICogIyMjIC5vdmVyd3JpdGVNZXRob2QoY3R4LCBuYW1lLCBmbilcbiAqXG4gKiBPdmVyd3JpdGVzIGFuIGFscmVhZHkgZXhpc3RpbmcgbWV0aG9kIGFuZCBwcm92aWRlc1xuICogYWNjZXNzIHRvIHByZXZpb3VzIGZ1bmN0aW9uLiBNdXN0IHJldHVybiBmdW5jdGlvblxuICogdG8gYmUgdXNlZCBmb3IgbmFtZS5cbiAqXG4gKiAgICAgdXRpbHMub3ZlcndyaXRlTWV0aG9kKGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgJ2VxdWFsJywgZnVuY3Rpb24gKF9zdXBlcikge1xuICogICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdHIpIHtcbiAqICAgICAgICAgdmFyIG9iaiA9IHV0aWxzLmZsYWcodGhpcywgJ29iamVjdCcpO1xuICogICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgRm9vKSB7XG4gKiAgICAgICAgICAgbmV3IGNoYWkuQXNzZXJ0aW9uKG9iai52YWx1ZSkudG8uZXF1YWwoc3RyKTtcbiAqICAgICAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAqICAgICAgICAgfVxuICogICAgICAgfVxuICogICAgIH0pO1xuICpcbiAqIENhbiBhbHNvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gYGNoYWkuQXNzZXJ0aW9uYC5cbiAqXG4gKiAgICAgY2hhaS5Bc3NlcnRpb24ub3ZlcndyaXRlTWV0aG9kKCdmb28nLCBmbik7XG4gKlxuICogVGhlbiBjYW4gYmUgdXNlZCBhcyBhbnkgb3RoZXIgYXNzZXJ0aW9uLlxuICpcbiAqICAgICBleHBlY3QobXlGb28pLnRvLmVxdWFsKCdiYXInKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IG9iamVjdCB3aG9zZSBtZXRob2QgaXMgdG8gYmUgb3ZlcndyaXR0ZW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIG1ldGhvZCB0byBvdmVyd3JpdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBuYW1lXG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBvdmVyd3JpdGVNZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBvdmVyd3JpdGVNZXRob2QoY3R4LCBuYW1lLCBtZXRob2QpIHtcbiAgdmFyIF9tZXRob2QgPSBjdHhbbmFtZV1cbiAgICAsIF9zdXBlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihuYW1lICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgIH07XG5cbiAgaWYgKF9tZXRob2QgJiYgJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIF9tZXRob2QpXG4gICAgX3N1cGVyID0gX21ldGhvZDtcblxuICB2YXIgb3ZlcndyaXRpbmdNZXRob2RXcmFwcGVyID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFNldHRpbmcgdGhlIGBzc2ZpYCBmbGFnIHRvIGBvdmVyd3JpdGluZ01ldGhvZFdyYXBwZXJgIGNhdXNlcyB0aGlzXG4gICAgLy8gZnVuY3Rpb24gdG8gYmUgdGhlIHN0YXJ0aW5nIHBvaW50IGZvciByZW1vdmluZyBpbXBsZW1lbnRhdGlvbiBmcmFtZXMgZnJvbVxuICAgIC8vIHRoZSBzdGFjayB0cmFjZSBvZiBhIGZhaWxlZCBhc3NlcnRpb24uXG4gICAgLy9cbiAgICAvLyBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gdXNlIHRoaXMgZnVuY3Rpb24gYXMgdGhlIHN0YXJ0aW5nIHBvaW50IGlmIHRoZVxuICAgIC8vIGBsb2NrU3NmaWAgZmxhZyBpc24ndCBzZXQuXG4gICAgLy9cbiAgICAvLyBJZiB0aGUgYGxvY2tTc2ZpYCBmbGFnIGlzIHNldCwgdGhlbiBlaXRoZXIgdGhpcyBhc3NlcnRpb24gaGFzIGJlZW5cbiAgICAvLyBvdmVyd3JpdHRlbiBieSBhbm90aGVyIGFzc2VydGlvbiwgb3IgdGhpcyBhc3NlcnRpb24gaXMgYmVpbmcgaW52b2tlZCBmcm9tXG4gICAgLy8gaW5zaWRlIG9mIGFub3RoZXIgYXNzZXJ0aW9uLiBJbiB0aGUgZmlyc3QgY2FzZSwgdGhlIGBzc2ZpYCBmbGFnIGhhc1xuICAgIC8vIGFscmVhZHkgYmVlbiBzZXQgYnkgdGhlIG92ZXJ3cml0aW5nIGFzc2VydGlvbi4gSW4gdGhlIHNlY29uZCBjYXNlLCB0aGVcbiAgICAvLyBgc3NmaWAgZmxhZyBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSB0aGUgb3V0ZXIgYXNzZXJ0aW9uLlxuICAgIGlmICghZmxhZyh0aGlzLCAnbG9ja1NzZmknKSkge1xuICAgICAgZmxhZyh0aGlzLCAnc3NmaScsIG92ZXJ3cml0aW5nTWV0aG9kV3JhcHBlcik7XG4gICAgfVxuXG4gICAgLy8gU2V0dGluZyB0aGUgYGxvY2tTc2ZpYCBmbGFnIHRvIGB0cnVlYCBwcmV2ZW50cyB0aGUgb3ZlcndyaXR0ZW4gYXNzZXJ0aW9uXG4gICAgLy8gZnJvbSBjaGFuZ2luZyB0aGUgYHNzZmlgIGZsYWcuIEJ5IHRoaXMgcG9pbnQsIHRoZSBgc3NmaWAgZmxhZyBpcyBhbHJlYWR5XG4gICAgLy8gc2V0IHRvIHRoZSBjb3JyZWN0IHN0YXJ0aW5nIHBvaW50IGZvciB0aGlzIGFzc2VydGlvbi5cbiAgICB2YXIgb3JpZ0xvY2tTc2ZpID0gZmxhZyh0aGlzLCAnbG9ja1NzZmknKTtcbiAgICBmbGFnKHRoaXMsICdsb2NrU3NmaScsIHRydWUpO1xuICAgIHZhciByZXN1bHQgPSBtZXRob2QoX3N1cGVyKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGZsYWcodGhpcywgJ2xvY2tTc2ZpJywgb3JpZ0xvY2tTc2ZpKTtcblxuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICB2YXIgbmV3QXNzZXJ0aW9uID0gbmV3IGNoYWkuQXNzZXJ0aW9uKCk7XG4gICAgdHJhbnNmZXJGbGFncyh0aGlzLCBuZXdBc3NlcnRpb24pO1xuICAgIHJldHVybiBuZXdBc3NlcnRpb247XG4gIH1cblxuICBhZGRMZW5ndGhHdWFyZChvdmVyd3JpdGluZ01ldGhvZFdyYXBwZXIsIG5hbWUsIGZhbHNlKTtcbiAgY3R4W25hbWVdID0gcHJveGlmeShvdmVyd3JpdGluZ01ldGhvZFdyYXBwZXIsIG5hbWUpO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGFkZENoYWluaW5nTWV0aG9kIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgYWRkTGVuZ3RoR3VhcmQgPSByZXF1aXJlKCcuL2FkZExlbmd0aEd1YXJkJyk7XG52YXIgY2hhaSA9IHJlcXVpcmUoJy4uLy4uL2NoYWknKTtcbnZhciBmbGFnID0gcmVxdWlyZSgnLi9mbGFnJyk7XG52YXIgcHJveGlmeSA9IHJlcXVpcmUoJy4vcHJveGlmeScpO1xudmFyIHRyYW5zZmVyRmxhZ3MgPSByZXF1aXJlKCcuL3RyYW5zZmVyRmxhZ3MnKTtcblxuLyohXG4gKiBNb2R1bGUgdmFyaWFibGVzXG4gKi9cblxuLy8gQ2hlY2sgd2hldGhlciBgT2JqZWN0LnNldFByb3RvdHlwZU9mYCBpcyBzdXBwb3J0ZWRcbnZhciBjYW5TZXRQcm90b3R5cGUgPSB0eXBlb2YgT2JqZWN0LnNldFByb3RvdHlwZU9mID09PSAnZnVuY3Rpb24nO1xuXG4vLyBXaXRob3V0IGBPYmplY3Quc2V0UHJvdG90eXBlT2ZgIHN1cHBvcnQsIHRoaXMgbW9kdWxlIHdpbGwgbmVlZCB0byBhZGQgcHJvcGVydGllcyB0byBhIGZ1bmN0aW9uLlxuLy8gSG93ZXZlciwgc29tZSBvZiBmdW5jdGlvbnMnIG93biBwcm9wcyBhcmUgbm90IGNvbmZpZ3VyYWJsZSBhbmQgc2hvdWxkIGJlIHNraXBwZWQuXG52YXIgdGVzdEZuID0gZnVuY3Rpb24oKSB7fTtcbnZhciBleGNsdWRlTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0Rm4pLmZpbHRlcihmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBwcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGVzdEZuLCBuYW1lKTtcblxuICAvLyBOb3RlOiBQaGFudG9tSlMgMS54IGluY2x1ZGVzIGBjYWxsZWVgIGFzIG9uZSBvZiBgdGVzdEZuYCdzIG93biBwcm9wZXJ0aWVzLFxuICAvLyBidXQgdGhlbiByZXR1cm5zIGB1bmRlZmluZWRgIGFzIHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciBgY2FsbGVlYC4gQXMgYVxuICAvLyB3b3JrYXJvdW5kLCB3ZSBwZXJmb3JtIGFuIG90aGVyd2lzZSB1bm5lY2Vzc2FyeSB0eXBlLWNoZWNrIGZvciBgcHJvcERlc2NgLFxuICAvLyBhbmQgdGhlbiBmaWx0ZXIgaXQgb3V0IGlmIGl0J3Mgbm90IGFuIG9iamVjdCBhcyBpdCBzaG91bGQgYmUuXG4gIGlmICh0eXBlb2YgcHJvcERlc2MgIT09ICdvYmplY3QnKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIHJldHVybiAhcHJvcERlc2MuY29uZmlndXJhYmxlO1xufSk7XG5cbi8vIENhY2hlIGBGdW5jdGlvbmAgcHJvcGVydGllc1xudmFyIGNhbGwgID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwsXG4gICAgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8qKlxuICogIyMjIC5hZGRDaGFpbmFibGVNZXRob2QoY3R4LCBuYW1lLCBtZXRob2QsIGNoYWluaW5nQmVoYXZpb3IpXG4gKlxuICogQWRkcyBhIG1ldGhvZCB0byBhbiBvYmplY3QsIHN1Y2ggdGhhdCB0aGUgbWV0aG9kIGNhbiBhbHNvIGJlIGNoYWluZWQuXG4gKlxuICogICAgIHV0aWxzLmFkZENoYWluYWJsZU1ldGhvZChjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdmb28nLCBmdW5jdGlvbiAoc3RyKSB7XG4gKiAgICAgICB2YXIgb2JqID0gdXRpbHMuZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gKiAgICAgICBuZXcgY2hhaS5Bc3NlcnRpb24ob2JqKS50by5iZS5lcXVhbChzdHIpO1xuICogICAgIH0pO1xuICpcbiAqIENhbiBhbHNvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gYGNoYWkuQXNzZXJ0aW9uYC5cbiAqXG4gKiAgICAgY2hhaS5Bc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdmb28nLCBmbiwgY2hhaW5pbmdCZWhhdmlvcik7XG4gKlxuICogVGhlIHJlc3VsdCBjYW4gdGhlbiBiZSB1c2VkIGFzIGJvdGggYSBtZXRob2QgYXNzZXJ0aW9uLCBleGVjdXRpbmcgYm90aCBgbWV0aG9kYCBhbmRcbiAqIGBjaGFpbmluZ0JlaGF2aW9yYCwgb3IgYXMgYSBsYW5ndWFnZSBjaGFpbiwgd2hpY2ggb25seSBleGVjdXRlcyBgY2hhaW5pbmdCZWhhdmlvcmAuXG4gKlxuICogICAgIGV4cGVjdChmb29TdHIpLnRvLmJlLmZvbygnYmFyJyk7XG4gKiAgICAgZXhwZWN0KGZvb1N0cikudG8uYmUuZm9vLmVxdWFsKCdmb28nKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IG9iamVjdCB0byB3aGljaCB0aGUgbWV0aG9kIGlzIGFkZGVkXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiBtZXRob2QgdG8gYWRkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2QgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgYG5hbWVgLCB3aGVuIGNhbGxlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2hhaW5pbmdCZWhhdmlvciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZXZlcnkgdGltZSB0aGUgcHJvcGVydHkgaXMgYWNjZXNzZWRcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGFkZENoYWluYWJsZU1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFkZENoYWluYWJsZU1ldGhvZChjdHgsIG5hbWUsIG1ldGhvZCwgY2hhaW5pbmdCZWhhdmlvcikge1xuICBpZiAodHlwZW9mIGNoYWluaW5nQmVoYXZpb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICBjaGFpbmluZ0JlaGF2aW9yID0gZnVuY3Rpb24gKCkgeyB9O1xuICB9XG5cbiAgdmFyIGNoYWluYWJsZUJlaGF2aW9yID0ge1xuICAgICAgbWV0aG9kOiBtZXRob2RcbiAgICAsIGNoYWluaW5nQmVoYXZpb3I6IGNoYWluaW5nQmVoYXZpb3JcbiAgfTtcblxuICAvLyBzYXZlIHRoZSBtZXRob2RzIHNvIHdlIGNhbiBvdmVyd3JpdGUgdGhlbSBsYXRlciwgaWYgd2UgbmVlZCB0by5cbiAgaWYgKCFjdHguX19tZXRob2RzKSB7XG4gICAgY3R4Ll9fbWV0aG9kcyA9IHt9O1xuICB9XG4gIGN0eC5fX21ldGhvZHNbbmFtZV0gPSBjaGFpbmFibGVCZWhhdmlvcjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBuYW1lLFxuICAgIHsgZ2V0OiBmdW5jdGlvbiBjaGFpbmFibGVNZXRob2RHZXR0ZXIoKSB7XG4gICAgICAgIGNoYWluYWJsZUJlaGF2aW9yLmNoYWluaW5nQmVoYXZpb3IuY2FsbCh0aGlzKTtcblxuICAgICAgICB2YXIgY2hhaW5hYmxlTWV0aG9kV3JhcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIHRoZSBgc3NmaWAgZmxhZyB0byBgY2hhaW5hYmxlTWV0aG9kV3JhcHBlcmAgY2F1c2VzIHRoaXNcbiAgICAgICAgICAvLyBmdW5jdGlvbiB0byBiZSB0aGUgc3RhcnRpbmcgcG9pbnQgZm9yIHJlbW92aW5nIGltcGxlbWVudGF0aW9uXG4gICAgICAgICAgLy8gZnJhbWVzIGZyb20gdGhlIHN0YWNrIHRyYWNlIG9mIGEgZmFpbGVkIGFzc2VydGlvbi5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byB1c2UgdGhpcyBmdW5jdGlvbiBhcyB0aGUgc3RhcnRpbmcgcG9pbnQgaWZcbiAgICAgICAgICAvLyB0aGUgYGxvY2tTc2ZpYCBmbGFnIGlzbid0IHNldC5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIElmIHRoZSBgbG9ja1NzZmlgIGZsYWcgaXMgc2V0LCB0aGVuIHRoaXMgYXNzZXJ0aW9uIGlzIGJlaW5nXG4gICAgICAgICAgLy8gaW52b2tlZCBmcm9tIGluc2lkZSBvZiBhbm90aGVyIGFzc2VydGlvbi4gSW4gdGhpcyBjYXNlLCB0aGUgYHNzZmlgXG4gICAgICAgICAgLy8gZmxhZyBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSB0aGUgb3V0ZXIgYXNzZXJ0aW9uLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gTm90ZSB0aGF0IG92ZXJ3cml0aW5nIGEgY2hhaW5hYmxlIG1ldGhvZCBtZXJlbHkgcmVwbGFjZXMgdGhlIHNhdmVkXG4gICAgICAgICAgLy8gbWV0aG9kcyBpbiBgY3R4Ll9fbWV0aG9kc2AgaW5zdGVhZCBvZiBjb21wbGV0ZWx5IHJlcGxhY2luZyB0aGVcbiAgICAgICAgICAvLyBvdmVyd3JpdHRlbiBhc3NlcnRpb24uIFRoZXJlZm9yZSwgYW4gb3ZlcndyaXRpbmcgYXNzZXJ0aW9uIHdvbid0XG4gICAgICAgICAgLy8gc2V0IHRoZSBgc3NmaWAgb3IgYGxvY2tTc2ZpYCBmbGFncy5cbiAgICAgICAgICBpZiAoIWZsYWcodGhpcywgJ2xvY2tTc2ZpJykpIHtcbiAgICAgICAgICAgIGZsYWcodGhpcywgJ3NzZmknLCBjaGFpbmFibGVNZXRob2RXcmFwcGVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVzdWx0ID0gY2hhaW5hYmxlQmVoYXZpb3IubWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBuZXdBc3NlcnRpb24gPSBuZXcgY2hhaS5Bc3NlcnRpb24oKTtcbiAgICAgICAgICB0cmFuc2ZlckZsYWdzKHRoaXMsIG5ld0Fzc2VydGlvbik7XG4gICAgICAgICAgcmV0dXJuIG5ld0Fzc2VydGlvbjtcbiAgICAgICAgfTtcblxuICAgICAgICBhZGRMZW5ndGhHdWFyZChjaGFpbmFibGVNZXRob2RXcmFwcGVyLCBuYW1lLCB0cnVlKTtcblxuICAgICAgICAvLyBVc2UgYE9iamVjdC5zZXRQcm90b3R5cGVPZmAgaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmIChjYW5TZXRQcm90b3R5cGUpIHtcbiAgICAgICAgICAvLyBJbmhlcml0IGFsbCBwcm9wZXJ0aWVzIGZyb20gdGhlIG9iamVjdCBieSByZXBsYWNpbmcgdGhlIGBGdW5jdGlvbmAgcHJvdG90eXBlXG4gICAgICAgICAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgICAgICAgLy8gUmVzdG9yZSB0aGUgYGNhbGxgIGFuZCBgYXBwbHlgIG1ldGhvZHMgZnJvbSBgRnVuY3Rpb25gXG4gICAgICAgICAgcHJvdG90eXBlLmNhbGwgPSBjYWxsO1xuICAgICAgICAgIHByb3RvdHlwZS5hcHBseSA9IGFwcGx5O1xuICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihjaGFpbmFibGVNZXRob2RXcmFwcGVyLCBwcm90b3R5cGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgcmVkZWZpbmUgYWxsIHByb3BlcnRpZXMgKHNsb3chKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgYXNzZXJ0ZXJOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGN0eCk7XG4gICAgICAgICAgYXNzZXJ0ZXJOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChhc3NlcnRlck5hbWUpIHtcbiAgICAgICAgICAgIGlmIChleGNsdWRlTmFtZXMuaW5kZXhPZihhc3NlcnRlck5hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY3R4LCBhc3NlcnRlck5hbWUpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNoYWluYWJsZU1ldGhvZFdyYXBwZXIsIGFzc2VydGVyTmFtZSwgcGQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhbnNmZXJGbGFncyh0aGlzLCBjaGFpbmFibGVNZXRob2RXcmFwcGVyKTtcbiAgICAgICAgcmV0dXJuIHByb3hpZnkoY2hhaW5hYmxlTWV0aG9kV3JhcHBlcik7XG4gICAgICB9XG4gICAgLCBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gb3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgY2hhaSA9IHJlcXVpcmUoJy4uLy4uL2NoYWknKTtcbnZhciB0cmFuc2ZlckZsYWdzID0gcmVxdWlyZSgnLi90cmFuc2ZlckZsYWdzJyk7XG5cbi8qKlxuICogIyMjIC5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QoY3R4LCBuYW1lLCBtZXRob2QsIGNoYWluaW5nQmVoYXZpb3IpXG4gKlxuICogT3ZlcndyaXRlcyBhbiBhbHJlYWR5IGV4aXN0aW5nIGNoYWluYWJsZSBtZXRob2RcbiAqIGFuZCBwcm92aWRlcyBhY2Nlc3MgdG8gdGhlIHByZXZpb3VzIGZ1bmN0aW9uIG9yXG4gKiBwcm9wZXJ0eS4gIE11c3QgcmV0dXJuIGZ1bmN0aW9ucyB0byBiZSB1c2VkIGZvclxuICogbmFtZS5cbiAqXG4gKiAgICAgdXRpbHMub3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kKGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgJ2xlbmd0aE9mJyxcbiAqICAgICAgIGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAqICAgICAgIH1cbiAqICAgICAsIGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAqICAgICAgIH1cbiAqICAgICApO1xuICpcbiAqIENhbiBhbHNvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gYGNoYWkuQXNzZXJ0aW9uYC5cbiAqXG4gKiAgICAgY2hhaS5Bc3NlcnRpb24ub3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kKCdmb28nLCBmbiwgZm4pO1xuICpcbiAqIFRoZW4gY2FuIGJlIHVzZWQgYXMgYW55IG90aGVyIGFzc2VydGlvbi5cbiAqXG4gKiAgICAgZXhwZWN0KG15Rm9vKS50by5oYXZlLmxlbmd0aE9mKDMpO1xuICogICAgIGV4cGVjdChteUZvbykudG8uaGF2ZS5sZW5ndGhPZi5hYm92ZSgzKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IG9iamVjdCB3aG9zZSBtZXRob2QgLyBwcm9wZXJ0eSBpcyB0byBiZSBvdmVyd3JpdHRlblxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgbWV0aG9kIC8gcHJvcGVydHkgdG8gb3ZlcndyaXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2QgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2hhaW5pbmdCZWhhdmlvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBwcm9wZXJ0eVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQG5hbWUgb3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gb3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kKGN0eCwgbmFtZSwgbWV0aG9kLCBjaGFpbmluZ0JlaGF2aW9yKSB7XG4gIHZhciBjaGFpbmFibGVCZWhhdmlvciA9IGN0eC5fX21ldGhvZHNbbmFtZV07XG5cbiAgdmFyIF9jaGFpbmluZ0JlaGF2aW9yID0gY2hhaW5hYmxlQmVoYXZpb3IuY2hhaW5pbmdCZWhhdmlvcjtcbiAgY2hhaW5hYmxlQmVoYXZpb3IuY2hhaW5pbmdCZWhhdmlvciA9IGZ1bmN0aW9uIG92ZXJ3cml0aW5nQ2hhaW5hYmxlTWV0aG9kR2V0dGVyKCkge1xuICAgIHZhciByZXN1bHQgPSBjaGFpbmluZ0JlaGF2aW9yKF9jaGFpbmluZ0JlaGF2aW9yKS5jYWxsKHRoaXMpO1xuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICB2YXIgbmV3QXNzZXJ0aW9uID0gbmV3IGNoYWkuQXNzZXJ0aW9uKCk7XG4gICAgdHJhbnNmZXJGbGFncyh0aGlzLCBuZXdBc3NlcnRpb24pO1xuICAgIHJldHVybiBuZXdBc3NlcnRpb247XG4gIH07XG5cbiAgdmFyIF9tZXRob2QgPSBjaGFpbmFibGVCZWhhdmlvci5tZXRob2Q7XG4gIGNoYWluYWJsZUJlaGF2aW9yLm1ldGhvZCA9IGZ1bmN0aW9uIG92ZXJ3cml0aW5nQ2hhaW5hYmxlTWV0aG9kV3JhcHBlcigpIHtcbiAgICB2YXIgcmVzdWx0ID0gbWV0aG9kKF9tZXRob2QpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHZhciBuZXdBc3NlcnRpb24gPSBuZXcgY2hhaS5Bc3NlcnRpb24oKTtcbiAgICB0cmFuc2ZlckZsYWdzKHRoaXMsIG5ld0Fzc2VydGlvbik7XG4gICAgcmV0dXJuIG5ld0Fzc2VydGlvbjtcbiAgfTtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBjb21wYXJlQnlJbnNwZWN0IHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTYgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgaW5zcGVjdCA9IHJlcXVpcmUoJy4vaW5zcGVjdCcpO1xuXG4vKipcbiAqICMjIyAuY29tcGFyZUJ5SW5zcGVjdChtaXhlZCwgbWl4ZWQpXG4gKlxuICogVG8gYmUgdXNlZCBhcyBhIGNvbXBhcmVGdW5jdGlvbiB3aXRoIEFycmF5LnByb3RvdHlwZS5zb3J0LiBDb21wYXJlcyBlbGVtZW50c1xuICogdXNpbmcgaW5zcGVjdCBpbnN0ZWFkIG9mIGRlZmF1bHQgYmVoYXZpb3Igb2YgdXNpbmcgdG9TdHJpbmcgc28gdGhhdCBTeW1ib2xzXG4gKiBhbmQgb2JqZWN0cyB3aXRoIGlycmVndWxhci9taXNzaW5nIHRvU3RyaW5nIGNhbiBzdGlsbCBiZSBzb3J0ZWQgd2l0aG91dCBhXG4gKiBUeXBlRXJyb3IuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gZmlyc3QgZWxlbWVudCB0byBjb21wYXJlXG4gKiBAcGFyYW0ge01peGVkfSBzZWNvbmQgZWxlbWVudCB0byBjb21wYXJlXG4gKiBAcmV0dXJucyB7TnVtYmVyfSAtMSBpZiAnYScgc2hvdWxkIGNvbWUgYmVmb3JlICdiJzsgb3RoZXJ3aXNlIDFcbiAqIEBuYW1lIGNvbXBhcmVCeUluc3BlY3RcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21wYXJlQnlJbnNwZWN0KGEsIGIpIHtcbiAgcmV0dXJuIGluc3BlY3QoYSkgPCBpbnNwZWN0KGIpID8gLTEgOiAxO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGdldE93bkVudW1lcmFibGVQcm9wZXJ0eVN5bWJvbHMgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNiBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC5nZXRPd25FbnVtZXJhYmxlUHJvcGVydHlTeW1ib2xzKG9iamVjdClcbiAqXG4gKiBUaGlzIGFsbG93cyB0aGUgcmV0cmlldmFsIG9mIGRpcmVjdGx5LW93bmVkIGVudW1lcmFibGUgcHJvcGVydHkgc3ltYm9scyBvZiBhblxuICogb2JqZWN0LiBUaGlzIGZ1bmN0aW9uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbiAqIHJldHVybnMgYm90aCBlbnVtZXJhYmxlIGFuZCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBzeW1ib2xzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBuYW1lIGdldE93bkVudW1lcmFibGVQcm9wZXJ0eVN5bWJvbHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRPd25FbnVtZXJhYmxlUHJvcGVydHlTeW1ib2xzKG9iaikge1xuICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgIT09ICdmdW5jdGlvbicpIHJldHVybiBbXTtcblxuICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBzeW0pLmVudW1lcmFibGU7XG4gIH0pO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGdldE93bkVudW1lcmFibGVQcm9wZXJ0aWVzIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTYgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgZ2V0T3duRW51bWVyYWJsZVByb3BlcnR5U3ltYm9scyA9IHJlcXVpcmUoJy4vZ2V0T3duRW51bWVyYWJsZVByb3BlcnR5U3ltYm9scycpO1xuXG4vKipcbiAqICMjIyAuZ2V0T3duRW51bWVyYWJsZVByb3BlcnRpZXMob2JqZWN0KVxuICpcbiAqIFRoaXMgYWxsb3dzIHRoZSByZXRyaWV2YWwgb2YgZGlyZWN0bHktb3duZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYW4gb2JqZWN0LiBUaGlzIGZ1bmN0aW9uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIE9iamVjdC5rZXlzIG9ubHlcbiAqIHJldHVybnMgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcywgbm90IGVudW1lcmFibGUgcHJvcGVydHkgc3ltYm9scy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAbmFtZSBnZXRPd25FbnVtZXJhYmxlUHJvcGVydGllc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldE93bkVudW1lcmFibGVQcm9wZXJ0aWVzKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5jb25jYXQoZ2V0T3duRW51bWVyYWJsZVByb3BlcnR5U3ltYm9scyhvYmopKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qICFcbiAqIENoYWkgLSBjaGVja0Vycm9yIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTYgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAuY2hlY2tFcnJvclxuICpcbiAqIENoZWNrcyB0aGF0IGFuIGVycm9yIGNvbmZvcm1zIHRvIGEgZ2l2ZW4gc2V0IG9mIGNyaXRlcmlhIGFuZC9vciByZXRyaWV2ZXMgaW5mb3JtYXRpb24gYWJvdXQgaXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqICMjIyAuY29tcGF0aWJsZUluc3RhbmNlKHRocm93biwgZXJyb3JMaWtlKVxuICpcbiAqIENoZWNrcyBpZiB0d28gaW5zdGFuY2VzIGFyZSBjb21wYXRpYmxlIChzdHJpY3QgZXF1YWwpLlxuICogUmV0dXJucyBmYWxzZSBpZiBlcnJvckxpa2UgaXMgbm90IGFuIGluc3RhbmNlIG9mIEVycm9yLCBiZWNhdXNlIGluc3RhbmNlc1xuICogY2FuIG9ubHkgYmUgY29tcGF0aWJsZSBpZiB0aGV5J3JlIGJvdGggZXJyb3IgaW5zdGFuY2VzLlxuICpcbiAqIEBuYW1lIGNvbXBhdGlibGVJbnN0YW5jZVxuICogQHBhcmFtIHtFcnJvcn0gdGhyb3duIGVycm9yXG4gKiBAcGFyYW0ge0Vycm9yfEVycm9yQ29uc3RydWN0b3J9IGVycm9yTGlrZSBvYmplY3QgdG8gY29tcGFyZSBhZ2FpbnN0XG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNvbXBhdGlibGVJbnN0YW5jZSh0aHJvd24sIGVycm9yTGlrZSkge1xuICByZXR1cm4gZXJyb3JMaWtlIGluc3RhbmNlb2YgRXJyb3IgJiYgdGhyb3duID09PSBlcnJvckxpa2U7XG59XG5cbi8qKlxuICogIyMjIC5jb21wYXRpYmxlQ29uc3RydWN0b3IodGhyb3duLCBlcnJvckxpa2UpXG4gKlxuICogQ2hlY2tzIGlmIHR3byBjb25zdHJ1Y3RvcnMgYXJlIGNvbXBhdGlibGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbiByZWNlaXZlIGVpdGhlciBhbiBlcnJvciBjb25zdHJ1Y3RvciBvclxuICogYW4gZXJyb3IgaW5zdGFuY2UgYXMgdGhlIGBlcnJvckxpa2VgIGFyZ3VtZW50LlxuICogQ29uc3RydWN0b3JzIGFyZSBjb21wYXRpYmxlIGlmIHRoZXkncmUgdGhlIHNhbWUgb3IgaWYgb25lIGlzXG4gKiBhbiBpbnN0YW5jZSBvZiBhbm90aGVyLlxuICpcbiAqIEBuYW1lIGNvbXBhdGlibGVDb25zdHJ1Y3RvclxuICogQHBhcmFtIHtFcnJvcn0gdGhyb3duIGVycm9yXG4gKiBAcGFyYW0ge0Vycm9yfEVycm9yQ29uc3RydWN0b3J9IGVycm9yTGlrZSBvYmplY3QgdG8gY29tcGFyZSBhZ2FpbnN0XG4gKiBAbmFtZXNwYWNlIFV0aWxzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNvbXBhdGlibGVDb25zdHJ1Y3Rvcih0aHJvd24sIGVycm9yTGlrZSkge1xuICBpZiAoZXJyb3JMaWtlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAvLyBJZiBgZXJyb3JMaWtlYCBpcyBhbiBpbnN0YW5jZSBvZiBhbnkgZXJyb3Igd2UgY29tcGFyZSB0aGVpciBjb25zdHJ1Y3RvcnNcbiAgICByZXR1cm4gdGhyb3duLmNvbnN0cnVjdG9yID09PSBlcnJvckxpa2UuY29uc3RydWN0b3IgfHwgdGhyb3duIGluc3RhbmNlb2YgZXJyb3JMaWtlLmNvbnN0cnVjdG9yO1xuICB9IGVsc2UgaWYgKGVycm9yTGlrZS5wcm90b3R5cGUgaW5zdGFuY2VvZiBFcnJvciB8fCBlcnJvckxpa2UgPT09IEVycm9yKSB7XG4gICAgLy8gSWYgYGVycm9yTGlrZWAgaXMgYSBjb25zdHJ1Y3RvciB0aGF0IGluaGVyaXRzIGZyb20gRXJyb3IsIHdlIGNvbXBhcmUgYHRocm93bmAgdG8gYGVycm9yTGlrZWAgZGlyZWN0bHlcbiAgICByZXR1cm4gdGhyb3duLmNvbnN0cnVjdG9yID09PSBlcnJvckxpa2UgfHwgdGhyb3duIGluc3RhbmNlb2YgZXJyb3JMaWtlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqICMjIyAuY29tcGF0aWJsZU1lc3NhZ2UodGhyb3duLCBlcnJNYXRjaGVyKVxuICpcbiAqIENoZWNrcyBpZiBhbiBlcnJvcidzIG1lc3NhZ2UgaXMgY29tcGF0aWJsZSB3aXRoIGEgbWF0Y2hlciAoU3RyaW5nIG9yIFJlZ0V4cCkuXG4gKiBJZiB0aGUgbWVzc2FnZSBjb250YWlucyB0aGUgU3RyaW5nIG9yIHBhc3NlcyB0aGUgUmVnRXhwIHRlc3QsXG4gKiBpdCBpcyBjb25zaWRlcmVkIGNvbXBhdGlibGUuXG4gKlxuICogQG5hbWUgY29tcGF0aWJsZU1lc3NhZ2VcbiAqIEBwYXJhbSB7RXJyb3J9IHRocm93biBlcnJvclxuICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBlcnJNYXRjaGVyIHRvIGxvb2sgZm9yIGludG8gdGhlIG1lc3NhZ2VcbiAqIEBuYW1lc3BhY2UgVXRpbHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY29tcGF0aWJsZU1lc3NhZ2UodGhyb3duLCBlcnJNYXRjaGVyKSB7XG4gIHZhciBjb21wYXJpc29uU3RyaW5nID0gdHlwZW9mIHRocm93biA9PT0gJ3N0cmluZycgPyB0aHJvd24gOiB0aHJvd24ubWVzc2FnZTtcbiAgaWYgKGVyck1hdGNoZXIgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gZXJyTWF0Y2hlci50ZXN0KGNvbXBhcmlzb25TdHJpbmcpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlcnJNYXRjaGVyID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBjb21wYXJpc29uU3RyaW5nLmluZGV4T2YoZXJyTWF0Y2hlcikgIT09IC0xOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW1hZ2ljLW51bWJlcnNcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiAjIyMgLmdldEZ1bmN0aW9uTmFtZShjb25zdHJ1Y3RvckZuKVxuICpcbiAqIFJldHVybnMgdGhlIG5hbWUgb2YgYSBmdW5jdGlvbi5cbiAqIFRoaXMgYWxzbyBpbmNsdWRlcyBhIHBvbHlmaWxsIGZ1bmN0aW9uIGlmIGBjb25zdHJ1Y3RvckZuLm5hbWVgIGlzIG5vdCBkZWZpbmVkLlxuICpcbiAqIEBuYW1lIGdldEZ1bmN0aW9uTmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29uc3RydWN0b3JGblxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIGZ1bmN0aW9uTmFtZU1hdGNoID0gL1xccypmdW5jdGlvbig/Olxcc3xcXHMqXFwvXFwqW14oPzoqXFwvKV0rXFwqXFwvXFxzKikqKFteXFwoXFwvXSspLztcbmZ1bmN0aW9uIGdldEZ1bmN0aW9uTmFtZShjb25zdHJ1Y3RvckZuKSB7XG4gIHZhciBuYW1lID0gJyc7XG4gIGlmICh0eXBlb2YgY29uc3RydWN0b3JGbi5uYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEhlcmUgd2UgcnVuIGEgcG9seWZpbGwgaWYgY29uc3RydWN0b3JGbi5uYW1lIGlzIG5vdCBkZWZpbmVkXG4gICAgdmFyIG1hdGNoID0gU3RyaW5nKGNvbnN0cnVjdG9yRm4pLm1hdGNoKGZ1bmN0aW9uTmFtZU1hdGNoKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIG5hbWUgPSBtYXRjaFsxXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmFtZSA9IGNvbnN0cnVjdG9yRm4ubmFtZTtcbiAgfVxuXG4gIHJldHVybiBuYW1lO1xufVxuXG4vKipcbiAqICMjIyAuZ2V0Q29uc3RydWN0b3JOYW1lKGVycm9yTGlrZSlcbiAqXG4gKiBHZXRzIHRoZSBjb25zdHJ1Y3RvciBuYW1lIGZvciBhbiBFcnJvciBpbnN0YW5jZSBvciBjb25zdHJ1Y3RvciBpdHNlbGYuXG4gKlxuICogQG5hbWUgZ2V0Q29uc3RydWN0b3JOYW1lXG4gKiBAcGFyYW0ge0Vycm9yfEVycm9yQ29uc3RydWN0b3J9IGVycm9yTGlrZVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBnZXRDb25zdHJ1Y3Rvck5hbWUoZXJyb3JMaWtlKSB7XG4gIHZhciBjb25zdHJ1Y3Rvck5hbWUgPSBlcnJvckxpa2U7XG4gIGlmIChlcnJvckxpa2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIGNvbnN0cnVjdG9yTmFtZSA9IGdldEZ1bmN0aW9uTmFtZShlcnJvckxpa2UuY29uc3RydWN0b3IpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlcnJvckxpa2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBJZiBgZXJyYCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgRXJyb3IgaXQgaXMgYW4gZXJyb3IgY29uc3RydWN0b3IgaXRzZWxmIG9yIGFub3RoZXIgZnVuY3Rpb24uXG4gICAgLy8gSWYgd2UndmUgZ290IGEgY29tbW9uIGZ1bmN0aW9uIHdlIGdldCBpdHMgbmFtZSwgb3RoZXJ3aXNlIHdlIG1heSBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZVxuICAgIC8vIG9mIHRoZSBlcnJvciBqdXN0IGluIGNhc2UgaXQncyBhIHBvb3JseS1jb25zdHJ1Y3RlZCBlcnJvci4gUGxlYXNlIHNlZSBjaGFpanMvY2hhaS9pc3N1ZXMvNDUgdG8ga25vdyBtb3JlLlxuICAgIGNvbnN0cnVjdG9yTmFtZSA9IGdldEZ1bmN0aW9uTmFtZShlcnJvckxpa2UpLnRyaW0oKSB8fFxuICAgICAgICBnZXRGdW5jdGlvbk5hbWUobmV3IGVycm9yTGlrZSgpKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG4gIH1cblxuICByZXR1cm4gY29uc3RydWN0b3JOYW1lO1xufVxuXG4vKipcbiAqICMjIyAuZ2V0TWVzc2FnZShlcnJvckxpa2UpXG4gKlxuICogR2V0cyB0aGUgZXJyb3IgbWVzc2FnZSBmcm9tIGFuIGVycm9yLlxuICogSWYgYGVycmAgaXMgYSBTdHJpbmcgaXRzZWxmLCB3ZSByZXR1cm4gaXQuXG4gKiBJZiB0aGUgZXJyb3IgaGFzIG5vIG1lc3NhZ2UsIHdlIHJldHVybiBhbiBlbXB0eSBzdHJpbmcuXG4gKlxuICogQG5hbWUgZ2V0TWVzc2FnZVxuICogQHBhcmFtIHtFcnJvcnxTdHJpbmd9IGVycm9yTGlrZVxuICogQG5hbWVzcGFjZSBVdGlsc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBnZXRNZXNzYWdlKGVycm9yTGlrZSkge1xuICB2YXIgbXNnID0gJyc7XG4gIGlmIChlcnJvckxpa2UgJiYgZXJyb3JMaWtlLm1lc3NhZ2UpIHtcbiAgICBtc2cgPSBlcnJvckxpa2UubWVzc2FnZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXJyb3JMaWtlID09PSAnc3RyaW5nJykge1xuICAgIG1zZyA9IGVycm9yTGlrZTtcbiAgfVxuXG4gIHJldHVybiBtc2c7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb21wYXRpYmxlSW5zdGFuY2U6IGNvbXBhdGlibGVJbnN0YW5jZSxcbiAgY29tcGF0aWJsZUNvbnN0cnVjdG9yOiBjb21wYXRpYmxlQ29uc3RydWN0b3IsXG4gIGNvbXBhdGlibGVNZXNzYWdlOiBjb21wYXRpYmxlTWVzc2FnZSxcbiAgZ2V0TWVzc2FnZTogZ2V0TWVzc2FnZSxcbiAgZ2V0Q29uc3RydWN0b3JOYW1lOiBnZXRDb25zdHJ1Y3Rvck5hbWUsXG59O1xuIiwiLyohXG4gKiBDaGFpIC0gaXNOYU4gdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNSBTYWt0aGlwcml5YW4gVmFpcmFtYW5pIDx0aGVjaGFyZ2luZ3ZvbGNhbm9AZ21haWwuY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmlzTmFOKHZhbHVlKVxuICpcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgTmFOIG9yIG5vdC5cbiAqXG4gKiAgICAgdXRpbHMuaXNOYU4oTmFOKTsgLy8gdHJ1ZVxuICpcbiAqIEBwYXJhbSB7VmFsdWV9IFRoZSB2YWx1ZSB3aGljaCBoYXMgdG8gYmUgY2hlY2tlZCBpZiBpdCBpcyBOYU5cbiAqIEBuYW1lIGlzTmFOXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuICAvLyBSZWZlciBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtaXNuYW4tbnVtYmVyXG4gIC8vIHNlY3Rpb24ncyBOT1RFLlxuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG4vLyBJZiBFQ01BU2NyaXB0IDYncyBOdW1iZXIuaXNOYU4gaXMgcHJlc2VudCwgcHJlZmVyIHRoYXQuXG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlci5pc05hTiB8fCBpc05hTjtcbiIsIi8qIVxuICogY2hhaVxuICogQ29weXJpZ2h0KGMpIDIwMTEgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIERlcGVuZGVuY2llcyB0aGF0IGFyZSB1c2VkIGZvciBtdWx0aXBsZSBleHBvcnRzIGFyZSByZXF1aXJlZCBoZXJlIG9ubHkgb25jZVxuICovXG5cbnZhciBwYXRodmFsID0gcmVxdWlyZSgncGF0aHZhbCcpO1xuXG4vKiFcbiAqIHRlc3QgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMudGVzdCA9IHJlcXVpcmUoJy4vdGVzdCcpO1xuXG4vKiFcbiAqIHR5cGUgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMudHlwZSA9IHJlcXVpcmUoJ3R5cGUtZGV0ZWN0Jyk7XG5cbi8qIVxuICogZXhwZWN0VHlwZXMgdXRpbGl0eVxuICovXG5leHBvcnRzLmV4cGVjdFR5cGVzID0gcmVxdWlyZSgnLi9leHBlY3RUeXBlcycpO1xuXG4vKiFcbiAqIG1lc3NhZ2UgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMuZ2V0TWVzc2FnZSA9IHJlcXVpcmUoJy4vZ2V0TWVzc2FnZScpO1xuXG4vKiFcbiAqIGFjdHVhbCB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy5nZXRBY3R1YWwgPSByZXF1aXJlKCcuL2dldEFjdHVhbCcpO1xuXG4vKiFcbiAqIEluc3BlY3QgdXRpbFxuICovXG5cbmV4cG9ydHMuaW5zcGVjdCA9IHJlcXVpcmUoJy4vaW5zcGVjdCcpO1xuXG4vKiFcbiAqIE9iamVjdCBEaXNwbGF5IHV0aWxcbiAqL1xuXG5leHBvcnRzLm9iakRpc3BsYXkgPSByZXF1aXJlKCcuL29iakRpc3BsYXknKTtcblxuLyohXG4gKiBGbGFnIHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLmZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKTtcblxuLyohXG4gKiBGbGFnIHRyYW5zZmVycmluZyB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy50cmFuc2ZlckZsYWdzID0gcmVxdWlyZSgnLi90cmFuc2ZlckZsYWdzJyk7XG5cbi8qIVxuICogRGVlcCBlcXVhbCB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy5lcWwgPSByZXF1aXJlKCdkZWVwLWVxbCcpO1xuXG4vKiFcbiAqIERlZXAgcGF0aCBpbmZvXG4gKi9cblxuZXhwb3J0cy5nZXRQYXRoSW5mbyA9IHBhdGh2YWwuZ2V0UGF0aEluZm87XG5cbi8qIVxuICogQ2hlY2sgaWYgYSBwcm9wZXJ0eSBleGlzdHNcbiAqL1xuXG5leHBvcnRzLmhhc1Byb3BlcnR5ID0gcGF0aHZhbC5oYXNQcm9wZXJ0eTtcblxuLyohXG4gKiBGdW5jdGlvbiBuYW1lXG4gKi9cblxuZXhwb3J0cy5nZXROYW1lID0gcmVxdWlyZSgnZ2V0LWZ1bmMtbmFtZScpO1xuXG4vKiFcbiAqIGFkZCBQcm9wZXJ0eVxuICovXG5cbmV4cG9ydHMuYWRkUHJvcGVydHkgPSByZXF1aXJlKCcuL2FkZFByb3BlcnR5Jyk7XG5cbi8qIVxuICogYWRkIE1ldGhvZFxuICovXG5cbmV4cG9ydHMuYWRkTWV0aG9kID0gcmVxdWlyZSgnLi9hZGRNZXRob2QnKTtcblxuLyohXG4gKiBvdmVyd3JpdGUgUHJvcGVydHlcbiAqL1xuXG5leHBvcnRzLm92ZXJ3cml0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9vdmVyd3JpdGVQcm9wZXJ0eScpO1xuXG4vKiFcbiAqIG92ZXJ3cml0ZSBNZXRob2RcbiAqL1xuXG5leHBvcnRzLm92ZXJ3cml0ZU1ldGhvZCA9IHJlcXVpcmUoJy4vb3ZlcndyaXRlTWV0aG9kJyk7XG5cbi8qIVxuICogQWRkIGEgY2hhaW5hYmxlIG1ldGhvZFxuICovXG5cbmV4cG9ydHMuYWRkQ2hhaW5hYmxlTWV0aG9kID0gcmVxdWlyZSgnLi9hZGRDaGFpbmFibGVNZXRob2QnKTtcblxuLyohXG4gKiBPdmVyd3JpdGUgY2hhaW5hYmxlIG1ldGhvZFxuICovXG5cbmV4cG9ydHMub3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kID0gcmVxdWlyZSgnLi9vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QnKTtcblxuLyohXG4gKiBDb21wYXJlIGJ5IGluc3BlY3QgbWV0aG9kXG4gKi9cblxuZXhwb3J0cy5jb21wYXJlQnlJbnNwZWN0ID0gcmVxdWlyZSgnLi9jb21wYXJlQnlJbnNwZWN0Jyk7XG5cbi8qIVxuICogR2V0IG93biBlbnVtZXJhYmxlIHByb3BlcnR5IHN5bWJvbHMgbWV0aG9kXG4gKi9cblxuZXhwb3J0cy5nZXRPd25FbnVtZXJhYmxlUHJvcGVydHlTeW1ib2xzID0gcmVxdWlyZSgnLi9nZXRPd25FbnVtZXJhYmxlUHJvcGVydHlTeW1ib2xzJyk7XG5cbi8qIVxuICogR2V0IG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgbWV0aG9kXG4gKi9cblxuZXhwb3J0cy5nZXRPd25FbnVtZXJhYmxlUHJvcGVydGllcyA9IHJlcXVpcmUoJy4vZ2V0T3duRW51bWVyYWJsZVByb3BlcnRpZXMnKTtcblxuLyohXG4gKiBDaGVja3MgZXJyb3IgYWdhaW5zdCBhIGdpdmVuIHNldCBvZiBjcml0ZXJpYVxuICovXG5cbmV4cG9ydHMuY2hlY2tFcnJvciA9IHJlcXVpcmUoJ2NoZWNrLWVycm9yJyk7XG5cbi8qIVxuICogUHJveGlmeSB1dGlsXG4gKi9cblxuZXhwb3J0cy5wcm94aWZ5ID0gcmVxdWlyZSgnLi9wcm94aWZ5Jyk7XG5cbi8qIVxuICogYWRkTGVuZ3RoR3VhcmQgdXRpbFxuICovXG5cbmV4cG9ydHMuYWRkTGVuZ3RoR3VhcmQgPSByZXF1aXJlKCcuL2FkZExlbmd0aEd1YXJkJyk7XG5cbi8qIVxuICogaXNQcm94eUVuYWJsZWQgaGVscGVyXG4gKi9cblxuZXhwb3J0cy5pc1Byb3h5RW5hYmxlZCA9IHJlcXVpcmUoJy4vaXNQcm94eUVuYWJsZWQnKTtcblxuLyohXG4gKiBpc05hTiBtZXRob2RcbiAqL1xuXG5leHBvcnRzLmlzTmFOID0gcmVxdWlyZSgnLi9pc05hTicpO1xuIiwiLyohXG4gKiBjaGFpXG4gKiBodHRwOi8vY2hhaWpzLmNvbVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbnZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfY2hhaSwgdXRpbCkge1xuICAvKiFcbiAgICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAgICovXG5cbiAgdmFyIEFzc2VydGlvbkVycm9yID0gX2NoYWkuQXNzZXJ0aW9uRXJyb3JcbiAgICAsIGZsYWcgPSB1dGlsLmZsYWc7XG5cbiAgLyohXG4gICAqIE1vZHVsZSBleHBvcnQuXG4gICAqL1xuXG4gIF9jaGFpLkFzc2VydGlvbiA9IEFzc2VydGlvbjtcblxuICAvKiFcbiAgICogQXNzZXJ0aW9uIENvbnN0cnVjdG9yXG4gICAqXG4gICAqIENyZWF0ZXMgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICpcbiAgICogYEFzc2VydGlvbmAgb2JqZWN0cyBjb250YWluIG1ldGFkYXRhIGluIHRoZSBmb3JtIG9mIGZsYWdzLiBUaHJlZSBmbGFncyBjYW5cbiAgICogYmUgYXNzaWduZWQgZHVyaW5nIGluc3RhbnRpYXRpb24gYnkgcGFzc2luZyBhcmd1bWVudHMgdG8gdGhpcyBjb25zdHJ1Y3RvcjpcbiAgICpcbiAgICogLSBgb2JqZWN0YDogVGhpcyBmbGFnIGNvbnRhaW5zIHRoZSB0YXJnZXQgb2YgdGhlIGFzc2VydGlvbi4gRm9yIGV4YW1wbGUsIGluXG4gICAqICAgdGhlIGFzc2VydGlvbiBgZXhwZWN0KG51bUtpdHRlbnMpLnRvLmVxdWFsKDcpO2AsIHRoZSBgb2JqZWN0YCBmbGFnIHdpbGxcbiAgICogICBjb250YWluIGBudW1LaXR0ZW5zYCBzbyB0aGF0IHRoZSBgZXF1YWxgIGFzc2VydGlvbiBjYW4gcmVmZXJlbmNlIGl0IHdoZW5cbiAgICogICBuZWVkZWQuXG4gICAqXG4gICAqIC0gYG1lc3NhZ2VgOiBUaGlzIGZsYWcgY29udGFpbnMgYW4gb3B0aW9uYWwgY3VzdG9tIGVycm9yIG1lc3NhZ2UgdG8gYmVcbiAgICogICBwcmVwZW5kZWQgdG8gdGhlIGVycm9yIG1lc3NhZ2UgdGhhdCdzIGdlbmVyYXRlZCBieSB0aGUgYXNzZXJ0aW9uIHdoZW4gaXRcbiAgICogICBmYWlscy5cbiAgICpcbiAgICogLSBgc3NmaWA6IFRoaXMgZmxhZyBzdGFuZHMgZm9yIFwic3RhcnQgc3RhY2sgZnVuY3Rpb24gaW5kaWNhdG9yXCIuIEl0XG4gICAqICAgY29udGFpbnMgYSBmdW5jdGlvbiByZWZlcmVuY2UgdGhhdCBzZXJ2ZXMgYXMgdGhlIHN0YXJ0aW5nIHBvaW50IGZvclxuICAgKiAgIHJlbW92aW5nIGZyYW1lcyBmcm9tIHRoZSBzdGFjayB0cmFjZSBvZiB0aGUgZXJyb3IgdGhhdCdzIGNyZWF0ZWQgYnkgdGhlXG4gICAqICAgYXNzZXJ0aW9uIHdoZW4gaXQgZmFpbHMuIFRoZSBnb2FsIGlzIHRvIHByb3ZpZGUgYSBjbGVhbmVyIHN0YWNrIHRyYWNlIHRvXG4gICAqICAgZW5kIHVzZXJzIGJ5IHJlbW92aW5nIENoYWkncyBpbnRlcm5hbCBmdW5jdGlvbnMuIE5vdGUgdGhhdCBpdCBvbmx5IHdvcmtzXG4gICAqICAgaW4gZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2VgLCBhbmQgb25seSB3aGVuXG4gICAqICAgYENoYWkuY29uZmlnLmluY2x1ZGVTdGFja2AgaGFzbid0IGJlZW4gc2V0IHRvIGBmYWxzZWAuXG4gICAqXG4gICAqIC0gYGxvY2tTc2ZpYDogVGhpcyBmbGFnIGNvbnRyb2xzIHdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBgc3NmaWAgZmxhZ1xuICAgKiAgIHNob3VsZCByZXRhaW4gaXRzIGN1cnJlbnQgdmFsdWUsIGV2ZW4gYXMgYXNzZXJ0aW9ucyBhcmUgY2hhaW5lZCBvZmYgb2ZcbiAgICogICB0aGlzIG9iamVjdC4gVGhpcyBpcyB1c3VhbGx5IHNldCB0byBgdHJ1ZWAgd2hlbiBjcmVhdGluZyBhIG5ldyBhc3NlcnRpb25cbiAgICogICBmcm9tIHdpdGhpbiBhbm90aGVyIGFzc2VydGlvbi4gSXQncyBhbHNvIHRlbXBvcmFyaWx5IHNldCB0byBgdHJ1ZWAgYmVmb3JlXG4gICAqICAgYW4gb3ZlcndyaXR0ZW4gYXNzZXJ0aW9uIGdldHMgY2FsbGVkIGJ5IHRoZSBvdmVyd3JpdGluZyBhc3NlcnRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iaiB0YXJnZXQgb2YgdGhlIGFzc2VydGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIChvcHRpb25hbCkgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3NmaSAob3B0aW9uYWwpIHN0YXJ0aW5nIHBvaW50IGZvciByZW1vdmluZyBzdGFjayBmcmFtZXNcbiAgICogQHBhcmFtIHtCb29sZWFufSBsb2NrU3NmaSAob3B0aW9uYWwpIHdoZXRoZXIgb3Igbm90IHRoZSBzc2ZpIGZsYWcgaXMgbG9ja2VkXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBmdW5jdGlvbiBBc3NlcnRpb24gKG9iaiwgbXNnLCBzc2ZpLCBsb2NrU3NmaSkge1xuICAgIGZsYWcodGhpcywgJ3NzZmknLCBzc2ZpIHx8IEFzc2VydGlvbik7XG4gICAgZmxhZyh0aGlzLCAnbG9ja1NzZmknLCBsb2NrU3NmaSk7XG4gICAgZmxhZyh0aGlzLCAnb2JqZWN0Jywgb2JqKTtcbiAgICBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcblxuICAgIHJldHVybiB1dGlsLnByb3hpZnkodGhpcyk7XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXNzZXJ0aW9uLCAnaW5jbHVkZVN0YWNrJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0Fzc2VydGlvbi5pbmNsdWRlU3RhY2sgaXMgZGVwcmVjYXRlZCwgdXNlIGNoYWkuY29uZmlnLmluY2x1ZGVTdGFjayBpbnN0ZWFkLicpO1xuICAgICAgcmV0dXJuIGNvbmZpZy5pbmNsdWRlU3RhY2s7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0Fzc2VydGlvbi5pbmNsdWRlU3RhY2sgaXMgZGVwcmVjYXRlZCwgdXNlIGNoYWkuY29uZmlnLmluY2x1ZGVTdGFjayBpbnN0ZWFkLicpO1xuICAgICAgY29uZmlnLmluY2x1ZGVTdGFjayA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFzc2VydGlvbiwgJ3Nob3dEaWZmJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0Fzc2VydGlvbi5zaG93RGlmZiBpcyBkZXByZWNhdGVkLCB1c2UgY2hhaS5jb25maWcuc2hvd0RpZmYgaW5zdGVhZC4nKTtcbiAgICAgIHJldHVybiBjb25maWcuc2hvd0RpZmY7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0Fzc2VydGlvbi5zaG93RGlmZiBpcyBkZXByZWNhdGVkLCB1c2UgY2hhaS5jb25maWcuc2hvd0RpZmYgaW5zdGVhZC4nKTtcbiAgICAgIGNvbmZpZy5zaG93RGlmZiA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5ID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gICAgdXRpbC5hZGRQcm9wZXJ0eSh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4pO1xuICB9O1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgICB1dGlsLmFkZE1ldGhvZCh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4pO1xuICB9O1xuXG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QgPSBmdW5jdGlvbiAobmFtZSwgZm4sIGNoYWluaW5nQmVoYXZpb3IpIHtcbiAgICB1dGlsLmFkZENoYWluYWJsZU1ldGhvZCh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4sIGNoYWluaW5nQmVoYXZpb3IpO1xuICB9O1xuXG4gIEFzc2VydGlvbi5vdmVyd3JpdGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICAgIHV0aWwub3ZlcndyaXRlUHJvcGVydHkodGhpcy5wcm90b3R5cGUsIG5hbWUsIGZuKTtcbiAgfTtcblxuICBBc3NlcnRpb24ub3ZlcndyaXRlTWV0aG9kID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gICAgdXRpbC5vdmVyd3JpdGVNZXRob2QodGhpcy5wcm90b3R5cGUsIG5hbWUsIGZuKTtcbiAgfTtcblxuICBBc3NlcnRpb24ub3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kID0gZnVuY3Rpb24gKG5hbWUsIGZuLCBjaGFpbmluZ0JlaGF2aW9yKSB7XG4gICAgdXRpbC5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QodGhpcy5wcm90b3R5cGUsIG5hbWUsIGZuLCBjaGFpbmluZ0JlaGF2aW9yKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5hc3NlcnQoZXhwcmVzc2lvbiwgbWVzc2FnZSwgbmVnYXRlTWVzc2FnZSwgZXhwZWN0ZWQsIGFjdHVhbCwgc2hvd0RpZmYpXG4gICAqXG4gICAqIEV4ZWN1dGVzIGFuIGV4cHJlc3Npb24gYW5kIGNoZWNrIGV4cGVjdGF0aW9ucy4gVGhyb3dzIEFzc2VydGlvbkVycm9yIGZvciByZXBvcnRpbmcgaWYgdGVzdCBkb2Vzbid0IHBhc3MuXG4gICAqXG4gICAqIEBuYW1lIGFzc2VydFxuICAgKiBAcGFyYW0ge1BoaWxvc29waGljYWx9IGV4cHJlc3Npb24gdG8gYmUgdGVzdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBtZXNzYWdlIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBtZXNzYWdlIHRvIGRpc3BsYXkgaWYgZXhwcmVzc2lvbiBmYWlsc1xuICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gbmVnYXRlZE1lc3NhZ2Ugb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIG5lZ2F0ZWRNZXNzYWdlIHRvIGRpc3BsYXkgaWYgbmVnYXRlZCBleHByZXNzaW9uIGZhaWxzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkIHZhbHVlIChyZW1lbWJlciB0byBjaGVjayBmb3IgbmVnYXRpb24pXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbCAob3B0aW9uYWwpIHdpbGwgZGVmYXVsdCB0byBgdGhpcy5vYmpgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hvd0RpZmYgKG9wdGlvbmFsKSB3aGVuIHNldCB0byBgdHJ1ZWAsIGFzc2VydCB3aWxsIGRpc3BsYXkgYSBkaWZmIGluIGFkZGl0aW9uIHRvIHRoZSBtZXNzYWdlIGlmIGV4cHJlc3Npb24gZmFpbHNcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIEFzc2VydGlvbi5wcm90b3R5cGUuYXNzZXJ0ID0gZnVuY3Rpb24gKGV4cHIsIG1zZywgbmVnYXRlTXNnLCBleHBlY3RlZCwgX2FjdHVhbCwgc2hvd0RpZmYpIHtcbiAgICB2YXIgb2sgPSB1dGlsLnRlc3QodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoZmFsc2UgIT09IHNob3dEaWZmKSBzaG93RGlmZiA9IHRydWU7XG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gZXhwZWN0ZWQgJiYgdW5kZWZpbmVkID09PSBfYWN0dWFsKSBzaG93RGlmZiA9IGZhbHNlO1xuICAgIGlmICh0cnVlICE9PSBjb25maWcuc2hvd0RpZmYpIHNob3dEaWZmID0gZmFsc2U7XG5cbiAgICBpZiAoIW9rKSB7XG4gICAgICBtc2cgPSB1dGlsLmdldE1lc3NhZ2UodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHZhciBhY3R1YWwgPSB1dGlsLmdldEFjdHVhbCh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKG1zZywge1xuICAgICAgICAgIGFjdHVhbDogYWN0dWFsXG4gICAgICAgICwgZXhwZWN0ZWQ6IGV4cGVjdGVkXG4gICAgICAgICwgc2hvd0RpZmY6IHNob3dEaWZmXG4gICAgICB9LCAoY29uZmlnLmluY2x1ZGVTdGFjaykgPyB0aGlzLmFzc2VydCA6IGZsYWcodGhpcywgJ3NzZmknKSk7XG4gICAgfVxuICB9O1xuXG4gIC8qIVxuICAgKiAjIyMgLl9vYmpcbiAgICpcbiAgICogUXVpY2sgcmVmZXJlbmNlIHRvIHN0b3JlZCBgYWN0dWFsYCB2YWx1ZSBmb3IgcGx1Z2luIGRldmVsb3BlcnMuXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXNzZXJ0aW9uLnByb3RvdHlwZSwgJ19vYmonLFxuICAgIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICAgIH1cbiAgICAsIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICBmbGFnKHRoaXMsICdvYmplY3QnLCB2YWwpO1xuICAgICAgfVxuICB9KTtcbn07XG4iLCIvKiFcbiAqIGNoYWlcbiAqIGh0dHA6Ly9jaGFpanMuY29tXG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY2hhaSwgXykge1xuICB2YXIgQXNzZXJ0aW9uID0gY2hhaS5Bc3NlcnRpb25cbiAgICAsIEFzc2VydGlvbkVycm9yID0gY2hhaS5Bc3NlcnRpb25FcnJvclxuICAgICwgZmxhZyA9IF8uZmxhZztcblxuICAvKipcbiAgICogIyMjIExhbmd1YWdlIENoYWluc1xuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIGFyZSBwcm92aWRlZCBhcyBjaGFpbmFibGUgZ2V0dGVycyB0byBpbXByb3ZlIHRoZSByZWFkYWJpbGl0eVxuICAgKiBvZiB5b3VyIGFzc2VydGlvbnMuXG4gICAqXG4gICAqICoqQ2hhaW5zKipcbiAgICpcbiAgICogLSB0b1xuICAgKiAtIGJlXG4gICAqIC0gYmVlblxuICAgKiAtIGlzXG4gICAqIC0gdGhhdFxuICAgKiAtIHdoaWNoXG4gICAqIC0gYW5kXG4gICAqIC0gaGFzXG4gICAqIC0gaGF2ZVxuICAgKiAtIHdpdGhcbiAgICogLSBhdFxuICAgKiAtIG9mXG4gICAqIC0gc2FtZVxuICAgKiAtIGJ1dFxuICAgKiAtIGRvZXNcbiAgICogLSBzdGlsbFxuICAgKlxuICAgKiBAbmFtZSBsYW5ndWFnZSBjaGFpbnNcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgWyAndG8nLCAnYmUnLCAnYmVlbicsICdpcydcbiAgLCAnYW5kJywgJ2hhcycsICdoYXZlJywgJ3dpdGgnXG4gICwgJ3RoYXQnLCAnd2hpY2gnLCAnYXQnLCAnb2YnXG4gICwgJ3NhbWUnLCAnYnV0JywgJ2RvZXMnLCAnc3RpbGwnIF0uZm9yRWFjaChmdW5jdGlvbiAoY2hhaW4pIHtcbiAgICBBc3NlcnRpb24uYWRkUHJvcGVydHkoY2hhaW4pO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5ub3RcbiAgICpcbiAgICogTmVnYXRlcyBhbGwgYXNzZXJ0aW9ucyB0aGF0IGZvbGxvdyBpbiB0aGUgY2hhaW4uXG4gICAqXG4gICAqICAgICBleHBlY3QoZnVuY3Rpb24gKCkge30pLnRvLm5vdC50aHJvdygpO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8ubm90LmhhdmUucHJvcGVydHkoJ2InKTtcbiAgICogICAgIGV4cGVjdChbMSwgMl0pLnRvLmJlLmFuKCdhcnJheScpLnRoYXQuZG9lcy5ub3QuaW5jbHVkZSgzKTtcbiAgICpcbiAgICogSnVzdCBiZWNhdXNlIHlvdSBjYW4gbmVnYXRlIGFueSBhc3NlcnRpb24gd2l0aCBgLm5vdGAgZG9lc24ndCBtZWFuIHlvdVxuICAgKiBzaG91bGQuIFdpdGggZ3JlYXQgcG93ZXIgY29tZXMgZ3JlYXQgcmVzcG9uc2liaWxpdHkuIEl0J3Mgb2Z0ZW4gYmVzdCB0b1xuICAgKiBhc3NlcnQgdGhhdCB0aGUgb25lIGV4cGVjdGVkIG91dHB1dCB3YXMgcHJvZHVjZWQsIHJhdGhlciB0aGFuIGFzc2VydGluZ1xuICAgKiB0aGF0IG9uZSBvZiBjb3VudGxlc3MgdW5leHBlY3RlZCBvdXRwdXRzIHdhc24ndCBwcm9kdWNlZC4gU2VlIGluZGl2aWR1YWxcbiAgICogYXNzZXJ0aW9ucyBmb3Igc3BlY2lmaWMgZ3VpZGFuY2UuXG4gICAqXG4gICAqICAgICBleHBlY3QoMikudG8uZXF1YWwoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMikudG8ubm90LmVxdWFsKDEpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQG5hbWUgbm90XG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnbm90JywgZnVuY3Rpb24gKCkge1xuICAgIGZsYWcodGhpcywgJ25lZ2F0ZScsIHRydWUpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwXG4gICAqXG4gICAqIENhdXNlcyBhbGwgYC5lcXVhbGAsIGAuaW5jbHVkZWAsIGAubWVtYmVyc2AsIGAua2V5c2AsIGFuZCBgLnByb3BlcnR5YFxuICAgKiBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpbiB0byB1c2UgZGVlcCBlcXVhbGl0eSBpbnN0ZWFkIG9mIHN0cmljdFxuICAgKiAoYD09PWApIGVxdWFsaXR5LiBTZWUgdGhlIGBkZWVwLWVxbGAgcHJvamVjdCBwYWdlIGZvciBpbmZvIG9uIHRoZSBkZWVwXG4gICAqIGVxdWFsaXR5IGFsZ29yaXRobTogaHR0cHM6Ly9naXRodWIuY29tL2NoYWlqcy9kZWVwLWVxbC5cbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBvYmplY3QgZGVlcGx5IChidXQgbm90IHN0cmljdGx5KSBlcXVhbHMgYHthOiAxfWBcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmRlZXAuZXF1YWwoe2E6IDF9KTtcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLm5vdC5lcXVhbCh7YTogMX0pO1xuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IGFycmF5IGRlZXBseSAoYnV0IG5vdCBzdHJpY3RseSkgaW5jbHVkZXMgYHthOiAxfWBcbiAgICogICAgIGV4cGVjdChbe2E6IDF9XSkudG8uZGVlcC5pbmNsdWRlKHthOiAxfSk7XG4gICAqICAgICBleHBlY3QoW3thOiAxfV0pLnRvLm5vdC5pbmNsdWRlKHthOiAxfSk7XG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgb2JqZWN0IGRlZXBseSAoYnV0IG5vdCBzdHJpY3RseSkgaW5jbHVkZXMgYHg6IHthOiAxfWBcbiAgICogICAgIGV4cGVjdCh7eDoge2E6IDF9fSkudG8uZGVlcC5pbmNsdWRlKHt4OiB7YTogMX19KTtcbiAgICogICAgIGV4cGVjdCh7eDoge2E6IDF9fSkudG8ubm90LmluY2x1ZGUoe3g6IHthOiAxfX0pO1xuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IGFycmF5IGRlZXBseSAoYnV0IG5vdCBzdHJpY3RseSkgaGFzIG1lbWJlciBge2E6IDF9YFxuICAgKiAgICAgZXhwZWN0KFt7YTogMX1dKS50by5oYXZlLmRlZXAubWVtYmVycyhbe2E6IDF9XSk7XG4gICAqICAgICBleHBlY3QoW3thOiAxfV0pLnRvLm5vdC5oYXZlLm1lbWJlcnMoW3thOiAxfV0pO1xuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IHNldCBkZWVwbHkgKGJ1dCBub3Qgc3RyaWN0bHkpIGhhcyBrZXkgYHthOiAxfWBcbiAgICogICAgIGV4cGVjdChuZXcgU2V0KFt7YTogMX1dKSkudG8uaGF2ZS5kZWVwLmtleXMoW3thOiAxfV0pO1xuICAgKiAgICAgZXhwZWN0KG5ldyBTZXQoW3thOiAxfV0pKS50by5ub3QuaGF2ZS5rZXlzKFt7YTogMX1dKTtcbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBvYmplY3QgZGVlcGx5IChidXQgbm90IHN0cmljdGx5KSBoYXMgcHJvcGVydHkgYHg6IHthOiAxfWBcbiAgICogICAgIGV4cGVjdCh7eDoge2E6IDF9fSkudG8uaGF2ZS5kZWVwLnByb3BlcnR5KCd4Jywge2E6IDF9KTtcbiAgICogICAgIGV4cGVjdCh7eDoge2E6IDF9fSkudG8ubm90LmhhdmUucHJvcGVydHkoJ3gnLCB7YTogMX0pO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZGVlcCcsIGZ1bmN0aW9uICgpIHtcbiAgICBmbGFnKHRoaXMsICdkZWVwJywgdHJ1ZSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLm5lc3RlZFxuICAgKlxuICAgKiBFbmFibGVzIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gaW4gYWxsIGAucHJvcGVydHlgIGFuZCBgLmluY2x1ZGVgXG4gICAqIGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlIGNoYWluLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiB7YjogWyd4JywgJ3knXX19KS50by5oYXZlLm5lc3RlZC5wcm9wZXJ0eSgnYS5iWzFdJyk7XG4gICAqICAgICBleHBlY3Qoe2E6IHtiOiBbJ3gnLCAneSddfX0pLnRvLm5lc3RlZC5pbmNsdWRlKHsnYS5iWzFdJzogJ3knfSk7XG4gICAqXG4gICAqIElmIGAuYCBvciBgW11gIGFyZSBwYXJ0IG9mIGFuIGFjdHVhbCBwcm9wZXJ0eSBuYW1lLCB0aGV5IGNhbiBiZSBlc2NhcGVkIGJ5XG4gICAqIGFkZGluZyB0d28gYmFja3NsYXNoZXMgYmVmb3JlIHRoZW0uXG4gICAqXG4gICAqICAgICBleHBlY3QoeycuYSc6IHsnW2JdJzogJ3gnfX0pLnRvLmhhdmUubmVzdGVkLnByb3BlcnR5KCdcXFxcLmEuXFxcXFtiXFxcXF0nKTtcbiAgICogICAgIGV4cGVjdCh7Jy5hJzogeydbYl0nOiAneCd9fSkudG8ubmVzdGVkLmluY2x1ZGUoeydcXFxcLmEuXFxcXFtiXFxcXF0nOiAneCd9KTtcbiAgICpcbiAgICogYC5uZXN0ZWRgIGNhbm5vdCBiZSBjb21iaW5lZCB3aXRoIGAub3duYC5cbiAgICpcbiAgICogQG5hbWUgbmVzdGVkXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnbmVzdGVkJywgZnVuY3Rpb24gKCkge1xuICAgIGZsYWcodGhpcywgJ25lc3RlZCcsIHRydWUpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5vd25cbiAgICpcbiAgICogQ2F1c2VzIGFsbCBgLnByb3BlcnR5YCBhbmQgYC5pbmNsdWRlYCBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpblxuICAgKiB0byBpZ25vcmUgaW5oZXJpdGVkIHByb3BlcnRpZXMuXG4gICAqXG4gICAqICAgICBPYmplY3QucHJvdG90eXBlLmIgPSAyO1xuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5vd24ucHJvcGVydHkoJ2EnKTtcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmhhdmUucHJvcGVydHkoJ2InKTtcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLm5vdC5oYXZlLm93bi5wcm9wZXJ0eSgnYicpO1xuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8ub3duLmluY2x1ZGUoe2E6IDF9KTtcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmluY2x1ZGUoe2I6IDJ9KS5idXQubm90Lm93bi5pbmNsdWRlKHtiOiAyfSk7XG4gICAqXG4gICAqIGAub3duYCBjYW5ub3QgYmUgY29tYmluZWQgd2l0aCBgLm5lc3RlZGAuXG4gICAqXG4gICAqIEBuYW1lIG93blxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ293bicsIGZ1bmN0aW9uICgpIHtcbiAgICBmbGFnKHRoaXMsICdvd24nLCB0cnVlKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAub3JkZXJlZFxuICAgKlxuICAgKiBDYXVzZXMgYWxsIGAubWVtYmVyc2AgYXNzZXJ0aW9ucyB0aGF0IGZvbGxvdyBpbiB0aGUgY2hhaW4gdG8gcmVxdWlyZSB0aGF0XG4gICAqIG1lbWJlcnMgYmUgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDJdKS50by5oYXZlLm9yZGVyZWQubWVtYmVycyhbMSwgMl0pXG4gICAqICAgICAgIC5idXQubm90LmhhdmUub3JkZXJlZC5tZW1iZXJzKFsyLCAxXSk7XG4gICAqXG4gICAqIFdoZW4gYC5pbmNsdWRlYCBhbmQgYC5vcmRlcmVkYCBhcmUgY29tYmluZWQsIHRoZSBvcmRlcmluZyBiZWdpbnMgYXQgdGhlXG4gICAqIHN0YXJ0IG9mIGJvdGggYXJyYXlzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaW5jbHVkZS5vcmRlcmVkLm1lbWJlcnMoWzEsIDJdKVxuICAgKiAgICAgICAuYnV0Lm5vdC5pbmNsdWRlLm9yZGVyZWQubWVtYmVycyhbMiwgM10pO1xuICAgKlxuICAgKiBAbmFtZSBvcmRlcmVkXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnb3JkZXJlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBmbGFnKHRoaXMsICdvcmRlcmVkJywgdHJ1ZSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmFueVxuICAgKlxuICAgKiBDYXVzZXMgYWxsIGAua2V5c2AgYXNzZXJ0aW9ucyB0aGF0IGZvbGxvdyBpbiB0aGUgY2hhaW4gdG8gb25seSByZXF1aXJlIHRoYXRcbiAgICogdGhlIHRhcmdldCBoYXZlIGF0IGxlYXN0IG9uZSBvZiB0aGUgZ2l2ZW4ga2V5cy4gVGhpcyBpcyB0aGUgb3Bwb3NpdGUgb2ZcbiAgICogYC5hbGxgLCB3aGljaCByZXF1aXJlcyB0aGF0IHRoZSB0YXJnZXQgaGF2ZSBhbGwgb2YgdGhlIGdpdmVuIGtleXMuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDJ9KS50by5ub3QuaGF2ZS5hbnkua2V5cygnYycsICdkJyk7XG4gICAqXG4gICAqIFNlZSB0aGUgYC5rZXlzYCBkb2MgZm9yIGd1aWRhbmNlIG9uIHdoZW4gdG8gdXNlIGAuYW55YCBvciBgLmFsbGAuXG4gICAqXG4gICAqIEBuYW1lIGFueVxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2FueScsIGZ1bmN0aW9uICgpIHtcbiAgICBmbGFnKHRoaXMsICdhbnknLCB0cnVlKTtcbiAgICBmbGFnKHRoaXMsICdhbGwnLCBmYWxzZSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmFsbFxuICAgKlxuICAgKiBDYXVzZXMgYWxsIGAua2V5c2AgYXNzZXJ0aW9ucyB0aGF0IGZvbGxvdyBpbiB0aGUgY2hhaW4gdG8gcmVxdWlyZSB0aGF0IHRoZVxuICAgKiB0YXJnZXQgaGF2ZSBhbGwgb2YgdGhlIGdpdmVuIGtleXMuIFRoaXMgaXMgdGhlIG9wcG9zaXRlIG9mIGAuYW55YCwgd2hpY2hcbiAgICogb25seSByZXF1aXJlcyB0aGF0IHRoZSB0YXJnZXQgaGF2ZSBhdCBsZWFzdCBvbmUgb2YgdGhlIGdpdmVuIGtleXMuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDJ9KS50by5oYXZlLmFsbC5rZXlzKCdhJywgJ2InKTtcbiAgICpcbiAgICogTm90ZSB0aGF0IGAuYWxsYCBpcyB1c2VkIGJ5IGRlZmF1bHQgd2hlbiBuZWl0aGVyIGAuYWxsYCBub3IgYC5hbnlgIGFyZVxuICAgKiBhZGRlZCBlYXJsaWVyIGluIHRoZSBjaGFpbi4gSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0IHRvIGFkZCBgLmFsbGAgYW55d2F5XG4gICAqIGJlY2F1c2UgaXQgaW1wcm92ZXMgcmVhZGFiaWxpdHkuXG4gICAqXG4gICAqIFNlZSB0aGUgYC5rZXlzYCBkb2MgZm9yIGd1aWRhbmNlIG9uIHdoZW4gdG8gdXNlIGAuYW55YCBvciBgLmFsbGAuXG4gICAqXG4gICAqIEBuYW1lIGFsbFxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2FsbCcsIGZ1bmN0aW9uICgpIHtcbiAgICBmbGFnKHRoaXMsICdhbGwnLCB0cnVlKTtcbiAgICBmbGFnKHRoaXMsICdhbnknLCBmYWxzZSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmEodHlwZVssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0J3MgdHlwZSBpcyBlcXVhbCB0byB0aGUgZ2l2ZW4gc3RyaW5nIGB0eXBlYC4gVHlwZXNcbiAgICogYXJlIGNhc2UgaW5zZW5zaXRpdmUuIFNlZSB0aGUgYHR5cGUtZGV0ZWN0YCBwcm9qZWN0IHBhZ2UgZm9yIGluZm8gb24gdGhlXG4gICAqIHR5cGUgZGV0ZWN0aW9uIGFsZ29yaXRobTogaHR0cHM6Ly9naXRodWIuY29tL2NoYWlqcy90eXBlLWRldGVjdC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uYmUuYSgnc3RyaW5nJyk7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5iZS5hbignb2JqZWN0Jyk7XG4gICAqICAgICBleHBlY3QobnVsbCkudG8uYmUuYSgnbnVsbCcpO1xuICAgKiAgICAgZXhwZWN0KHVuZGVmaW5lZCkudG8uYmUuYW4oJ3VuZGVmaW5lZCcpO1xuICAgKiAgICAgZXhwZWN0KG5ldyBFcnJvcikudG8uYmUuYW4oJ2Vycm9yJyk7XG4gICAqICAgICBleHBlY3QoUHJvbWlzZS5yZXNvbHZlKCkpLnRvLmJlLmEoJ3Byb21pc2UnKTtcbiAgICogICAgIGV4cGVjdChuZXcgRmxvYXQzMkFycmF5KS50by5iZS5hKCdmbG9hdDMyYXJyYXknKTtcbiAgICogICAgIGV4cGVjdChTeW1ib2woKSkudG8uYmUuYSgnc3ltYm9sJyk7XG4gICAqXG4gICAqIGAuYWAgc3VwcG9ydHMgb2JqZWN0cyB0aGF0IGhhdmUgYSBjdXN0b20gdHlwZSBzZXQgdmlhIGBTeW1ib2wudG9TdHJpbmdUYWdgLlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge1xuICAgKiAgICAgICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ215Q3VzdG9tVHlwZSdcbiAgICogICAgIH07XG4gICAqXG4gICAqICAgICBleHBlY3QobXlPYmopLnRvLmJlLmEoJ215Q3VzdG9tVHlwZScpLmJ1dC5ub3QuYW4oJ29iamVjdCcpO1xuICAgKlxuICAgKiBJdCdzIG9mdGVuIGJlc3QgdG8gdXNlIGAuYWAgdG8gY2hlY2sgYSB0YXJnZXQncyB0eXBlIGJlZm9yZSBtYWtpbmcgbW9yZVxuICAgKiBhc3NlcnRpb25zIG9uIHRoZSBzYW1lIHRhcmdldC4gVGhhdCB3YXksIHlvdSBhdm9pZCB1bmV4cGVjdGVkIGJlaGF2aW9yIGZyb21cbiAgICogYW55IGFzc2VydGlvbiB0aGF0IGRvZXMgZGlmZmVyZW50IHRoaW5ncyBiYXNlZCBvbiB0aGUgdGFyZ2V0J3MgdHlwZS5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmJlLmFuKCdhcnJheScpLnRoYXQuaW5jbHVkZXMoMik7XG4gICAqICAgICBleHBlY3QoW10pLnRvLmJlLmFuKCdhcnJheScpLnRoYXQuaXMuZW1wdHk7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuYWAuIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdCB0b1xuICAgKiBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0IGlzIHRoZSBleHBlY3RlZCB0eXBlLCByYXRoZXIgdGhhbiBhc3NlcnRpbmcgdGhhdCBpdFxuICAgKiBpc24ndCBvbmUgb2YgbWFueSB1bmV4cGVjdGVkIHR5cGVzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5iZS5hKCdzdHJpbmcnKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8ubm90LmJlLmFuKCdhcnJheScpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC5hYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2UgdG9cbiAgICogc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzIHRoZSBzZWNvbmRcbiAgICogYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uYmUuYSgnc3RyaW5nJywgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KDEsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5hKCdzdHJpbmcnKTtcbiAgICpcbiAgICogYC5hYCBjYW4gYWxzbyBiZSB1c2VkIGFzIGEgbGFuZ3VhZ2UgY2hhaW4gdG8gaW1wcm92ZSB0aGUgcmVhZGFiaWxpdHkgb2ZcbiAgICogeW91ciBhc3NlcnRpb25zLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHtiOiAyfSkudG8uaGF2ZS5hLnByb3BlcnR5KCdiJyk7XG4gICAqXG4gICAqIFRoZSBhbGlhcyBgLmFuYCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLmFgLlxuICAgKlxuICAgKiBAbmFtZSBhXG4gICAqIEBhbGlhcyBhblxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYW4gKHR5cGUsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGFydGljbGUgPSB+WyAnYScsICdlJywgJ2knLCAnbycsICd1JyBdLmluZGV4T2YodHlwZS5jaGFyQXQoMCkpID8gJ2FuICcgOiAnYSAnO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHR5cGUgPT09IF8udHlwZShvYmopLnRvTG93ZXJDYXNlKClcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgJyArIGFydGljbGUgKyB0eXBlXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IG5vdCB0byBiZSAnICsgYXJ0aWNsZSArIHR5cGVcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnYW4nLCBhbik7XG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2EnLCBhbik7XG5cbiAgLyoqXG4gICAqICMjIyAuaW5jbHVkZSh2YWxbLCBtc2ddKVxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgYSBzdHJpbmcsIGAuaW5jbHVkZWAgYXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiBzdHJpbmcgYHZhbGBcbiAgICogaXMgYSBzdWJzdHJpbmcgb2YgdGhlIHRhcmdldC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJykudG8uaW5jbHVkZSgnZm9vJyk7XG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBhbiBhcnJheSwgYC5pbmNsdWRlYCBhc3NlcnRzIHRoYXQgdGhlIGdpdmVuIGB2YWxgIGlzIGFcbiAgICogbWVtYmVyIG9mIHRoZSB0YXJnZXQuXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5pbmNsdWRlKDIpO1xuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgYW4gb2JqZWN0LCBgLmluY2x1ZGVgIGFzc2VydHMgdGhhdCB0aGUgZ2l2ZW4gb2JqZWN0XG4gICAqIGB2YWxgJ3MgcHJvcGVydGllcyBhcmUgYSBzdWJzZXQgb2YgdGhlIHRhcmdldCdzIHByb3BlcnRpZXMuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDIsIGM6IDN9KS50by5pbmNsdWRlKHthOiAxLCBiOiAyfSk7XG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBhIFNldCBvciBXZWFrU2V0LCBgLmluY2x1ZGVgIGFzc2VydHMgdGhhdCB0aGUgZ2l2ZW4gYHZhbGAgaXMgYVxuICAgKiBtZW1iZXIgb2YgdGhlIHRhcmdldC4gU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG0gaXMgdXNlZC5cbiAgICpcbiAgICogICAgIGV4cGVjdChuZXcgU2V0KFsxLCAyXSkpLnRvLmluY2x1ZGUoMik7XG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBhIE1hcCwgYC5pbmNsdWRlYCBhc3NlcnRzIHRoYXQgdGhlIGdpdmVuIGB2YWxgIGlzIG9uZSBvZlxuICAgKiB0aGUgdmFsdWVzIG9mIHRoZSB0YXJnZXQuIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtIGlzIHVzZWQuXG4gICAqXG4gICAqICAgICBleHBlY3QobmV3IE1hcChbWydhJywgMV0sIFsnYicsIDJdXSkpLnRvLmluY2x1ZGUoMik7XG4gICAqXG4gICAqIEJlY2F1c2UgYC5pbmNsdWRlYCBkb2VzIGRpZmZlcmVudCB0aGluZ3MgYmFzZWQgb24gdGhlIHRhcmdldCdzIHR5cGUsIGl0J3NcbiAgICogaW1wb3J0YW50IHRvIGNoZWNrIHRoZSB0YXJnZXQncyB0eXBlIGJlZm9yZSB1c2luZyBgLmluY2x1ZGVgLiBTZWUgdGhlIGAuYWBcbiAgICogZG9jIGZvciBpbmZvIG9uIHRlc3RpbmcgYSB0YXJnZXQncyB0eXBlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uYmUuYW4oJ2FycmF5JykudGhhdC5pbmNsdWRlcygyKTtcbiAgICpcbiAgICogQnkgZGVmYXVsdCwgc3RyaWN0IChgPT09YCkgZXF1YWxpdHkgaXMgdXNlZCB0byBjb21wYXJlIGFycmF5IG1lbWJlcnMgYW5kXG4gICAqIG9iamVjdCBwcm9wZXJ0aWVzLiBBZGQgYC5kZWVwYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byB1c2UgZGVlcCBlcXVhbGl0eVxuICAgKiBpbnN0ZWFkIChXZWFrU2V0IHRhcmdldHMgYXJlIG5vdCBzdXBwb3J0ZWQpLiBTZWUgdGhlIGBkZWVwLWVxbGAgcHJvamVjdFxuICAgKiBwYWdlIGZvciBpbmZvIG9uIHRoZSBkZWVwIGVxdWFsaXR5IGFsZ29yaXRobTogaHR0cHM6Ly9naXRodWIuY29tL2NoYWlqcy9kZWVwLWVxbC5cbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBhcnJheSBkZWVwbHkgKGJ1dCBub3Qgc3RyaWN0bHkpIGluY2x1ZGVzIGB7YTogMX1gXG4gICAqICAgICBleHBlY3QoW3thOiAxfV0pLnRvLmRlZXAuaW5jbHVkZSh7YTogMX0pO1xuICAgKiAgICAgZXhwZWN0KFt7YTogMX1dKS50by5ub3QuaW5jbHVkZSh7YTogMX0pO1xuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IG9iamVjdCBkZWVwbHkgKGJ1dCBub3Qgc3RyaWN0bHkpIGluY2x1ZGVzIGB4OiB7YTogMX1gXG4gICAqICAgICBleHBlY3Qoe3g6IHthOiAxfX0pLnRvLmRlZXAuaW5jbHVkZSh7eDoge2E6IDF9fSk7XG4gICAqICAgICBleHBlY3Qoe3g6IHthOiAxfX0pLnRvLm5vdC5pbmNsdWRlKHt4OiB7YTogMX19KTtcbiAgICpcbiAgICogQnkgZGVmYXVsdCwgYWxsIG9mIHRoZSB0YXJnZXQncyBwcm9wZXJ0aWVzIGFyZSBzZWFyY2hlZCB3aGVuIHdvcmtpbmcgd2l0aFxuICAgKiBvYmplY3RzLiBUaGlzIGluY2x1ZGVzIHByb3BlcnRpZXMgdGhhdCBhcmUgaW5oZXJpdGVkIGFuZC9vciBub24tZW51bWVyYWJsZS5cbiAgICogQWRkIGAub3duYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBleGNsdWRlIHRoZSB0YXJnZXQncyBpbmhlcml0ZWRcbiAgICogcHJvcGVydGllcyBmcm9tIHRoZSBzZWFyY2guXG4gICAqXG4gICAqICAgICBPYmplY3QucHJvdG90eXBlLmIgPSAyO1xuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8ub3duLmluY2x1ZGUoe2E6IDF9KTtcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmluY2x1ZGUoe2I6IDJ9KS5idXQubm90Lm93bi5pbmNsdWRlKHtiOiAyfSk7XG4gICAqXG4gICAqIE5vdGUgdGhhdCBhIHRhcmdldCBvYmplY3QgaXMgYWx3YXlzIG9ubHkgc2VhcmNoZWQgZm9yIGB2YWxgJ3Mgb3duXG4gICAqIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICpcbiAgICogYC5kZWVwYCBhbmQgYC5vd25gIGNhbiBiZSBjb21iaW5lZC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YToge2I6IDJ9fSkudG8uZGVlcC5vd24uaW5jbHVkZSh7YToge2I6IDJ9fSk7XG4gICAqXG4gICAqIEFkZCBgLm5lc3RlZGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gZW5hYmxlIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gd2hlblxuICAgKiByZWZlcmVuY2luZyBuZXN0ZWQgcHJvcGVydGllcy5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YToge2I6IFsneCcsICd5J119fSkudG8ubmVzdGVkLmluY2x1ZGUoeydhLmJbMV0nOiAneSd9KTtcbiAgICpcbiAgICogSWYgYC5gIG9yIGBbXWAgYXJlIHBhcnQgb2YgYW4gYWN0dWFsIHByb3BlcnR5IG5hbWUsIHRoZXkgY2FuIGJlIGVzY2FwZWQgYnlcbiAgICogYWRkaW5nIHR3byBiYWNrc2xhc2hlcyBiZWZvcmUgdGhlbS5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7Jy5hJzogeydbYl0nOiAyfX0pLnRvLm5lc3RlZC5pbmNsdWRlKHsnXFxcXC5hLlxcXFxbYlxcXFxdJzogMn0pO1xuICAgKlxuICAgKiBgLmRlZXBgIGFuZCBgLm5lc3RlZGAgY2FuIGJlIGNvbWJpbmVkLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiB7YjogW3tjOiAzfV19fSkudG8uZGVlcC5uZXN0ZWQuaW5jbHVkZSh7J2EuYlswXSc6IHtjOiAzfX0pO1xuICAgKlxuICAgKiBgLm93bmAgYW5kIGAubmVzdGVkYCBjYW5ub3QgYmUgY29tYmluZWQuXG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuaW5jbHVkZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicpLnRvLm5vdC5pbmNsdWRlKCd0YWNvJyk7XG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5ub3QuaW5jbHVkZSg0KTtcbiAgICpcbiAgICogSG93ZXZlciwgaXQncyBkYW5nZXJvdXMgdG8gbmVnYXRlIGAuaW5jbHVkZWAgd2hlbiB0aGUgdGFyZ2V0IGlzIGFuIG9iamVjdC5cbiAgICogVGhlIHByb2JsZW0gaXMgdGhhdCBpdCBjcmVhdGVzIHVuY2VydGFpbiBleHBlY3RhdGlvbnMgYnkgYXNzZXJ0aW5nIHRoYXQgdGhlXG4gICAqIHRhcmdldCBvYmplY3QgZG9lc24ndCBoYXZlIGFsbCBvZiBgdmFsYCdzIGtleS92YWx1ZSBwYWlycyBidXQgbWF5IG9yIG1heVxuICAgKiBub3QgaGF2ZSBzb21lIG9mIHRoZW0uIEl0J3Mgb2Z0ZW4gYmVzdCB0byBpZGVudGlmeSB0aGUgZXhhY3Qgb3V0cHV0IHRoYXQnc1xuICAgKiBleHBlY3RlZCwgYW5kIHRoZW4gd3JpdGUgYW4gYXNzZXJ0aW9uIHRoYXQgb25seSBhY2NlcHRzIHRoYXQgZXhhY3Qgb3V0cHV0LlxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgb2JqZWN0IGlzbid0IGV2ZW4gZXhwZWN0ZWQgdG8gaGF2ZSBgdmFsYCdzIGtleXMsIGl0J3NcbiAgICogb2Z0ZW4gYmVzdCB0byBhc3NlcnQgZXhhY3RseSB0aGF0LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHtjOiAzfSkudG8ubm90LmhhdmUuYW55LmtleXMoJ2EnLCAnYicpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHtjOiAzfSkudG8ubm90LmluY2x1ZGUoe2E6IDEsIGI6IDJ9KTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBvYmplY3QgaXMgZXhwZWN0ZWQgdG8gaGF2ZSBgdmFsYCdzIGtleXMsIGl0J3Mgb2Z0ZW4gYmVzdCB0b1xuICAgKiBhc3NlcnQgdGhhdCBlYWNoIG9mIHRoZSBwcm9wZXJ0aWVzIGhhcyBpdHMgZXhwZWN0ZWQgdmFsdWUsIHJhdGhlciB0aGFuXG4gICAqIGFzc2VydGluZyB0aGF0IGVhY2ggcHJvcGVydHkgZG9lc24ndCBoYXZlIG9uZSBvZiBtYW55IHVuZXhwZWN0ZWQgdmFsdWVzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAzLCBiOiA0fSkudG8uaW5jbHVkZSh7YTogMywgYjogNH0pOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHthOiAzLCBiOiA0fSkudG8ubm90LmluY2x1ZGUoe2E6IDEsIGI6IDJ9KTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAuaW5jbHVkZWAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvclxuICAgKiBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhc1xuICAgKiB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaW5jbHVkZSg0LCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uaW5jbHVkZSg0KTtcbiAgICpcbiAgICogYC5pbmNsdWRlYCBjYW4gYWxzbyBiZSB1c2VkIGFzIGEgbGFuZ3VhZ2UgY2hhaW4sIGNhdXNpbmcgYWxsIGAubWVtYmVyc2AgYW5kXG4gICAqIGAua2V5c2AgYXNzZXJ0aW9ucyB0aGF0IGZvbGxvdyBpbiB0aGUgY2hhaW4gdG8gcmVxdWlyZSB0aGUgdGFyZ2V0IHRvIGJlIGFcbiAgICogc3VwZXJzZXQgb2YgdGhlIGV4cGVjdGVkIHNldCwgcmF0aGVyIHRoYW4gYW4gaWRlbnRpY2FsIHNldC4gTm90ZSB0aGF0XG4gICAqIGAubWVtYmVyc2AgaWdub3JlcyBkdXBsaWNhdGVzIGluIHRoZSBzdWJzZXQgd2hlbiBgLmluY2x1ZGVgIGlzIGFkZGVkLlxuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IG9iamVjdCdzIGtleXMgYXJlIGEgc3VwZXJzZXQgb2YgWydhJywgJ2InXSBidXQgbm90IGlkZW50aWNhbFxuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyLCBjOiAzfSkudG8uaW5jbHVkZS5hbGwua2V5cygnYScsICdiJyk7XG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDIsIGM6IDN9KS50by5ub3QuaGF2ZS5hbGwua2V5cygnYScsICdiJyk7XG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgYXJyYXkgaXMgYSBzdXBlcnNldCBvZiBbMSwgMl0gYnV0IG5vdCBpZGVudGljYWxcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmluY2x1ZGUubWVtYmVycyhbMSwgMl0pO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8ubm90LmhhdmUubWVtYmVycyhbMSwgMl0pO1xuICAgKlxuICAgKiAgICAgLy8gRHVwbGljYXRlcyBpbiB0aGUgc3Vic2V0IGFyZSBpZ25vcmVkXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5pbmNsdWRlLm1lbWJlcnMoWzEsIDIsIDIsIDJdKTtcbiAgICpcbiAgICogTm90ZSB0aGF0IGFkZGluZyBgLmFueWAgZWFybGllciBpbiB0aGUgY2hhaW4gY2F1c2VzIHRoZSBgLmtleXNgIGFzc2VydGlvblxuICAgKiB0byBpZ25vcmUgYC5pbmNsdWRlYC5cbiAgICpcbiAgICogICAgIC8vIEJvdGggYXNzZXJ0aW9ucyBhcmUgaWRlbnRpY2FsXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5pbmNsdWRlLmFueS5rZXlzKCdhJywgJ2InKTtcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmhhdmUuYW55LmtleXMoJ2EnLCAnYicpO1xuICAgKlxuICAgKiBUaGUgYWxpYXNlcyBgLmluY2x1ZGVzYCwgYC5jb250YWluYCwgYW5kIGAuY29udGFpbnNgIGNhbiBiZSB1c2VkXG4gICAqIGludGVyY2hhbmdlYWJseSB3aXRoIGAuaW5jbHVkZWAuXG4gICAqXG4gICAqIEBuYW1lIGluY2x1ZGVcbiAgICogQGFsaWFzIGNvbnRhaW5cbiAgICogQGFsaWFzIGluY2x1ZGVzXG4gICAqIEBhbGlhcyBjb250YWluc1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIFNhbWVWYWx1ZVplcm8oYSwgYikge1xuICAgIHJldHVybiAoXy5pc05hTihhKSAmJiBfLmlzTmFOKGIpKSB8fCBhID09PSBiO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5jbHVkZUNoYWluaW5nQmVoYXZpb3IgKCkge1xuICAgIGZsYWcodGhpcywgJ2NvbnRhaW5zJywgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbmNsdWRlICh2YWwsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuXG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIG9ialR5cGUgPSBfLnR5cGUob2JqKS50b0xvd2VyQ2FzZSgpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgbmVnYXRlID0gZmxhZyh0aGlzLCAnbmVnYXRlJylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKVxuICAgICAgLCBpc0RlZXAgPSBmbGFnKHRoaXMsICdkZWVwJylcbiAgICAgICwgZGVzY3JpcHRvciA9IGlzRGVlcCA/ICdkZWVwICcgOiAnJztcblxuICAgIGZsYWdNc2cgPSBmbGFnTXNnID8gZmxhZ01zZyArICc6ICcgOiAnJztcblxuICAgIHZhciBpbmNsdWRlZCA9IGZhbHNlO1xuXG4gICAgc3dpdGNoIChvYmpUeXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICBpbmNsdWRlZCA9IG9iai5pbmRleE9mKHZhbCkgIT09IC0xO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnd2Vha3NldCc6XG4gICAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoXG4gICAgICAgICAgICBmbGFnTXNnICsgJ3VuYWJsZSB0byB1c2UgLmRlZXAuaW5jbHVkZSB3aXRoIFdlYWtTZXQnLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgc3NmaVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpbmNsdWRlZCA9IG9iai5oYXModmFsKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ21hcCc6XG4gICAgICAgIHZhciBpc0VxbCA9IGlzRGVlcCA/IF8uZXFsIDogU2FtZVZhbHVlWmVybztcbiAgICAgICAgb2JqLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICBpbmNsdWRlZCA9IGluY2x1ZGVkIHx8IGlzRXFsKGl0ZW0sIHZhbCk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICAgIG9iai5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBpbmNsdWRlZCA9IGluY2x1ZGVkIHx8IF8uZXFsKGl0ZW0sIHZhbCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5jbHVkZWQgPSBvYmouaGFzKHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICAgIGluY2x1ZGVkID0gb2JqLnNvbWUoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBfLmVxbChpdGVtLCB2YWwpO1xuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5jbHVkZWQgPSBvYmouaW5kZXhPZih2YWwpICE9PSAtMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gVGhpcyBibG9jayBpcyBmb3IgYXNzZXJ0aW5nIGEgc3Vic2V0IG9mIHByb3BlcnRpZXMgaW4gYW4gb2JqZWN0LlxuICAgICAgICAvLyBgXy5leHBlY3RUeXBlc2AgaXNuJ3QgdXNlZCBoZXJlIGJlY2F1c2UgYC5pbmNsdWRlYCBzaG91bGQgd29yayB3aXRoXG4gICAgICAgIC8vIG9iamVjdHMgd2l0aCBhIGN1c3RvbSBgQEB0b1N0cmluZ1RhZ2AuXG4gICAgICAgIGlmICh2YWwgIT09IE9iamVjdCh2YWwpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKFxuICAgICAgICAgICAgZmxhZ01zZyArICdvYmplY3QgdGVzdGVkIG11c3QgYmUgYW4gYXJyYXksIGEgbWFwLCBhbiBvYmplY3QsJ1xuICAgICAgICAgICAgICArICcgYSBzZXQsIGEgc3RyaW5nLCBvciBhIHdlYWtzZXQsIGJ1dCAnICsgb2JqVHlwZSArICcgZ2l2ZW4nLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgc3NmaVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJvcHMgPSBPYmplY3Qua2V5cyh2YWwpXG4gICAgICAgICAgLCBmaXJzdEVyciA9IG51bGxcbiAgICAgICAgICAsIG51bUVycnMgPSAwO1xuXG4gICAgICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICB2YXIgcHJvcEFzc2VydGlvbiA9IG5ldyBBc3NlcnRpb24ob2JqKTtcbiAgICAgICAgICBfLnRyYW5zZmVyRmxhZ3ModGhpcywgcHJvcEFzc2VydGlvbiwgdHJ1ZSk7XG4gICAgICAgICAgZmxhZyhwcm9wQXNzZXJ0aW9uLCAnbG9ja1NzZmknLCB0cnVlKTtcblxuICAgICAgICAgIGlmICghbmVnYXRlIHx8IHByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcHJvcEFzc2VydGlvbi5wcm9wZXJ0eShwcm9wLCB2YWxbcHJvcF0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm9wQXNzZXJ0aW9uLnByb3BlcnR5KHByb3AsIHZhbFtwcm9wXSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoIV8uY2hlY2tFcnJvci5jb21wYXRpYmxlQ29uc3RydWN0b3IoZXJyLCBBc3NlcnRpb25FcnJvcikpIHtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0RXJyID09PSBudWxsKSBmaXJzdEVyciA9IGVycjtcbiAgICAgICAgICAgIG51bUVycnMrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIC8vIFdoZW4gdmFsaWRhdGluZyAubm90LmluY2x1ZGUgd2l0aCBtdWx0aXBsZSBwcm9wZXJ0aWVzLCB3ZSBvbmx5IHdhbnRcbiAgICAgICAgLy8gdG8gdGhyb3cgYW4gYXNzZXJ0aW9uIGVycm9yIGlmIGFsbCBvZiB0aGUgcHJvcGVydGllcyBhcmUgaW5jbHVkZWQsXG4gICAgICAgIC8vIGluIHdoaWNoIGNhc2Ugd2UgdGhyb3cgdGhlIGZpcnN0IHByb3BlcnR5IGFzc2VydGlvbiBlcnJvciB0aGF0IHdlXG4gICAgICAgIC8vIGVuY291bnRlcmVkLlxuICAgICAgICBpZiAobmVnYXRlICYmIHByb3BzLmxlbmd0aCA+IDEgJiYgbnVtRXJycyA9PT0gcHJvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgZmlyc3RFcnI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEFzc2VydCBpbmNsdXNpb24gaW4gY29sbGVjdGlvbiBvciBzdWJzdHJpbmcgaW4gYSBzdHJpbmcuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBpbmNsdWRlZFxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byAnICsgZGVzY3JpcHRvciArICdpbmNsdWRlICcgKyBfLmluc3BlY3QodmFsKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgJyArIGRlc2NyaXB0b3IgKyAnaW5jbHVkZSAnICsgXy5pbnNwZWN0KHZhbCkpO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnaW5jbHVkZScsIGluY2x1ZGUsIGluY2x1ZGVDaGFpbmluZ0JlaGF2aW9yKTtcbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnY29udGFpbicsIGluY2x1ZGUsIGluY2x1ZGVDaGFpbmluZ0JlaGF2aW9yKTtcbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnY29udGFpbnMnLCBpbmNsdWRlLCBpbmNsdWRlQ2hhaW5pbmdCZWhhdmlvcik7XG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2luY2x1ZGVzJywgaW5jbHVkZSwgaW5jbHVkZUNoYWluaW5nQmVoYXZpb3IpO1xuXG4gIC8qKlxuICAgKiAjIyMgLm9rXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGEgdHJ1dGh5IHZhbHVlIChjb25zaWRlcmVkIGB0cnVlYCBpbiBib29sZWFuIGNvbnRleHQpLlxuICAgKiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBzdHJpY3RseSAoYD09PWApIG9yXG4gICAqIGRlZXBseSBlcXVhbCB0byBpdHMgZXhwZWN0ZWQgdmFsdWUuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uZXF1YWwoMSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMSkudG8uYmUub2s7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KHRydWUpLnRvLmJlLnRydWU7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QodHJ1ZSkudG8uYmUub2s7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLm9rYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgwKS50by5lcXVhbCgwKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgwKS50by5ub3QuYmUub2s7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZhbHNlKS50by5iZS5mYWxzZTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChmYWxzZSkudG8ubm90LmJlLm9rOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdChudWxsKS50by5iZS5udWxsOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KG51bGwpLnRvLm5vdC5iZS5vazsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QodW5kZWZpbmVkKS50by5iZS51bmRlZmluZWQ7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QodW5kZWZpbmVkKS50by5ub3QuYmUub2s7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBIGN1c3RvbSBlcnJvciBtZXNzYWdlIGNhbiBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZhbHNlLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUub2s7XG4gICAqXG4gICAqIEBuYW1lIG9rXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnb2snLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHRydXRoeSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgZmFsc3knKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAudHJ1ZVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBzdHJpY3RseSAoYD09PWApIGVxdWFsIHRvIGB0cnVlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh0cnVlKS50by5iZS50cnVlO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLnRydWVgLiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3RcbiAgICogdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCB0byBpdHMgZXhwZWN0ZWQgdmFsdWUsIHJhdGhlciB0aGFuIG5vdFxuICAgKiBlcXVhbCB0byBgdHJ1ZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoZmFsc2UpLnRvLmJlLmZhbHNlOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KGZhbHNlKS50by5ub3QuYmUudHJ1ZTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uZXF1YWwoMSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMSkudG8ubm90LmJlLnRydWU7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBIGN1c3RvbSBlcnJvciBtZXNzYWdlIGNhbiBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZhbHNlLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUudHJ1ZTtcbiAgICpcbiAgICogQG5hbWUgdHJ1ZVxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ3RydWUnLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHRydWUgPT09IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHRydWUnXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGZhbHNlJ1xuICAgICAgLCBmbGFnKHRoaXMsICduZWdhdGUnKSA/IGZhbHNlIDogdHJ1ZVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmZhbHNlXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIHN0cmljdGx5IChgPT09YCkgZXF1YWwgdG8gYGZhbHNlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdChmYWxzZSkudG8uYmUuZmFsc2U7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuZmFsc2VgLiBIb3dldmVyLCBpdCdzIG9mdGVuXG4gICAqIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCB0byBpdHMgZXhwZWN0ZWQgdmFsdWUsIHJhdGhlciB0aGFuXG4gICAqIG5vdCBlcXVhbCB0byBgZmFsc2VgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHRydWUpLnRvLmJlLnRydWU7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QodHJ1ZSkudG8ubm90LmJlLmZhbHNlOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgxKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3QuYmUuZmFsc2U7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBIGN1c3RvbSBlcnJvciBtZXNzYWdlIGNhbiBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHRydWUsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5mYWxzZTtcbiAgICpcbiAgICogQG5hbWUgZmFsc2VcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdmYWxzZScsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgZmFsc2UgPT09IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGZhbHNlJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSB0cnVlJ1xuICAgICAgLCBmbGFnKHRoaXMsICduZWdhdGUnKSA/IHRydWUgOiBmYWxzZVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLm51bGxcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgc3RyaWN0bHkgKGA9PT1gKSBlcXVhbCB0byBgbnVsbGAuXG4gICAqXG4gICAqICAgICBleHBlY3QobnVsbCkudG8uYmUubnVsbDtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5udWxsYC4gSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0XG4gICAqIHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgdG8gaXRzIGV4cGVjdGVkIHZhbHVlLCByYXRoZXIgdGhhbiBub3RcbiAgICogZXF1YWwgdG8gYG51bGxgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmVxdWFsKDEpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEpLnRvLm5vdC5iZS5udWxsOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCg0MiwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLm51bGw7XG4gICAqXG4gICAqIEBuYW1lIG51bGxcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdudWxsJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBudWxsID09PSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBudWxsJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgbnVsbCdcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC51bmRlZmluZWRcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgc3RyaWN0bHkgKGA9PT1gKSBlcXVhbCB0byBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh1bmRlZmluZWQpLnRvLmJlLnVuZGVmaW5lZDtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC51bmRlZmluZWRgLiBIb3dldmVyLCBpdCdzIG9mdGVuXG4gICAqIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCB0byBpdHMgZXhwZWN0ZWQgdmFsdWUsIHJhdGhlciB0aGFuXG4gICAqIG5vdCBlcXVhbCB0byBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgxKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3QuYmUudW5kZWZpbmVkOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCg0MiwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLnVuZGVmaW5lZDtcbiAgICpcbiAgICogQG5hbWUgdW5kZWZpbmVkXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgndW5kZWZpbmVkJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB1bmRlZmluZWQgPT09IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHVuZGVmaW5lZCdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIGJlIHVuZGVmaW5lZCdcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5OYU5cbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgZXhhY3RseSBgTmFOYC5cbiAgICpcbiAgICogICAgIGV4cGVjdChOYU4pLnRvLmJlLk5hTjtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5OYU5gLiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3RcbiAgICogdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCB0byBpdHMgZXhwZWN0ZWQgdmFsdWUsIHJhdGhlciB0aGFuIG5vdFxuICAgKiBlcXVhbCB0byBgTmFOYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uZXF1YWwoJ2ZvbycpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5ub3QuYmUuTmFOOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQSBjdXN0b20gZXJyb3IgbWVzc2FnZSBjYW4gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCg0MiwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLk5hTjtcbiAgICpcbiAgICogQG5hbWUgTmFOXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnTmFOJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBfLmlzTmFOKGZsYWcodGhpcywgJ29iamVjdCcpKVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIE5hTidcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgTmFOJ1xuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmV4aXN0XG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIG5vdCBzdHJpY3RseSAoYD09PWApIGVxdWFsIHRvIGVpdGhlciBgbnVsbGAgb3JcbiAgICogYHVuZGVmaW5lZGAuIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIHRvXG4gICAqIGl0cyBleHBlY3RlZCB2YWx1ZS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgxKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5leGlzdDsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QoMCkudG8uZXF1YWwoMCk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMCkudG8uZXhpc3Q7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmV4aXN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdChudWxsKS50by5iZS5udWxsOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KG51bGwpLnRvLm5vdC5leGlzdDsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QodW5kZWZpbmVkKS50by5iZS51bmRlZmluZWQ7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QodW5kZWZpbmVkKS50by5ub3QuZXhpc3Q7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBIGN1c3RvbSBlcnJvciBtZXNzYWdlIGNhbiBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KG51bGwsICdub29vIHdoeSBmYWlsPz8nKS50by5leGlzdDtcbiAgICpcbiAgICogQG5hbWUgZXhpc3RcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdleGlzdCcsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHZhbCAhPT0gbnVsbCAmJiB2YWwgIT09IHVuZGVmaW5lZFxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBleGlzdCdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGV4aXN0J1xuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmVtcHR5XG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBhIHN0cmluZyBvciBhcnJheSwgYC5lbXB0eWAgYXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQnc1xuICAgKiBgbGVuZ3RoYCBwcm9wZXJ0eSBpcyBzdHJpY3RseSAoYD09PWApIGVxdWFsIHRvIGAwYC5cbiAgICpcbiAgICogICAgIGV4cGVjdChbXSkudG8uYmUuZW1wdHk7XG4gICAqICAgICBleHBlY3QoJycpLnRvLmJlLmVtcHR5O1xuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgYSBtYXAgb3Igc2V0LCBgLmVtcHR5YCBhc3NlcnRzIHRoYXQgdGhlIHRhcmdldCdzIGBzaXplYFxuICAgKiBwcm9wZXJ0eSBpcyBzdHJpY3RseSBlcXVhbCB0byBgMGAuXG4gICAqXG4gICAqICAgICBleHBlY3QobmV3IFNldCgpKS50by5iZS5lbXB0eTtcbiAgICogICAgIGV4cGVjdChuZXcgTWFwKCkpLnRvLmJlLmVtcHR5O1xuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgYSBub24tZnVuY3Rpb24gb2JqZWN0LCBgLmVtcHR5YCBhc3NlcnRzIHRoYXQgdGhlIHRhcmdldFxuICAgKiBkb2Vzbid0IGhhdmUgYW55IG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIFByb3BlcnRpZXMgd2l0aCBTeW1ib2wtYmFzZWRcbiAgICoga2V5cyBhcmUgZXhjbHVkZWQgZnJvbSB0aGUgY291bnQuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe30pLnRvLmJlLmVtcHR5O1xuICAgKlxuICAgKiBCZWNhdXNlIGAuZW1wdHlgIGRvZXMgZGlmZmVyZW50IHRoaW5ncyBiYXNlZCBvbiB0aGUgdGFyZ2V0J3MgdHlwZSwgaXQnc1xuICAgKiBpbXBvcnRhbnQgdG8gY2hlY2sgdGhlIHRhcmdldCdzIHR5cGUgYmVmb3JlIHVzaW5nIGAuZW1wdHlgLiBTZWUgdGhlIGAuYWBcbiAgICogZG9jIGZvciBpbmZvIG9uIHRlc3RpbmcgYSB0YXJnZXQncyB0eXBlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFtdKS50by5iZS5hbignYXJyYXknKS50aGF0LmlzLmVtcHR5O1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmVtcHR5YC4gSG93ZXZlciwgaXQncyBvZnRlblxuICAgKiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgY29udGFpbnMgaXRzIGV4cGVjdGVkIG51bWJlciBvZiB2YWx1ZXMsXG4gICAqIHJhdGhlciB0aGFuIGFzc2VydGluZyB0aGF0IGl0J3Mgbm90IGVtcHR5LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZigzKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLm5vdC5iZS5lbXB0eTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QobmV3IFNldChbMSwgMiwgM10pKS50by5oYXZlLnByb3BlcnR5KCdzaXplJywgMyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QobmV3IFNldChbMSwgMiwgM10pKS50by5ub3QuYmUuZW1wdHk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KE9iamVjdC5rZXlzKHthOiAxfSkpLnRvLmhhdmUubGVuZ3RoT2YoMSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5ub3QuYmUuZW1wdHk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBIGN1c3RvbSBlcnJvciBtZXNzYWdlIGNhbiBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLmVtcHR5O1xuICAgKlxuICAgKiBAbmFtZSBlbXB0eVxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2VtcHR5JywgZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWwgPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgaXRlbXNDb3VudDtcblxuICAgIGZsYWdNc2cgPSBmbGFnTXNnID8gZmxhZ01zZyArICc6ICcgOiAnJztcblxuICAgIHN3aXRjaCAoXy50eXBlKHZhbCkudG9Mb3dlckNhc2UoKSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgaXRlbXNDb3VudCA9IHZhbC5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWFwJzpcbiAgICAgIGNhc2UgJ3NldCc6XG4gICAgICAgIGl0ZW1zQ291bnQgPSB2YWwuc2l6ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd3ZWFrbWFwJzpcbiAgICAgIGNhc2UgJ3dlYWtzZXQnOlxuICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoXG4gICAgICAgICAgZmxhZ01zZyArICcuZW1wdHkgd2FzIHBhc3NlZCBhIHdlYWsgY29sbGVjdGlvbicsXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIHNzZmlcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgdmFyIG1zZyA9IGZsYWdNc2cgKyAnLmVtcHR5IHdhcyBwYXNzZWQgYSBmdW5jdGlvbiAnICsgXy5nZXROYW1lKHZhbCk7XG4gICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihtc2cudHJpbSgpLCB1bmRlZmluZWQsIHNzZmkpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHZhbCAhPT0gT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoXG4gICAgICAgICAgICBmbGFnTXNnICsgJy5lbXB0eSB3YXMgcGFzc2VkIG5vbi1zdHJpbmcgcHJpbWl0aXZlICcgKyBfLmluc3BlY3QodmFsKSxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNzZmlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGl0ZW1zQ291bnQgPSBPYmplY3Qua2V5cyh2YWwpLmxlbmd0aDtcbiAgICB9XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgMCA9PT0gaXRlbXNDb3VudFxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBlbXB0eSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIGJlIGVtcHR5J1xuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmFyZ3VtZW50c1xuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gICAqXG4gICAqICAgICBmdW5jdGlvbiB0ZXN0ICgpIHtcbiAgICogICAgICAgZXhwZWN0KGFyZ3VtZW50cykudG8uYmUuYXJndW1lbnRzO1xuICAgKiAgICAgfVxuICAgKlxuICAgKiAgICAgdGVzdCgpO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmFyZ3VtZW50c2AuIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW5cbiAgICogYmVzdCB0byBhc3NlcnQgd2hpY2ggdHlwZSB0aGUgdGFyZ2V0IGlzIGV4cGVjdGVkIHRvIGJlLCByYXRoZXIgdGhhblxuICAgKiBhc3NlcnRpbmcgdGhhdCBpdHMgbm90IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uYmUuYSgnc3RyaW5nJyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLm5vdC5iZS5hcmd1bWVudHM7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBIGN1c3RvbSBlcnJvciBtZXNzYWdlIGNhbiBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHt9LCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUuYXJndW1lbnRzO1xuICAgKlxuICAgKiBUaGUgYWxpYXMgYC5Bcmd1bWVudHNgIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAuYXJndW1lbnRzYC5cbiAgICpcbiAgICogQG5hbWUgYXJndW1lbnRzXG4gICAqIEBhbGlhcyBBcmd1bWVudHNcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gY2hlY2tBcmd1bWVudHMgKCkge1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCB0eXBlID0gXy50eXBlKG9iaik7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICdBcmd1bWVudHMnID09PSB0eXBlXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGFyZ3VtZW50cyBidXQgZ290ICcgKyB0eXBlXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSBhcmd1bWVudHMnXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnYXJndW1lbnRzJywgY2hlY2tBcmd1bWVudHMpO1xuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ0FyZ3VtZW50cycsIGNoZWNrQXJndW1lbnRzKTtcblxuICAvKipcbiAgICogIyMjIC5lcXVhbCh2YWxbLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBzdHJpY3RseSAoYD09PWApIGVxdWFsIHRvIHRoZSBnaXZlbiBgdmFsYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgxKTtcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uZXF1YWwoJ2ZvbycpO1xuICAgKlxuICAgKiBBZGQgYC5kZWVwYCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byB1c2UgZGVlcCBlcXVhbGl0eSBpbnN0ZWFkLiBTZWUgdGhlXG4gICAqIGBkZWVwLWVxbGAgcHJvamVjdCBwYWdlIGZvciBpbmZvIG9uIHRoZSBkZWVwIGVxdWFsaXR5IGFsZ29yaXRobTpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2NoYWlqcy9kZWVwLWVxbC5cbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBvYmplY3QgZGVlcGx5IChidXQgbm90IHN0cmljdGx5KSBlcXVhbHMgYHthOiAxfWBcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmRlZXAuZXF1YWwoe2E6IDF9KTtcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLm5vdC5lcXVhbCh7YTogMX0pO1xuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IGFycmF5IGRlZXBseSAoYnV0IG5vdCBzdHJpY3RseSkgZXF1YWxzIGBbMSwgMl1gXG4gICAqICAgICBleHBlY3QoWzEsIDJdKS50by5kZWVwLmVxdWFsKFsxLCAyXSk7XG4gICAqICAgICBleHBlY3QoWzEsIDJdKS50by5ub3QuZXF1YWwoWzEsIDJdKTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5lcXVhbGAuIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW5cbiAgICogYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIHRvIGl0cyBleHBlY3RlZCB2YWx1ZSwgcmF0aGVyIHRoYW5cbiAgICogbm90IGVxdWFsIHRvIG9uZSBvZiBjb3VudGxlc3MgdW5leHBlY3RlZCB2YWx1ZXMuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uZXF1YWwoMSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMSkudG8ubm90LmVxdWFsKDIpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC5lcXVhbGAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gICAqIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhcyB0aGVcbiAgICogc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmVxdWFsKDIsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdCgxLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uZXF1YWwoMik7XG4gICAqXG4gICAqIFRoZSBhbGlhc2VzIGAuZXF1YWxzYCBhbmQgYGVxYCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLmVxdWFsYC5cbiAgICpcbiAgICogQG5hbWUgZXF1YWxcbiAgICogQGFsaWFzIGVxdWFsc1xuICAgKiBAYWxpYXMgZXFcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRFcXVhbCAodmFsLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgaWYgKGZsYWcodGhpcywgJ2RlZXAnKSkge1xuICAgICAgdmFyIHByZXZMb2NrU3NmaSA9IGZsYWcodGhpcywgJ2xvY2tTc2ZpJyk7XG4gICAgICBmbGFnKHRoaXMsICdsb2NrU3NmaScsIHRydWUpO1xuICAgICAgdGhpcy5lcWwodmFsKTtcbiAgICAgIGZsYWcodGhpcywgJ2xvY2tTc2ZpJywgcHJldkxvY2tTc2ZpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgdmFsID09PSBvYmpcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBlcXVhbCAje2V4cH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGVxdWFsICN7ZXhwfSdcbiAgICAgICAgLCB2YWxcbiAgICAgICAgLCB0aGlzLl9vYmpcbiAgICAgICAgLCB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2VxdWFsJywgYXNzZXJ0RXF1YWwpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdlcXVhbHMnLCBhc3NlcnRFcXVhbCk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2VxJywgYXNzZXJ0RXF1YWwpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmVxbChvYmpbLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBkZWVwbHkgZXF1YWwgdG8gdGhlIGdpdmVuIGBvYmpgLiBTZWUgdGhlXG4gICAqIGBkZWVwLWVxbGAgcHJvamVjdCBwYWdlIGZvciBpbmZvIG9uIHRoZSBkZWVwIGVxdWFsaXR5IGFsZ29yaXRobTpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2NoYWlqcy9kZWVwLWVxbC5cbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBvYmplY3QgaXMgZGVlcGx5IChidXQgbm90IHN0cmljdGx5KSBlcXVhbCB0byB7YTogMX1cbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmVxbCh7YTogMX0pLmJ1dC5ub3QuZXF1YWwoe2E6IDF9KTtcbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBhcnJheSBpcyBkZWVwbHkgKGJ1dCBub3Qgc3RyaWN0bHkpIGVxdWFsIHRvIFsxLCAyXVxuICAgKiAgICAgZXhwZWN0KFsxLCAyXSkudG8uZXFsKFsxLCAyXSkuYnV0Lm5vdC5lcXVhbChbMSwgMl0pO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmVxbGAuIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdFxuICAgKiB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0IGlzIGRlZXBseSBlcXVhbCB0byBpdHMgZXhwZWN0ZWQgdmFsdWUsIHJhdGhlclxuICAgKiB0aGFuIG5vdCBkZWVwbHkgZXF1YWwgdG8gb25lIG9mIGNvdW50bGVzcyB1bmV4cGVjdGVkIHZhbHVlcy5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmVxbCh7YTogMX0pOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8ubm90LmVxbCh7YjogMn0pOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC5lcWxgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICAgKiB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXMgdGhlXG4gICAqIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmVxbCh7YjogMn0sICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdCh7YTogMX0sICdub29vIHdoeSBmYWlsPz8nKS50by5lcWwoe2I6IDJ9KTtcbiAgICpcbiAgICogVGhlIGFsaWFzIGAuZXFsc2AgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5lcWxgLlxuICAgKlxuICAgKiBUaGUgYC5kZWVwLmVxdWFsYCBhc3NlcnRpb24gaXMgYWxtb3N0IGlkZW50aWNhbCB0byBgLmVxbGAgYnV0IHdpdGggb25lXG4gICAqIGRpZmZlcmVuY2U6IGAuZGVlcC5lcXVhbGAgY2F1c2VzIGRlZXAgZXF1YWxpdHkgY29tcGFyaXNvbnMgdG8gYWxzbyBiZSB1c2VkXG4gICAqIGZvciBhbnkgb3RoZXIgYXNzZXJ0aW9ucyB0aGF0IGZvbGxvdyBpbiB0aGUgY2hhaW4uXG4gICAqXG4gICAqIEBuYW1lIGVxbFxuICAgKiBAYWxpYXMgZXFsc1xuICAgKiBAcGFyYW0ge01peGVkfSBvYmpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEVxbChvYmosIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBfLmVxbChvYmosIGZsYWcodGhpcywgJ29iamVjdCcpKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBkZWVwbHkgZXF1YWwgI3tleHB9J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgZGVlcGx5IGVxdWFsICN7ZXhwfSdcbiAgICAgICwgb2JqXG4gICAgICAsIHRoaXMuX29ialxuICAgICAgLCB0cnVlXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2VxbCcsIGFzc2VydEVxbCk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2VxbHMnLCBhc3NlcnRFcWwpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmFib3ZlKG5bLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBhIG51bWJlciBvciBhIGRhdGUgZ3JlYXRlciB0aGFuIHRoZSBnaXZlbiBudW1iZXIgb3IgZGF0ZSBgbmAgcmVzcGVjdGl2ZWx5LlxuICAgKiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCB0byBpdHMgZXhwZWN0ZWRcbiAgICogdmFsdWUuXG4gICAqXG4gICAqICAgICBleHBlY3QoMikudG8uZXF1YWwoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMikudG8uYmUuYWJvdmUoMSk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5sZW5ndGhPZmAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCdzIGBsZW5ndGhgXG4gICAqIG9yIGBzaXplYCBpcyBncmVhdGVyIHRoYW4gdGhlIGdpdmVuIG51bWJlciBgbmAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoT2YoMyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoT2YuYWJvdmUoMik7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZigzKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YuYWJvdmUoMik7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmFib3ZlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgyKS50by5lcXVhbCgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3QuYmUuYWJvdmUoMik7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLmFib3ZlYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAgICogdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzIHRoZVxuICAgKiBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uYmUuYWJvdmUoMiwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KDEsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5hYm92ZSgyKTtcbiAgICpcbiAgICogVGhlIGFsaWFzZXMgYC5ndGAgYW5kIGAuZ3JlYXRlclRoYW5gIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoXG4gICAqIGAuYWJvdmVgLlxuICAgKlxuICAgKiBAbmFtZSBhYm92ZVxuICAgKiBAYWxpYXMgZ3RcbiAgICogQGFsaWFzIGdyZWF0ZXJUaGFuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRBYm92ZSAobiwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGRvTGVuZ3RoID0gZmxhZyh0aGlzLCAnZG9MZW5ndGgnKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIG1zZ1ByZWZpeCA9ICgoZmxhZ01zZykgPyBmbGFnTXNnICsgJzogJyA6ICcnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpXG4gICAgICAsIG9ialR5cGUgPSBfLnR5cGUob2JqKS50b0xvd2VyQ2FzZSgpXG4gICAgICAsIG5UeXBlID0gXy50eXBlKG4pLnRvTG93ZXJDYXNlKClcbiAgICAgICwgZXJyb3JNZXNzYWdlXG4gICAgICAsIHNob3VsZFRocm93ID0gdHJ1ZTtcblxuICAgIGlmIChkb0xlbmd0aCAmJiBvYmpUeXBlICE9PSAnbWFwJyAmJiBvYmpUeXBlICE9PSAnc2V0Jykge1xuICAgICAgbmV3IEFzc2VydGlvbihvYmosIGZsYWdNc2csIHNzZmksIHRydWUpLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgIH1cblxuICAgIGlmICghZG9MZW5ndGggJiYgKG9ialR5cGUgPT09ICdkYXRlJyAmJiBuVHlwZSAhPT0gJ2RhdGUnKSkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gbXNnUHJlZml4ICsgJ3RoZSBhcmd1bWVudCB0byBhYm92ZSBtdXN0IGJlIGEgZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChuVHlwZSAhPT0gJ251bWJlcicgJiYgKGRvTGVuZ3RoIHx8IG9ialR5cGUgPT09ICdudW1iZXInKSkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gbXNnUHJlZml4ICsgJ3RoZSBhcmd1bWVudCB0byBhYm92ZSBtdXN0IGJlIGEgbnVtYmVyJztcbiAgICB9IGVsc2UgaWYgKCFkb0xlbmd0aCAmJiAob2JqVHlwZSAhPT0gJ2RhdGUnICYmIG9ialR5cGUgIT09ICdudW1iZXInKSkge1xuICAgICAgdmFyIHByaW50T2JqID0gKG9ialR5cGUgPT09ICdzdHJpbmcnKSA/IFwiJ1wiICsgb2JqICsgXCInXCIgOiBvYmo7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAnZXhwZWN0ZWQgJyArIHByaW50T2JqICsgJyB0byBiZSBhIG51bWJlciBvciBhIGRhdGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaG91bGRUaHJvdyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRUaHJvdykge1xuICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKGVycm9yTWVzc2FnZSwgdW5kZWZpbmVkLCBzc2ZpKTtcbiAgICB9XG5cbiAgICBpZiAoZG9MZW5ndGgpIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gJ2xlbmd0aCdcbiAgICAgICAgLCBpdGVtc0NvdW50O1xuICAgICAgaWYgKG9ialR5cGUgPT09ICdtYXAnIHx8IG9ialR5cGUgPT09ICdzZXQnKSB7XG4gICAgICAgIGRlc2NyaXB0b3IgPSAnc2l6ZSc7XG4gICAgICAgIGl0ZW1zQ291bnQgPSBvYmouc2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW1zQ291bnQgPSBvYmoubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgaXRlbXNDb3VudCA+IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgJyArIGRlc2NyaXB0b3IgKyAnIGFib3ZlICN7ZXhwfSBidXQgZ290ICN7YWN0fSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSBhICcgKyBkZXNjcmlwdG9yICsgJyBhYm92ZSAje2V4cH0nXG4gICAgICAgICwgblxuICAgICAgICAsIGl0ZW1zQ291bnRcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA+IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhYm92ZSAje2V4cH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYXQgbW9zdCAje2V4cH0nXG4gICAgICAgICwgblxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdhYm92ZScsIGFzc2VydEFib3ZlKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZ3QnLCBhc3NlcnRBYm92ZSk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2dyZWF0ZXJUaGFuJywgYXNzZXJ0QWJvdmUpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmxlYXN0KG5bLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBhIG51bWJlciBvciBhIGRhdGUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBnaXZlblxuICAgKiBudW1iZXIgb3IgZGF0ZSBgbmAgcmVzcGVjdGl2ZWx5LiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCB0b1xuICAgKiBpdHMgZXhwZWN0ZWQgdmFsdWUuXG4gICAqXG4gICAqICAgICBleHBlY3QoMikudG8uZXF1YWwoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMikudG8uYmUuYXQubGVhc3QoMSk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDIpLnRvLmJlLmF0LmxlYXN0KDIpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQWRkIGAubGVuZ3RoT2ZgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQncyBgbGVuZ3RoYFxuICAgKiBvciBgc2l6ZWAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBnaXZlbiBudW1iZXIgYG5gLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aE9mKDMpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aE9mLmF0LmxlYXN0KDIpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YoMyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mLmF0LmxlYXN0KDIpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5sZWFzdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uZXF1YWwoMSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMSkudG8ubm90LmJlLmF0LmxlYXN0KDIpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC5sZWFzdGAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gICAqIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhcyB0aGVcbiAgICogc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmJlLmF0LmxlYXN0KDIsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdCgxLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUuYXQubGVhc3QoMik7XG4gICAqXG4gICAqIFRoZSBhbGlhcyBgLmd0ZWAgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5sZWFzdGAuXG4gICAqXG4gICAqIEBuYW1lIGxlYXN0XG4gICAqIEBhbGlhcyBndGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydExlYXN0IChuLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgZG9MZW5ndGggPSBmbGFnKHRoaXMsICdkb0xlbmd0aCcpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgbXNnUHJlZml4ID0gKChmbGFnTXNnKSA/IGZsYWdNc2cgKyAnOiAnIDogJycpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJylcbiAgICAgICwgb2JqVHlwZSA9IF8udHlwZShvYmopLnRvTG93ZXJDYXNlKClcbiAgICAgICwgblR5cGUgPSBfLnR5cGUobikudG9Mb3dlckNhc2UoKVxuICAgICAgLCBlcnJvck1lc3NhZ2VcbiAgICAgICwgc2hvdWxkVGhyb3cgPSB0cnVlO1xuXG4gICAgaWYgKGRvTGVuZ3RoICYmIG9ialR5cGUgIT09ICdtYXAnICYmIG9ialR5cGUgIT09ICdzZXQnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkudG8uaGF2ZS5wcm9wZXJ0eSgnbGVuZ3RoJyk7XG4gICAgfVxuXG4gICAgaWYgKCFkb0xlbmd0aCAmJiAob2JqVHlwZSA9PT0gJ2RhdGUnICYmIG5UeXBlICE9PSAnZGF0ZScpKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAndGhlIGFyZ3VtZW50IHRvIGxlYXN0IG11c3QgYmUgYSBkYXRlJztcbiAgICB9IGVsc2UgaWYgKG5UeXBlICE9PSAnbnVtYmVyJyAmJiAoZG9MZW5ndGggfHwgb2JqVHlwZSA9PT0gJ251bWJlcicpKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAndGhlIGFyZ3VtZW50IHRvIGxlYXN0IG11c3QgYmUgYSBudW1iZXInO1xuICAgIH0gZWxzZSBpZiAoIWRvTGVuZ3RoICYmIChvYmpUeXBlICE9PSAnZGF0ZScgJiYgb2JqVHlwZSAhPT0gJ251bWJlcicpKSB7XG4gICAgICB2YXIgcHJpbnRPYmogPSAob2JqVHlwZSA9PT0gJ3N0cmluZycpID8gXCInXCIgKyBvYmogKyBcIidcIiA6IG9iajtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICdleHBlY3RlZCAnICsgcHJpbnRPYmogKyAnIHRvIGJlIGEgbnVtYmVyIG9yIGEgZGF0ZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZFRocm93ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRocm93KSB7XG4gICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoZXJyb3JNZXNzYWdlLCB1bmRlZmluZWQsIHNzZmkpO1xuICAgIH1cblxuICAgIGlmIChkb0xlbmd0aCkge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSAnbGVuZ3RoJ1xuICAgICAgICAsIGl0ZW1zQ291bnQ7XG4gICAgICBpZiAob2JqVHlwZSA9PT0gJ21hcCcgfHwgb2JqVHlwZSA9PT0gJ3NldCcpIHtcbiAgICAgICAgZGVzY3JpcHRvciA9ICdzaXplJztcbiAgICAgICAgaXRlbXNDb3VudCA9IG9iai5zaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlbXNDb3VudCA9IG9iai5sZW5ndGg7XG4gICAgICB9XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBpdGVtc0NvdW50ID49IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgJyArIGRlc2NyaXB0b3IgKyAnIGF0IGxlYXN0ICN7ZXhwfSBidXQgZ290ICN7YWN0fSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgJyArIGRlc2NyaXB0b3IgKyAnIGJlbG93ICN7ZXhwfSdcbiAgICAgICAgLCBuXG4gICAgICAgICwgaXRlbXNDb3VudFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgb2JqID49IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhdCBsZWFzdCAje2V4cH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYmVsb3cgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbGVhc3QnLCBhc3NlcnRMZWFzdCk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2d0ZScsIGFzc2VydExlYXN0KTtcblxuICAvKipcbiAgICogIyMjIC5iZWxvdyhuWywgbXNnXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYSBudW1iZXIgb3IgYSBkYXRlIGxlc3MgdGhhbiB0aGUgZ2l2ZW4gbnVtYmVyIG9yIGRhdGUgYG5gIHJlc3BlY3RpdmVseS5cbiAgICogSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgdG8gaXRzIGV4cGVjdGVkXG4gICAqIHZhbHVlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmVxdWFsKDEpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEpLnRvLmJlLmJlbG93KDIpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQWRkIGAubGVuZ3RoT2ZgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQncyBgbGVuZ3RoYFxuICAgKiBvciBgc2l6ZWAgaXMgbGVzcyB0aGFuIHRoZSBnaXZlbiBudW1iZXIgYG5gLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aE9mKDMpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aE9mLmJlbG93KDQpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoKDMpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZi5iZWxvdyg0KTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuYmVsb3dgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDIpLnRvLmVxdWFsKDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDIpLnRvLm5vdC5iZS5iZWxvdygxKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAuYmVsb3dgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICAgKiB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXMgdGhlXG4gICAqIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgyKS50by5iZS5iZWxvdygxLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoMiwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLmJlbG93KDEpO1xuICAgKlxuICAgKiBUaGUgYWxpYXNlcyBgLmx0YCBhbmQgYC5sZXNzVGhhbmAgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGhcbiAgICogYC5iZWxvd2AuXG4gICAqXG4gICAqIEBuYW1lIGJlbG93XG4gICAqIEBhbGlhcyBsdFxuICAgKiBAYWxpYXMgbGVzc1RoYW5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEJlbG93IChuLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgZG9MZW5ndGggPSBmbGFnKHRoaXMsICdkb0xlbmd0aCcpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgbXNnUHJlZml4ID0gKChmbGFnTXNnKSA/IGZsYWdNc2cgKyAnOiAnIDogJycpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJylcbiAgICAgICwgb2JqVHlwZSA9IF8udHlwZShvYmopLnRvTG93ZXJDYXNlKClcbiAgICAgICwgblR5cGUgPSBfLnR5cGUobikudG9Mb3dlckNhc2UoKVxuICAgICAgLCBlcnJvck1lc3NhZ2VcbiAgICAgICwgc2hvdWxkVGhyb3cgPSB0cnVlO1xuXG4gICAgaWYgKGRvTGVuZ3RoICYmIG9ialR5cGUgIT09ICdtYXAnICYmIG9ialR5cGUgIT09ICdzZXQnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkudG8uaGF2ZS5wcm9wZXJ0eSgnbGVuZ3RoJyk7XG4gICAgfVxuXG4gICAgaWYgKCFkb0xlbmd0aCAmJiAob2JqVHlwZSA9PT0gJ2RhdGUnICYmIG5UeXBlICE9PSAnZGF0ZScpKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAndGhlIGFyZ3VtZW50IHRvIGJlbG93IG11c3QgYmUgYSBkYXRlJztcbiAgICB9IGVsc2UgaWYgKG5UeXBlICE9PSAnbnVtYmVyJyAmJiAoZG9MZW5ndGggfHwgb2JqVHlwZSA9PT0gJ251bWJlcicpKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAndGhlIGFyZ3VtZW50IHRvIGJlbG93IG11c3QgYmUgYSBudW1iZXInO1xuICAgIH0gZWxzZSBpZiAoIWRvTGVuZ3RoICYmIChvYmpUeXBlICE9PSAnZGF0ZScgJiYgb2JqVHlwZSAhPT0gJ251bWJlcicpKSB7XG4gICAgICB2YXIgcHJpbnRPYmogPSAob2JqVHlwZSA9PT0gJ3N0cmluZycpID8gXCInXCIgKyBvYmogKyBcIidcIiA6IG9iajtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICdleHBlY3RlZCAnICsgcHJpbnRPYmogKyAnIHRvIGJlIGEgbnVtYmVyIG9yIGEgZGF0ZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZFRocm93ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRocm93KSB7XG4gICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoZXJyb3JNZXNzYWdlLCB1bmRlZmluZWQsIHNzZmkpO1xuICAgIH1cblxuICAgIGlmIChkb0xlbmd0aCkge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSAnbGVuZ3RoJ1xuICAgICAgICAsIGl0ZW1zQ291bnQ7XG4gICAgICBpZiAob2JqVHlwZSA9PT0gJ21hcCcgfHwgb2JqVHlwZSA9PT0gJ3NldCcpIHtcbiAgICAgICAgZGVzY3JpcHRvciA9ICdzaXplJztcbiAgICAgICAgaXRlbXNDb3VudCA9IG9iai5zaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlbXNDb3VudCA9IG9iai5sZW5ndGg7XG4gICAgICB9XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBpdGVtc0NvdW50IDwgblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSAnICsgZGVzY3JpcHRvciArICcgYmVsb3cgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIGEgJyArIGRlc2NyaXB0b3IgKyAnIGJlbG93ICN7ZXhwfSdcbiAgICAgICAgLCBuXG4gICAgICAgICwgaXRlbXNDb3VudFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgb2JqIDwgblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGJlbG93ICN7ZXhwfSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhdCBsZWFzdCAje2V4cH0nXG4gICAgICAgICwgblxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdiZWxvdycsIGFzc2VydEJlbG93KTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbHQnLCBhc3NlcnRCZWxvdyk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2xlc3NUaGFuJywgYXNzZXJ0QmVsb3cpO1xuXG4gIC8qKlxuICAgKiAjIyMgLm1vc3QoblssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGEgbnVtYmVyIG9yIGEgZGF0ZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGdpdmVuIG51bWJlclxuICAgKiBvciBkYXRlIGBuYCByZXNwZWN0aXZlbHkuIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIHRvIGl0c1xuICAgKiBleHBlY3RlZCB2YWx1ZS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgxKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5iZS5hdC5tb3N0KDIpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5iZS5hdC5tb3N0KDEpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQWRkIGAubGVuZ3RoT2ZgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQncyBgbGVuZ3RoYFxuICAgKiBvciBgc2l6ZWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBnaXZlbiBudW1iZXIgYG5gLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aE9mKDMpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aE9mLmF0Lm1vc3QoNCk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZigzKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YuYXQubW9zdCg0KTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAubW9zdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMikudG8uZXF1YWwoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMikudG8ubm90LmJlLmF0Lm1vc3QoMSk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLm1vc3RgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICAgKiB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXMgdGhlXG4gICAqIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgyKS50by5iZS5hdC5tb3N0KDEsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdCgyLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUuYXQubW9zdCgxKTtcbiAgICpcbiAgICogVGhlIGFsaWFzIGAubHRlYCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLm1vc3RgLlxuICAgKlxuICAgKiBAbmFtZSBtb3N0XG4gICAqIEBhbGlhcyBsdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydE1vc3QgKG4sIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBkb0xlbmd0aCA9IGZsYWcodGhpcywgJ2RvTGVuZ3RoJylcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKVxuICAgICAgLCBtc2dQcmVmaXggPSAoKGZsYWdNc2cpID8gZmxhZ01zZyArICc6ICcgOiAnJylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKVxuICAgICAgLCBvYmpUeXBlID0gXy50eXBlKG9iaikudG9Mb3dlckNhc2UoKVxuICAgICAgLCBuVHlwZSA9IF8udHlwZShuKS50b0xvd2VyQ2FzZSgpXG4gICAgICAsIGVycm9yTWVzc2FnZVxuICAgICAgLCBzaG91bGRUaHJvdyA9IHRydWU7XG5cbiAgICBpZiAoZG9MZW5ndGggJiYgb2JqVHlwZSAhPT0gJ21hcCcgJiYgb2JqVHlwZSAhPT0gJ3NldCcpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICB9XG5cbiAgICBpZiAoIWRvTGVuZ3RoICYmIChvYmpUeXBlID09PSAnZGF0ZScgJiYgblR5cGUgIT09ICdkYXRlJykpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICd0aGUgYXJndW1lbnQgdG8gbW9zdCBtdXN0IGJlIGEgZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChuVHlwZSAhPT0gJ251bWJlcicgJiYgKGRvTGVuZ3RoIHx8IG9ialR5cGUgPT09ICdudW1iZXInKSkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gbXNnUHJlZml4ICsgJ3RoZSBhcmd1bWVudCB0byBtb3N0IG11c3QgYmUgYSBudW1iZXInO1xuICAgIH0gZWxzZSBpZiAoIWRvTGVuZ3RoICYmIChvYmpUeXBlICE9PSAnZGF0ZScgJiYgb2JqVHlwZSAhPT0gJ251bWJlcicpKSB7XG4gICAgICB2YXIgcHJpbnRPYmogPSAob2JqVHlwZSA9PT0gJ3N0cmluZycpID8gXCInXCIgKyBvYmogKyBcIidcIiA6IG9iajtcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1zZ1ByZWZpeCArICdleHBlY3RlZCAnICsgcHJpbnRPYmogKyAnIHRvIGJlIGEgbnVtYmVyIG9yIGEgZGF0ZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZFRocm93ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRocm93KSB7XG4gICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoZXJyb3JNZXNzYWdlLCB1bmRlZmluZWQsIHNzZmkpO1xuICAgIH1cblxuICAgIGlmIChkb0xlbmd0aCkge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSAnbGVuZ3RoJ1xuICAgICAgICAsIGl0ZW1zQ291bnQ7XG4gICAgICBpZiAob2JqVHlwZSA9PT0gJ21hcCcgfHwgb2JqVHlwZSA9PT0gJ3NldCcpIHtcbiAgICAgICAgZGVzY3JpcHRvciA9ICdzaXplJztcbiAgICAgICAgaXRlbXNDb3VudCA9IG9iai5zaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlbXNDb3VudCA9IG9iai5sZW5ndGg7XG4gICAgICB9XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBpdGVtc0NvdW50IDw9IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgJyArIGRlc2NyaXB0b3IgKyAnIGF0IG1vc3QgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSAnICsgZGVzY3JpcHRvciArICcgYWJvdmUgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICAgLCBpdGVtc0NvdW50XG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBvYmogPD0gblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGF0IG1vc3QgI3tleHB9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGFib3ZlICN7ZXhwfSdcbiAgICAgICAgLCBuXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ21vc3QnLCBhc3NlcnRNb3N0KTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbHRlJywgYXNzZXJ0TW9zdCk7XG5cbiAgLyoqXG4gICAqICMjIyAud2l0aGluKHN0YXJ0LCBmaW5pc2hbLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBhIG51bWJlciBvciBhIGRhdGUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBnaXZlblxuICAgKiBudW1iZXIgb3IgZGF0ZSBgc3RhcnRgLCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBnaXZlbiBudW1iZXIgb3IgZGF0ZSBgZmluaXNoYCByZXNwZWN0aXZlbHkuXG4gICAqIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIHRvIGl0cyBleHBlY3RlZFxuICAgKiB2YWx1ZS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgyKS50by5lcXVhbCgyKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgyKS50by5iZS53aXRoaW4oMSwgMyk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDIpLnRvLmJlLndpdGhpbigyLCAzKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMikudG8uYmUud2l0aGluKDEsIDIpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQWRkIGAubGVuZ3RoT2ZgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIGFzc2VydCB0aGF0IHRoZSB0YXJnZXQncyBgbGVuZ3RoYFxuICAgKiBvciBgc2l6ZWAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBnaXZlbiBudW1iZXIgYHN0YXJ0YCwgYW5kIGxlc3NcbiAgICogdGhhbiBvciBlcXVhbCB0byB0aGUgZ2l2ZW4gbnVtYmVyIGBmaW5pc2hgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aE9mKDMpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aE9mLndpdGhpbigyLCA0KTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mKDMpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZi53aXRoaW4oMiwgNCk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLndpdGhpbmAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uZXF1YWwoMSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMSkudG8ubm90LmJlLndpdGhpbigyLCA0KTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAud2l0aGluYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yXG4gICAqIG1lc3NhZ2UgdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzXG4gICAqIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoNCkudG8uYmUud2l0aGluKDEsIDMsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdCg0LCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUud2l0aGluKDEsIDMpO1xuICAgKlxuICAgKiBAbmFtZSB3aXRoaW5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IGxvd2VyIGJvdW5kIGluY2x1c2l2ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gZmluaXNoIHVwcGVyIGJvdW5kIGluY2x1c2l2ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnd2l0aGluJywgZnVuY3Rpb24gKHN0YXJ0LCBmaW5pc2gsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBkb0xlbmd0aCA9IGZsYWcodGhpcywgJ2RvTGVuZ3RoJylcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKVxuICAgICAgLCBtc2dQcmVmaXggPSAoKGZsYWdNc2cpID8gZmxhZ01zZyArICc6ICcgOiAnJylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKVxuICAgICAgLCBvYmpUeXBlID0gXy50eXBlKG9iaikudG9Mb3dlckNhc2UoKVxuICAgICAgLCBzdGFydFR5cGUgPSBfLnR5cGUoc3RhcnQpLnRvTG93ZXJDYXNlKClcbiAgICAgICwgZmluaXNoVHlwZSA9IF8udHlwZShmaW5pc2gpLnRvTG93ZXJDYXNlKClcbiAgICAgICwgZXJyb3JNZXNzYWdlXG4gICAgICAsIHNob3VsZFRocm93ID0gdHJ1ZVxuICAgICAgLCByYW5nZSA9IChzdGFydFR5cGUgPT09ICdkYXRlJyAmJiBmaW5pc2hUeXBlID09PSAnZGF0ZScpXG4gICAgICAgICAgPyBzdGFydC50b1VUQ1N0cmluZygpICsgJy4uJyArIGZpbmlzaC50b1VUQ1N0cmluZygpXG4gICAgICAgICAgOiBzdGFydCArICcuLicgKyBmaW5pc2g7XG5cbiAgICBpZiAoZG9MZW5ndGggJiYgb2JqVHlwZSAhPT0gJ21hcCcgJiYgb2JqVHlwZSAhPT0gJ3NldCcpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICB9XG5cbiAgICBpZiAoIWRvTGVuZ3RoICYmIChvYmpUeXBlID09PSAnZGF0ZScgJiYgKHN0YXJ0VHlwZSAhPT0gJ2RhdGUnIHx8IGZpbmlzaFR5cGUgIT09ICdkYXRlJykpKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBtc2dQcmVmaXggKyAndGhlIGFyZ3VtZW50cyB0byB3aXRoaW4gbXVzdCBiZSBkYXRlcyc7XG4gICAgfSBlbHNlIGlmICgoc3RhcnRUeXBlICE9PSAnbnVtYmVyJyB8fCBmaW5pc2hUeXBlICE9PSAnbnVtYmVyJykgJiYgKGRvTGVuZ3RoIHx8IG9ialR5cGUgPT09ICdudW1iZXInKSkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gbXNnUHJlZml4ICsgJ3RoZSBhcmd1bWVudHMgdG8gd2l0aGluIG11c3QgYmUgbnVtYmVycyc7XG4gICAgfSBlbHNlIGlmICghZG9MZW5ndGggJiYgKG9ialR5cGUgIT09ICdkYXRlJyAmJiBvYmpUeXBlICE9PSAnbnVtYmVyJykpIHtcbiAgICAgIHZhciBwcmludE9iaiA9IChvYmpUeXBlID09PSAnc3RyaW5nJykgPyBcIidcIiArIG9iaiArIFwiJ1wiIDogb2JqO1xuICAgICAgZXJyb3JNZXNzYWdlID0gbXNnUHJlZml4ICsgJ2V4cGVjdGVkICcgKyBwcmludE9iaiArICcgdG8gYmUgYSBudW1iZXIgb3IgYSBkYXRlJztcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkVGhyb3cgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVGhyb3cpIHtcbiAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihlcnJvck1lc3NhZ2UsIHVuZGVmaW5lZCwgc3NmaSk7XG4gICAgfVxuXG4gICAgaWYgKGRvTGVuZ3RoKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9ICdsZW5ndGgnXG4gICAgICAgICwgaXRlbXNDb3VudDtcbiAgICAgIGlmIChvYmpUeXBlID09PSAnbWFwJyB8fCBvYmpUeXBlID09PSAnc2V0Jykge1xuICAgICAgICBkZXNjcmlwdG9yID0gJ3NpemUnO1xuICAgICAgICBpdGVtc0NvdW50ID0gb2JqLnNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVtc0NvdW50ID0gb2JqLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIGl0ZW1zQ291bnQgPj0gc3RhcnQgJiYgaXRlbXNDb3VudCA8PSBmaW5pc2hcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgJyArIGRlc2NyaXB0b3IgKyAnIHdpdGhpbiAnICsgcmFuZ2VcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSBhICcgKyBkZXNjcmlwdG9yICsgJyB3aXRoaW4gJyArIHJhbmdlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBvYmogPj0gc3RhcnQgJiYgb2JqIDw9IGZpbmlzaFxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHdpdGhpbiAnICsgcmFuZ2VcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgd2l0aGluICcgKyByYW5nZVxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmluc3RhbmNlb2YoY29uc3RydWN0b3JbLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgZ2l2ZW4gYGNvbnN0cnVjdG9yYC5cbiAgICpcbiAgICogICAgIGZ1bmN0aW9uIENhdCAoKSB7IH1cbiAgICpcbiAgICogICAgIGV4cGVjdChuZXcgQ2F0KCkpLnRvLmJlLmFuLmluc3RhbmNlb2YoQ2F0KTtcbiAgICogICAgIGV4cGVjdChbMSwgMl0pLnRvLmJlLmFuLmluc3RhbmNlb2YoQXJyYXkpO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmluc3RhbmNlb2ZgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8ubm90LmJlLmFuLmluc3RhbmNlb2YoQXJyYXkpO1xuICAgKlxuICAgKiBgLmluc3RhbmNlb2ZgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3JcbiAgICogbWVzc2FnZSB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXNcbiAgICogdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5iZS5hbi5pbnN0YW5jZW9mKEFycmF5LCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoMSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLmFuLmluc3RhbmNlb2YoQXJyYXkpO1xuICAgKlxuICAgKiBEdWUgdG8gbGltaXRhdGlvbnMgaW4gRVM1LCBgLmluc3RhbmNlb2ZgIG1heSBub3QgYWx3YXlzIHdvcmsgYXMgZXhwZWN0ZWRcbiAgICogd2hlbiB1c2luZyBhIHRyYW5zcGlsZXIgc3VjaCBhcyBCYWJlbCBvciBUeXBlU2NyaXB0LiBJbiBwYXJ0aWN1bGFyLCBpdCBtYXlcbiAgICogcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHMgd2hlbiBzdWJjbGFzc2luZyBidWlsdC1pbiBvYmplY3Qgc3VjaCBhc1xuICAgKiBgQXJyYXlgLCBgRXJyb3JgLCBhbmQgYE1hcGAuIFNlZSB5b3VyIHRyYW5zcGlsZXIncyBkb2NzIGZvciBkZXRhaWxzOlxuICAgKlxuICAgKiAtIChbQmFiZWxdKGh0dHBzOi8vYmFiZWxqcy5pby9kb2NzL3VzYWdlL2NhdmVhdHMvI2NsYXNzZXMpKVxuICAgKiAtIChbVHlwZVNjcmlwdF0oaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L3dpa2kvQnJlYWtpbmctQ2hhbmdlcyNleHRlbmRpbmctYnVpbHQtaW5zLWxpa2UtZXJyb3ItYXJyYXktYW5kLW1hcC1tYXktbm8tbG9uZ2VyLXdvcmspKVxuICAgKlxuICAgKiBUaGUgYWxpYXMgYC5pbnN0YW5jZU9mYCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLmluc3RhbmNlb2ZgLlxuICAgKlxuICAgKiBAbmFtZSBpbnN0YW5jZW9mXG4gICAqIEBwYXJhbSB7Q29uc3RydWN0b3J9IGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAYWxpYXMgaW5zdGFuY2VPZlxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRJbnN0YW5jZU9mIChjb25zdHJ1Y3RvciwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG5cbiAgICB2YXIgdGFyZ2V0ID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICB2YXIgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKTtcbiAgICB2YXIgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKTtcblxuICAgIHRyeSB7XG4gICAgICB2YXIgaXNJbnN0YW5jZU9mID0gdGFyZ2V0IGluc3RhbmNlb2YgY29uc3RydWN0b3I7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICAgIGZsYWdNc2cgPSBmbGFnTXNnID8gZmxhZ01zZyArICc6ICcgOiAnJztcbiAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKFxuICAgICAgICAgIGZsYWdNc2cgKyAnVGhlIGluc3RhbmNlb2YgYXNzZXJ0aW9uIG5lZWRzIGEgY29uc3RydWN0b3IgYnV0ICdcbiAgICAgICAgICAgICsgXy50eXBlKGNvbnN0cnVjdG9yKSArICcgd2FzIGdpdmVuLicsXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIHNzZmlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycjtcbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IF8uZ2V0TmFtZShjb25zdHJ1Y3Rvcik7XG4gICAgaWYgKG5hbWUgPT09IG51bGwpIHtcbiAgICAgIG5hbWUgPSAnYW4gdW5uYW1lZCBjb25zdHJ1Y3Rvcic7XG4gICAgfVxuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGlzSW5zdGFuY2VPZlxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhbiBpbnN0YW5jZSBvZiAnICsgbmFtZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgYW4gaW5zdGFuY2Ugb2YgJyArIG5hbWVcbiAgICApO1xuICB9O1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2luc3RhbmNlb2YnLCBhc3NlcnRJbnN0YW5jZU9mKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnaW5zdGFuY2VPZicsIGFzc2VydEluc3RhbmNlT2YpO1xuXG4gIC8qKlxuICAgKiAjIyMgLnByb3BlcnR5KG5hbWVbLCB2YWxbLCBtc2ddXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaGFzIGEgcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4ga2V5IGBuYW1lYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmhhdmUucHJvcGVydHkoJ2EnKTtcbiAgICpcbiAgICogV2hlbiBgdmFsYCBpcyBwcm92aWRlZCwgYC5wcm9wZXJ0eWAgYWxzbyBhc3NlcnRzIHRoYXQgdGhlIHByb3BlcnR5J3MgdmFsdWVcbiAgICogaXMgZXF1YWwgdG8gdGhlIGdpdmVuIGB2YWxgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5wcm9wZXJ0eSgnYScsIDEpO1xuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBzdHJpY3QgKGA9PT1gKSBlcXVhbGl0eSBpcyB1c2VkLiBBZGQgYC5kZWVwYCBlYXJsaWVyIGluIHRoZVxuICAgKiBjaGFpbiB0byB1c2UgZGVlcCBlcXVhbGl0eSBpbnN0ZWFkLiBTZWUgdGhlIGBkZWVwLWVxbGAgcHJvamVjdCBwYWdlIGZvclxuICAgKiBpbmZvIG9uIHRoZSBkZWVwIGVxdWFsaXR5IGFsZ29yaXRobTogaHR0cHM6Ly9naXRodWIuY29tL2NoYWlqcy9kZWVwLWVxbC5cbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBvYmplY3QgZGVlcGx5IChidXQgbm90IHN0cmljdGx5KSBoYXMgcHJvcGVydHkgYHg6IHthOiAxfWBcbiAgICogICAgIGV4cGVjdCh7eDoge2E6IDF9fSkudG8uaGF2ZS5kZWVwLnByb3BlcnR5KCd4Jywge2E6IDF9KTtcbiAgICogICAgIGV4cGVjdCh7eDoge2E6IDF9fSkudG8ubm90LmhhdmUucHJvcGVydHkoJ3gnLCB7YTogMX0pO1xuICAgKlxuICAgKiBUaGUgdGFyZ2V0J3MgZW51bWVyYWJsZSBhbmQgbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBhcmUgYWx3YXlzIGluY2x1ZGVkXG4gICAqIGluIHRoZSBzZWFyY2guIEJ5IGRlZmF1bHQsIGJvdGggb3duIGFuZCBpbmhlcml0ZWQgcHJvcGVydGllcyBhcmUgaW5jbHVkZWQuXG4gICAqIEFkZCBgLm93bmAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gZXhjbHVkZSBpbmhlcml0ZWQgcHJvcGVydGllcyBmcm9tIHRoZVxuICAgKiBzZWFyY2guXG4gICAqXG4gICAqICAgICBPYmplY3QucHJvdG90eXBlLmIgPSAyO1xuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5vd24ucHJvcGVydHkoJ2EnKTtcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmhhdmUub3duLnByb3BlcnR5KCdhJywgMSk7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLnByb3BlcnR5KCdiJyk7XG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5ub3QuaGF2ZS5vd24ucHJvcGVydHkoJ2InKTtcbiAgICpcbiAgICogYC5kZWVwYCBhbmQgYC5vd25gIGNhbiBiZSBjb21iaW5lZC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7eDoge2E6IDF9fSkudG8uaGF2ZS5kZWVwLm93bi5wcm9wZXJ0eSgneCcsIHthOiAxfSk7XG4gICAqXG4gICAqIEFkZCBgLm5lc3RlZGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gZW5hYmxlIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gd2hlblxuICAgKiByZWZlcmVuY2luZyBuZXN0ZWQgcHJvcGVydGllcy5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YToge2I6IFsneCcsICd5J119fSkudG8uaGF2ZS5uZXN0ZWQucHJvcGVydHkoJ2EuYlsxXScpO1xuICAgKiAgICAgZXhwZWN0KHthOiB7YjogWyd4JywgJ3knXX19KS50by5oYXZlLm5lc3RlZC5wcm9wZXJ0eSgnYS5iWzFdJywgJ3knKTtcbiAgICpcbiAgICogSWYgYC5gIG9yIGBbXWAgYXJlIHBhcnQgb2YgYW4gYWN0dWFsIHByb3BlcnR5IG5hbWUsIHRoZXkgY2FuIGJlIGVzY2FwZWQgYnlcbiAgICogYWRkaW5nIHR3byBiYWNrc2xhc2hlcyBiZWZvcmUgdGhlbS5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7Jy5hJzogeydbYl0nOiAneCd9fSkudG8uaGF2ZS5uZXN0ZWQucHJvcGVydHkoJ1xcXFwuYS5cXFxcW2JcXFxcXScpO1xuICAgKlxuICAgKiBgLmRlZXBgIGFuZCBgLm5lc3RlZGAgY2FuIGJlIGNvbWJpbmVkLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiB7YjogW3tjOiAzfV19fSlcbiAgICogICAgICAgLnRvLmhhdmUuZGVlcC5uZXN0ZWQucHJvcGVydHkoJ2EuYlswXScsIHtjOiAzfSk7XG4gICAqXG4gICAqIGAub3duYCBhbmQgYC5uZXN0ZWRgIGNhbm5vdCBiZSBjb21iaW5lZC5cbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5wcm9wZXJ0eWAuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5ub3QuaGF2ZS5wcm9wZXJ0eSgnYicpO1xuICAgKlxuICAgKiBIb3dldmVyLCBpdCdzIGRhbmdlcm91cyB0byBuZWdhdGUgYC5wcm9wZXJ0eWAgd2hlbiBwcm92aWRpbmcgYHZhbGAuIFRoZVxuICAgKiBwcm9ibGVtIGlzIHRoYXQgaXQgY3JlYXRlcyB1bmNlcnRhaW4gZXhwZWN0YXRpb25zIGJ5IGFzc2VydGluZyB0aGF0IHRoZVxuICAgKiB0YXJnZXQgZWl0aGVyIGRvZXNuJ3QgaGF2ZSBhIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIGtleSBgbmFtZWAsIG9yIHRoYXQgaXRcbiAgICogZG9lcyBoYXZlIGEgcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4ga2V5IGBuYW1lYCBidXQgaXRzIHZhbHVlIGlzbid0IGVxdWFsIHRvXG4gICAqIHRoZSBnaXZlbiBgdmFsYC4gSXQncyBvZnRlbiBiZXN0IHRvIGlkZW50aWZ5IHRoZSBleGFjdCBvdXRwdXQgdGhhdCdzXG4gICAqIGV4cGVjdGVkLCBhbmQgdGhlbiB3cml0ZSBhbiBhc3NlcnRpb24gdGhhdCBvbmx5IGFjY2VwdHMgdGhhdCBleGFjdCBvdXRwdXQuXG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpc24ndCBleHBlY3RlZCB0byBoYXZlIGEgcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4ga2V5XG4gICAqIGBuYW1lYCwgaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydCBleGFjdGx5IHRoYXQuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2I6IDJ9KS50by5ub3QuaGF2ZS5wcm9wZXJ0eSgnYScpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHtiOiAyfSkudG8ubm90LmhhdmUucHJvcGVydHkoJ2EnLCAxKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBleHBlY3RlZCB0byBoYXZlIGEgcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4ga2V5IGBuYW1lYCxcbiAgICogaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSBwcm9wZXJ0eSBoYXMgaXRzIGV4cGVjdGVkIHZhbHVlLCByYXRoZXJcbiAgICogdGhhbiBhc3NlcnRpbmcgdGhhdCBpdCBkb2Vzbid0IGhhdmUgb25lIG9mIG1hbnkgdW5leHBlY3RlZCB2YWx1ZXMuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDN9KS50by5oYXZlLnByb3BlcnR5KCdhJywgMyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2E6IDN9KS50by5ub3QuaGF2ZS5wcm9wZXJ0eSgnYScsIDEpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC5wcm9wZXJ0eWAgY2hhbmdlcyB0aGUgdGFyZ2V0IG9mIGFueSBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpblxuICAgKiB0byBiZSB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IGZyb20gdGhlIG9yaWdpbmFsIHRhcmdldCBvYmplY3QuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLnByb3BlcnR5KCdhJykudGhhdC5pcy5hKCdudW1iZXInKTtcbiAgICpcbiAgICogYC5wcm9wZXJ0eWAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvclxuICAgKiBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhc1xuICAgKiB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLiBXaGVuIG5vdCBwcm92aWRpbmcgYHZhbGAsIG9ubHkgdXNlIHRoZVxuICAgKiBzZWNvbmQgZm9ybS5cbiAgICpcbiAgICogICAgIC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5oYXZlLnByb3BlcnR5KCdhJywgMiwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmhhdmUucHJvcGVydHkoJ2EnLCAyKTtcbiAgICogICAgIGV4cGVjdCh7YTogMX0sICdub29vIHdoeSBmYWlsPz8nKS50by5oYXZlLnByb3BlcnR5KCdiJyk7XG4gICAqXG4gICAqICAgICAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmhhdmUucHJvcGVydHkoJ2InLCB1bmRlZmluZWQsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICpcbiAgICogVGhlIGFib3ZlIGFzc2VydGlvbiBpc24ndCB0aGUgc2FtZSB0aGluZyBhcyBub3QgcHJvdmlkaW5nIGB2YWxgLiBJbnN0ZWFkLFxuICAgKiBpdCdzIGFzc2VydGluZyB0aGF0IHRoZSB0YXJnZXQgb2JqZWN0IGhhcyBhIGBiYCBwcm9wZXJ0eSB0aGF0J3MgZXF1YWwgdG9cbiAgICogYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqIFRoZSBhc3NlcnRpb25zIGAub3duUHJvcGVydHlgIGFuZCBgLmhhdmVPd25Qcm9wZXJ0eWAgY2FuIGJlIHVzZWRcbiAgICogaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5vd24ucHJvcGVydHlgLlxuICAgKlxuICAgKiBAbmFtZSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWwgKG9wdGlvbmFsKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQHJldHVybnMgdmFsdWUgb2YgcHJvcGVydHkgZm9yIGNoYWluaW5nXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydFByb3BlcnR5IChuYW1lLCB2YWwsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuXG4gICAgdmFyIGlzTmVzdGVkID0gZmxhZyh0aGlzLCAnbmVzdGVkJylcbiAgICAgICwgaXNPd24gPSBmbGFnKHRoaXMsICdvd24nKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJylcbiAgICAgICwgbmFtZVR5cGUgPSB0eXBlb2YgbmFtZTtcblxuICAgIGZsYWdNc2cgPSBmbGFnTXNnID8gZmxhZ01zZyArICc6ICcgOiAnJztcblxuICAgIGlmIChpc05lc3RlZCkge1xuICAgICAgaWYgKG5hbWVUeXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoXG4gICAgICAgICAgZmxhZ01zZyArICd0aGUgYXJndW1lbnQgdG8gcHJvcGVydHkgbXVzdCBiZSBhIHN0cmluZyB3aGVuIHVzaW5nIG5lc3RlZCBzeW50YXgnLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICBzc2ZpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuYW1lVHlwZSAhPT0gJ3N0cmluZycgJiYgbmFtZVR5cGUgIT09ICdudW1iZXInICYmIG5hbWVUeXBlICE9PSAnc3ltYm9sJykge1xuICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoXG4gICAgICAgICAgZmxhZ01zZyArICd0aGUgYXJndW1lbnQgdG8gcHJvcGVydHkgbXVzdCBiZSBhIHN0cmluZywgbnVtYmVyLCBvciBzeW1ib2wnLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICBzc2ZpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzTmVzdGVkICYmIGlzT3duKSB7XG4gICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoXG4gICAgICAgIGZsYWdNc2cgKyAnVGhlIFwibmVzdGVkXCIgYW5kIFwib3duXCIgZmxhZ3MgY2Fubm90IGJlIGNvbWJpbmVkLicsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgc3NmaVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAob2JqID09PSBudWxsIHx8IG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoXG4gICAgICAgIGZsYWdNc2cgKyAnVGFyZ2V0IGNhbm5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC4nLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHNzZmlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGlzRGVlcCA9IGZsYWcodGhpcywgJ2RlZXAnKVxuICAgICAgLCBuZWdhdGUgPSBmbGFnKHRoaXMsICduZWdhdGUnKVxuICAgICAgLCBwYXRoSW5mbyA9IGlzTmVzdGVkID8gXy5nZXRQYXRoSW5mbyhvYmosIG5hbWUpIDogbnVsbFxuICAgICAgLCB2YWx1ZSA9IGlzTmVzdGVkID8gcGF0aEluZm8udmFsdWUgOiBvYmpbbmFtZV07XG5cbiAgICB2YXIgZGVzY3JpcHRvciA9ICcnO1xuICAgIGlmIChpc0RlZXApIGRlc2NyaXB0b3IgKz0gJ2RlZXAgJztcbiAgICBpZiAoaXNPd24pIGRlc2NyaXB0b3IgKz0gJ293biAnO1xuICAgIGlmIChpc05lc3RlZCkgZGVzY3JpcHRvciArPSAnbmVzdGVkICc7XG4gICAgZGVzY3JpcHRvciArPSAncHJvcGVydHkgJztcblxuICAgIHZhciBoYXNQcm9wZXJ0eTtcbiAgICBpZiAoaXNPd24pIGhhc1Byb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgbmFtZSk7XG4gICAgZWxzZSBpZiAoaXNOZXN0ZWQpIGhhc1Byb3BlcnR5ID0gcGF0aEluZm8uZXhpc3RzO1xuICAgIGVsc2UgaGFzUHJvcGVydHkgPSBfLmhhc1Byb3BlcnR5KG9iaiwgbmFtZSk7XG5cbiAgICAvLyBXaGVuIHBlcmZvcm1pbmcgYSBuZWdhdGVkIGFzc2VydGlvbiBmb3IgYm90aCBuYW1lIGFuZCB2YWwsIG1lcmVseSBoYXZpbmdcbiAgICAvLyBhIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIG5hbWUgaXNuJ3QgZW5vdWdoIHRvIGNhdXNlIHRoZSBhc3NlcnRpb24gdG9cbiAgICAvLyBmYWlsLiBJdCBtdXN0IGJvdGggaGF2ZSBhIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIG5hbWUsIGFuZCB0aGUgdmFsdWUgb2ZcbiAgICAvLyB0aGF0IHByb3BlcnR5IG11c3QgZXF1YWwgdGhlIGdpdmVuIHZhbC4gVGhlcmVmb3JlLCBza2lwIHRoaXMgYXNzZXJ0aW9uIGluXG4gICAgLy8gZmF2b3Igb2YgdGhlIG5leHQuXG4gICAgaWYgKCFuZWdhdGUgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgaGFzUHJvcGVydHlcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlICcgKyBkZXNjcmlwdG9yICsgXy5pbnNwZWN0KG5hbWUpXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgJyArIGRlc2NyaXB0b3IgKyBfLmluc3BlY3QobmFtZSkpO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgaGFzUHJvcGVydHkgJiYgKGlzRGVlcCA/IF8uZXFsKHZhbCwgdmFsdWUpIDogdmFsID09PSB2YWx1ZSlcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlICcgKyBkZXNjcmlwdG9yICsgXy5pbnNwZWN0KG5hbWUpICsgJyBvZiAje2V4cH0sIGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlICcgKyBkZXNjcmlwdG9yICsgXy5pbnNwZWN0KG5hbWUpICsgJyBvZiAje2FjdH0nXG4gICAgICAgICwgdmFsXG4gICAgICAgICwgdmFsdWVcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZmxhZyh0aGlzLCAnb2JqZWN0JywgdmFsdWUpO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgncHJvcGVydHknLCBhc3NlcnRQcm9wZXJ0eSk7XG5cbiAgZnVuY3Rpb24gYXNzZXJ0T3duUHJvcGVydHkgKG5hbWUsIHZhbHVlLCBtc2cpIHtcbiAgICBmbGFnKHRoaXMsICdvd24nLCB0cnVlKTtcbiAgICBhc3NlcnRQcm9wZXJ0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnb3duUHJvcGVydHknLCBhc3NlcnRPd25Qcm9wZXJ0eSk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2hhdmVPd25Qcm9wZXJ0eScsIGFzc2VydE93blByb3BlcnR5KTtcblxuICAvKipcbiAgICogIyMjIC5vd25Qcm9wZXJ0eURlc2NyaXB0b3IobmFtZVssIGRlc2NyaXB0b3JbLCBtc2ddXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaGFzIGl0cyBvd24gcHJvcGVydHkgZGVzY3JpcHRvciB3aXRoIHRoZSBnaXZlbiBrZXlcbiAgICogYG5hbWVgLiBFbnVtZXJhYmxlIGFuZCBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZSBpbmNsdWRlZCBpbiB0aGVcbiAgICogc2VhcmNoLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5vd25Qcm9wZXJ0eURlc2NyaXB0b3IoJ2EnKTtcbiAgICpcbiAgICogV2hlbiBgZGVzY3JpcHRvcmAgaXMgcHJvdmlkZWQsIGAub3duUHJvcGVydHlEZXNjcmlwdG9yYCBhbHNvIGFzc2VydHMgdGhhdFxuICAgKiB0aGUgcHJvcGVydHkncyBkZXNjcmlwdG9yIGlzIGRlZXBseSBlcXVhbCB0byB0aGUgZ2l2ZW4gYGRlc2NyaXB0b3JgLiBTZWVcbiAgICogdGhlIGBkZWVwLWVxbGAgcHJvamVjdCBwYWdlIGZvciBpbmZvIG9uIHRoZSBkZWVwIGVxdWFsaXR5IGFsZ29yaXRobTpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2NoYWlqcy9kZWVwLWVxbC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmhhdmUub3duUHJvcGVydHlEZXNjcmlwdG9yKCdhJywge1xuICAgKiAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAqICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAqICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgKiAgICAgICB2YWx1ZTogMSxcbiAgICogICAgIH0pO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLm93blByb3BlcnR5RGVzY3JpcHRvcmAuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5ub3QuaGF2ZS5vd25Qcm9wZXJ0eURlc2NyaXB0b3IoJ2InKTtcbiAgICpcbiAgICogSG93ZXZlciwgaXQncyBkYW5nZXJvdXMgdG8gbmVnYXRlIGAub3duUHJvcGVydHlEZXNjcmlwdG9yYCB3aGVuIHByb3ZpZGluZ1xuICAgKiBhIGBkZXNjcmlwdG9yYC4gVGhlIHByb2JsZW0gaXMgdGhhdCBpdCBjcmVhdGVzIHVuY2VydGFpbiBleHBlY3RhdGlvbnMgYnlcbiAgICogYXNzZXJ0aW5nIHRoYXQgdGhlIHRhcmdldCBlaXRoZXIgZG9lc24ndCBoYXZlIGEgcHJvcGVydHkgZGVzY3JpcHRvciB3aXRoXG4gICAqIHRoZSBnaXZlbiBrZXkgYG5hbWVgLCBvciB0aGF0IGl0IGRvZXMgaGF2ZSBhIHByb3BlcnR5IGRlc2NyaXB0b3Igd2l0aCB0aGVcbiAgICogZ2l2ZW4ga2V5IGBuYW1lYCBidXQgaXRzIG5vdCBkZWVwbHkgZXF1YWwgdG8gdGhlIGdpdmVuIGBkZXNjcmlwdG9yYC4gSXQnc1xuICAgKiBvZnRlbiBiZXN0IHRvIGlkZW50aWZ5IHRoZSBleGFjdCBvdXRwdXQgdGhhdCdzIGV4cGVjdGVkLCBhbmQgdGhlbiB3cml0ZSBhblxuICAgKiBhc3NlcnRpb24gdGhhdCBvbmx5IGFjY2VwdHMgdGhhdCBleGFjdCBvdXRwdXQuXG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpc24ndCBleHBlY3RlZCB0byBoYXZlIGEgcHJvcGVydHkgZGVzY3JpcHRvciB3aXRoIHRoZSBnaXZlblxuICAgKiBrZXkgYG5hbWVgLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IGV4YWN0bHkgdGhhdC5cbiAgICpcbiAgICogICAgIC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2I6IDJ9KS50by5ub3QuaGF2ZS5vd25Qcm9wZXJ0eURlc2NyaXB0b3IoJ2EnKTtcbiAgICpcbiAgICogICAgIC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHtiOiAyfSkudG8ubm90LmhhdmUub3duUHJvcGVydHlEZXNjcmlwdG9yKCdhJywge1xuICAgKiAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAqICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAqICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgKiAgICAgICB2YWx1ZTogMSxcbiAgICogICAgIH0pO1xuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgZXhwZWN0ZWQgdG8gaGF2ZSBhIHByb3BlcnR5IGRlc2NyaXB0b3Igd2l0aCB0aGUgZ2l2ZW5cbiAgICoga2V5IGBuYW1lYCwgaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSBwcm9wZXJ0eSBoYXMgaXRzIGV4cGVjdGVkXG4gICAqIGRlc2NyaXB0b3IsIHJhdGhlciB0aGFuIGFzc2VydGluZyB0aGF0IGl0IGRvZXNuJ3QgaGF2ZSBvbmUgb2YgbWFueVxuICAgKiB1bmV4cGVjdGVkIGRlc2NyaXB0b3JzLlxuICAgKlxuICAgKiAgICAgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YTogM30pLnRvLmhhdmUub3duUHJvcGVydHlEZXNjcmlwdG9yKCdhJywge1xuICAgKiAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAqICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAqICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgKiAgICAgICB2YWx1ZTogMyxcbiAgICogICAgIH0pO1xuICAgKlxuICAgKiAgICAgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2E6IDN9KS50by5ub3QuaGF2ZS5vd25Qcm9wZXJ0eURlc2NyaXB0b3IoJ2EnLCB7XG4gICAqICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICogICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICogICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAqICAgICAgIHZhbHVlOiAxLFxuICAgKiAgICAgfSk7XG4gICAqXG4gICAqIGAub3duUHJvcGVydHlEZXNjcmlwdG9yYCBjaGFuZ2VzIHRoZSB0YXJnZXQgb2YgYW55IGFzc2VydGlvbnMgdGhhdCBmb2xsb3dcbiAgICogaW4gdGhlIGNoYWluIHRvIGJlIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgZGVzY3JpcHRvciBmcm9tIHRoZSBvcmlnaW5hbFxuICAgKiB0YXJnZXQgb2JqZWN0LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaGF2ZS5vd25Qcm9wZXJ0eURlc2NyaXB0b3IoJ2EnKVxuICAgKiAgICAgICAudGhhdC5oYXMucHJvcGVydHkoJ2VudW1lcmFibGUnLCB0cnVlKTtcbiAgICpcbiAgICogYC5vd25Qcm9wZXJ0eURlc2NyaXB0b3JgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYVxuICAgKiBjdXN0b20gZXJyb3IgbWVzc2FnZSB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc29cbiAgICogYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC4gV2hlbiBub3QgcHJvdmlkaW5nXG4gICAqIGBkZXNjcmlwdG9yYCwgb25seSB1c2UgdGhlIHNlY29uZCBmb3JtLlxuICAgKlxuICAgKiAgICAgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmhhdmUub3duUHJvcGVydHlEZXNjcmlwdG9yKCdhJywge1xuICAgKiAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAqICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAqICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgKiAgICAgICB2YWx1ZTogMixcbiAgICogICAgIH0sICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICpcbiAgICogICAgIC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2E6IDF9LCAnbm9vbyB3aHkgZmFpbD8/JykudG8uaGF2ZS5vd25Qcm9wZXJ0eURlc2NyaXB0b3IoJ2EnLCB7XG4gICAqICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICogICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICogICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAqICAgICAgIHZhbHVlOiAyLFxuICAgKiAgICAgfSk7XG4gICAqXG4gICAqICAgICAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHthOiAxfSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmhhdmUub3duUHJvcGVydHlEZXNjcmlwdG9yKCdiJyk7XG4gICAqXG4gICAqICAgICAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCh7YTogMX0pXG4gICAqICAgICAgIC50by5oYXZlLm93blByb3BlcnR5RGVzY3JpcHRvcignYicsIHVuZGVmaW5lZCwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKlxuICAgKiBUaGUgYWJvdmUgYXNzZXJ0aW9uIGlzbid0IHRoZSBzYW1lIHRoaW5nIGFzIG5vdCBwcm92aWRpbmcgYGRlc2NyaXB0b3JgLlxuICAgKiBJbnN0ZWFkLCBpdCdzIGFzc2VydGluZyB0aGF0IHRoZSB0YXJnZXQgb2JqZWN0IGhhcyBhIGBiYCBwcm9wZXJ0eVxuICAgKiBkZXNjcmlwdG9yIHRoYXQncyBkZWVwbHkgZXF1YWwgdG8gYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqIFRoZSBhbGlhcyBgLmhhdmVPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoXG4gICAqIGAub3duUHJvcGVydHlEZXNjcmlwdG9yYC5cbiAgICpcbiAgICogQG5hbWUgb3duUHJvcGVydHlEZXNjcmlwdG9yXG4gICAqIEBhbGlhcyBoYXZlT3duUHJvcGVydHlEZXNjcmlwdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZXNjcmlwdG9yIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydE93blByb3BlcnR5RGVzY3JpcHRvciAobmFtZSwgZGVzY3JpcHRvciwgbXNnKSB7XG4gICAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgbXNnID0gZGVzY3JpcHRvcjtcbiAgICAgIGRlc2NyaXB0b3IgPSBudWxsO1xuICAgIH1cbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgdmFyIGFjdHVhbERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdChvYmopLCBuYW1lKTtcbiAgICBpZiAoYWN0dWFsRGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yKSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBfLmVxbChkZXNjcmlwdG9yLCBhY3R1YWxEZXNjcmlwdG9yKVxuICAgICAgICAsICdleHBlY3RlZCB0aGUgb3duIHByb3BlcnR5IGRlc2NyaXB0b3IgZm9yICcgKyBfLmluc3BlY3QobmFtZSkgKyAnIG9uICN7dGhpc30gdG8gbWF0Y2ggJyArIF8uaW5zcGVjdChkZXNjcmlwdG9yKSArICcsIGdvdCAnICsgXy5pbnNwZWN0KGFjdHVhbERlc2NyaXB0b3IpXG4gICAgICAgICwgJ2V4cGVjdGVkIHRoZSBvd24gcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgJyArIF8uaW5zcGVjdChuYW1lKSArICcgb24gI3t0aGlzfSB0byBub3QgbWF0Y2ggJyArIF8uaW5zcGVjdChkZXNjcmlwdG9yKVxuICAgICAgICAsIGRlc2NyaXB0b3JcbiAgICAgICAgLCBhY3R1YWxEZXNjcmlwdG9yXG4gICAgICAgICwgdHJ1ZVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgYWN0dWFsRGVzY3JpcHRvclxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYW4gb3duIHByb3BlcnR5IGRlc2NyaXB0b3IgZm9yICcgKyBfLmluc3BlY3QobmFtZSlcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSBhbiBvd24gcHJvcGVydHkgZGVzY3JpcHRvciBmb3IgJyArIF8uaW5zcGVjdChuYW1lKVxuICAgICAgKTtcbiAgICB9XG4gICAgZmxhZyh0aGlzLCAnb2JqZWN0JywgYWN0dWFsRGVzY3JpcHRvcik7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdvd25Qcm9wZXJ0eURlc2NyaXB0b3InLCBhc3NlcnRPd25Qcm9wZXJ0eURlc2NyaXB0b3IpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdoYXZlT3duUHJvcGVydHlEZXNjcmlwdG9yJywgYXNzZXJ0T3duUHJvcGVydHlEZXNjcmlwdG9yKTtcblxuICAvKipcbiAgICogIyMjIC5sZW5ndGhPZihuWywgbXNnXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQncyBgbGVuZ3RoYCBvciBgc2l6ZWAgaXMgZXF1YWwgdG8gdGhlIGdpdmVuIG51bWJlclxuICAgKiBgbmAuXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mKDMpO1xuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aE9mKDMpO1xuICAgKiAgICAgZXhwZWN0KG5ldyBTZXQoWzEsIDIsIDNdKSkudG8uaGF2ZS5sZW5ndGhPZigzKTtcbiAgICogICAgIGV4cGVjdChuZXcgTWFwKFtbJ2EnLCAxXSwgWydiJywgMl0sIFsnYycsIDNdXSkpLnRvLmhhdmUubGVuZ3RoT2YoMyk7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAubGVuZ3RoT2ZgLiBIb3dldmVyLCBpdCdzIG9mdGVuXG4gICAqIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlIHRhcmdldCdzIGBsZW5ndGhgIHByb3BlcnR5IGlzIGVxdWFsIHRvIGl0cyBleHBlY3RlZFxuICAgKiB2YWx1ZSwgcmF0aGVyIHRoYW4gbm90IGVxdWFsIHRvIG9uZSBvZiBtYW55IHVuZXhwZWN0ZWQgdmFsdWVzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aE9mKDMpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5ub3QuaGF2ZS5sZW5ndGhPZig0KTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAubGVuZ3RoT2ZgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3JcbiAgICogbWVzc2FnZSB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXNcbiAgICogdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YoMiwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmhhdmUubGVuZ3RoT2YoMik7XG4gICAqXG4gICAqIGAubGVuZ3RoT2ZgIGNhbiBhbHNvIGJlIHVzZWQgYXMgYSBsYW5ndWFnZSBjaGFpbiwgY2F1c2luZyBhbGwgYC5hYm92ZWAsXG4gICAqIGAuYmVsb3dgLCBgLmxlYXN0YCwgYC5tb3N0YCwgYW5kIGAud2l0aGluYCBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZVxuICAgKiBjaGFpbiB0byB1c2UgdGhlIHRhcmdldCdzIGBsZW5ndGhgIHByb3BlcnR5IGFzIHRoZSB0YXJnZXQuIEhvd2V2ZXIsIGl0J3NcbiAgICogb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0J3MgYGxlbmd0aGAgcHJvcGVydHkgaXMgZXF1YWwgdG8gaXRzXG4gICAqIGV4cGVjdGVkIGxlbmd0aCwgcmF0aGVyIHRoYW4gYXNzZXJ0aW5nIHRoYXQgaXRzIGBsZW5ndGhgIHByb3BlcnR5IGZhbGxzXG4gICAqIHdpdGhpbiBzb21lIHJhbmdlIG9mIHZhbHVlcy5cbiAgICpcbiAgICogICAgIC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mKDMpO1xuICAgKlxuICAgKiAgICAgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mLmFib3ZlKDIpO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGhPZi5iZWxvdyg0KTtcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubGVuZ3RoT2YuYXQubGVhc3QoMyk7XG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mLmF0Lm1vc3QoMyk7XG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLmxlbmd0aE9mLndpdGhpbigyLDQpO1xuICAgKlxuICAgKiBEdWUgdG8gYSBjb21wYXRpYmlsaXR5IGlzc3VlLCB0aGUgYWxpYXMgYC5sZW5ndGhgIGNhbid0IGJlIGNoYWluZWQgZGlyZWN0bHlcbiAgICogb2ZmIG9mIGFuIHVuaW52b2tlZCBtZXRob2Qgc3VjaCBhcyBgLmFgLiBUaGVyZWZvcmUsIGAubGVuZ3RoYCBjYW4ndCBiZSB1c2VkXG4gICAqIGludGVyY2hhbmdlYWJseSB3aXRoIGAubGVuZ3RoT2ZgIGluIGV2ZXJ5IHNpdHVhdGlvbi4gSXQncyByZWNvbW1lbmRlZCB0b1xuICAgKiBhbHdheXMgdXNlIGAubGVuZ3RoT2ZgIGluc3RlYWQgb2YgYC5sZW5ndGhgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8uaGF2ZS5hLmxlbmd0aCgzKTsgLy8gaW5jb21wYXRpYmxlOyB0aHJvd3MgZXJyb3JcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUuYS5sZW5ndGhPZigzKTsgIC8vIHBhc3NlcyBhcyBleHBlY3RlZFxuICAgKlxuICAgKiBAbmFtZSBsZW5ndGhPZlxuICAgKiBAYWxpYXMgbGVuZ3RoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRMZW5ndGhDaGFpbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnZG9MZW5ndGgnLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydExlbmd0aCAobiwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIG9ialR5cGUgPSBfLnR5cGUob2JqKS50b0xvd2VyQ2FzZSgpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKVxuICAgICAgLCBkZXNjcmlwdG9yID0gJ2xlbmd0aCdcbiAgICAgICwgaXRlbXNDb3VudDtcblxuICAgIHN3aXRjaCAob2JqVHlwZSkge1xuICAgICAgY2FzZSAnbWFwJzpcbiAgICAgIGNhc2UgJ3NldCc6XG4gICAgICAgIGRlc2NyaXB0b3IgPSAnc2l6ZSc7XG4gICAgICAgIGl0ZW1zQ291bnQgPSBvYmouc2l6ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkudG8uaGF2ZS5wcm9wZXJ0eSgnbGVuZ3RoJyk7XG4gICAgICAgIGl0ZW1zQ291bnQgPSBvYmoubGVuZ3RoO1xuICAgIH1cblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBpdGVtc0NvdW50ID09IG5cbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhICcgKyBkZXNjcmlwdG9yICsgJyBvZiAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIGEgJyArIGRlc2NyaXB0b3IgKyAnIG9mICN7YWN0fSdcbiAgICAgICwgblxuICAgICAgLCBpdGVtc0NvdW50XG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2xlbmd0aCcsIGFzc2VydExlbmd0aCwgYXNzZXJ0TGVuZ3RoQ2hhaW4pO1xuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdsZW5ndGhPZicsIGFzc2VydExlbmd0aCwgYXNzZXJ0TGVuZ3RoQ2hhaW4pO1xuXG4gIC8qKlxuICAgKiAjIyMgLm1hdGNoKHJlWywgbXNnXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgbWF0Y2hlcyB0aGUgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uIGByZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicpLnRvLm1hdGNoKC9eZm9vLyk7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAubWF0Y2hgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb29iYXInKS50by5ub3QubWF0Y2goL3RhY28vKTtcbiAgICpcbiAgICogYC5tYXRjaGAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gICAqIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhcyB0aGVcbiAgICogc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb29iYXInKS50by5tYXRjaCgvdGFjby8sICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJywgJ25vb28gd2h5IGZhaWw/PycpLnRvLm1hdGNoKC90YWNvLyk7XG4gICAqXG4gICAqIFRoZSBhbGlhcyBgLm1hdGNoZXNgIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAubWF0Y2hgLlxuICAgKlxuICAgKiBAbmFtZSBtYXRjaFxuICAgKiBAYWxpYXMgbWF0Y2hlc1xuICAgKiBAcGFyYW0ge1JlZ0V4cH0gcmVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuICBmdW5jdGlvbiBhc3NlcnRNYXRjaChyZSwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICByZS5leGVjKG9iailcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbWF0Y2ggJyArIHJlXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IG5vdCB0byBtYXRjaCAnICsgcmVcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbWF0Y2gnLCBhc3NlcnRNYXRjaCk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ21hdGNoZXMnLCBhc3NlcnRNYXRjaCk7XG5cbiAgLyoqXG4gICAqICMjIyAuc3RyaW5nKHN0clssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IHN0cmluZyBjb250YWlucyB0aGUgZ2l2ZW4gc3Vic3RyaW5nIGBzdHJgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb29iYXInKS50by5oYXZlLnN0cmluZygnYmFyJyk7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuc3RyaW5nYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJykudG8ubm90LmhhdmUuc3RyaW5nKCd0YWNvJyk7XG4gICAqXG4gICAqIGAuc3RyaW5nYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yXG4gICAqIG1lc3NhZ2UgdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzXG4gICAqIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicpLnRvLmhhdmUuc3RyaW5nKCd0YWNvJywgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KCdmb29iYXInLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uaGF2ZS5zdHJpbmcoJ3RhY28nKTtcbiAgICpcbiAgICogQG5hbWUgc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3N0cmluZycsIGZ1bmN0aW9uIChzdHIsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJyk7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIGZsYWdNc2csIHNzZmksIHRydWUpLmlzLmEoJ3N0cmluZycpO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIH5vYmouaW5kZXhPZihzdHIpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGNvbnRhaW4gJyArIF8uaW5zcGVjdChzdHIpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBjb250YWluICcgKyBfLmluc3BlY3Qoc3RyKVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmtleXMoa2V5MVssIGtleTJbLCAuLi5dXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgb2JqZWN0LCBhcnJheSwgbWFwLCBvciBzZXQgaGFzIHRoZSBnaXZlbiBrZXlzLiBPbmx5XG4gICAqIHRoZSB0YXJnZXQncyBvd24gaW5oZXJpdGVkIHByb3BlcnRpZXMgYXJlIGluY2x1ZGVkIGluIHRoZSBzZWFyY2guXG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBhbiBvYmplY3Qgb3IgYXJyYXksIGtleXMgY2FuIGJlIHByb3ZpZGVkIGFzIG9uZSBvciBtb3JlXG4gICAqIHN0cmluZyBhcmd1bWVudHMsIGEgc2luZ2xlIGFycmF5IGFyZ3VtZW50LCBvciBhIHNpbmdsZSBvYmplY3QgYXJndW1lbnQuIEluXG4gICAqIHRoZSBsYXR0ZXIgY2FzZSwgb25seSB0aGUga2V5cyBpbiB0aGUgZ2l2ZW4gb2JqZWN0IG1hdHRlcjsgdGhlIHZhbHVlcyBhcmVcbiAgICogaWdub3JlZC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMSwgYjogMn0pLnRvLmhhdmUuYWxsLmtleXMoJ2EnLCAnYicpO1xuICAgKiAgICAgZXhwZWN0KFsneCcsICd5J10pLnRvLmhhdmUuYWxsLmtleXMoMCwgMSk7XG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDJ9KS50by5oYXZlLmFsbC5rZXlzKFsnYScsICdiJ10pO1xuICAgKiAgICAgZXhwZWN0KFsneCcsICd5J10pLnRvLmhhdmUuYWxsLmtleXMoWzAsIDFdKTtcbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMSwgYjogMn0pLnRvLmhhdmUuYWxsLmtleXMoe2E6IDQsIGI6IDV9KTsgLy8gaWdub3JlIDQgYW5kIDVcbiAgICogICAgIGV4cGVjdChbJ3gnLCAneSddKS50by5oYXZlLmFsbC5rZXlzKHswOiA0LCAxOiA1fSk7IC8vIGlnbm9yZSA0IGFuZCA1XG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBhIG1hcCBvciBzZXQsIGVhY2gga2V5IG11c3QgYmUgcHJvdmlkZWQgYXMgYSBzZXBhcmF0ZVxuICAgKiBhcmd1bWVudC5cbiAgICpcbiAgICogICAgIGV4cGVjdChuZXcgTWFwKFtbJ2EnLCAxXSwgWydiJywgMl1dKSkudG8uaGF2ZS5hbGwua2V5cygnYScsICdiJyk7XG4gICAqICAgICBleHBlY3QobmV3IFNldChbJ2EnLCAnYiddKSkudG8uaGF2ZS5hbGwua2V5cygnYScsICdiJyk7XG4gICAqXG4gICAqIEJlY2F1c2UgYC5rZXlzYCBkb2VzIGRpZmZlcmVudCB0aGluZ3MgYmFzZWQgb24gdGhlIHRhcmdldCdzIHR5cGUsIGl0J3NcbiAgICogaW1wb3J0YW50IHRvIGNoZWNrIHRoZSB0YXJnZXQncyB0eXBlIGJlZm9yZSB1c2luZyBgLmtleXNgLiBTZWUgdGhlIGAuYWAgZG9jXG4gICAqIGZvciBpbmZvIG9uIHRlc3RpbmcgYSB0YXJnZXQncyB0eXBlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyfSkudG8uYmUuYW4oJ29iamVjdCcpLnRoYXQuaGFzLmFsbC5rZXlzKCdhJywgJ2InKTtcbiAgICpcbiAgICogQnkgZGVmYXVsdCwgc3RyaWN0IChgPT09YCkgZXF1YWxpdHkgaXMgdXNlZCB0byBjb21wYXJlIGtleXMgb2YgbWFwcyBhbmRcbiAgICogc2V0cy4gQWRkIGAuZGVlcGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gdXNlIGRlZXAgZXF1YWxpdHkgaW5zdGVhZC4gU2VlXG4gICAqIHRoZSBgZGVlcC1lcWxgIHByb2plY3QgcGFnZSBmb3IgaW5mbyBvbiB0aGUgZGVlcCBlcXVhbGl0eSBhbGdvcml0aG06XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFpanMvZGVlcC1lcWwuXG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgc2V0IGRlZXBseSAoYnV0IG5vdCBzdHJpY3RseSkgaGFzIGtleSBge2E6IDF9YFxuICAgKiAgICAgZXhwZWN0KG5ldyBTZXQoW3thOiAxfV0pKS50by5oYXZlLmFsbC5kZWVwLmtleXMoW3thOiAxfV0pO1xuICAgKiAgICAgZXhwZWN0KG5ldyBTZXQoW3thOiAxfV0pKS50by5ub3QuaGF2ZS5hbGwua2V5cyhbe2E6IDF9XSk7XG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSB0YXJnZXQgbXVzdCBoYXZlIGFsbCBvZiB0aGUgZ2l2ZW4ga2V5cyBhbmQgbm8gbW9yZS4gQWRkXG4gICAqIGAuYW55YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBvbmx5IHJlcXVpcmUgdGhhdCB0aGUgdGFyZ2V0IGhhdmUgYXQgbGVhc3RcbiAgICogb25lIG9mIHRoZSBnaXZlbiBrZXlzLiBBbHNvLCBhZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZVxuICAgKiBgLmtleXNgLiBJdCdzIG9mdGVuIGJlc3QgdG8gYWRkIGAuYW55YCB3aGVuIG5lZ2F0aW5nIGAua2V5c2AsIGFuZCB0byB1c2VcbiAgICogYC5hbGxgIHdoZW4gYXNzZXJ0aW5nIGAua2V5c2Agd2l0aG91dCBuZWdhdGlvbi5cbiAgICpcbiAgICogV2hlbiBuZWdhdGluZyBgLmtleXNgLCBgLmFueWAgaXMgcHJlZmVycmVkIGJlY2F1c2UgYC5ub3QuYW55LmtleXNgIGFzc2VydHNcbiAgICogZXhhY3RseSB3aGF0J3MgZXhwZWN0ZWQgb2YgdGhlIG91dHB1dCwgd2hlcmVhcyBgLm5vdC5hbGwua2V5c2AgY3JlYXRlc1xuICAgKiB1bmNlcnRhaW4gZXhwZWN0YXRpb25zLlxuICAgKlxuICAgKiAgICAgLy8gUmVjb21tZW5kZWQ7IGFzc2VydHMgdGhhdCB0YXJnZXQgZG9lc24ndCBoYXZlIGFueSBvZiB0aGUgZ2l2ZW4ga2V5c1xuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyfSkudG8ubm90LmhhdmUuYW55LmtleXMoJ2MnLCAnZCcpO1xuICAgKlxuICAgKiAgICAgLy8gTm90IHJlY29tbWVuZGVkOyBhc3NlcnRzIHRoYXQgdGFyZ2V0IGRvZXNuJ3QgaGF2ZSBhbGwgb2YgdGhlIGdpdmVuXG4gICAqICAgICAvLyBrZXlzIGJ1dCBtYXkgb3IgbWF5IG5vdCBoYXZlIHNvbWUgb2YgdGhlbVxuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyfSkudG8ubm90LmhhdmUuYWxsLmtleXMoJ2MnLCAnZCcpO1xuICAgKlxuICAgKiBXaGVuIGFzc2VydGluZyBgLmtleXNgIHdpdGhvdXQgbmVnYXRpb24sIGAuYWxsYCBpcyBwcmVmZXJyZWQgYmVjYXVzZVxuICAgKiBgLmFsbC5rZXlzYCBhc3NlcnRzIGV4YWN0bHkgd2hhdCdzIGV4cGVjdGVkIG9mIHRoZSBvdXRwdXQsIHdoZXJlYXNcbiAgICogYC5hbnkua2V5c2AgY3JlYXRlcyB1bmNlcnRhaW4gZXhwZWN0YXRpb25zLlxuICAgKlxuICAgKiAgICAgLy8gUmVjb21tZW5kZWQ7IGFzc2VydHMgdGhhdCB0YXJnZXQgaGFzIGFsbCB0aGUgZ2l2ZW4ga2V5c1xuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyfSkudG8uaGF2ZS5hbGwua2V5cygnYScsICdiJyk7XG4gICAqXG4gICAqICAgICAvLyBOb3QgcmVjb21tZW5kZWQ7IGFzc2VydHMgdGhhdCB0YXJnZXQgaGFzIGF0IGxlYXN0IG9uZSBvZiB0aGUgZ2l2ZW5cbiAgICogICAgIC8vIGtleXMgYnV0IG1heSBvciBtYXkgbm90IGhhdmUgbW9yZSBvZiB0aGVtXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDJ9KS50by5oYXZlLmFueS5rZXlzKCdhJywgJ2InKTtcbiAgICpcbiAgICogTm90ZSB0aGF0IGAuYWxsYCBpcyB1c2VkIGJ5IGRlZmF1bHQgd2hlbiBuZWl0aGVyIGAuYWxsYCBub3IgYC5hbnlgIGFwcGVhclxuICAgKiBlYXJsaWVyIGluIHRoZSBjaGFpbi4gSG93ZXZlciwgaXQncyBvZnRlbiBiZXN0IHRvIGFkZCBgLmFsbGAgYW55d2F5IGJlY2F1c2VcbiAgICogaXQgaW1wcm92ZXMgcmVhZGFiaWxpdHkuXG4gICAqXG4gICAqICAgICAvLyBCb3RoIGFzc2VydGlvbnMgYXJlIGlkZW50aWNhbFxuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyfSkudG8uaGF2ZS5hbGwua2V5cygnYScsICdiJyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDJ9KS50by5oYXZlLmtleXMoJ2EnLCAnYicpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQWRkIGAuaW5jbHVkZWAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gcmVxdWlyZSB0aGF0IHRoZSB0YXJnZXQncyBrZXlzIGJlIGFcbiAgICogc3VwZXJzZXQgb2YgdGhlIGV4cGVjdGVkIGtleXMsIHJhdGhlciB0aGFuIGlkZW50aWNhbCBzZXRzLlxuICAgKlxuICAgKiAgICAgLy8gVGFyZ2V0IG9iamVjdCdzIGtleXMgYXJlIGEgc3VwZXJzZXQgb2YgWydhJywgJ2InXSBidXQgbm90IGlkZW50aWNhbFxuICAgKiAgICAgZXhwZWN0KHthOiAxLCBiOiAyLCBjOiAzfSkudG8uaW5jbHVkZS5hbGwua2V5cygnYScsICdiJyk7XG4gICAqICAgICBleHBlY3Qoe2E6IDEsIGI6IDIsIGM6IDN9KS50by5ub3QuaGF2ZS5hbGwua2V5cygnYScsICdiJyk7XG4gICAqXG4gICAqIEhvd2V2ZXIsIGlmIGAuYW55YCBhbmQgYC5pbmNsdWRlYCBhcmUgY29tYmluZWQsIG9ubHkgdGhlIGAuYW55YCB0YWtlc1xuICAgKiBlZmZlY3QuIFRoZSBgLmluY2x1ZGVgIGlzIGlnbm9yZWQgaW4gdGhpcyBjYXNlLlxuICAgKlxuICAgKiAgICAgLy8gQm90aCBhc3NlcnRpb25zIGFyZSBpZGVudGljYWxcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLmhhdmUuYW55LmtleXMoJ2EnLCAnYicpO1xuICAgKiAgICAgZXhwZWN0KHthOiAxfSkudG8uaW5jbHVkZS5hbnkua2V5cygnYScsICdiJyk7XG4gICAqXG4gICAqIEEgY3VzdG9tIGVycm9yIG1lc3NhZ2UgY2FuIGJlIGdpdmVuIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9LCAnbm9vbyB3aHkgZmFpbD8/JykudG8uaGF2ZS5rZXkoJ2InKTtcbiAgICpcbiAgICogVGhlIGFsaWFzIGAua2V5YCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLmtleXNgLlxuICAgKlxuICAgKiBAbmFtZSBrZXlzXG4gICAqIEBhbGlhcyBrZXlcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd8QXJyYXl8T2JqZWN0fSBrZXlzXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEtleXMgKGtleXMpIHtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgb2JqVHlwZSA9IF8udHlwZShvYmopXG4gICAgICAsIGtleXNUeXBlID0gXy50eXBlKGtleXMpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJylcbiAgICAgICwgaXNEZWVwID0gZmxhZyh0aGlzLCAnZGVlcCcpXG4gICAgICAsIHN0clxuICAgICAgLCBkZWVwU3RyID0gJydcbiAgICAgICwgYWN0dWFsXG4gICAgICAsIG9rID0gdHJ1ZVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpO1xuXG4gICAgZmxhZ01zZyA9IGZsYWdNc2cgPyBmbGFnTXNnICsgJzogJyA6ICcnO1xuICAgIHZhciBtaXhlZEFyZ3NNc2cgPSBmbGFnTXNnICsgJ3doZW4gdGVzdGluZyBrZXlzIGFnYWluc3QgYW4gb2JqZWN0IG9yIGFuIGFycmF5IHlvdSBtdXN0IGdpdmUgYSBzaW5nbGUgQXJyYXl8T2JqZWN0fFN0cmluZyBhcmd1bWVudCBvciBtdWx0aXBsZSBTdHJpbmcgYXJndW1lbnRzJztcblxuICAgIGlmIChvYmpUeXBlID09PSAnTWFwJyB8fCBvYmpUeXBlID09PSAnU2V0Jykge1xuICAgICAgZGVlcFN0ciA9IGlzRGVlcCA/ICdkZWVwbHkgJyA6ICcnO1xuICAgICAgYWN0dWFsID0gW107XG5cbiAgICAgIC8vIE1hcCBhbmQgU2V0ICcua2V5cycgYXJlbid0IHN1cHBvcnRlZCBpbiBJRSAxMS4gVGhlcmVmb3JlLCB1c2UgLmZvckVhY2guXG4gICAgICBvYmouZm9yRWFjaChmdW5jdGlvbiAodmFsLCBrZXkpIHsgYWN0dWFsLnB1c2goa2V5KSB9KTtcblxuICAgICAgaWYgKGtleXNUeXBlICE9PSAnQXJyYXknKSB7XG4gICAgICAgIGtleXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhY3R1YWwgPSBfLmdldE93bkVudW1lcmFibGVQcm9wZXJ0aWVzKG9iaik7XG5cbiAgICAgIHN3aXRjaCAoa2V5c1R5cGUpIHtcbiAgICAgICAgY2FzZSAnQXJyYXknOlxuICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKG1peGVkQXJnc01zZywgdW5kZWZpbmVkLCBzc2ZpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ09iamVjdCc6XG4gICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IobWl4ZWRBcmdzTXNnLCB1bmRlZmluZWQsIHNzZmkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrZXlzID0gT2JqZWN0LmtleXMoa2V5cyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAga2V5cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIC8vIE9ubHkgc3RyaW5naWZ5IG5vbi1TeW1ib2xzIGJlY2F1c2UgU3ltYm9scyB3b3VsZCBiZWNvbWUgXCJTeW1ib2woKVwiXG4gICAgICBrZXlzID0ga2V5cy5tYXAoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N5bWJvbCcgPyB2YWwgOiBTdHJpbmcodmFsKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICgha2V5cy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihmbGFnTXNnICsgJ2tleXMgcmVxdWlyZWQnLCB1bmRlZmluZWQsIHNzZmkpO1xuICAgIH1cblxuICAgIHZhciBsZW4gPSBrZXlzLmxlbmd0aFxuICAgICAgLCBhbnkgPSBmbGFnKHRoaXMsICdhbnknKVxuICAgICAgLCBhbGwgPSBmbGFnKHRoaXMsICdhbGwnKVxuICAgICAgLCBleHBlY3RlZCA9IGtleXM7XG5cbiAgICBpZiAoIWFueSAmJiAhYWxsKSB7XG4gICAgICBhbGwgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIEhhcyBhbnlcbiAgICBpZiAoYW55KSB7XG4gICAgICBvayA9IGV4cGVjdGVkLnNvbWUoZnVuY3Rpb24oZXhwZWN0ZWRLZXkpIHtcbiAgICAgICAgcmV0dXJuIGFjdHVhbC5zb21lKGZ1bmN0aW9uKGFjdHVhbEtleSkge1xuICAgICAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgICAgIHJldHVybiBfLmVxbChleHBlY3RlZEtleSwgYWN0dWFsS2V5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGVkS2V5ID09PSBhY3R1YWxLZXk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEhhcyBhbGxcbiAgICBpZiAoYWxsKSB7XG4gICAgICBvayA9IGV4cGVjdGVkLmV2ZXJ5KGZ1bmN0aW9uKGV4cGVjdGVkS2V5KSB7XG4gICAgICAgIHJldHVybiBhY3R1YWwuc29tZShmdW5jdGlvbihhY3R1YWxLZXkpIHtcbiAgICAgICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgICAgICByZXR1cm4gXy5lcWwoZXhwZWN0ZWRLZXksIGFjdHVhbEtleSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBleHBlY3RlZEtleSA9PT0gYWN0dWFsS2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFmbGFnKHRoaXMsICdjb250YWlucycpKSB7XG4gICAgICAgIG9rID0gb2sgJiYga2V5cy5sZW5ndGggPT0gYWN0dWFsLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBLZXkgc3RyaW5nXG4gICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgIGtleXMgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIF8uaW5zcGVjdChrZXkpO1xuICAgICAgfSk7XG4gICAgICB2YXIgbGFzdCA9IGtleXMucG9wKCk7XG4gICAgICBpZiAoYWxsKSB7XG4gICAgICAgIHN0ciA9IGtleXMuam9pbignLCAnKSArICcsIGFuZCAnICsgbGFzdDtcbiAgICAgIH1cbiAgICAgIGlmIChhbnkpIHtcbiAgICAgICAgc3RyID0ga2V5cy5qb2luKCcsICcpICsgJywgb3IgJyArIGxhc3Q7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IF8uaW5zcGVjdChrZXlzWzBdKTtcbiAgICB9XG5cbiAgICAvLyBGb3JtXG4gICAgc3RyID0gKGxlbiA+IDEgPyAna2V5cyAnIDogJ2tleSAnKSArIHN0cjtcblxuICAgIC8vIEhhdmUgLyBpbmNsdWRlXG4gICAgc3RyID0gKGZsYWcodGhpcywgJ2NvbnRhaW5zJykgPyAnY29udGFpbiAnIDogJ2hhdmUgJykgKyBzdHI7XG5cbiAgICAvLyBBc3NlcnRpb25cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgb2tcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gJyArIGRlZXBTdHIgKyBzdHJcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90ICcgKyBkZWVwU3RyICsgc3RyXG4gICAgICAsIGV4cGVjdGVkLnNsaWNlKDApLnNvcnQoXy5jb21wYXJlQnlJbnNwZWN0KVxuICAgICAgLCBhY3R1YWwuc29ydChfLmNvbXBhcmVCeUluc3BlY3QpXG4gICAgICAsIHRydWVcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgna2V5cycsIGFzc2VydEtleXMpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdrZXknLCBhc3NlcnRLZXlzKTtcblxuICAvKipcbiAgICogIyMjIC50aHJvdyhbZXJyb3JMaWtlXSwgW2Vyck1zZ01hdGNoZXJdLCBbbXNnXSlcbiAgICpcbiAgICogV2hlbiBubyBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLCBgLnRocm93YCBpbnZva2VzIHRoZSB0YXJnZXQgZnVuY3Rpb24gYW5kXG4gICAqIGFzc2VydHMgdGhhdCBhbiBlcnJvciBpcyB0aHJvd24uXG4gICAqXG4gICAqICAgICB2YXIgYmFkRm4gPSBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgc2FsbW9uIScpOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGJhZEZuKS50by50aHJvdygpO1xuICAgKlxuICAgKiBXaGVuIG9uZSBhcmd1bWVudCBpcyBwcm92aWRlZCwgYW5kIGl0J3MgYW4gZXJyb3IgY29uc3RydWN0b3IsIGAudGhyb3dgXG4gICAqIGludm9rZXMgdGhlIHRhcmdldCBmdW5jdGlvbiBhbmQgYXNzZXJ0cyB0aGF0IGFuIGVycm9yIGlzIHRocm93biB0aGF0J3MgYW5cbiAgICogaW5zdGFuY2Ugb2YgdGhhdCBlcnJvciBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogICAgIHZhciBiYWRGbiA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBzYWxtb24hJyk7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYmFkRm4pLnRvLnRocm93KFR5cGVFcnJvcik7XG4gICAqXG4gICAqIFdoZW4gb25lIGFyZ3VtZW50IGlzIHByb3ZpZGVkLCBhbmQgaXQncyBhbiBlcnJvciBpbnN0YW5jZSwgYC50aHJvd2AgaW52b2tlc1xuICAgKiB0aGUgdGFyZ2V0IGZ1bmN0aW9uIGFuZCBhc3NlcnRzIHRoYXQgYW4gZXJyb3IgaXMgdGhyb3duIHRoYXQncyBzdHJpY3RseVxuICAgKiAoYD09PWApIGVxdWFsIHRvIHRoYXQgZXJyb3IgaW5zdGFuY2UuXG4gICAqXG4gICAqICAgICB2YXIgZXJyID0gbmV3IFR5cGVFcnJvcignSWxsZWdhbCBzYWxtb24hJyk7XG4gICAqICAgICB2YXIgYmFkRm4gPSBmdW5jdGlvbiAoKSB7IHRocm93IGVycjsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChiYWRGbikudG8udGhyb3coZXJyKTtcbiAgICpcbiAgICogV2hlbiBvbmUgYXJndW1lbnQgaXMgcHJvdmlkZWQsIGFuZCBpdCdzIGEgc3RyaW5nLCBgLnRocm93YCBpbnZva2VzIHRoZVxuICAgKiB0YXJnZXQgZnVuY3Rpb24gYW5kIGFzc2VydHMgdGhhdCBhbiBlcnJvciBpcyB0aHJvd24gd2l0aCBhIG1lc3NhZ2UgdGhhdFxuICAgKiBjb250YWlucyB0aGF0IHN0cmluZy5cbiAgICpcbiAgICogICAgIHZhciBiYWRGbiA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBzYWxtb24hJyk7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYmFkRm4pLnRvLnRocm93KCdzYWxtb24nKTtcbiAgICpcbiAgICogV2hlbiBvbmUgYXJndW1lbnQgaXMgcHJvdmlkZWQsIGFuZCBpdCdzIGEgcmVndWxhciBleHByZXNzaW9uLCBgLnRocm93YFxuICAgKiBpbnZva2VzIHRoZSB0YXJnZXQgZnVuY3Rpb24gYW5kIGFzc2VydHMgdGhhdCBhbiBlcnJvciBpcyB0aHJvd24gd2l0aCBhXG4gICAqIG1lc3NhZ2UgdGhhdCBtYXRjaGVzIHRoYXQgcmVndWxhciBleHByZXNzaW9uLlxuICAgKlxuICAgKiAgICAgdmFyIGJhZEZuID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIHNhbG1vbiEnKTsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChiYWRGbikudG8udGhyb3coL3NhbG1vbi8pO1xuICAgKlxuICAgKiBXaGVuIHR3byBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLCBhbmQgdGhlIGZpcnN0IGlzIGFuIGVycm9yIGluc3RhbmNlIG9yXG4gICAqIGNvbnN0cnVjdG9yLCBhbmQgdGhlIHNlY29uZCBpcyBhIHN0cmluZyBvciByZWd1bGFyIGV4cHJlc3Npb24sIGAudGhyb3dgXG4gICAqIGludm9rZXMgdGhlIGZ1bmN0aW9uIGFuZCBhc3NlcnRzIHRoYXQgYW4gZXJyb3IgaXMgdGhyb3duIHRoYXQgZnVsZmlsbHMgYm90aFxuICAgKiBjb25kaXRpb25zIGFzIGRlc2NyaWJlZCBhYm92ZS5cbiAgICpcbiAgICogICAgIHZhciBlcnIgPSBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIHNhbG1vbiEnKTtcbiAgICogICAgIHZhciBiYWRGbiA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgZXJyOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGJhZEZuKS50by50aHJvdyhUeXBlRXJyb3IsICdzYWxtb24nKTtcbiAgICogICAgIGV4cGVjdChiYWRGbikudG8udGhyb3coVHlwZUVycm9yLCAvc2FsbW9uLyk7XG4gICAqICAgICBleHBlY3QoYmFkRm4pLnRvLnRocm93KGVyciwgJ3NhbG1vbicpO1xuICAgKiAgICAgZXhwZWN0KGJhZEZuKS50by50aHJvdyhlcnIsIC9zYWxtb24vKTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC50aHJvd2AuXG4gICAqXG4gICAqICAgICB2YXIgZ29vZEZuID0gZnVuY3Rpb24gKCkge307XG4gICAqXG4gICAqICAgICBleHBlY3QoZ29vZEZuKS50by5ub3QudGhyb3coKTtcbiAgICpcbiAgICogSG93ZXZlciwgaXQncyBkYW5nZXJvdXMgdG8gbmVnYXRlIGAudGhyb3dgIHdoZW4gcHJvdmlkaW5nIGFueSBhcmd1bWVudHMuXG4gICAqIFRoZSBwcm9ibGVtIGlzIHRoYXQgaXQgY3JlYXRlcyB1bmNlcnRhaW4gZXhwZWN0YXRpb25zIGJ5IGFzc2VydGluZyB0aGF0IHRoZVxuICAgKiB0YXJnZXQgZWl0aGVyIGRvZXNuJ3QgdGhyb3cgYW4gZXJyb3IsIG9yIHRoYXQgaXQgdGhyb3dzIGFuIGVycm9yIGJ1dCBvZiBhXG4gICAqIGRpZmZlcmVudCB0eXBlIHRoYW4gdGhlIGdpdmVuIHR5cGUsIG9yIHRoYXQgaXQgdGhyb3dzIGFuIGVycm9yIG9mIHRoZSBnaXZlblxuICAgKiB0eXBlIGJ1dCB3aXRoIGEgbWVzc2FnZSB0aGF0IGRvZXNuJ3QgaW5jbHVkZSB0aGUgZ2l2ZW4gc3RyaW5nLiBJdCdzIG9mdGVuXG4gICAqIGJlc3QgdG8gaWRlbnRpZnkgdGhlIGV4YWN0IG91dHB1dCB0aGF0J3MgZXhwZWN0ZWQsIGFuZCB0aGVuIHdyaXRlIGFuXG4gICAqIGFzc2VydGlvbiB0aGF0IG9ubHkgYWNjZXB0cyB0aGF0IGV4YWN0IG91dHB1dC5cbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzbid0IGV4cGVjdGVkIHRvIHRocm93IGFuIGVycm9yLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0XG4gICAqIGV4YWN0bHkgdGhhdC5cbiAgICpcbiAgICogICAgIHZhciBnb29kRm4gPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChnb29kRm4pLnRvLm5vdC50aHJvdygpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KGdvb2RGbikudG8ubm90LnRocm93KFJlZmVyZW5jZUVycm9yLCAneCcpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGV4cGVjdGVkIHRvIHRocm93IGFuIGVycm9yLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0XG4gICAqIHRoYXQgdGhlIGVycm9yIGlzIG9mIGl0cyBleHBlY3RlZCB0eXBlLCBhbmQgaGFzIGEgbWVzc2FnZSB0aGF0IGluY2x1ZGVzIGFuXG4gICAqIGV4cGVjdGVkIHN0cmluZywgcmF0aGVyIHRoYW4gYXNzZXJ0aW5nIHRoYXQgaXQgZG9lc24ndCBoYXZlIG9uZSBvZiBtYW55XG4gICAqIHVuZXhwZWN0ZWQgdHlwZXMsIGFuZCBkb2Vzbid0IGhhdmUgYSBtZXNzYWdlIHRoYXQgaW5jbHVkZXMgc29tZSBzdHJpbmcuXG4gICAqXG4gICAqICAgICB2YXIgYmFkRm4gPSBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0lsbGVnYWwgc2FsbW9uIScpOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGJhZEZuKS50by50aHJvdyhUeXBlRXJyb3IsICdzYWxtb24nKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChiYWRGbikudG8ubm90LnRocm93KFJlZmVyZW5jZUVycm9yLCAneCcpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC50aHJvd2AgY2hhbmdlcyB0aGUgdGFyZ2V0IG9mIGFueSBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpbiB0b1xuICAgKiBiZSB0aGUgZXJyb3Igb2JqZWN0IHRoYXQncyB0aHJvd24uXG4gICAqXG4gICAqICAgICB2YXIgZXJyID0gbmV3IFR5cGVFcnJvcignSWxsZWdhbCBzYWxtb24hJyk7XG4gICAqICAgICBlcnIuY29kZSA9IDQyO1xuICAgKiAgICAgdmFyIGJhZEZuID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBlcnI7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYmFkRm4pLnRvLnRocm93KFR5cGVFcnJvcikud2l0aC5wcm9wZXJ0eSgnY29kZScsIDQyKTtcbiAgICpcbiAgICogYC50aHJvd2AgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gICAqIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhcyB0aGVcbiAgICogc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLiBXaGVuIG5vdCBwcm92aWRpbmcgdHdvIGFyZ3VtZW50cywgYWx3YXlzIHVzZVxuICAgKiB0aGUgc2Vjb25kIGZvcm0uXG4gICAqXG4gICAqICAgICB2YXIgZ29vZEZuID0gZnVuY3Rpb24gKCkge307XG4gICAqXG4gICAqICAgICBleHBlY3QoZ29vZEZuKS50by50aHJvdyhUeXBlRXJyb3IsICd4JywgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KGdvb2RGbiwgJ25vb28gd2h5IGZhaWw/PycpLnRvLnRocm93KCk7XG4gICAqXG4gICAqIER1ZSB0byBsaW1pdGF0aW9ucyBpbiBFUzUsIGAudGhyb3dgIG1heSBub3QgYWx3YXlzIHdvcmsgYXMgZXhwZWN0ZWQgd2hlblxuICAgKiB1c2luZyBhIHRyYW5zcGlsZXIgc3VjaCBhcyBCYWJlbCBvciBUeXBlU2NyaXB0LiBJbiBwYXJ0aWN1bGFyLCBpdCBtYXlcbiAgICogcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHMgd2hlbiBzdWJjbGFzc2luZyB0aGUgYnVpbHQtaW4gYEVycm9yYCBvYmplY3QgYW5kXG4gICAqIHRoZW4gcGFzc2luZyB0aGUgc3ViY2xhc3NlZCBjb25zdHJ1Y3RvciB0byBgLnRocm93YC4gU2VlIHlvdXIgdHJhbnNwaWxlcidzXG4gICAqIGRvY3MgZm9yIGRldGFpbHM6XG4gICAqXG4gICAqIC0gKFtCYWJlbF0oaHR0cHM6Ly9iYWJlbGpzLmlvL2RvY3MvdXNhZ2UvY2F2ZWF0cy8jY2xhc3NlcykpXG4gICAqIC0gKFtUeXBlU2NyaXB0XShodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvd2lraS9CcmVha2luZy1DaGFuZ2VzI2V4dGVuZGluZy1idWlsdC1pbnMtbGlrZS1lcnJvci1hcnJheS1hbmQtbWFwLW1heS1uby1sb25nZXItd29yaykpXG4gICAqXG4gICAqIEJld2FyZSBvZiBzb21lIGNvbW1vbiBtaXN0YWtlcyB3aGVuIHVzaW5nIHRoZSBgdGhyb3dgIGFzc2VydGlvbi4gT25lIGNvbW1vblxuICAgKiBtaXN0YWtlIGlzIHRvIGFjY2lkZW50YWxseSBpbnZva2UgdGhlIGZ1bmN0aW9uIHlvdXJzZWxmIGluc3RlYWQgb2YgbGV0dGluZ1xuICAgKiB0aGUgYHRocm93YCBhc3NlcnRpb24gaW52b2tlIHRoZSBmdW5jdGlvbiBmb3IgeW91LiBGb3IgZXhhbXBsZSwgd2hlblxuICAgKiB0ZXN0aW5nIGlmIGEgZnVuY3Rpb24gbmFtZWQgYGZuYCB0aHJvd3MsIHByb3ZpZGUgYGZuYCBpbnN0ZWFkIG9mIGBmbigpYCBhc1xuICAgKiB0aGUgdGFyZ2V0IGZvciB0aGUgYXNzZXJ0aW9uLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZuKS50by50aHJvdygpOyAgICAgLy8gR29vZCEgVGVzdHMgYGZuYCBhcyBkZXNpcmVkXG4gICAqICAgICBleHBlY3QoZm4oKSkudG8udGhyb3coKTsgICAvLyBCYWQhIFRlc3RzIHJlc3VsdCBvZiBgZm4oKWAsIG5vdCBgZm5gXG4gICAqXG4gICAqIElmIHlvdSBuZWVkIHRvIGFzc2VydCB0aGF0IHlvdXIgZnVuY3Rpb24gYGZuYCB0aHJvd3Mgd2hlbiBwYXNzZWQgY2VydGFpblxuICAgKiBhcmd1bWVudHMsIHRoZW4gd3JhcCBhIGNhbGwgdG8gYGZuYCBpbnNpZGUgb2YgYW5vdGhlciBmdW5jdGlvbi5cbiAgICpcbiAgICogICAgIGV4cGVjdChmdW5jdGlvbiAoKSB7IGZuKDQyKTsgfSkudG8udGhyb3coKTsgIC8vIEZ1bmN0aW9uIGV4cHJlc3Npb25cbiAgICogICAgIGV4cGVjdCgoKSA9PiBmbig0MikpLnRvLnRocm93KCk7ICAgICAgICAgICAgIC8vIEVTNiBhcnJvdyBmdW5jdGlvblxuICAgKlxuICAgKiBBbm90aGVyIGNvbW1vbiBtaXN0YWtlIGlzIHRvIHByb3ZpZGUgYW4gb2JqZWN0IG1ldGhvZCAob3IgYW55IHN0YW5kLWFsb25lXG4gICAqIGZ1bmN0aW9uIHRoYXQgcmVsaWVzIG9uIGB0aGlzYCkgYXMgdGhlIHRhcmdldCBvZiB0aGUgYXNzZXJ0aW9uLiBEb2luZyBzbyBpc1xuICAgKiBwcm9ibGVtYXRpYyBiZWNhdXNlIHRoZSBgdGhpc2AgY29udGV4dCB3aWxsIGJlIGxvc3Qgd2hlbiB0aGUgZnVuY3Rpb24gaXNcbiAgICogaW52b2tlZCBieSBgLnRocm93YDsgdGhlcmUncyBubyB3YXkgZm9yIGl0IHRvIGtub3cgd2hhdCBgdGhpc2AgaXMgc3VwcG9zZWRcbiAgICogdG8gYmUuIFRoZXJlIGFyZSB0d28gd2F5cyBhcm91bmQgdGhpcyBwcm9ibGVtLiBPbmUgc29sdXRpb24gaXMgdG8gd3JhcCB0aGVcbiAgICogbWV0aG9kIG9yIGZ1bmN0aW9uIGNhbGwgaW5zaWRlIG9mIGFub3RoZXIgZnVuY3Rpb24uIEFub3RoZXIgc29sdXRpb24gaXMgdG9cbiAgICogdXNlIGBiaW5kYC5cbiAgICpcbiAgICogICAgIGV4cGVjdChmdW5jdGlvbiAoKSB7IGNhdC5tZW93KCk7IH0pLnRvLnRocm93KCk7ICAvLyBGdW5jdGlvbiBleHByZXNzaW9uXG4gICAqICAgICBleHBlY3QoKCkgPT4gY2F0Lm1lb3coKSkudG8udGhyb3coKTsgICAgICAgICAgICAgLy8gRVM2IGFycm93IGZ1bmN0aW9uXG4gICAqICAgICBleHBlY3QoY2F0Lm1lb3cuYmluZChjYXQpKS50by50aHJvdygpOyAgICAgICAgICAgLy8gQmluZFxuICAgKlxuICAgKiBGaW5hbGx5LCBpdCdzIHdvcnRoIG1lbnRpb25pbmcgdGhhdCBpdCdzIGEgYmVzdCBwcmFjdGljZSBpbiBKYXZhU2NyaXB0IHRvXG4gICAqIG9ubHkgdGhyb3cgYEVycm9yYCBhbmQgZGVyaXZhdGl2ZXMgb2YgYEVycm9yYCBzdWNoIGFzIGBSZWZlcmVuY2VFcnJvcmAsXG4gICAqIGBUeXBlRXJyb3JgLCBhbmQgdXNlci1kZWZpbmVkIG9iamVjdHMgdGhhdCBleHRlbmQgYEVycm9yYC4gTm8gb3RoZXIgdHlwZSBvZlxuICAgKiB2YWx1ZSB3aWxsIGdlbmVyYXRlIGEgc3RhY2sgdHJhY2Ugd2hlbiBpbml0aWFsaXplZC4gV2l0aCB0aGF0IHNhaWQsIHRoZVxuICAgKiBgdGhyb3dgIGFzc2VydGlvbiBkb2VzIHRlY2huaWNhbGx5IHN1cHBvcnQgYW55IHR5cGUgb2YgdmFsdWUgYmVpbmcgdGhyb3duLFxuICAgKiBub3QganVzdCBgRXJyb3JgIGFuZCBpdHMgZGVyaXZhdGl2ZXMuXG4gICAqXG4gICAqIFRoZSBhbGlhc2VzIGAudGhyb3dzYCBhbmQgYC5UaHJvd2AgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGhcbiAgICogYC50aHJvd2AuXG4gICAqXG4gICAqIEBuYW1lIHRocm93XG4gICAqIEBhbGlhcyB0aHJvd3NcbiAgICogQGFsaWFzIFRocm93XG4gICAqIEBwYXJhbSB7RXJyb3J8RXJyb3JDb25zdHJ1Y3Rvcn0gZXJyb3JMaWtlXG4gICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXJyTXNnTWF0Y2hlciBlcnJvciBtZXNzYWdlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yI0Vycm9yX3R5cGVzXG4gICAqIEByZXR1cm5zIGVycm9yIGZvciBjaGFpbmluZyAobnVsbCBpZiBubyBlcnJvcilcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0VGhyb3dzIChlcnJvckxpa2UsIGVyck1zZ01hdGNoZXIsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgbmVnYXRlID0gZmxhZyh0aGlzLCAnbmVnYXRlJykgfHwgZmFsc2U7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIGZsYWdNc2csIHNzZmksIHRydWUpLmlzLmEoJ2Z1bmN0aW9uJyk7XG5cbiAgICBpZiAoZXJyb3JMaWtlIGluc3RhbmNlb2YgUmVnRXhwIHx8IHR5cGVvZiBlcnJvckxpa2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnJNc2dNYXRjaGVyID0gZXJyb3JMaWtlO1xuICAgICAgZXJyb3JMaWtlID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgY2F1Z2h0RXJyO1xuICAgIHRyeSB7XG4gICAgICBvYmooKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNhdWdodEVyciA9IGVycjtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBoYXZlIHRoZSBuZWdhdGUgZmxhZyBlbmFibGVkIGFuZCBhdCBsZWFzdCBvbmUgdmFsaWQgYXJndW1lbnQgaXQgbWVhbnMgd2UgZG8gZXhwZWN0IGFuIGVycm9yXG4gICAgLy8gYnV0IHdlIHdhbnQgaXQgdG8gbWF0Y2ggYSBnaXZlbiBzZXQgb2YgY3JpdGVyaWFcbiAgICB2YXIgZXZlcnlBcmdJc1VuZGVmaW5lZCA9IGVycm9yTGlrZSA9PT0gdW5kZWZpbmVkICYmIGVyck1zZ01hdGNoZXIgPT09IHVuZGVmaW5lZDtcblxuICAgIC8vIElmIHdlJ3ZlIGdvdCB0aGUgbmVnYXRlIGZsYWcgZW5hYmxlZCBhbmQgYm90aCBhcmdzLCB3ZSBzaG91bGQgb25seSBmYWlsIGlmIGJvdGggYXJlbid0IGNvbXBhdGlibGVcbiAgICAvLyBTZWUgSXNzdWUgIzU1MSBhbmQgUFIgIzY4M0BHaXRIdWJcbiAgICB2YXIgZXZlcnlBcmdJc0RlZmluZWQgPSBCb29sZWFuKGVycm9yTGlrZSAmJiBlcnJNc2dNYXRjaGVyKTtcbiAgICB2YXIgZXJyb3JMaWtlRmFpbCA9IGZhbHNlO1xuICAgIHZhciBlcnJNc2dNYXRjaGVyRmFpbCA9IGZhbHNlO1xuXG4gICAgLy8gQ2hlY2tpbmcgaWYgZXJyb3Igd2FzIHRocm93blxuICAgIGlmIChldmVyeUFyZ0lzVW5kZWZpbmVkIHx8ICFldmVyeUFyZ0lzVW5kZWZpbmVkICYmICFuZWdhdGUpIHtcbiAgICAgIC8vIFdlIG5lZWQgdGhpcyB0byBkaXNwbGF5IHJlc3VsdHMgY29ycmVjdGx5IGFjY29yZGluZyB0byB0aGVpciB0eXBlc1xuICAgICAgdmFyIGVycm9yTGlrZVN0cmluZyA9ICdhbiBlcnJvcic7XG4gICAgICBpZiAoZXJyb3JMaWtlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgZXJyb3JMaWtlU3RyaW5nID0gJyN7ZXhwfSc7XG4gICAgICB9IGVsc2UgaWYgKGVycm9yTGlrZSkge1xuICAgICAgICBlcnJvckxpa2VTdHJpbmcgPSBfLmNoZWNrRXJyb3IuZ2V0Q29uc3RydWN0b3JOYW1lKGVycm9yTGlrZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIGNhdWdodEVyclxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHRocm93ICcgKyBlcnJvckxpa2VTdHJpbmdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgdGhyb3cgYW4gZXJyb3IgYnV0ICN7YWN0fSB3YXMgdGhyb3duJ1xuICAgICAgICAsIGVycm9yTGlrZSAmJiBlcnJvckxpa2UudG9TdHJpbmcoKVxuICAgICAgICAsIChjYXVnaHRFcnIgaW5zdGFuY2VvZiBFcnJvciA/XG4gICAgICAgICAgICBjYXVnaHRFcnIudG9TdHJpbmcoKSA6ICh0eXBlb2YgY2F1Z2h0RXJyID09PSAnc3RyaW5nJyA/IGNhdWdodEVyciA6IGNhdWdodEVyciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5jaGVja0Vycm9yLmdldENvbnN0cnVjdG9yTmFtZShjYXVnaHRFcnIpKSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGVycm9yTGlrZSAmJiBjYXVnaHRFcnIpIHtcbiAgICAgIC8vIFdlIHNob3VsZCBjb21wYXJlIGluc3RhbmNlcyBvbmx5IGlmIGBlcnJvckxpa2VgIGlzIGFuIGluc3RhbmNlIG9mIGBFcnJvcmBcbiAgICAgIGlmIChlcnJvckxpa2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB2YXIgaXNDb21wYXRpYmxlSW5zdGFuY2UgPSBfLmNoZWNrRXJyb3IuY29tcGF0aWJsZUluc3RhbmNlKGNhdWdodEVyciwgZXJyb3JMaWtlKTtcblxuICAgICAgICBpZiAoaXNDb21wYXRpYmxlSW5zdGFuY2UgPT09IG5lZ2F0ZSkge1xuICAgICAgICAgIC8vIFRoZXNlIGNoZWNrcyB3ZXJlIGNyZWF0ZWQgdG8gZW5zdXJlIHdlIHdvbid0IGZhaWwgdG9vIHNvb24gd2hlbiB3ZSd2ZSBnb3QgYm90aCBhcmdzIGFuZCBhIG5lZ2F0ZVxuICAgICAgICAgIC8vIFNlZSBJc3N1ZSAjNTUxIGFuZCBQUiAjNjgzQEdpdEh1YlxuICAgICAgICAgIGlmIChldmVyeUFyZ0lzRGVmaW5lZCAmJiBuZWdhdGUpIHtcbiAgICAgICAgICAgIGVycm9yTGlrZUZhaWwgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICAgICAgICBuZWdhdGVcbiAgICAgICAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyAje2V4cH0gYnV0ICN7YWN0fSB3YXMgdGhyb3duJ1xuICAgICAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCB0aHJvdyAje2V4cH0nICsgKGNhdWdodEVyciAmJiAhbmVnYXRlID8gJyBidXQgI3thY3R9IHdhcyB0aHJvd24nIDogJycpXG4gICAgICAgICAgICAgICwgZXJyb3JMaWtlLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgLCBjYXVnaHRFcnIudG9TdHJpbmcoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGlzQ29tcGF0aWJsZUNvbnN0cnVjdG9yID0gXy5jaGVja0Vycm9yLmNvbXBhdGlibGVDb25zdHJ1Y3RvcihjYXVnaHRFcnIsIGVycm9yTGlrZSk7XG4gICAgICBpZiAoaXNDb21wYXRpYmxlQ29uc3RydWN0b3IgPT09IG5lZ2F0ZSkge1xuICAgICAgICBpZiAoZXZlcnlBcmdJc0RlZmluZWQgJiYgbmVnYXRlKSB7XG4gICAgICAgICAgICBlcnJvckxpa2VGYWlsID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICAgICAgbmVnYXRlXG4gICAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHRocm93ICN7ZXhwfSBidXQgI3thY3R9IHdhcyB0aHJvd24nXG4gICAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCB0aHJvdyAje2V4cH0nICsgKGNhdWdodEVyciA/ICcgYnV0ICN7YWN0fSB3YXMgdGhyb3duJyA6ICcnKVxuICAgICAgICAgICAgLCAoZXJyb3JMaWtlIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvckxpa2UudG9TdHJpbmcoKSA6IGVycm9yTGlrZSAmJiBfLmNoZWNrRXJyb3IuZ2V0Q29uc3RydWN0b3JOYW1lKGVycm9yTGlrZSkpXG4gICAgICAgICAgICAsIChjYXVnaHRFcnIgaW5zdGFuY2VvZiBFcnJvciA/IGNhdWdodEVyci50b1N0cmluZygpIDogY2F1Z2h0RXJyICYmIF8uY2hlY2tFcnJvci5nZXRDb25zdHJ1Y3Rvck5hbWUoY2F1Z2h0RXJyKSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNhdWdodEVyciAmJiBlcnJNc2dNYXRjaGVyICE9PSB1bmRlZmluZWQgJiYgZXJyTXNnTWF0Y2hlciAhPT0gbnVsbCkge1xuICAgICAgLy8gSGVyZSB3ZSBjaGVjayBjb21wYXRpYmxlIG1lc3NhZ2VzXG4gICAgICB2YXIgcGxhY2Vob2xkZXIgPSAnaW5jbHVkaW5nJztcbiAgICAgIGlmIChlcnJNc2dNYXRjaGVyIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHBsYWNlaG9sZGVyID0gJ21hdGNoaW5nJ1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNDb21wYXRpYmxlTWVzc2FnZSA9IF8uY2hlY2tFcnJvci5jb21wYXRpYmxlTWVzc2FnZShjYXVnaHRFcnIsIGVyck1zZ01hdGNoZXIpO1xuICAgICAgaWYgKGlzQ29tcGF0aWJsZU1lc3NhZ2UgPT09IG5lZ2F0ZSkge1xuICAgICAgICBpZiAoZXZlcnlBcmdJc0RlZmluZWQgJiYgbmVnYXRlKSB7XG4gICAgICAgICAgICBlcnJNc2dNYXRjaGVyRmFpbCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgICBuZWdhdGVcbiAgICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgZXJyb3IgJyArIHBsYWNlaG9sZGVyICsgJyAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHRocm93IGVycm9yIG5vdCAnICsgcGxhY2Vob2xkZXIgKyAnICN7ZXhwfSdcbiAgICAgICAgICAgICwgIGVyck1zZ01hdGNoZXJcbiAgICAgICAgICAgICwgIF8uY2hlY2tFcnJvci5nZXRNZXNzYWdlKGNhdWdodEVycilcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgYm90aCBhc3NlcnRpb25zIGZhaWxlZCBhbmQgYm90aCBzaG91bGQndmUgbWF0Y2hlZCB3ZSB0aHJvdyBhbiBlcnJvclxuICAgIGlmIChlcnJvckxpa2VGYWlsICYmIGVyck1zZ01hdGNoZXJGYWlsKSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgbmVnYXRlXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgI3tleHB9IGJ1dCAje2FjdH0gd2FzIHRocm93bidcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgdGhyb3cgI3tleHB9JyArIChjYXVnaHRFcnIgPyAnIGJ1dCAje2FjdH0gd2FzIHRocm93bicgOiAnJylcbiAgICAgICAgLCAoZXJyb3JMaWtlIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvckxpa2UudG9TdHJpbmcoKSA6IGVycm9yTGlrZSAmJiBfLmNoZWNrRXJyb3IuZ2V0Q29uc3RydWN0b3JOYW1lKGVycm9yTGlrZSkpXG4gICAgICAgICwgKGNhdWdodEVyciBpbnN0YW5jZW9mIEVycm9yID8gY2F1Z2h0RXJyLnRvU3RyaW5nKCkgOiBjYXVnaHRFcnIgJiYgXy5jaGVja0Vycm9yLmdldENvbnN0cnVjdG9yTmFtZShjYXVnaHRFcnIpKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmbGFnKHRoaXMsICdvYmplY3QnLCBjYXVnaHRFcnIpO1xuICB9O1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3Rocm93JywgYXNzZXJ0VGhyb3dzKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgndGhyb3dzJywgYXNzZXJ0VGhyb3dzKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnVGhyb3cnLCBhc3NlcnRUaHJvd3MpO1xuXG4gIC8qKlxuICAgKiAjIyMgLnJlc3BvbmRUbyhtZXRob2RbLCBtc2ddKVxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgYSBub24tZnVuY3Rpb24gb2JqZWN0LCBgLnJlc3BvbmRUb2AgYXNzZXJ0cyB0aGF0IHRoZVxuICAgKiB0YXJnZXQgaGFzIGEgbWV0aG9kIHdpdGggdGhlIGdpdmVuIG5hbWUgYG1ldGhvZGAuIFRoZSBtZXRob2QgY2FuIGJlIG93biBvclxuICAgKiBpbmhlcml0ZWQsIGFuZCBpdCBjYW4gYmUgZW51bWVyYWJsZSBvciBub24tZW51bWVyYWJsZS5cbiAgICpcbiAgICogICAgIGZ1bmN0aW9uIENhdCAoKSB7fVxuICAgKiAgICAgQ2F0LnByb3RvdHlwZS5tZW93ID0gZnVuY3Rpb24gKCkge307XG4gICAqXG4gICAqICAgICBleHBlY3QobmV3IENhdCgpKS50by5yZXNwb25kVG8oJ21lb3cnKTtcbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzIGEgZnVuY3Rpb24sIGAucmVzcG9uZFRvYCBhc3NlcnRzIHRoYXQgdGhlIHRhcmdldCdzXG4gICAqIGBwcm90b3R5cGVgIHByb3BlcnR5IGhhcyBhIG1ldGhvZCB3aXRoIHRoZSBnaXZlbiBuYW1lIGBtZXRob2RgLiBBZ2FpbiwgdGhlXG4gICAqIG1ldGhvZCBjYW4gYmUgb3duIG9yIGluaGVyaXRlZCwgYW5kIGl0IGNhbiBiZSBlbnVtZXJhYmxlIG9yIG5vbi1lbnVtZXJhYmxlLlxuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gQ2F0ICgpIHt9XG4gICAqICAgICBDYXQucHJvdG90eXBlLm1lb3cgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChDYXQpLnRvLnJlc3BvbmRUbygnbWVvdycpO1xuICAgKlxuICAgKiBBZGQgYC5pdHNlbGZgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIGZvcmNlIGAucmVzcG9uZFRvYCB0byB0cmVhdCB0aGVcbiAgICogdGFyZ2V0IGFzIGEgbm9uLWZ1bmN0aW9uIG9iamVjdCwgZXZlbiBpZiBpdCdzIGEgZnVuY3Rpb24uIFRodXMsIGl0IGFzc2VydHNcbiAgICogdGhhdCB0aGUgdGFyZ2V0IGhhcyBhIG1ldGhvZCB3aXRoIHRoZSBnaXZlbiBuYW1lIGBtZXRob2RgLCByYXRoZXIgdGhhblxuICAgKiBhc3NlcnRpbmcgdGhhdCB0aGUgdGFyZ2V0J3MgYHByb3RvdHlwZWAgcHJvcGVydHkgaGFzIGEgbWV0aG9kIHdpdGggdGhlXG4gICAqIGdpdmVuIG5hbWUgYG1ldGhvZGAuXG4gICAqXG4gICAqICAgICBmdW5jdGlvbiBDYXQgKCkge31cbiAgICogICAgIENhdC5wcm90b3R5cGUubWVvdyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgKiAgICAgQ2F0Lmhpc3MgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChDYXQpLml0c2VsZi50by5yZXNwb25kVG8oJ2hpc3MnKS5idXQubm90LnJlc3BvbmRUbygnbWVvdycpO1xuICAgKlxuICAgKiBXaGVuIG5vdCBhZGRpbmcgYC5pdHNlbGZgLCBpdCdzIGltcG9ydGFudCB0byBjaGVjayB0aGUgdGFyZ2V0J3MgdHlwZSBiZWZvcmVcbiAgICogdXNpbmcgYC5yZXNwb25kVG9gLiBTZWUgdGhlIGAuYWAgZG9jIGZvciBpbmZvIG9uIGNoZWNraW5nIGEgdGFyZ2V0J3MgdHlwZS5cbiAgICpcbiAgICogICAgIGZ1bmN0aW9uIENhdCAoKSB7fVxuICAgKiAgICAgQ2F0LnByb3RvdHlwZS5tZW93ID0gZnVuY3Rpb24gKCkge307XG4gICAqXG4gICAqICAgICBleHBlY3QobmV3IENhdCgpKS50by5iZS5hbignb2JqZWN0JykudGhhdC5yZXNwb25kc1RvKCdtZW93Jyk7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAucmVzcG9uZFRvYC5cbiAgICpcbiAgICogICAgIGZ1bmN0aW9uIERvZyAoKSB7fVxuICAgKiAgICAgRG9nLnByb3RvdHlwZS5iYXJrID0gZnVuY3Rpb24gKCkge307XG4gICAqXG4gICAqICAgICBleHBlY3QobmV3IERvZygpKS50by5ub3QucmVzcG9uZFRvKCdtZW93Jyk7XG4gICAqXG4gICAqIGAucmVzcG9uZFRvYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yXG4gICAqIG1lc3NhZ2UgdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzXG4gICAqIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe30pLnRvLnJlc3BvbmRUbygnbWVvdycsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICogICAgIGV4cGVjdCh7fSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLnJlc3BvbmRUbygnbWVvdycpO1xuICAgKlxuICAgKiBUaGUgYWxpYXMgYC5yZXNwb25kc1RvYCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLnJlc3BvbmRUb2AuXG4gICAqXG4gICAqIEBuYW1lIHJlc3BvbmRUb1xuICAgKiBAYWxpYXMgcmVzcG9uZHNUb1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiByZXNwb25kVG8gKG1ldGhvZCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGl0c2VsZiA9IGZsYWcodGhpcywgJ2l0c2VsZicpXG4gICAgICAsIGNvbnRleHQgPSAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIG9iaiAmJiAhaXRzZWxmKVxuICAgICAgICA/IG9iai5wcm90b3R5cGVbbWV0aG9kXVxuICAgICAgICA6IG9ialttZXRob2RdO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICdmdW5jdGlvbicgPT09IHR5cGVvZiBjb250ZXh0XG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHJlc3BvbmQgdG8gJyArIF8uaW5zcGVjdChtZXRob2QpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCByZXNwb25kIHRvICcgKyBfLmluc3BlY3QobWV0aG9kKVxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdyZXNwb25kVG8nLCByZXNwb25kVG8pO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdyZXNwb25kc1RvJywgcmVzcG9uZFRvKTtcblxuICAvKipcbiAgICogIyMjIC5pdHNlbGZcbiAgICpcbiAgICogRm9yY2VzIGFsbCBgLnJlc3BvbmRUb2AgYXNzZXJ0aW9ucyB0aGF0IGZvbGxvdyBpbiB0aGUgY2hhaW4gdG8gYmVoYXZlIGFzIGlmXG4gICAqIHRoZSB0YXJnZXQgaXMgYSBub24tZnVuY3Rpb24gb2JqZWN0LCBldmVuIGlmIGl0J3MgYSBmdW5jdGlvbi4gVGh1cywgaXRcbiAgICogY2F1c2VzIGAucmVzcG9uZFRvYCB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0IGhhcyBhIG1ldGhvZCB3aXRoIHRoZSBnaXZlblxuICAgKiBuYW1lLCByYXRoZXIgdGhhbiBhc3NlcnRpbmcgdGhhdCB0aGUgdGFyZ2V0J3MgYHByb3RvdHlwZWAgcHJvcGVydHkgaGFzIGFcbiAgICogbWV0aG9kIHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gICAqXG4gICAqICAgICBmdW5jdGlvbiBDYXQgKCkge31cbiAgICogICAgIENhdC5wcm90b3R5cGUubWVvdyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgKiAgICAgQ2F0Lmhpc3MgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChDYXQpLml0c2VsZi50by5yZXNwb25kVG8oJ2hpc3MnKS5idXQubm90LnJlc3BvbmRUbygnbWVvdycpO1xuICAgKlxuICAgKiBAbmFtZSBpdHNlbGZcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdpdHNlbGYnLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnaXRzZWxmJywgdHJ1ZSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLnNhdGlzZnkobWF0Y2hlclssIG1zZ10pXG4gICAqXG4gICAqIEludm9rZXMgdGhlIGdpdmVuIGBtYXRjaGVyYCBmdW5jdGlvbiB3aXRoIHRoZSB0YXJnZXQgYmVpbmcgcGFzc2VkIGFzIHRoZVxuICAgKiBmaXJzdCBhcmd1bWVudCwgYW5kIGFzc2VydHMgdGhhdCB0aGUgdmFsdWUgcmV0dXJuZWQgaXMgdHJ1dGh5LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLnNhdGlzZnkoZnVuY3Rpb24obnVtKSB7XG4gICAqICAgICAgIHJldHVybiBudW0gPiAwO1xuICAgKiAgICAgfSk7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuc2F0aXNmeWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8ubm90LnNhdGlzZnkoZnVuY3Rpb24obnVtKSB7XG4gICAqICAgICAgIHJldHVybiBudW0gPiAyO1xuICAgKiAgICAgfSk7XG4gICAqXG4gICAqIGAuc2F0aXNmeWAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvclxuICAgKiBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhc1xuICAgKiB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLnNhdGlzZnkoZnVuY3Rpb24obnVtKSB7XG4gICAqICAgICAgIHJldHVybiBudW0gPiAyO1xuICAgKiAgICAgfSwgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKlxuICAgKiAgICAgZXhwZWN0KDEsICdub29vIHdoeSBmYWlsPz8nKS50by5zYXRpc2Z5KGZ1bmN0aW9uKG51bSkge1xuICAgKiAgICAgICByZXR1cm4gbnVtID4gMjtcbiAgICogICAgIH0pO1xuICAgKlxuICAgKiBUaGUgYWxpYXMgYC5zYXRpc2ZpZXNgIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAuc2F0aXNmeWAuXG4gICAqXG4gICAqIEBuYW1lIHNhdGlzZnlcbiAgICogQGFsaWFzIHNhdGlzZmllc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtYXRjaGVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBzYXRpc2Z5IChtYXRjaGVyLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgdmFyIHJlc3VsdCA9IG1hdGNoZXIob2JqKTtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgcmVzdWx0XG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHNhdGlzZnkgJyArIF8ub2JqRGlzcGxheShtYXRjaGVyKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3Qgc2F0aXNmeScgKyBfLm9iakRpc3BsYXkobWF0Y2hlcilcbiAgICAgICwgZmxhZyh0aGlzLCAnbmVnYXRlJykgPyBmYWxzZSA6IHRydWVcbiAgICAgICwgcmVzdWx0XG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3NhdGlzZnknLCBzYXRpc2Z5KTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnc2F0aXNmaWVzJywgc2F0aXNmeSk7XG5cbiAgLyoqXG4gICAqICMjIyAuY2xvc2VUbyhleHBlY3RlZCwgZGVsdGFbLCBtc2ddKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBhIG51bWJlciB0aGF0J3Mgd2l0aGluIGEgZ2l2ZW4gKy8tIGBkZWx0YWAgcmFuZ2VcbiAgICogb2YgdGhlIGdpdmVuIG51bWJlciBgZXhwZWN0ZWRgLiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgdGhlXG4gICAqIHRhcmdldCBpcyBlcXVhbCB0byBpdHMgZXhwZWN0ZWQgdmFsdWUuXG4gICAqXG4gICAqICAgICAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEuNSkudG8uZXF1YWwoMS41KTtcbiAgICpcbiAgICogICAgIC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KDEuNSkudG8uYmUuY2xvc2VUbygxLCAwLjUpO1xuICAgKiAgICAgZXhwZWN0KDEuNSkudG8uYmUuY2xvc2VUbygyLCAwLjUpO1xuICAgKiAgICAgZXhwZWN0KDEuNSkudG8uYmUuY2xvc2VUbygxLCAxKTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5jbG9zZVRvYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxLjUpLnRvLmVxdWFsKDEuNSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMS41KS50by5ub3QuYmUuY2xvc2VUbygzLCAxKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAuY2xvc2VUb2AgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvclxuICAgKiBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhc1xuICAgKiB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEuNSkudG8uYmUuY2xvc2VUbygzLCAxLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoMS41LCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUuY2xvc2VUbygzLCAxKTtcbiAgICpcbiAgICogVGhlIGFsaWFzIGAuYXBwcm94aW1hdGVseWAgY2FuIGJlIHVzZWQgaW50ZXJjaGFuZ2VhYmx5IHdpdGggYC5jbG9zZVRvYC5cbiAgICpcbiAgICogQG5hbWUgY2xvc2VUb1xuICAgKiBAYWxpYXMgYXBwcm94aW1hdGVseVxuICAgKiBAcGFyYW0ge051bWJlcn0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBjbG9zZVRvKGV4cGVjdGVkLCBkZWx0YSwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKTtcblxuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS5pcy5hKCdudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIGV4cGVjdGVkICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgZGVsdGEgIT09ICdudW1iZXInKSB7XG4gICAgICBmbGFnTXNnID0gZmxhZ01zZyA/IGZsYWdNc2cgKyAnOiAnIDogJyc7XG4gICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoXG4gICAgICAgICAgZmxhZ01zZyArICd0aGUgYXJndW1lbnRzIHRvIGNsb3NlVG8gb3IgYXBwcm94aW1hdGVseSBtdXN0IGJlIG51bWJlcnMnLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICBzc2ZpXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBNYXRoLmFicyhvYmogLSBleHBlY3RlZCkgPD0gZGVsdGFcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgY2xvc2UgdG8gJyArIGV4cGVjdGVkICsgJyArLy0gJyArIGRlbHRhXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IG5vdCB0byBiZSBjbG9zZSB0byAnICsgZXhwZWN0ZWQgKyAnICsvLSAnICsgZGVsdGFcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnY2xvc2VUbycsIGNsb3NlVG8pO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdhcHByb3hpbWF0ZWx5JywgY2xvc2VUbyk7XG5cbiAgLy8gTm90ZTogRHVwbGljYXRlcyBhcmUgaWdub3JlZCBpZiB0ZXN0aW5nIGZvciBpbmNsdXNpb24gaW5zdGVhZCBvZiBzYW1lbmVzcy5cbiAgZnVuY3Rpb24gaXNTdWJzZXRPZihzdWJzZXQsIHN1cGVyc2V0LCBjbXAsIGNvbnRhaW5zLCBvcmRlcmVkKSB7XG4gICAgaWYgKCFjb250YWlucykge1xuICAgICAgaWYgKHN1YnNldC5sZW5ndGggIT09IHN1cGVyc2V0Lmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgc3VwZXJzZXQgPSBzdXBlcnNldC5zbGljZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBzdWJzZXQuZXZlcnkoZnVuY3Rpb24oZWxlbSwgaWR4KSB7XG4gICAgICBpZiAob3JkZXJlZCkgcmV0dXJuIGNtcCA/IGNtcChlbGVtLCBzdXBlcnNldFtpZHhdKSA6IGVsZW0gPT09IHN1cGVyc2V0W2lkeF07XG5cbiAgICAgIGlmICghY21wKSB7XG4gICAgICAgIHZhciBtYXRjaElkeCA9IHN1cGVyc2V0LmluZGV4T2YoZWxlbSk7XG4gICAgICAgIGlmIChtYXRjaElkeCA9PT0gLTEpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAvLyBSZW1vdmUgbWF0Y2ggZnJvbSBzdXBlcnNldCBzbyBub3QgY291bnRlZCB0d2ljZSBpZiBkdXBsaWNhdGUgaW4gc3Vic2V0LlxuICAgICAgICBpZiAoIWNvbnRhaW5zKSBzdXBlcnNldC5zcGxpY2UobWF0Y2hJZHgsIDEpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN1cGVyc2V0LnNvbWUoZnVuY3Rpb24oZWxlbTIsIG1hdGNoSWR4KSB7XG4gICAgICAgIGlmICghY21wKGVsZW0sIGVsZW0yKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIC8vIFJlbW92ZSBtYXRjaCBmcm9tIHN1cGVyc2V0IHNvIG5vdCBjb3VudGVkIHR3aWNlIGlmIGR1cGxpY2F0ZSBpbiBzdWJzZXQuXG4gICAgICAgIGlmICghY29udGFpbnMpIHN1cGVyc2V0LnNwbGljZShtYXRjaElkeCwgMSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5tZW1iZXJzKHNldFssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGFycmF5IGhhcyB0aGUgc2FtZSBtZW1iZXJzIGFzIHRoZSBnaXZlbiBhcnJheVxuICAgKiBgc2V0YC5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUubWVtYmVycyhbMiwgMSwgM10pO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAyXSkudG8uaGF2ZS5tZW1iZXJzKFsyLCAxLCAyXSk7XG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIG1lbWJlcnMgYXJlIGNvbXBhcmVkIHVzaW5nIHN0cmljdCAoYD09PWApIGVxdWFsaXR5LiBBZGQgYC5kZWVwYFxuICAgKiBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byB1c2UgZGVlcCBlcXVhbGl0eSBpbnN0ZWFkLiBTZWUgdGhlIGBkZWVwLWVxbGBcbiAgICogcHJvamVjdCBwYWdlIGZvciBpbmZvIG9uIHRoZSBkZWVwIGVxdWFsaXR5IGFsZ29yaXRobTpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2NoYWlqcy9kZWVwLWVxbC5cbiAgICpcbiAgICogICAgIC8vIFRhcmdldCBhcnJheSBkZWVwbHkgKGJ1dCBub3Qgc3RyaWN0bHkpIGhhcyBtZW1iZXIgYHthOiAxfWBcbiAgICogICAgIGV4cGVjdChbe2E6IDF9XSkudG8uaGF2ZS5kZWVwLm1lbWJlcnMoW3thOiAxfV0pO1xuICAgKiAgICAgZXhwZWN0KFt7YTogMX1dKS50by5ub3QuaGF2ZS5tZW1iZXJzKFt7YTogMX1dKTtcbiAgICpcbiAgICogQnkgZGVmYXVsdCwgb3JkZXIgZG9lc24ndCBtYXR0ZXIuIEFkZCBgLm9yZGVyZWRgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvXG4gICAqIHJlcXVpcmUgdGhhdCBtZW1iZXJzIGFwcGVhciBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmhhdmUub3JkZXJlZC5tZW1iZXJzKFsxLCAyLCAzXSk7XG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5oYXZlLm1lbWJlcnMoWzIsIDEsIDNdKVxuICAgKiAgICAgICAuYnV0Lm5vdC5vcmRlcmVkLm1lbWJlcnMoWzIsIDEsIDNdKTtcbiAgICpcbiAgICogQnkgZGVmYXVsdCwgYm90aCBhcnJheXMgbXVzdCBiZSB0aGUgc2FtZSBzaXplLiBBZGQgYC5pbmNsdWRlYCBlYXJsaWVyIGluXG4gICAqIHRoZSBjaGFpbiB0byByZXF1aXJlIHRoYXQgdGhlIHRhcmdldCdzIG1lbWJlcnMgYmUgYSBzdXBlcnNldCBvZiB0aGVcbiAgICogZXhwZWN0ZWQgbWVtYmVycy4gTm90ZSB0aGF0IGR1cGxpY2F0ZXMgYXJlIGlnbm9yZWQgaW4gdGhlIHN1YnNldCB3aGVuXG4gICAqIGAuaW5jbHVkZWAgaXMgYWRkZWQuXG4gICAqXG4gICAqICAgICAvLyBUYXJnZXQgYXJyYXkgaXMgYSBzdXBlcnNldCBvZiBbMSwgMl0gYnV0IG5vdCBpZGVudGljYWxcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmluY2x1ZGUubWVtYmVycyhbMSwgMl0pO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8ubm90LmhhdmUubWVtYmVycyhbMSwgMl0pO1xuICAgKlxuICAgKiAgICAgLy8gRHVwbGljYXRlcyBpbiB0aGUgc3Vic2V0IGFyZSBpZ25vcmVkXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5pbmNsdWRlLm1lbWJlcnMoWzEsIDIsIDIsIDJdKTtcbiAgICpcbiAgICogYC5kZWVwYCwgYC5vcmRlcmVkYCwgYW5kIGAuaW5jbHVkZWAgY2FuIGFsbCBiZSBjb21iaW5lZC4gSG93ZXZlciwgaWZcbiAgICogYC5pbmNsdWRlYCBhbmQgYC5vcmRlcmVkYCBhcmUgY29tYmluZWQsIHRoZSBvcmRlcmluZyBiZWdpbnMgYXQgdGhlIHN0YXJ0IG9mXG4gICAqIGJvdGggYXJyYXlzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFt7YTogMX0sIHtiOiAyfSwge2M6IDN9XSlcbiAgICogICAgICAgLnRvLmluY2x1ZGUuZGVlcC5vcmRlcmVkLm1lbWJlcnMoW3thOiAxfSwge2I6IDJ9XSlcbiAgICogICAgICAgLmJ1dC5ub3QuaW5jbHVkZS5kZWVwLm9yZGVyZWQubWVtYmVycyhbe2I6IDJ9LCB7YzogM31dKTtcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5tZW1iZXJzYC4gSG93ZXZlciwgaXQnc1xuICAgKiBkYW5nZXJvdXMgdG8gZG8gc28uIFRoZSBwcm9ibGVtIGlzIHRoYXQgaXQgY3JlYXRlcyB1bmNlcnRhaW4gZXhwZWN0YXRpb25zXG4gICAqIGJ5IGFzc2VydGluZyB0aGF0IHRoZSB0YXJnZXQgYXJyYXkgZG9lc24ndCBoYXZlIGFsbCBvZiB0aGUgc2FtZSBtZW1iZXJzIGFzXG4gICAqIHRoZSBnaXZlbiBhcnJheSBgc2V0YCBidXQgbWF5IG9yIG1heSBub3QgaGF2ZSBzb21lIG9mIHRoZW0uIEl0J3Mgb2Z0ZW4gYmVzdFxuICAgKiB0byBpZGVudGlmeSB0aGUgZXhhY3Qgb3V0cHV0IHRoYXQncyBleHBlY3RlZCwgYW5kIHRoZW4gd3JpdGUgYW4gYXNzZXJ0aW9uXG4gICAqIHRoYXQgb25seSBhY2NlcHRzIHRoYXQgZXhhY3Qgb3V0cHV0LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLCAyXSkudG8ubm90LmluY2x1ZGUoMykuYW5kLm5vdC5pbmNsdWRlKDQpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KFsxLCAyXSkudG8ubm90LmhhdmUubWVtYmVycyhbMywgNF0pOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC5tZW1iZXJzYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yXG4gICAqIG1lc3NhZ2UgdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzXG4gICAqIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDJdKS50by5oYXZlLm1lbWJlcnMoWzEsIDIsIDNdLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoWzEsIDJdLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uaGF2ZS5tZW1iZXJzKFsxLCAyLCAzXSk7XG4gICAqXG4gICAqIEBuYW1lIG1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdtZW1iZXJzJywgZnVuY3Rpb24gKHN1YnNldCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGZsYWdNc2cgPSBmbGFnKHRoaXMsICdtZXNzYWdlJylcbiAgICAgICwgc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKTtcblxuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS50by5iZS5hbignYXJyYXknKTtcbiAgICBuZXcgQXNzZXJ0aW9uKHN1YnNldCwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkudG8uYmUuYW4oJ2FycmF5Jyk7XG5cbiAgICB2YXIgY29udGFpbnMgPSBmbGFnKHRoaXMsICdjb250YWlucycpO1xuICAgIHZhciBvcmRlcmVkID0gZmxhZyh0aGlzLCAnb3JkZXJlZCcpO1xuXG4gICAgdmFyIHN1YmplY3QsIGZhaWxNc2csIGZhaWxOZWdhdGVNc2c7XG5cbiAgICBpZiAoY29udGFpbnMpIHtcbiAgICAgIHN1YmplY3QgPSBvcmRlcmVkID8gJ2FuIG9yZGVyZWQgc3VwZXJzZXQnIDogJ2Egc3VwZXJzZXQnO1xuICAgICAgZmFpbE1zZyA9ICdleHBlY3RlZCAje3RoaXN9IHRvIGJlICcgKyBzdWJqZWN0ICsgJyBvZiAje2V4cH0nO1xuICAgICAgZmFpbE5lZ2F0ZU1zZyA9ICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSAnICsgc3ViamVjdCArICcgb2YgI3tleHB9JztcbiAgICB9IGVsc2Uge1xuICAgICAgc3ViamVjdCA9IG9yZGVyZWQgPyAnb3JkZXJlZCBtZW1iZXJzJyA6ICdtZW1iZXJzJztcbiAgICAgIGZhaWxNc2cgPSAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIHRoZSBzYW1lICcgKyBzdWJqZWN0ICsgJyBhcyAje2V4cH0nO1xuICAgICAgZmFpbE5lZ2F0ZU1zZyA9ICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIHRoZSBzYW1lICcgKyBzdWJqZWN0ICsgJyBhcyAje2V4cH0nO1xuICAgIH1cblxuICAgIHZhciBjbXAgPSBmbGFnKHRoaXMsICdkZWVwJykgPyBfLmVxbCA6IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBpc1N1YnNldE9mKHN1YnNldCwgb2JqLCBjbXAsIGNvbnRhaW5zLCBvcmRlcmVkKVxuICAgICAgLCBmYWlsTXNnXG4gICAgICAsIGZhaWxOZWdhdGVNc2dcbiAgICAgICwgc3Vic2V0XG4gICAgICAsIG9ialxuICAgICAgLCB0cnVlXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAub25lT2YobGlzdFssIG1zZ10pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGEgbWVtYmVyIG9mIHRoZSBnaXZlbiBhcnJheSBgbGlzdGAuIEhvd2V2ZXIsXG4gICAqIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIHRvIGl0cyBleHBlY3RlZCB2YWx1ZS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5lcXVhbCgxKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdCgxKS50by5iZS5vbmVPZihbMSwgMiwgM10pOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQ29tcGFyaXNvbnMgYXJlIHBlcmZvcm1lZCB1c2luZyBzdHJpY3QgKGA9PT1gKSBlcXVhbGl0eS5cbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5vbmVPZmAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uZXF1YWwoMSk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoMSkudG8ubm90LmJlLm9uZU9mKFsyLCAzLCA0XSk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBgLm9uZU9mYCBhY2NlcHRzIGFuIG9wdGlvbmFsIGBtc2dgIGFyZ3VtZW50IHdoaWNoIGlzIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAgICogdG8gc2hvdyB3aGVuIHRoZSBhc3NlcnRpb24gZmFpbHMuIFRoZSBtZXNzYWdlIGNhbiBhbHNvIGJlIGdpdmVuIGFzIHRoZVxuICAgKiBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uYmUub25lT2YoWzIsIDMsIDRdLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqICAgICBleHBlY3QoMSwgJ25vb28gd2h5IGZhaWw/PycpLnRvLmJlLm9uZU9mKFsyLCAzLCA0XSk7XG4gICAqXG4gICAqIEBuYW1lIG9uZU9mXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IGxpc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uZU9mIChsaXN0LCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgZXhwZWN0ZWQgPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJyk7XG4gICAgbmV3IEFzc2VydGlvbihsaXN0LCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS50by5iZS5hbignYXJyYXknKTtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBsaXN0LmluZGV4T2YoZXhwZWN0ZWQpID4gLTFcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgb25lIG9mICN7ZXhwfSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIG9uZSBvZiAje2V4cH0nXG4gICAgICAsIGxpc3RcbiAgICAgICwgZXhwZWN0ZWRcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnb25lT2YnLCBvbmVPZik7XG5cbiAgLyoqXG4gICAqICMjIyAuY2hhbmdlKHN1YmplY3RbLCBwcm9wWywgbXNnXV0pXG4gICAqXG4gICAqIFdoZW4gb25lIGFyZ3VtZW50IGlzIHByb3ZpZGVkLCBgLmNoYW5nZWAgYXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiBmdW5jdGlvblxuICAgKiBgc3ViamVjdGAgcmV0dXJucyBhIGRpZmZlcmVudCB2YWx1ZSB3aGVuIGl0J3MgaW52b2tlZCBiZWZvcmUgdGhlIHRhcmdldFxuICAgKiBmdW5jdGlvbiBjb21wYXJlZCB0byB3aGVuIGl0J3MgaW52b2tlZCBhZnRlcndhcmQuIEhvd2V2ZXIsIGl0J3Mgb2Z0ZW4gYmVzdFxuICAgKiB0byBhc3NlcnQgdGhhdCBgc3ViamVjdGAgaXMgZXF1YWwgdG8gaXRzIGV4cGVjdGVkIHZhbHVlLlxuICAgKlxuICAgKiAgICAgdmFyIGRvdHMgPSAnJ1xuICAgKiAgICAgICAsIGFkZERvdCA9IGZ1bmN0aW9uICgpIHsgZG90cyArPSAnLic7IH1cbiAgICogICAgICAgLCBnZXREb3RzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZG90czsgfTtcbiAgICpcbiAgICogICAgIC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoZ2V0RG90cygpKS50by5lcXVhbCgnJyk7XG4gICAqICAgICBhZGREb3QoKTtcbiAgICogICAgIGV4cGVjdChnZXREb3RzKCkpLnRvLmVxdWFsKCcuJyk7XG4gICAqXG4gICAqICAgICAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChhZGREb3QpLnRvLmNoYW5nZShnZXREb3RzKTtcbiAgICpcbiAgICogV2hlbiB0d28gYXJndW1lbnRzIGFyZSBwcm92aWRlZCwgYC5jaGFuZ2VgIGFzc2VydHMgdGhhdCB0aGUgdmFsdWUgb2YgdGhlXG4gICAqIGdpdmVuIG9iamVjdCBgc3ViamVjdGAncyBgcHJvcGAgcHJvcGVydHkgaXMgZGlmZmVyZW50IGJlZm9yZSBpbnZva2luZyB0aGVcbiAgICogdGFyZ2V0IGZ1bmN0aW9uIGNvbXBhcmVkIHRvIGFmdGVyd2FyZC5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHtkb3RzOiAnJ31cbiAgICogICAgICAgLCBhZGREb3QgPSBmdW5jdGlvbiAoKSB7IG15T2JqLmRvdHMgKz0gJy4nOyB9O1xuICAgKlxuICAgKiAgICAgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChteU9iaikudG8uaGF2ZS5wcm9wZXJ0eSgnZG90cycsICcnKTtcbiAgICogICAgIGFkZERvdCgpO1xuICAgKiAgICAgZXhwZWN0KG15T2JqKS50by5oYXZlLnByb3BlcnR5KCdkb3RzJywgJy4nKTtcbiAgICpcbiAgICogICAgIC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KGFkZERvdCkudG8uY2hhbmdlKG15T2JqLCAnZG90cycpO1xuICAgKlxuICAgKiBTdHJpY3QgKGA9PT1gKSBlcXVhbGl0eSBpcyB1c2VkIHRvIGNvbXBhcmUgYmVmb3JlIGFuZCBhZnRlciB2YWx1ZXMuXG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuY2hhbmdlYC5cbiAgICpcbiAgICogICAgIHZhciBkb3RzID0gJydcbiAgICogICAgICAgLCBub29wID0gZnVuY3Rpb24gKCkge31cbiAgICogICAgICAgLCBnZXREb3RzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZG90czsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChub29wKS50by5ub3QuY2hhbmdlKGdldERvdHMpO1xuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge2RvdHM6ICcnfVxuICAgKiAgICAgICAsIG5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChub29wKS50by5ub3QuY2hhbmdlKG15T2JqLCAnZG90cycpO1xuICAgKlxuICAgKiBgLmNoYW5nZWAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvclxuICAgKiBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhc1xuICAgKiB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLiBXaGVuIG5vdCBwcm92aWRpbmcgdHdvIGFyZ3VtZW50cywgYWx3YXlzXG4gICAqIHVzZSB0aGUgc2Vjb25kIGZvcm0uXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7ZG90czogJyd9XG4gICAqICAgICAgICwgYWRkRG90ID0gZnVuY3Rpb24gKCkgeyBteU9iai5kb3RzICs9ICcuJzsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChhZGREb3QpLnRvLm5vdC5jaGFuZ2UobXlPYmosICdkb3RzJywgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKlxuICAgKiAgICAgdmFyIGRvdHMgPSAnJ1xuICAgKiAgICAgICAsIGFkZERvdCA9IGZ1bmN0aW9uICgpIHsgZG90cyArPSAnLic7IH1cbiAgICogICAgICAgLCBnZXREb3RzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZG90czsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChhZGREb3QsICdub29vIHdoeSBmYWlsPz8nKS50by5ub3QuY2hhbmdlKGdldERvdHMpO1xuICAgKlxuICAgKiBgLmNoYW5nZWAgYWxzbyBjYXVzZXMgYWxsIGAuYnlgIGFzc2VydGlvbnMgdGhhdCBmb2xsb3cgaW4gdGhlIGNoYWluIHRvXG4gICAqIGFzc2VydCBob3cgbXVjaCBhIG51bWVyaWMgc3ViamVjdCB3YXMgaW5jcmVhc2VkIG9yIGRlY3JlYXNlZCBieS4gSG93ZXZlcixcbiAgICogaXQncyBkYW5nZXJvdXMgdG8gdXNlIGAuY2hhbmdlLmJ5YC4gVGhlIHByb2JsZW0gaXMgdGhhdCBpdCBjcmVhdGVzXG4gICAqIHVuY2VydGFpbiBleHBlY3RhdGlvbnMgYnkgYXNzZXJ0aW5nIHRoYXQgdGhlIHN1YmplY3QgZWl0aGVyIGluY3JlYXNlcyBieVxuICAgKiB0aGUgZ2l2ZW4gZGVsdGEsIG9yIHRoYXQgaXQgZGVjcmVhc2VzIGJ5IHRoZSBnaXZlbiBkZWx0YS4gSXQncyBvZnRlbiBiZXN0XG4gICAqIHRvIGlkZW50aWZ5IHRoZSBleGFjdCBvdXRwdXQgdGhhdCdzIGV4cGVjdGVkLCBhbmQgdGhlbiB3cml0ZSBhbiBhc3NlcnRpb25cbiAgICogdGhhdCBvbmx5IGFjY2VwdHMgdGhhdCBleGFjdCBvdXRwdXQuXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7dmFsOiAxfVxuICAgKiAgICAgICAsIGFkZFR3byA9IGZ1bmN0aW9uICgpIHsgbXlPYmoudmFsICs9IDI7IH1cbiAgICogICAgICAgLCBzdWJ0cmFjdFR3byA9IGZ1bmN0aW9uICgpIHsgbXlPYmoudmFsIC09IDI7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYWRkVHdvKS50by5pbmNyZWFzZShteU9iaiwgJ3ZhbCcpLmJ5KDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KGFkZFR3bykudG8uY2hhbmdlKG15T2JqLCAndmFsJykuYnkoMik7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KHN1YnRyYWN0VHdvKS50by5kZWNyZWFzZShteU9iaiwgJ3ZhbCcpLmJ5KDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHN1YnRyYWN0VHdvKS50by5jaGFuZ2UobXlPYmosICd2YWwnKS5ieSgyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIFRoZSBhbGlhcyBgLmNoYW5nZXNgIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAuY2hhbmdlYC5cbiAgICpcbiAgICogQG5hbWUgY2hhbmdlXG4gICAqIEBhbGlhcyBjaGFuZ2VzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdWJqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0Q2hhbmdlcyAoc3ViamVjdCwgcHJvcCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIGZuID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpO1xuICAgIG5ldyBBc3NlcnRpb24oZm4sIGZsYWdNc2csIHNzZmksIHRydWUpLmlzLmEoJ2Z1bmN0aW9uJyk7XG5cbiAgICB2YXIgaW5pdGlhbDtcbiAgICBpZiAoIXByb3ApIHtcbiAgICAgIG5ldyBBc3NlcnRpb24oc3ViamVjdCwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkuaXMuYSgnZnVuY3Rpb24nKTtcbiAgICAgIGluaXRpYWwgPSBzdWJqZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ldyBBc3NlcnRpb24oc3ViamVjdCwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkudG8uaGF2ZS5wcm9wZXJ0eShwcm9wKTtcbiAgICAgIGluaXRpYWwgPSBzdWJqZWN0W3Byb3BdO1xuICAgIH1cblxuICAgIGZuKCk7XG5cbiAgICB2YXIgZmluYWwgPSBwcm9wID09PSB1bmRlZmluZWQgfHwgcHJvcCA9PT0gbnVsbCA/IHN1YmplY3QoKSA6IHN1YmplY3RbcHJvcF07XG4gICAgdmFyIG1zZ09iaiA9IHByb3AgPT09IHVuZGVmaW5lZCB8fCBwcm9wID09PSBudWxsID8gaW5pdGlhbCA6ICcuJyArIHByb3A7XG5cbiAgICAvLyBUaGlzIGdldHMgZmxhZ2dlZCBiZWNhdXNlIG9mIHRoZSAuYnkoZGVsdGEpIGFzc2VydGlvblxuICAgIGZsYWcodGhpcywgJ2RlbHRhTXNnT2JqJywgbXNnT2JqKTtcbiAgICBmbGFnKHRoaXMsICdpbml0aWFsRGVsdGFWYWx1ZScsIGluaXRpYWwpO1xuICAgIGZsYWcodGhpcywgJ2ZpbmFsRGVsdGFWYWx1ZScsIGZpbmFsKTtcbiAgICBmbGFnKHRoaXMsICdkZWx0YUJlaGF2aW9yJywgJ2NoYW5nZScpO1xuICAgIGZsYWcodGhpcywgJ3JlYWxEZWx0YScsIGZpbmFsICE9PSBpbml0aWFsKTtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgaW5pdGlhbCAhPT0gZmluYWxcbiAgICAgICwgJ2V4cGVjdGVkICcgKyBtc2dPYmogKyAnIHRvIGNoYW5nZSdcbiAgICAgICwgJ2V4cGVjdGVkICcgKyBtc2dPYmogKyAnIHRvIG5vdCBjaGFuZ2UnXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2NoYW5nZScsIGFzc2VydENoYW5nZXMpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdjaGFuZ2VzJywgYXNzZXJ0Q2hhbmdlcyk7XG5cbiAgLyoqXG4gICAqICMjIyAuaW5jcmVhc2Uoc3ViamVjdFssIHByb3BbLCBtc2ddXSlcbiAgICpcbiAgICogV2hlbiBvbmUgYXJndW1lbnQgaXMgcHJvdmlkZWQsIGAuaW5jcmVhc2VgIGFzc2VydHMgdGhhdCB0aGUgZ2l2ZW4gZnVuY3Rpb25cbiAgICogYHN1YmplY3RgIHJldHVybnMgYSBncmVhdGVyIG51bWJlciB3aGVuIGl0J3MgaW52b2tlZCBhZnRlciBpbnZva2luZyB0aGVcbiAgICogdGFyZ2V0IGZ1bmN0aW9uIGNvbXBhcmVkIHRvIHdoZW4gaXQncyBpbnZva2VkIGJlZm9yZWhhbmQuIGAuaW5jcmVhc2VgIGFsc29cbiAgICogY2F1c2VzIGFsbCBgLmJ5YCBhc3NlcnRpb25zIHRoYXQgZm9sbG93IGluIHRoZSBjaGFpbiB0byBhc3NlcnQgaG93IG11Y2hcbiAgICogZ3JlYXRlciBvZiBhIG51bWJlciBpcyByZXR1cm5lZC4gSXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSByZXR1cm5cbiAgICogdmFsdWUgaW5jcmVhc2VkIGJ5IHRoZSBleHBlY3RlZCBhbW91bnQsIHJhdGhlciB0aGFuIGFzc2VydGluZyBpdCBpbmNyZWFzZWRcbiAgICogYnkgYW55IGFtb3VudC5cbiAgICpcbiAgICogICAgIHZhciB2YWwgPSAxXG4gICAqICAgICAgICwgYWRkVHdvID0gZnVuY3Rpb24gKCkgeyB2YWwgKz0gMjsgfVxuICAgKiAgICAgICAsIGdldFZhbCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbDsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChhZGRUd28pLnRvLmluY3JlYXNlKGdldFZhbCkuYnkoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoYWRkVHdvKS50by5pbmNyZWFzZShnZXRWYWwpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogV2hlbiB0d28gYXJndW1lbnRzIGFyZSBwcm92aWRlZCwgYC5pbmNyZWFzZWAgYXNzZXJ0cyB0aGF0IHRoZSB2YWx1ZSBvZiB0aGVcbiAgICogZ2l2ZW4gb2JqZWN0IGBzdWJqZWN0YCdzIGBwcm9wYCBwcm9wZXJ0eSBpcyBncmVhdGVyIGFmdGVyIGludm9raW5nIHRoZVxuICAgKiB0YXJnZXQgZnVuY3Rpb24gY29tcGFyZWQgdG8gYmVmb3JlaGFuZC5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHt2YWw6IDF9XG4gICAqICAgICAgICwgYWRkVHdvID0gZnVuY3Rpb24gKCkgeyBteU9iai52YWwgKz0gMjsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChhZGRUd28pLnRvLmluY3JlYXNlKG15T2JqLCAndmFsJykuYnkoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoYWRkVHdvKS50by5pbmNyZWFzZShteU9iaiwgJ3ZhbCcpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogQWRkIGAubm90YCBlYXJsaWVyIGluIHRoZSBjaGFpbiB0byBuZWdhdGUgYC5pbmNyZWFzZWAuIEhvd2V2ZXIsIGl0J3NcbiAgICogZGFuZ2Vyb3VzIHRvIGRvIHNvLiBUaGUgcHJvYmxlbSBpcyB0aGF0IGl0IGNyZWF0ZXMgdW5jZXJ0YWluIGV4cGVjdGF0aW9uc1xuICAgKiBieSBhc3NlcnRpbmcgdGhhdCB0aGUgc3ViamVjdCBlaXRoZXIgZGVjcmVhc2VzLCBvciB0aGF0IGl0IHN0YXlzIHRoZSBzYW1lLlxuICAgKiBJdCdzIG9mdGVuIGJlc3QgdG8gaWRlbnRpZnkgdGhlIGV4YWN0IG91dHB1dCB0aGF0J3MgZXhwZWN0ZWQsIGFuZCB0aGVuXG4gICAqIHdyaXRlIGFuIGFzc2VydGlvbiB0aGF0IG9ubHkgYWNjZXB0cyB0aGF0IGV4YWN0IG91dHB1dC5cbiAgICpcbiAgICogV2hlbiB0aGUgc3ViamVjdCBpcyBleHBlY3RlZCB0byBkZWNyZWFzZSwgaXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydCB0aGF0IGl0XG4gICAqIGRlY3JlYXNlZCBieSB0aGUgZXhwZWN0ZWQgYW1vdW50LlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge3ZhbDogMX1cbiAgICogICAgICAgLCBzdWJ0cmFjdFR3byA9IGZ1bmN0aW9uICgpIHsgbXlPYmoudmFsIC09IDI7IH07XG4gICAqXG4gICAqICAgICBleHBlY3Qoc3VidHJhY3RUd28pLnRvLmRlY3JlYXNlKG15T2JqLCAndmFsJykuYnkoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoc3VidHJhY3RUd28pLnRvLm5vdC5pbmNyZWFzZShteU9iaiwgJ3ZhbCcpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogV2hlbiB0aGUgc3ViamVjdCBpcyBleHBlY3RlZCB0byBzdGF5IHRoZSBzYW1lLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0XG4gICAqIGV4YWN0bHkgdGhhdC5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHt2YWw6IDF9XG4gICAqICAgICAgICwgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KG5vb3ApLnRvLm5vdC5jaGFuZ2UobXlPYmosICd2YWwnKTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChub29wKS50by5ub3QuaW5jcmVhc2UobXlPYmosICd2YWwnKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIGAuaW5jcmVhc2VgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3JcbiAgICogbWVzc2FnZSB0byBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXNcbiAgICogdGhlIHNlY29uZCBhcmd1bWVudCB0byBgZXhwZWN0YC4gV2hlbiBub3QgcHJvdmlkaW5nIHR3byBhcmd1bWVudHMsIGFsd2F5c1xuICAgKiB1c2UgdGhlIHNlY29uZCBmb3JtLlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge3ZhbDogMX1cbiAgICogICAgICAgLCBub29wID0gZnVuY3Rpb24gKCkge307XG4gICAqXG4gICAqICAgICBleHBlY3Qobm9vcCkudG8uaW5jcmVhc2UobXlPYmosICd2YWwnLCAnbm9vbyB3aHkgZmFpbD8/Jyk7XG4gICAqXG4gICAqICAgICB2YXIgdmFsID0gMVxuICAgKiAgICAgICAsIG5vb3AgPSBmdW5jdGlvbiAoKSB7fVxuICAgKiAgICAgICAsIGdldFZhbCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbDsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChub29wLCAnbm9vbyB3aHkgZmFpbD8/JykudG8uaW5jcmVhc2UoZ2V0VmFsKTtcbiAgICpcbiAgICogVGhlIGFsaWFzIGAuaW5jcmVhc2VzYCBjYW4gYmUgdXNlZCBpbnRlcmNoYW5nZWFibHkgd2l0aCBgLmluY3JlYXNlYC5cbiAgICpcbiAgICogQG5hbWUgaW5jcmVhc2VcbiAgICogQGFsaWFzIGluY3JlYXNlc1xuICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc3ViamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEluY3JlYXNlcyAoc3ViamVjdCwgcHJvcCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIGZuID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgZmxhZ01zZyA9IGZsYWcodGhpcywgJ21lc3NhZ2UnKVxuICAgICAgLCBzc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpO1xuICAgIG5ldyBBc3NlcnRpb24oZm4sIGZsYWdNc2csIHNzZmksIHRydWUpLmlzLmEoJ2Z1bmN0aW9uJyk7XG5cbiAgICB2YXIgaW5pdGlhbDtcbiAgICBpZiAoIXByb3ApIHtcbiAgICAgIG5ldyBBc3NlcnRpb24oc3ViamVjdCwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkuaXMuYSgnZnVuY3Rpb24nKTtcbiAgICAgIGluaXRpYWwgPSBzdWJqZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ldyBBc3NlcnRpb24oc3ViamVjdCwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkudG8uaGF2ZS5wcm9wZXJ0eShwcm9wKTtcbiAgICAgIGluaXRpYWwgPSBzdWJqZWN0W3Byb3BdO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSB0YXJnZXQgaXMgYSBudW1iZXJcbiAgICBuZXcgQXNzZXJ0aW9uKGluaXRpYWwsIGZsYWdNc2csIHNzZmksIHRydWUpLmlzLmEoJ251bWJlcicpO1xuXG4gICAgZm4oKTtcblxuICAgIHZhciBmaW5hbCA9IHByb3AgPT09IHVuZGVmaW5lZCB8fCBwcm9wID09PSBudWxsID8gc3ViamVjdCgpIDogc3ViamVjdFtwcm9wXTtcbiAgICB2YXIgbXNnT2JqID0gcHJvcCA9PT0gdW5kZWZpbmVkIHx8IHByb3AgPT09IG51bGwgPyBpbml0aWFsIDogJy4nICsgcHJvcDtcblxuICAgIGZsYWcodGhpcywgJ2RlbHRhTXNnT2JqJywgbXNnT2JqKTtcbiAgICBmbGFnKHRoaXMsICdpbml0aWFsRGVsdGFWYWx1ZScsIGluaXRpYWwpO1xuICAgIGZsYWcodGhpcywgJ2ZpbmFsRGVsdGFWYWx1ZScsIGZpbmFsKTtcbiAgICBmbGFnKHRoaXMsICdkZWx0YUJlaGF2aW9yJywgJ2luY3JlYXNlJyk7XG4gICAgZmxhZyh0aGlzLCAncmVhbERlbHRhJywgZmluYWwgLSBpbml0aWFsKTtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgZmluYWwgLSBpbml0aWFsID4gMFxuICAgICAgLCAnZXhwZWN0ZWQgJyArIG1zZ09iaiArICcgdG8gaW5jcmVhc2UnXG4gICAgICAsICdleHBlY3RlZCAnICsgbXNnT2JqICsgJyB0byBub3QgaW5jcmVhc2UnXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2luY3JlYXNlJywgYXNzZXJ0SW5jcmVhc2VzKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnaW5jcmVhc2VzJywgYXNzZXJ0SW5jcmVhc2VzKTtcblxuICAvKipcbiAgICogIyMjIC5kZWNyZWFzZShzdWJqZWN0WywgcHJvcFssIG1zZ11dKVxuICAgKlxuICAgKiBXaGVuIG9uZSBhcmd1bWVudCBpcyBwcm92aWRlZCwgYC5kZWNyZWFzZWAgYXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiBmdW5jdGlvblxuICAgKiBgc3ViamVjdGAgcmV0dXJucyBhIGxlc3NlciBudW1iZXIgd2hlbiBpdCdzIGludm9rZWQgYWZ0ZXIgaW52b2tpbmcgdGhlXG4gICAqIHRhcmdldCBmdW5jdGlvbiBjb21wYXJlZCB0byB3aGVuIGl0J3MgaW52b2tlZCBiZWZvcmVoYW5kLiBgLmRlY3JlYXNlYCBhbHNvXG4gICAqIGNhdXNlcyBhbGwgYC5ieWAgYXNzZXJ0aW9ucyB0aGF0IGZvbGxvdyBpbiB0aGUgY2hhaW4gdG8gYXNzZXJ0IGhvdyBtdWNoXG4gICAqIGxlc3NlciBvZiBhIG51bWJlciBpcyByZXR1cm5lZC4gSXQncyBvZnRlbiBiZXN0IHRvIGFzc2VydCB0aGF0IHRoZSByZXR1cm5cbiAgICogdmFsdWUgZGVjcmVhc2VkIGJ5IHRoZSBleHBlY3RlZCBhbW91bnQsIHJhdGhlciB0aGFuIGFzc2VydGluZyBpdCBkZWNyZWFzZWRcbiAgICogYnkgYW55IGFtb3VudC5cbiAgICpcbiAgICogICAgIHZhciB2YWwgPSAxXG4gICAqICAgICAgICwgc3VidHJhY3RUd28gPSBmdW5jdGlvbiAoKSB7IHZhbCAtPSAyOyB9XG4gICAqICAgICAgICwgZ2V0VmFsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KHN1YnRyYWN0VHdvKS50by5kZWNyZWFzZShnZXRWYWwpLmJ5KDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHN1YnRyYWN0VHdvKS50by5kZWNyZWFzZShnZXRWYWwpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogV2hlbiB0d28gYXJndW1lbnRzIGFyZSBwcm92aWRlZCwgYC5kZWNyZWFzZWAgYXNzZXJ0cyB0aGF0IHRoZSB2YWx1ZSBvZiB0aGVcbiAgICogZ2l2ZW4gb2JqZWN0IGBzdWJqZWN0YCdzIGBwcm9wYCBwcm9wZXJ0eSBpcyBsZXNzZXIgYWZ0ZXIgaW52b2tpbmcgdGhlXG4gICAqIHRhcmdldCBmdW5jdGlvbiBjb21wYXJlZCB0byBiZWZvcmVoYW5kLlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge3ZhbDogMX1cbiAgICogICAgICAgLCBzdWJ0cmFjdFR3byA9IGZ1bmN0aW9uICgpIHsgbXlPYmoudmFsIC09IDI7IH07XG4gICAqXG4gICAqICAgICBleHBlY3Qoc3VidHJhY3RUd28pLnRvLmRlY3JlYXNlKG15T2JqLCAndmFsJykuYnkoMik7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3Qoc3VidHJhY3RUd28pLnRvLmRlY3JlYXNlKG15T2JqLCAndmFsJyk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmRlY3JlYXNlYC4gSG93ZXZlciwgaXQnc1xuICAgKiBkYW5nZXJvdXMgdG8gZG8gc28uIFRoZSBwcm9ibGVtIGlzIHRoYXQgaXQgY3JlYXRlcyB1bmNlcnRhaW4gZXhwZWN0YXRpb25zXG4gICAqIGJ5IGFzc2VydGluZyB0aGF0IHRoZSBzdWJqZWN0IGVpdGhlciBpbmNyZWFzZXMsIG9yIHRoYXQgaXQgc3RheXMgdGhlIHNhbWUuXG4gICAqIEl0J3Mgb2Z0ZW4gYmVzdCB0byBpZGVudGlmeSB0aGUgZXhhY3Qgb3V0cHV0IHRoYXQncyBleHBlY3RlZCwgYW5kIHRoZW5cbiAgICogd3JpdGUgYW4gYXNzZXJ0aW9uIHRoYXQgb25seSBhY2NlcHRzIHRoYXQgZXhhY3Qgb3V0cHV0LlxuICAgKlxuICAgKiBXaGVuIHRoZSBzdWJqZWN0IGlzIGV4cGVjdGVkIHRvIGluY3JlYXNlLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0IHRoYXQgaXRcbiAgICogaW5jcmVhc2VkIGJ5IHRoZSBleHBlY3RlZCBhbW91bnQuXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7dmFsOiAxfVxuICAgKiAgICAgICAsIGFkZFR3byA9IGZ1bmN0aW9uICgpIHsgbXlPYmoudmFsICs9IDI7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYWRkVHdvKS50by5pbmNyZWFzZShteU9iaiwgJ3ZhbCcpLmJ5KDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KGFkZFR3bykudG8ubm90LmRlY3JlYXNlKG15T2JqLCAndmFsJyk7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBXaGVuIHRoZSBzdWJqZWN0IGlzIGV4cGVjdGVkIHRvIHN0YXkgdGhlIHNhbWUsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnRcbiAgICogZXhhY3RseSB0aGF0LlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge3ZhbDogMX1cbiAgICogICAgICAgLCBub29wID0gZnVuY3Rpb24gKCkge307XG4gICAqXG4gICAqICAgICBleHBlY3Qobm9vcCkudG8ubm90LmNoYW5nZShteU9iaiwgJ3ZhbCcpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KG5vb3ApLnRvLm5vdC5kZWNyZWFzZShteU9iaiwgJ3ZhbCcpOyAvLyBOb3QgcmVjb21tZW5kZWRcbiAgICpcbiAgICogYC5kZWNyZWFzZWAgYWNjZXB0cyBhbiBvcHRpb25hbCBgbXNnYCBhcmd1bWVudCB3aGljaCBpcyBhIGN1c3RvbSBlcnJvclxuICAgKiBtZXNzYWdlIHRvIHNob3cgd2hlbiB0aGUgYXNzZXJ0aW9uIGZhaWxzLiBUaGUgbWVzc2FnZSBjYW4gYWxzbyBiZSBnaXZlbiBhc1xuICAgKiB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLiBXaGVuIG5vdCBwcm92aWRpbmcgdHdvIGFyZ3VtZW50cywgYWx3YXlzXG4gICAqIHVzZSB0aGUgc2Vjb25kIGZvcm0uXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7dmFsOiAxfVxuICAgKiAgICAgICAsIG5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICpcbiAgICogICAgIGV4cGVjdChub29wKS50by5kZWNyZWFzZShteU9iaiwgJ3ZhbCcsICdub29vIHdoeSBmYWlsPz8nKTtcbiAgICpcbiAgICogICAgIHZhciB2YWwgPSAxXG4gICAqICAgICAgICwgbm9vcCA9IGZ1bmN0aW9uICgpIHt9XG4gICAqICAgICAgICwgZ2V0VmFsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KG5vb3AsICdub29vIHdoeSBmYWlsPz8nKS50by5kZWNyZWFzZShnZXRWYWwpO1xuICAgKlxuICAgKiBUaGUgYWxpYXMgYC5kZWNyZWFzZXNgIGNhbiBiZSB1c2VkIGludGVyY2hhbmdlYWJseSB3aXRoIGAuZGVjcmVhc2VgLlxuICAgKlxuICAgKiBAbmFtZSBkZWNyZWFzZVxuICAgKiBAYWxpYXMgZGVjcmVhc2VzXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzdWJqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0RGVjcmVhc2VzIChzdWJqZWN0LCBwcm9wLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgZm4gPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBmbGFnTXNnID0gZmxhZyh0aGlzLCAnbWVzc2FnZScpXG4gICAgICAsIHNzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJyk7XG4gICAgbmV3IEFzc2VydGlvbihmbiwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkuaXMuYSgnZnVuY3Rpb24nKTtcblxuICAgIHZhciBpbml0aWFsO1xuICAgIGlmICghcHJvcCkge1xuICAgICAgbmV3IEFzc2VydGlvbihzdWJqZWN0LCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS5pcy5hKCdmdW5jdGlvbicpO1xuICAgICAgaW5pdGlhbCA9IHN1YmplY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3IEFzc2VydGlvbihzdWJqZWN0LCBmbGFnTXNnLCBzc2ZpLCB0cnVlKS50by5oYXZlLnByb3BlcnR5KHByb3ApO1xuICAgICAgaW5pdGlhbCA9IHN1YmplY3RbcHJvcF07XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHRhcmdldCBpcyBhIG51bWJlclxuICAgIG5ldyBBc3NlcnRpb24oaW5pdGlhbCwgZmxhZ01zZywgc3NmaSwgdHJ1ZSkuaXMuYSgnbnVtYmVyJyk7XG5cbiAgICBmbigpO1xuXG4gICAgdmFyIGZpbmFsID0gcHJvcCA9PT0gdW5kZWZpbmVkIHx8IHByb3AgPT09IG51bGwgPyBzdWJqZWN0KCkgOiBzdWJqZWN0W3Byb3BdO1xuICAgIHZhciBtc2dPYmogPSBwcm9wID09PSB1bmRlZmluZWQgfHwgcHJvcCA9PT0gbnVsbCA/IGluaXRpYWwgOiAnLicgKyBwcm9wO1xuXG4gICAgZmxhZyh0aGlzLCAnZGVsdGFNc2dPYmonLCBtc2dPYmopO1xuICAgIGZsYWcodGhpcywgJ2luaXRpYWxEZWx0YVZhbHVlJywgaW5pdGlhbCk7XG4gICAgZmxhZyh0aGlzLCAnZmluYWxEZWx0YVZhbHVlJywgZmluYWwpO1xuICAgIGZsYWcodGhpcywgJ2RlbHRhQmVoYXZpb3InLCAnZGVjcmVhc2UnKTtcbiAgICBmbGFnKHRoaXMsICdyZWFsRGVsdGEnLCBpbml0aWFsIC0gZmluYWwpO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBmaW5hbCAtIGluaXRpYWwgPCAwXG4gICAgICAsICdleHBlY3RlZCAnICsgbXNnT2JqICsgJyB0byBkZWNyZWFzZSdcbiAgICAgICwgJ2V4cGVjdGVkICcgKyBtc2dPYmogKyAnIHRvIG5vdCBkZWNyZWFzZSdcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZGVjcmVhc2UnLCBhc3NlcnREZWNyZWFzZXMpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdkZWNyZWFzZXMnLCBhc3NlcnREZWNyZWFzZXMpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmJ5KGRlbHRhWywgbXNnXSlcbiAgICpcbiAgICogV2hlbiBmb2xsb3dpbmcgYW4gYC5pbmNyZWFzZWAgYXNzZXJ0aW9uIGluIHRoZSBjaGFpbiwgYC5ieWAgYXNzZXJ0cyB0aGF0XG4gICAqIHRoZSBzdWJqZWN0IG9mIHRoZSBgLmluY3JlYXNlYCBhc3NlcnRpb24gaW5jcmVhc2VkIGJ5IHRoZSBnaXZlbiBgZGVsdGFgLlxuICAgKlxuICAgKiAgICAgdmFyIG15T2JqID0ge3ZhbDogMX1cbiAgICogICAgICAgLCBhZGRUd28gPSBmdW5jdGlvbiAoKSB7IG15T2JqLnZhbCArPSAyOyB9O1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGFkZFR3bykudG8uaW5jcmVhc2UobXlPYmosICd2YWwnKS5ieSgyKTtcbiAgICpcbiAgICogV2hlbiBmb2xsb3dpbmcgYSBgLmRlY3JlYXNlYCBhc3NlcnRpb24gaW4gdGhlIGNoYWluLCBgLmJ5YCBhc3NlcnRzIHRoYXQgdGhlXG4gICAqIHN1YmplY3Qgb2YgdGhlIGAuZGVjcmVhc2VgIGFzc2VydGlvbiBkZWNyZWFzZWQgYnkgdGhlIGdpdmVuIGBkZWx0YWAuXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7dmFsOiAxfVxuICAgKiAgICAgICAsIHN1YnRyYWN0VHdvID0gZnVuY3Rpb24gKCkgeyBteU9iai52YWwgLT0gMjsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChzdWJ0cmFjdFR3bykudG8uZGVjcmVhc2UobXlPYmosICd2YWwnKS5ieSgyKTtcbiAgICpcbiAgICogV2hlbiBmb2xsb3dpbmcgYSBgLmNoYW5nZWAgYXNzZXJ0aW9uIGluIHRoZSBjaGFpbiwgYC5ieWAgYXNzZXJ0cyB0aGF0IHRoZVxuICAgKiBzdWJqZWN0IG9mIHRoZSBgLmNoYW5nZWAgYXNzZXJ0aW9uIGVpdGhlciBpbmNyZWFzZWQgb3IgZGVjcmVhc2VkIGJ5IHRoZVxuICAgKiBnaXZlbiBgZGVsdGFgLiBIb3dldmVyLCBpdCdzIGRhbmdlcm91cyB0byB1c2UgYC5jaGFuZ2UuYnlgLiBUaGUgcHJvYmxlbSBpc1xuICAgKiB0aGF0IGl0IGNyZWF0ZXMgdW5jZXJ0YWluIGV4cGVjdGF0aW9ucy4gSXQncyBvZnRlbiBiZXN0IHRvIGlkZW50aWZ5IHRoZVxuICAgKiBleGFjdCBvdXRwdXQgdGhhdCdzIGV4cGVjdGVkLCBhbmQgdGhlbiB3cml0ZSBhbiBhc3NlcnRpb24gdGhhdCBvbmx5IGFjY2VwdHNcbiAgICogdGhhdCBleGFjdCBvdXRwdXQuXG4gICAqXG4gICAqICAgICB2YXIgbXlPYmogPSB7dmFsOiAxfVxuICAgKiAgICAgICAsIGFkZFR3byA9IGZ1bmN0aW9uICgpIHsgbXlPYmoudmFsICs9IDI7IH1cbiAgICogICAgICAgLCBzdWJ0cmFjdFR3byA9IGZ1bmN0aW9uICgpIHsgbXlPYmoudmFsIC09IDI7IH07XG4gICAqXG4gICAqICAgICBleHBlY3QoYWRkVHdvKS50by5pbmNyZWFzZShteU9iaiwgJ3ZhbCcpLmJ5KDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KGFkZFR3bykudG8uY2hhbmdlKG15T2JqLCAndmFsJykuYnkoMik7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiAgICAgZXhwZWN0KHN1YnRyYWN0VHdvKS50by5kZWNyZWFzZShteU9iaiwgJ3ZhbCcpLmJ5KDIpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KHN1YnRyYWN0VHdvKS50by5jaGFuZ2UobXlPYmosICd2YWwnKS5ieSgyKTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuYnlgLiBIb3dldmVyLCBpdCdzIG9mdGVuIGJlc3RcbiAgICogdG8gYXNzZXJ0IHRoYXQgdGhlIHN1YmplY3QgY2hhbmdlZCBieSBpdHMgZXhwZWN0ZWQgZGVsdGEsIHJhdGhlciB0aGFuXG4gICAqIGFzc2VydGluZyB0aGF0IGl0IGRpZG4ndCBjaGFuZ2UgYnkgb25lIG9mIGNvdW50bGVzcyB1bmV4cGVjdGVkIGRlbHRhcy5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHt2YWw6IDF9XG4gICAqICAgICAgICwgYWRkVHdvID0gZnVuY3Rpb24gKCkgeyBteU9iai52YWwgKz0gMjsgfTtcbiAgICpcbiAgICogICAgIC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoYWRkVHdvKS50by5pbmNyZWFzZShteU9iaiwgJ3ZhbCcpLmJ5KDIpO1xuICAgKlxuICAgKiAgICAgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoYWRkVHdvKS50by5pbmNyZWFzZShteU9iaiwgJ3ZhbCcpLmJ1dC5ub3QuYnkoMyk7XG4gICAqXG4gICAqIGAuYnlgIGFjY2VwdHMgYW4gb3B0aW9uYWwgYG1zZ2AgYXJndW1lbnQgd2hpY2ggaXMgYSBjdXN0b20gZXJyb3IgbWVzc2FnZSB0b1xuICAgKiBzaG93IHdoZW4gdGhlIGFzc2VydGlvbiBmYWlscy4gVGhlIG1lc3NhZ2UgY2FuIGFsc28gYmUgZ2l2ZW4gYXMgdGhlIHNlY29uZFxuICAgKiBhcmd1bWVudCB0byBgZXhwZWN0YC5cbiAgICpcbiAgICogICAgIHZhciBteU9iaiA9IHt2YWw6IDF9XG4gICAqICAgICAgICwgYWRkVHdvID0gZnVuY3Rpb24gKCkgeyBteU9iai52YWwgKz0gMjsgfTtcbiAgICpcbiAgICogICAgIGV4cGVjdChhZGRUd28pLnRvLmluY3JlYXNlKG15T2JqLCAndmFsJykuYnkoMywgJ25vb28gd2h5IGZhaWw/PycpO1xuICAgKiAgICAgZXhwZWN0KGFkZFR3bywgJ25vb28gd2h5IGZhaWw/PycpLnRvLmluY3JlYXNlKG15T2JqLCAndmFsJykuYnkoMyk7XG4gICAqXG4gICAqIEBuYW1lIGJ5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0RGVsdGEoZGVsdGEsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuXG4gICAgdmFyIG1zZ09iaiA9IGZsYWcodGhpcywgJ2RlbHRhTXNnT2JqJyk7XG4gICAgdmFyIGluaXRpYWwgPSBmbGFnKHRoaXMsICdpbml0aWFsRGVsdGFWYWx1ZScpO1xuICAgIHZhciBmaW5hbCA9IGZsYWcodGhpcywgJ2ZpbmFsRGVsdGFWYWx1ZScpO1xuICAgIHZhciBiZWhhdmlvciA9IGZsYWcodGhpcywgJ2RlbHRhQmVoYXZpb3InKTtcbiAgICB2YXIgcmVhbERlbHRhID0gZmxhZyh0aGlzLCAncmVhbERlbHRhJyk7XG5cbiAgICB2YXIgZXhwcmVzc2lvbjtcbiAgICBpZiAoYmVoYXZpb3IgPT09ICdjaGFuZ2UnKSB7XG4gICAgICBleHByZXNzaW9uID0gTWF0aC5hYnMoZmluYWwgLSBpbml0aWFsKSA9PT0gTWF0aC5hYnMoZGVsdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHByZXNzaW9uID0gcmVhbERlbHRhID09PSBNYXRoLmFicyhkZWx0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBleHByZXNzaW9uXG4gICAgICAsICdleHBlY3RlZCAnICsgbXNnT2JqICsgJyB0byAnICsgYmVoYXZpb3IgKyAnIGJ5ICcgKyBkZWx0YVxuICAgICAgLCAnZXhwZWN0ZWQgJyArIG1zZ09iaiArICcgdG8gbm90ICcgKyBiZWhhdmlvciArICcgYnkgJyArIGRlbHRhXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2J5JywgYXNzZXJ0RGVsdGEpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmV4dGVuc2libGVcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgZXh0ZW5zaWJsZSwgd2hpY2ggbWVhbnMgdGhhdCBuZXcgcHJvcGVydGllcyBjYW5cbiAgICogYmUgYWRkZWQgdG8gaXQuIFByaW1pdGl2ZXMgYXJlIG5ldmVyIGV4dGVuc2libGUuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9KS50by5iZS5leHRlbnNpYmxlO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmV4dGVuc2libGVgLlxuICAgKlxuICAgKiAgICAgdmFyIG5vbkV4dGVuc2libGVPYmplY3QgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pXG4gICAqICAgICAgICwgc2VhbGVkT2JqZWN0ID0gT2JqZWN0LnNlYWwoe30pXG4gICAqICAgICAgICwgZnJvemVuT2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG4gICAqXG4gICAqICAgICBleHBlY3Qobm9uRXh0ZW5zaWJsZU9iamVjdCkudG8ubm90LmJlLmV4dGVuc2libGU7XG4gICAqICAgICBleHBlY3Qoc2VhbGVkT2JqZWN0KS50by5ub3QuYmUuZXh0ZW5zaWJsZTtcbiAgICogICAgIGV4cGVjdChmcm96ZW5PYmplY3QpLnRvLm5vdC5iZS5leHRlbnNpYmxlO1xuICAgKiAgICAgZXhwZWN0KDEpLnRvLm5vdC5iZS5leHRlbnNpYmxlO1xuICAgKlxuICAgKiBBIGN1c3RvbSBlcnJvciBtZXNzYWdlIGNhbiBiZSBnaXZlbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBleHBlY3RgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5leHRlbnNpYmxlO1xuICAgKlxuICAgKiBAbmFtZSBleHRlbnNpYmxlXG4gICAqIEBuYW1lc3BhY2UgQkREXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZXh0ZW5zaWJsZScsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcblxuICAgIC8vIEluIEVTNSwgaWYgdGhlIGFyZ3VtZW50IHRvIHRoaXMgbWV0aG9kIGlzIGEgcHJpbWl0aXZlLCB0aGVuIGl0IHdpbGwgY2F1c2UgYSBUeXBlRXJyb3IuXG4gICAgLy8gSW4gRVM2LCBhIG5vbi1vYmplY3QgYXJndW1lbnQgd2lsbCBiZSB0cmVhdGVkIGFzIGlmIGl0IHdhcyBhIG5vbi1leHRlbnNpYmxlIG9yZGluYXJ5IG9iamVjdCwgc2ltcGx5IHJldHVybiBmYWxzZS5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNFeHRlbnNpYmxlXG4gICAgLy8gVGhlIGZvbGxvd2luZyBwcm92aWRlcyBFUzYgYmVoYXZpb3IgZm9yIEVTNSBlbnZpcm9ubWVudHMuXG5cbiAgICB2YXIgaXNFeHRlbnNpYmxlID0gb2JqID09PSBPYmplY3Qob2JqKSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKG9iaik7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgIGlzRXh0ZW5zaWJsZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBleHRlbnNpYmxlJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgZXh0ZW5zaWJsZSdcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5zZWFsZWRcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgc2VhbGVkLCB3aGljaCBtZWFucyB0aGF0IG5ldyBwcm9wZXJ0aWVzIGNhbid0IGJlXG4gICAqIGFkZGVkIHRvIGl0LCBhbmQgaXRzIGV4aXN0aW5nIHByb3BlcnRpZXMgY2FuJ3QgYmUgcmVjb25maWd1cmVkIG9yIGRlbGV0ZWQuXG4gICAqIEhvd2V2ZXIsIGl0J3MgcG9zc2libGUgdGhhdCBpdHMgZXhpc3RpbmcgcHJvcGVydGllcyBjYW4gc3RpbGwgYmUgcmVhc3NpZ25lZFxuICAgKiB0byBkaWZmZXJlbnQgdmFsdWVzLiBQcmltaXRpdmVzIGFyZSBhbHdheXMgc2VhbGVkLlxuICAgKlxuICAgKiAgICAgdmFyIHNlYWxlZE9iamVjdCA9IE9iamVjdC5zZWFsKHt9KTtcbiAgICogICAgIHZhciBmcm96ZW5PYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcbiAgICpcbiAgICogICAgIGV4cGVjdChzZWFsZWRPYmplY3QpLnRvLmJlLnNlYWxlZDtcbiAgICogICAgIGV4cGVjdChmcm96ZW5PYmplY3QpLnRvLmJlLnNlYWxlZDtcbiAgICogICAgIGV4cGVjdCgxKS50by5iZS5zZWFsZWQ7XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuc2VhbGVkYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLm5vdC5iZS5zZWFsZWQ7XG4gICAqXG4gICAqIEEgY3VzdG9tIGVycm9yIG1lc3NhZ2UgY2FuIGJlIGdpdmVuIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9LCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUuc2VhbGVkO1xuICAgKlxuICAgKiBAbmFtZSBzZWFsZWRcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdzZWFsZWQnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG5cbiAgICAvLyBJbiBFUzUsIGlmIHRoZSBhcmd1bWVudCB0byB0aGlzIG1ldGhvZCBpcyBhIHByaW1pdGl2ZSwgdGhlbiBpdCB3aWxsIGNhdXNlIGEgVHlwZUVycm9yLlxuICAgIC8vIEluIEVTNiwgYSBub24tb2JqZWN0IGFyZ3VtZW50IHdpbGwgYmUgdHJlYXRlZCBhcyBpZiBpdCB3YXMgYSBzZWFsZWQgb3JkaW5hcnkgb2JqZWN0LCBzaW1wbHkgcmV0dXJuIHRydWUuXG4gICAgLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1NlYWxlZFxuICAgIC8vIFRoZSBmb2xsb3dpbmcgcHJvdmlkZXMgRVM2IGJlaGF2aW9yIGZvciBFUzUgZW52aXJvbm1lbnRzLlxuXG4gICAgdmFyIGlzU2VhbGVkID0gb2JqID09PSBPYmplY3Qob2JqKSA/IE9iamVjdC5pc1NlYWxlZChvYmopIDogdHJ1ZTtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgaXNTZWFsZWRcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgc2VhbGVkJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgc2VhbGVkJ1xuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmZyb3plblxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBmcm96ZW4sIHdoaWNoIG1lYW5zIHRoYXQgbmV3IHByb3BlcnRpZXMgY2FuJ3QgYmVcbiAgICogYWRkZWQgdG8gaXQsIGFuZCBpdHMgZXhpc3RpbmcgcHJvcGVydGllcyBjYW4ndCBiZSByZWFzc2lnbmVkIHRvIGRpZmZlcmVudFxuICAgKiB2YWx1ZXMsIHJlY29uZmlndXJlZCwgb3IgZGVsZXRlZC4gUHJpbWl0aXZlcyBhcmUgYWx3YXlzIGZyb3plbi5cbiAgICpcbiAgICogICAgIHZhciBmcm96ZW5PYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcbiAgICpcbiAgICogICAgIGV4cGVjdChmcm96ZW5PYmplY3QpLnRvLmJlLmZyb3plbjtcbiAgICogICAgIGV4cGVjdCgxKS50by5iZS5mcm96ZW47XG4gICAqXG4gICAqIEFkZCBgLm5vdGAgZWFybGllciBpbiB0aGUgY2hhaW4gdG8gbmVnYXRlIGAuZnJvemVuYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh7YTogMX0pLnRvLm5vdC5iZS5mcm96ZW47XG4gICAqXG4gICAqIEEgY3VzdG9tIGVycm9yIG1lc3NhZ2UgY2FuIGJlIGdpdmVuIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3Qoe2E6IDF9LCAnbm9vbyB3aHkgZmFpbD8/JykudG8uYmUuZnJvemVuO1xuICAgKlxuICAgKiBAbmFtZSBmcm96ZW5cbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdmcm96ZW4nLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG5cbiAgICAvLyBJbiBFUzUsIGlmIHRoZSBhcmd1bWVudCB0byB0aGlzIG1ldGhvZCBpcyBhIHByaW1pdGl2ZSwgdGhlbiBpdCB3aWxsIGNhdXNlIGEgVHlwZUVycm9yLlxuICAgIC8vIEluIEVTNiwgYSBub24tb2JqZWN0IGFyZ3VtZW50IHdpbGwgYmUgdHJlYXRlZCBhcyBpZiBpdCB3YXMgYSBmcm96ZW4gb3JkaW5hcnkgb2JqZWN0LCBzaW1wbHkgcmV0dXJuIHRydWUuXG4gICAgLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc0Zyb3plblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgcHJvdmlkZXMgRVM2IGJlaGF2aW9yIGZvciBFUzUgZW52aXJvbm1lbnRzLlxuXG4gICAgdmFyIGlzRnJvemVuID0gb2JqID09PSBPYmplY3Qob2JqKSA/IE9iamVjdC5pc0Zyb3plbihvYmopIDogdHJ1ZTtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgaXNGcm96ZW5cbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgZnJvemVuJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgZnJvemVuJ1xuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmZpbml0ZVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBhIG51bWJlciwgYW5kIGlzbid0IGBOYU5gIG9yIHBvc2l0aXZlL25lZ2F0aXZlXG4gICAqIGBJbmZpbml0eWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMSkudG8uYmUuZmluaXRlO1xuICAgKlxuICAgKiBBZGQgYC5ub3RgIGVhcmxpZXIgaW4gdGhlIGNoYWluIHRvIG5lZ2F0ZSBgLmZpbml0ZWAuIEhvd2V2ZXIsIGl0J3NcbiAgICogZGFuZ2Vyb3VzIHRvIGRvIHNvLiBUaGUgcHJvYmxlbSBpcyB0aGF0IGl0IGNyZWF0ZXMgdW5jZXJ0YWluIGV4cGVjdGF0aW9uc1xuICAgKiBieSBhc3NlcnRpbmcgdGhhdCB0aGUgc3ViamVjdCBlaXRoZXIgaXNuJ3QgYSBudW1iZXIsIG9yIHRoYXQgaXQncyBgTmFOYCwgb3JcbiAgICogdGhhdCBpdCdzIHBvc2l0aXZlIGBJbmZpbml0eWAsIG9yIHRoYXQgaXQncyBuZWdhdGl2ZSBgSW5maW5pdHlgLiBJdCdzIG9mdGVuXG4gICAqIGJlc3QgdG8gaWRlbnRpZnkgdGhlIGV4YWN0IG91dHB1dCB0aGF0J3MgZXhwZWN0ZWQsIGFuZCB0aGVuIHdyaXRlIGFuXG4gICAqIGFzc2VydGlvbiB0aGF0IG9ubHkgYWNjZXB0cyB0aGF0IGV4YWN0IG91dHB1dC5cbiAgICpcbiAgICogV2hlbiB0aGUgdGFyZ2V0IGlzbid0IGV4cGVjdGVkIHRvIGJlIGEgbnVtYmVyLCBpdCdzIG9mdGVuIGJlc3QgdG8gYXNzZXJ0XG4gICAqIHRoYXQgaXQncyB0aGUgZXhwZWN0ZWQgdHlwZSwgcmF0aGVyIHRoYW4gYXNzZXJ0aW5nIHRoYXQgaXQgaXNuJ3Qgb25lIG9mXG4gICAqIG1hbnkgdW5leHBlY3RlZCB0eXBlcy5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uYmUuYSgnc3RyaW5nJyk7IC8vIFJlY29tbWVuZGVkXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLm5vdC5iZS5maW5pdGU7IC8vIE5vdCByZWNvbW1lbmRlZFxuICAgKlxuICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgZXhwZWN0ZWQgdG8gYmUgYE5hTmAsIGl0J3Mgb2Z0ZW4gYmVzdCB0byBhc3NlcnQgZXhhY3RseVxuICAgKiB0aGF0LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KE5hTikudG8uYmUuTmFOOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KE5hTikudG8ubm90LmJlLmZpbml0ZTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBleHBlY3RlZCB0byBiZSBwb3NpdGl2ZSBpbmZpbml0eSwgaXQncyBvZnRlbiBiZXN0IHRvXG4gICAqIGFzc2VydCBleGFjdGx5IHRoYXQuXG4gICAqXG4gICAqICAgICBleHBlY3QoSW5maW5pdHkpLnRvLmVxdWFsKEluZmluaXR5KTsgLy8gUmVjb21tZW5kZWRcbiAgICogICAgIGV4cGVjdChJbmZpbml0eSkudG8ubm90LmJlLmZpbml0ZTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIFdoZW4gdGhlIHRhcmdldCBpcyBleHBlY3RlZCB0byBiZSBuZWdhdGl2ZSBpbmZpbml0eSwgaXQncyBvZnRlbiBiZXN0IHRvXG4gICAqIGFzc2VydCBleGFjdGx5IHRoYXQuXG4gICAqXG4gICAqICAgICBleHBlY3QoLUluZmluaXR5KS50by5lcXVhbCgtSW5maW5pdHkpOyAvLyBSZWNvbW1lbmRlZFxuICAgKiAgICAgZXhwZWN0KC1JbmZpbml0eSkudG8ubm90LmJlLmZpbml0ZTsgLy8gTm90IHJlY29tbWVuZGVkXG4gICAqXG4gICAqIEEgY3VzdG9tIGVycm9yIG1lc3NhZ2UgY2FuIGJlIGdpdmVuIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYGV4cGVjdGAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycsICdub29vIHdoeSBmYWlsPz8nKS50by5iZS5maW5pdGU7XG4gICAqXG4gICAqIEBuYW1lIGZpbml0ZVxuICAgKiBAbmFtZXNwYWNlIEJERFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2Zpbml0ZScsIGZ1bmN0aW9uKG1zZykge1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB0eXBlb2Ygb2JqID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZShvYmopXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGEgZmluaXRlIG51bWJlcidcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIGEgZmluaXRlIG51bWJlcidcbiAgICApO1xuICB9KTtcbn07XG4iLCIvKiFcbiAqIGNoYWlcbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjaGFpLCB1dGlsKSB7XG4gIGNoYWkuZXhwZWN0ID0gZnVuY3Rpb24gKHZhbCwgbWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgY2hhaS5Bc3NlcnRpb24odmFsLCBtZXNzYWdlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5mYWlsKFttZXNzYWdlXSlcbiAgICogIyMjIC5mYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSwgW29wZXJhdG9yXSlcbiAgICpcbiAgICogVGhyb3cgYSBmYWlsdXJlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0LmZhaWwoKTtcbiAgICogICAgIGV4cGVjdC5mYWlsKFwiY3VzdG9tIGVycm9yIG1lc3NhZ2VcIik7XG4gICAqICAgICBleHBlY3QuZmFpbCgxLCAyKTtcbiAgICogICAgIGV4cGVjdC5mYWlsKDEsIDIsIFwiY3VzdG9tIGVycm9yIG1lc3NhZ2VcIik7XG4gICAqICAgICBleHBlY3QuZmFpbCgxLCAyLCBcImN1c3RvbSBlcnJvciBtZXNzYWdlXCIsIFwiPlwiKTtcbiAgICogICAgIGV4cGVjdC5mYWlsKDEsIDIsIHVuZGVmaW5lZCwgXCI+XCIpO1xuICAgKlxuICAgKiBAbmFtZSBmYWlsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3BlcmF0b3JcbiAgICogQG5hbWVzcGFjZSBCRERcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgY2hhaS5leHBlY3QuZmFpbCA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICBtZXNzYWdlID0gYWN0dWFsO1xuICAgICAgICBhY3R1YWwgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ2V4cGVjdC5mYWlsKCknO1xuICAgIHRocm93IG5ldyBjaGFpLkFzc2VydGlvbkVycm9yKG1lc3NhZ2UsIHtcbiAgICAgICAgYWN0dWFsOiBhY3R1YWxcbiAgICAgICwgZXhwZWN0ZWQ6IGV4cGVjdGVkXG4gICAgICAsIG9wZXJhdG9yOiBvcGVyYXRvclxuICAgIH0sIGNoYWkuZXhwZWN0LmZhaWwpO1xuICB9O1xufTtcbiIsIi8qIVxuICogY2hhaVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNoYWksIHV0aWwpIHtcbiAgdmFyIEFzc2VydGlvbiA9IGNoYWkuQXNzZXJ0aW9uO1xuXG4gIGZ1bmN0aW9uIGxvYWRTaG91bGQgKCkge1xuICAgIC8vIGV4cGxpY2l0bHkgZGVmaW5lIHRoaXMgbWV0aG9kIGFzIGZ1bmN0aW9uIGFzIHRvIGhhdmUgaXQncyBuYW1lIHRvIGluY2x1ZGUgYXMgYHNzZmlgXG4gICAgZnVuY3Rpb24gc2hvdWxkR2V0dGVyKCkge1xuICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBTdHJpbmdcbiAgICAgICAgICB8fCB0aGlzIGluc3RhbmNlb2YgTnVtYmVyXG4gICAgICAgICAgfHwgdGhpcyBpbnN0YW5jZW9mIEJvb2xlYW5cbiAgICAgICAgICB8fCB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHRoaXMgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBc3NlcnRpb24odGhpcy52YWx1ZU9mKCksIG51bGwsIHNob3VsZEdldHRlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEFzc2VydGlvbih0aGlzLCBudWxsLCBzaG91bGRHZXR0ZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGRTZXR0ZXIodmFsdWUpIHtcbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhaWpzL2NoYWkvaXNzdWVzLzg2OiB0aGlzIG1ha2VzXG4gICAgICAvLyBgd2hhdGV2ZXIuc2hvdWxkID0gc29tZVZhbHVlYCBhY3R1YWxseSBzZXQgYHNvbWVWYWx1ZWAsIHdoaWNoIGlzXG4gICAgICAvLyBlc3BlY2lhbGx5IHVzZWZ1bCBmb3IgYGdsb2JhbC5zaG91bGQgPSByZXF1aXJlKCdjaGFpJykuc2hvdWxkKClgLlxuICAgICAgLy9cbiAgICAgIC8vIE5vdGUgdGhhdCB3ZSBoYXZlIHRvIHVzZSBbW0RlZmluZVByb3BlcnR5XV0gaW5zdGVhZCBvZiBbW1B1dF1dXG4gICAgICAvLyBzaW5jZSBvdGhlcndpc2Ugd2Ugd291bGQgdHJpZ2dlciB0aGlzIHZlcnkgc2V0dGVyIVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzaG91bGQnLCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIG1vZGlmeSBPYmplY3QucHJvdG90eXBlIHRvIGhhdmUgYHNob3VsZGBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LnByb3RvdHlwZSwgJ3Nob3VsZCcsIHtcbiAgICAgIHNldDogc2hvdWxkU2V0dGVyXG4gICAgICAsIGdldDogc2hvdWxkR2V0dGVyXG4gICAgICAsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgdmFyIHNob3VsZCA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogIyMjIC5mYWlsKFttZXNzYWdlXSlcbiAgICAgKiAjIyMgLmZhaWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdLCBbb3BlcmF0b3JdKVxuICAgICAqXG4gICAgICogVGhyb3cgYSBmYWlsdXJlLlxuICAgICAqXG4gICAgICogICAgIHNob3VsZC5mYWlsKCk7XG4gICAgICogICAgIHNob3VsZC5mYWlsKFwiY3VzdG9tIGVycm9yIG1lc3NhZ2VcIik7XG4gICAgICogICAgIHNob3VsZC5mYWlsKDEsIDIpO1xuICAgICAqICAgICBzaG91bGQuZmFpbCgxLCAyLCBcImN1c3RvbSBlcnJvciBtZXNzYWdlXCIpO1xuICAgICAqICAgICBzaG91bGQuZmFpbCgxLCAyLCBcImN1c3RvbSBlcnJvciBtZXNzYWdlXCIsIFwiPlwiKTtcbiAgICAgKiAgICAgc2hvdWxkLmZhaWwoMSwgMiwgdW5kZWZpbmVkLCBcIj5cIik7XG4gICAgICpcbiAgICAgKlxuICAgICAqIEBuYW1lIGZhaWxcbiAgICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wZXJhdG9yXG4gICAgICogQG5hbWVzcGFjZSBCRERcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuXG4gICAgc2hvdWxkLmZhaWwgPSBmdW5jdGlvbiAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICAgIG1lc3NhZ2UgPSBhY3R1YWw7XG4gICAgICAgICAgYWN0dWFsID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCAnc2hvdWxkLmZhaWwoKSc7XG4gICAgICB0aHJvdyBuZXcgY2hhaS5Bc3NlcnRpb25FcnJvcihtZXNzYWdlLCB7XG4gICAgICAgICAgYWN0dWFsOiBhY3R1YWxcbiAgICAgICAgLCBleHBlY3RlZDogZXhwZWN0ZWRcbiAgICAgICAgLCBvcGVyYXRvcjogb3BlcmF0b3JcbiAgICAgIH0sIHNob3VsZC5mYWlsKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogIyMjIC5lcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAgICpcbiAgICAgKiBBc3NlcnRzIG5vbi1zdHJpY3QgZXF1YWxpdHkgKGA9PWApIG9mIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgLlxuICAgICAqXG4gICAgICogICAgIHNob3VsZC5lcXVhbCgzLCAnMycsICc9PSBjb2VyY2VzIHZhbHVlcyB0byBzdHJpbmdzJyk7XG4gICAgICpcbiAgICAgKiBAbmFtZSBlcXVhbFxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAbmFtZXNwYWNlIFNob3VsZFxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgICBzaG91bGQuZXF1YWwgPSBmdW5jdGlvbiAodmFsMSwgdmFsMiwgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHZhbDEsIG1zZykudG8uZXF1YWwodmFsMik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqICMjIyAudGhyb3coZnVuY3Rpb24sIFtjb25zdHJ1Y3Rvci9zdHJpbmcvcmVnZXhwXSwgW3N0cmluZy9yZWdleHBdLCBbbWVzc2FnZV0pXG4gICAgICpcbiAgICAgKiBBc3NlcnRzIHRoYXQgYGZ1bmN0aW9uYCB3aWxsIHRocm93IGFuIGVycm9yIHRoYXQgaXMgYW4gaW5zdGFuY2Ugb2ZcbiAgICAgKiBgY29uc3RydWN0b3JgLCBvciBhbHRlcm5hdGVseSB0aGF0IGl0IHdpbGwgdGhyb3cgYW4gZXJyb3Igd2l0aCBtZXNzYWdlXG4gICAgICogbWF0Y2hpbmcgYHJlZ2V4cGAuXG4gICAgICpcbiAgICAgKiAgICAgc2hvdWxkLnRocm93KGZuLCAnZnVuY3Rpb24gdGhyb3dzIGEgcmVmZXJlbmNlIGVycm9yJyk7XG4gICAgICogICAgIHNob3VsZC50aHJvdyhmbiwgL2Z1bmN0aW9uIHRocm93cyBhIHJlZmVyZW5jZSBlcnJvci8pO1xuICAgICAqICAgICBzaG91bGQudGhyb3coZm4sIFJlZmVyZW5jZUVycm9yKTtcbiAgICAgKiAgICAgc2hvdWxkLnRocm93KGZuLCBSZWZlcmVuY2VFcnJvciwgJ2Z1bmN0aW9uIHRocm93cyBhIHJlZmVyZW5jZSBlcnJvcicpO1xuICAgICAqICAgICBzaG91bGQudGhyb3coZm4sIFJlZmVyZW5jZUVycm9yLCAvZnVuY3Rpb24gdGhyb3dzIGEgcmVmZXJlbmNlIGVycm9yLyk7XG4gICAgICpcbiAgICAgKiBAbmFtZSB0aHJvd1xuICAgICAqIEBhbGlhcyBUaHJvd1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtFcnJvckNvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IjRXJyb3JfdHlwZXNcbiAgICAgKiBAbmFtZXNwYWNlIFNob3VsZFxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgICBzaG91bGQuVGhyb3cgPSBmdW5jdGlvbiAoZm4sIGVycnQsIGVycnMsIG1zZykge1xuICAgICAgbmV3IEFzc2VydGlvbihmbiwgbXNnKS50by5UaHJvdyhlcnJ0LCBlcnJzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogIyMjIC5leGlzdFxuICAgICAqXG4gICAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgbmVpdGhlciBgbnVsbGAgbm9yIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogICAgIHZhciBmb28gPSAnaGknO1xuICAgICAqXG4gICAgICogICAgIHNob3VsZC5leGlzdChmb28sICdmb28gZXhpc3RzJyk7XG4gICAgICpcbiAgICAgKiBAbmFtZSBleGlzdFxuICAgICAqIEBuYW1lc3BhY2UgU2hvdWxkXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cblxuICAgIHNob3VsZC5leGlzdCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uZXhpc3Q7XG4gICAgfVxuXG4gICAgLy8gbmVnYXRpb25cbiAgICBzaG91bGQubm90ID0ge31cblxuICAgIC8qKlxuICAgICAqICMjIyAubm90LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICAgKlxuICAgICAqIEFzc2VydHMgbm9uLXN0cmljdCBpbmVxdWFsaXR5IChgIT1gKSBvZiBgYWN0dWFsYCBhbmQgYGV4cGVjdGVkYC5cbiAgICAgKlxuICAgICAqICAgICBzaG91bGQubm90LmVxdWFsKDMsIDQsICd0aGVzZSBudW1iZXJzIGFyZSBub3QgZXF1YWwnKTtcbiAgICAgKlxuICAgICAqIEBuYW1lIG5vdC5lcXVhbFxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAbmFtZXNwYWNlIFNob3VsZFxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgICBzaG91bGQubm90LmVxdWFsID0gZnVuY3Rpb24gKHZhbDEsIHZhbDIsIG1zZykge1xuICAgICAgbmV3IEFzc2VydGlvbih2YWwxLCBtc2cpLnRvLm5vdC5lcXVhbCh2YWwyKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogIyMjIC50aHJvdyhmdW5jdGlvbiwgW2NvbnN0cnVjdG9yL3JlZ2V4cF0sIFttZXNzYWdlXSlcbiAgICAgKlxuICAgICAqIEFzc2VydHMgdGhhdCBgZnVuY3Rpb25gIHdpbGwgX25vdF8gdGhyb3cgYW4gZXJyb3IgdGhhdCBpcyBhbiBpbnN0YW5jZSBvZlxuICAgICAqIGBjb25zdHJ1Y3RvcmAsIG9yIGFsdGVybmF0ZWx5IHRoYXQgaXQgd2lsbCBub3QgdGhyb3cgYW4gZXJyb3Igd2l0aCBtZXNzYWdlXG4gICAgICogbWF0Y2hpbmcgYHJlZ2V4cGAuXG4gICAgICpcbiAgICAgKiAgICAgc2hvdWxkLm5vdC50aHJvdyhmbiwgRXJyb3IsICdmdW5jdGlvbiBkb2VzIG5vdCB0aHJvdycpO1xuICAgICAqXG4gICAgICogQG5hbWUgbm90LnRocm93XG4gICAgICogQGFsaWFzIG5vdC5UaHJvd1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtFcnJvckNvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IjRXJyb3JfdHlwZXNcbiAgICAgKiBAbmFtZXNwYWNlIFNob3VsZFxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgICBzaG91bGQubm90LlRocm93ID0gZnVuY3Rpb24gKGZuLCBlcnJ0LCBlcnJzLCBtc2cpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24oZm4sIG1zZykudG8ubm90LlRocm93KGVycnQsIGVycnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAjIyMgLm5vdC5leGlzdFxuICAgICAqXG4gICAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgbmVpdGhlciBgbnVsbGAgbm9yIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogICAgIHZhciBiYXIgPSBudWxsO1xuICAgICAqXG4gICAgICogICAgIHNob3VsZC5ub3QuZXhpc3QoYmFyLCAnYmFyIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgICpcbiAgICAgKiBAbmFtZSBub3QuZXhpc3RcbiAgICAgKiBAbmFtZXNwYWNlIFNob3VsZFxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG5cbiAgICBzaG91bGQubm90LmV4aXN0ID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuZXhpc3Q7XG4gICAgfVxuXG4gICAgc2hvdWxkWyd0aHJvdyddID0gc2hvdWxkWydUaHJvdyddO1xuICAgIHNob3VsZC5ub3RbJ3Rocm93J10gPSBzaG91bGQubm90WydUaHJvdyddO1xuXG4gICAgcmV0dXJuIHNob3VsZDtcbiAgfTtcblxuICBjaGFpLnNob3VsZCA9IGxvYWRTaG91bGQ7XG4gIGNoYWkuU2hvdWxkID0gbG9hZFNob3VsZDtcbn07XG4iLCIvKiFcbiAqIGNoYWlcbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjaGFpLCB1dGlsKSB7XG4gIC8qIVxuICAgKiBDaGFpIGRlcGVuZGVuY2llcy5cbiAgICovXG5cbiAgdmFyIEFzc2VydGlvbiA9IGNoYWkuQXNzZXJ0aW9uXG4gICAgLCBmbGFnID0gdXRpbC5mbGFnO1xuXG4gIC8qIVxuICAgKiBNb2R1bGUgZXhwb3J0LlxuICAgKi9cblxuICAvKipcbiAgICogIyMjIGFzc2VydChleHByZXNzaW9uLCBtZXNzYWdlKVxuICAgKlxuICAgKiBXcml0ZSB5b3VyIG93biB0ZXN0IGV4cHJlc3Npb25zLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0KCdmb28nICE9PSAnYmFyJywgJ2ZvbyBpcyBub3QgYmFyJyk7XG4gICAqICAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShbXSksICdlbXB0eSBhcnJheXMgYXJlIGFycmF5cycpO1xuICAgKlxuICAgKiBAcGFyYW0ge01peGVkfSBleHByZXNzaW9uIHRvIHRlc3QgZm9yIHRydXRoaW5lc3NcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgdG8gZGlzcGxheSBvbiBlcnJvclxuICAgKiBAbmFtZSBhc3NlcnRcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgdmFyIGFzc2VydCA9IGNoYWkuYXNzZXJ0ID0gZnVuY3Rpb24gKGV4cHJlc3MsIGVycm1zZykge1xuICAgIHZhciB0ZXN0ID0gbmV3IEFzc2VydGlvbihudWxsLCBudWxsLCBjaGFpLmFzc2VydCwgdHJ1ZSk7XG4gICAgdGVzdC5hc3NlcnQoXG4gICAgICAgIGV4cHJlc3NcbiAgICAgICwgZXJybXNnXG4gICAgICAsICdbIG5lZ2F0aW9uIG1lc3NhZ2UgdW5hdmFpbGFibGUgXSdcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmZhaWwoW21lc3NhZ2VdKVxuICAgKiAjIyMgLmZhaWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdLCBbb3BlcmF0b3JdKVxuICAgKlxuICAgKiBUaHJvdyBhIGZhaWx1cmUuIE5vZGUuanMgYGFzc2VydGAgbW9kdWxlLWNvbXBhdGlibGUuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZmFpbCgpO1xuICAgKiAgICAgYXNzZXJ0LmZhaWwoXCJjdXN0b20gZXJyb3IgbWVzc2FnZVwiKTtcbiAgICogICAgIGFzc2VydC5mYWlsKDEsIDIpO1xuICAgKiAgICAgYXNzZXJ0LmZhaWwoMSwgMiwgXCJjdXN0b20gZXJyb3IgbWVzc2FnZVwiKTtcbiAgICogICAgIGFzc2VydC5mYWlsKDEsIDIsIFwiY3VzdG9tIGVycm9yIG1lc3NhZ2VcIiwgXCI+XCIpO1xuICAgKiAgICAgYXNzZXJ0LmZhaWwoMSwgMiwgdW5kZWZpbmVkLCBcIj5cIik7XG4gICAqXG4gICAqIEBuYW1lIGZhaWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcGVyYXRvclxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZmFpbCA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICAvLyBDb21wbHkgd2l0aCBOb2RlJ3MgZmFpbChbbWVzc2FnZV0pIGludGVyZmFjZVxuXG4gICAgICAgIG1lc3NhZ2UgPSBhY3R1YWw7XG4gICAgICAgIGFjdHVhbCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCAnYXNzZXJ0LmZhaWwoKSc7XG4gICAgdGhyb3cgbmV3IGNoYWkuQXNzZXJ0aW9uRXJyb3IobWVzc2FnZSwge1xuICAgICAgICBhY3R1YWw6IGFjdHVhbFxuICAgICAgLCBleHBlY3RlZDogZXhwZWN0ZWRcbiAgICAgICwgb3BlcmF0b3I6IG9wZXJhdG9yXG4gICAgfSwgYXNzZXJ0LmZhaWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzT2sob2JqZWN0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBpcyB0cnV0aHkuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNPaygnZXZlcnl0aGluZycsICdldmVyeXRoaW5nIGlzIG9rJyk7XG4gICAqICAgICBhc3NlcnQuaXNPayhmYWxzZSwgJ3RoaXMgd2lsbCBmYWlsJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzT2tcbiAgICogQGFsaWFzIG9rXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdCB0byB0ZXN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc09rID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzT2ssIHRydWUpLmlzLm9rO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90T2sob2JqZWN0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBpcyBmYWxzeS5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc05vdE9rKCdldmVyeXRoaW5nJywgJ3RoaXMgd2lsbCBmYWlsJyk7XG4gICAqICAgICBhc3NlcnQuaXNOb3RPayhmYWxzZSwgJ3RoaXMgd2lsbCBwYXNzJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90T2tcbiAgICogQGFsaWFzIG5vdE9rXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdCB0byB0ZXN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdE9rID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTm90T2ssIHRydWUpLmlzLm5vdC5vaztcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5lcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgbm9uLXN0cmljdCBlcXVhbGl0eSAoYD09YCkgb2YgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZXF1YWwoMywgJzMnLCAnPT0gY29lcmNlcyB2YWx1ZXMgdG8gc3RyaW5ncycpO1xuICAgKlxuICAgKiBAbmFtZSBlcXVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBtc2cpIHtcbiAgICB2YXIgdGVzdCA9IG5ldyBBc3NlcnRpb24oYWN0LCBtc2csIGFzc2VydC5lcXVhbCwgdHJ1ZSk7XG5cbiAgICB0ZXN0LmFzc2VydChcbiAgICAgICAgZXhwID09IGZsYWcodGVzdCwgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGVxdWFsICN7ZXhwfSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGVxdWFsICN7YWN0fSdcbiAgICAgICwgZXhwXG4gICAgICAsIGFjdFxuICAgICAgLCB0cnVlXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgbm9uLXN0cmljdCBpbmVxdWFsaXR5IChgIT1gKSBvZiBgYWN0dWFsYCBhbmQgYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RFcXVhbCgzLCA0LCAndGhlc2UgbnVtYmVycyBhcmUgbm90IGVxdWFsJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdEVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90RXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIHZhciB0ZXN0ID0gbmV3IEFzc2VydGlvbihhY3QsIG1zZywgYXNzZXJ0Lm5vdEVxdWFsLCB0cnVlKTtcblxuICAgIHRlc3QuYXNzZXJ0KFxuICAgICAgICBleHAgIT0gZmxhZyh0ZXN0LCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGVxdWFsICN7ZXhwfSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gZXF1YWwgI3thY3R9J1xuICAgICAgLCBleHBcbiAgICAgICwgYWN0XG4gICAgICAsIHRydWVcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLnN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBzdHJpY3QgZXF1YWxpdHkgKGA9PT1gKSBvZiBgYWN0dWFsYCBhbmQgYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCB0cnVlLCAndGhlc2UgYm9vbGVhbnMgYXJlIHN0cmljdGx5IGVxdWFsJyk7XG4gICAqXG4gICAqIEBuYW1lIHN0cmljdEVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oYWN0LCBtc2csIGFzc2VydC5zdHJpY3RFcXVhbCwgdHJ1ZSkudG8uZXF1YWwoZXhwKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgc3RyaWN0IGluZXF1YWxpdHkgKGAhPT1gKSBvZiBgYWN0dWFsYCBhbmQgYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RTdHJpY3RFcXVhbCgzLCAnMycsICdubyBjb2VyY2lvbiBmb3Igc3RyaWN0IGVxdWFsaXR5Jyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFN0cmljdEVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oYWN0LCBtc2csIGFzc2VydC5ub3RTdHJpY3RFcXVhbCwgdHJ1ZSkudG8ubm90LmVxdWFsKGV4cCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBhY3R1YWxgIGlzIGRlZXBseSBlcXVhbCB0byBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRlZXBFcXVhbCh7IHRlYTogJ2dyZWVuJyB9LCB7IHRlYTogJ2dyZWVuJyB9KTtcbiAgICpcbiAgICogQG5hbWUgZGVlcEVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYWxpYXMgZGVlcFN0cmljdEVxdWFsXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kZWVwRXF1YWwgPSBhc3NlcnQuZGVlcFN0cmljdEVxdWFsID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnLCBhc3NlcnQuZGVlcEVxdWFsLCB0cnVlKS50by5lcWwoZXhwKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnQgdGhhdCBgYWN0dWFsYCBpcyBub3QgZGVlcGx5IGVxdWFsIHRvIGBleHBlY3RlZGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90RGVlcEVxdWFsKHsgdGVhOiAnZ3JlZW4nIH0sIHsgdGVhOiAnamFzbWluZScgfSk7XG4gICAqXG4gICAqIEBuYW1lIG5vdERlZXBFcXVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihhY3QsIG1zZywgYXNzZXJ0Lm5vdERlZXBFcXVhbCwgdHJ1ZSkudG8ubm90LmVxbChleHApO1xuICB9O1xuXG4gICAvKipcbiAgICogIyMjIC5pc0Fib3ZlKHZhbHVlVG9DaGVjaywgdmFsdWVUb0JlQWJvdmUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBgdmFsdWVUb0NoZWNrYCBpcyBzdHJpY3RseSBncmVhdGVyIHRoYW4gKD4pIGB2YWx1ZVRvQmVBYm92ZWAuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNBYm92ZSg1LCAyLCAnNSBpcyBzdHJpY3RseSBncmVhdGVyIHRoYW4gMicpO1xuICAgKlxuICAgKiBAbmFtZSBpc0Fib3ZlXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlVG9DaGVja1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVRvQmVBYm92ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNBYm92ZSA9IGZ1bmN0aW9uICh2YWwsIGFidiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzQWJvdmUsIHRydWUpLnRvLmJlLmFib3ZlKGFidik7XG4gIH07XG5cbiAgIC8qKlxuICAgKiAjIyMgLmlzQXRMZWFzdCh2YWx1ZVRvQ2hlY2ssIHZhbHVlVG9CZUF0TGVhc3QsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBgdmFsdWVUb0NoZWNrYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gKD49KSBgdmFsdWVUb0JlQXRMZWFzdGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNBdExlYXN0KDUsIDIsICc1IGlzIGdyZWF0ZXIgb3IgZXF1YWwgdG8gMicpO1xuICAgKiAgICAgYXNzZXJ0LmlzQXRMZWFzdCgzLCAzLCAnMyBpcyBncmVhdGVyIG9yIGVxdWFsIHRvIDMnKTtcbiAgICpcbiAgICogQG5hbWUgaXNBdExlYXN0XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlVG9DaGVja1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVRvQmVBdExlYXN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0F0TGVhc3QgPSBmdW5jdGlvbiAodmFsLCBhdGxzdCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzQXRMZWFzdCwgdHJ1ZSkudG8uYmUubGVhc3QoYXRsc3QpO1xuICB9O1xuXG4gICAvKipcbiAgICogIyMjIC5pc0JlbG93KHZhbHVlVG9DaGVjaywgdmFsdWVUb0JlQmVsb3csIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBgdmFsdWVUb0NoZWNrYCBpcyBzdHJpY3RseSBsZXNzIHRoYW4gKDwpIGB2YWx1ZVRvQmVCZWxvd2AuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNCZWxvdygzLCA2LCAnMyBpcyBzdHJpY3RseSBsZXNzIHRoYW4gNicpO1xuICAgKlxuICAgKiBAbmFtZSBpc0JlbG93XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlVG9DaGVja1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVRvQmVCZWxvd1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNCZWxvdyA9IGZ1bmN0aW9uICh2YWwsIGJsdywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzQmVsb3csIHRydWUpLnRvLmJlLmJlbG93KGJsdyk7XG4gIH07XG5cbiAgIC8qKlxuICAgKiAjIyMgLmlzQXRNb3N0KHZhbHVlVG9DaGVjaywgdmFsdWVUb0JlQXRNb3N0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgYHZhbHVlVG9DaGVja2AgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICg8PSkgYHZhbHVlVG9CZUF0TW9zdGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNBdE1vc3QoMywgNiwgJzMgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIDYnKTtcbiAgICogICAgIGFzc2VydC5pc0F0TW9zdCg0LCA0LCAnNCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gNCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc0F0TW9zdFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVRvQ2hlY2tcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVUb0JlQXRNb3N0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0F0TW9zdCA9IGZ1bmN0aW9uICh2YWwsIGF0bXN0LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNBdE1vc3QsIHRydWUpLnRvLmJlLm1vc3QoYXRtc3QpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzVHJ1ZSh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyB0cnVlLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYVNlcnZlZCA9IHRydWU7XG4gICAqICAgICBhc3NlcnQuaXNUcnVlKHRlYVNlcnZlZCwgJ3RoZSB0ZWEgaGFzIGJlZW4gc2VydmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzVHJ1ZVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNUcnVlID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzVHJ1ZSwgdHJ1ZSkuaXNbJ3RydWUnXTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdFRydWUodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgbm90IHRydWUuXG4gICAqXG4gICAqICAgICB2YXIgdGVhID0gJ3Rhc3R5IGNoYWknO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90VHJ1ZSh0ZWEsICdncmVhdCwgdGltZSBmb3IgdGVhIScpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdFRydWVcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90VHJ1ZSA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc05vdFRydWUsIHRydWUpLnRvLm5vdC5lcXVhbCh0cnVlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0ZhbHNlKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGZhbHNlLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYVNlcnZlZCA9IGZhbHNlO1xuICAgKiAgICAgYXNzZXJ0LmlzRmFsc2UodGVhU2VydmVkLCAnbm8gdGVhIHlldD8gaG1tLi4uJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzRmFsc2VcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzRmFsc2UgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNGYWxzZSwgdHJ1ZSkuaXNbJ2ZhbHNlJ107XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RGYWxzZSh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBub3QgZmFsc2UuXG4gICAqXG4gICAqICAgICB2YXIgdGVhID0gJ3Rhc3R5IGNoYWknO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90RmFsc2UodGVhLCAnZ3JlYXQsIHRpbWUgZm9yIHRlYSEnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RGYWxzZVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RGYWxzZSA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc05vdEZhbHNlLCB0cnVlKS50by5ub3QuZXF1YWwoZmFsc2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTnVsbCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBudWxsLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzTnVsbChlcnIsICd0aGVyZSB3YXMgbm8gZXJyb3InKTtcbiAgICpcbiAgICogQG5hbWUgaXNOdWxsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc051bGwgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNOdWxsLCB0cnVlKS50by5lcXVhbChudWxsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdE51bGwodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgbm90IG51bGwuXG4gICAqXG4gICAqICAgICB2YXIgdGVhID0gJ3Rhc3R5IGNoYWknO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90TnVsbCh0ZWEsICdncmVhdCwgdGltZSBmb3IgdGVhIScpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdE51bGxcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90TnVsbCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc05vdE51bGwsIHRydWUpLnRvLm5vdC5lcXVhbChudWxsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05hTlxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdmFsdWUgaXMgTmFOLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzTmFOKE5hTiwgJ05hTiBpcyBOYU4nKTtcbiAgICpcbiAgICogQG5hbWUgaXNOYU5cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTmFOID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTmFOLCB0cnVlKS50by5iZS5OYU47XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3ROYU5cbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHZhbHVlIGlzIG5vdCBOYU4uXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNOb3ROYU4oNCwgJzQgaXMgbm90IE5hTicpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdE5hTlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cbiAgYXNzZXJ0LmlzTm90TmFOID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTm90TmFOLCB0cnVlKS5ub3QudG8uYmUuTmFOO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmV4aXN0c1xuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBuZWl0aGVyIGBudWxsYCBub3IgYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqICAgICB2YXIgZm9vID0gJ2hpJztcbiAgICpcbiAgICogICAgIGFzc2VydC5leGlzdHMoZm9vLCAnZm9vIGlzIG5laXRoZXIgYG51bGxgIG5vciBgdW5kZWZpbmVkYCcpO1xuICAgKlxuICAgKiBAbmFtZSBleGlzdHNcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmV4aXN0cyA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5leGlzdHMsIHRydWUpLnRvLmV4aXN0O1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdEV4aXN0c1xuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBlaXRoZXIgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICAgKlxuICAgKiAgICAgdmFyIGJhciA9IG51bGxcbiAgICogICAgICAgLCBiYXo7XG4gICAqXG4gICAqICAgICBhc3NlcnQubm90RXhpc3RzKGJhcik7XG4gICAqICAgICBhc3NlcnQubm90RXhpc3RzKGJheiwgJ2JheiBpcyBlaXRoZXIgbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICpcbiAgICogQG5hbWUgbm90RXhpc3RzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RFeGlzdHMgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQubm90RXhpc3RzLCB0cnVlKS50by5ub3QuZXhpc3Q7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNVbmRlZmluZWQodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqICAgICB2YXIgdGVhO1xuICAgKiAgICAgYXNzZXJ0LmlzVW5kZWZpbmVkKHRlYSwgJ25vIHRlYSBkZWZpbmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzVW5kZWZpbmVkXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc1VuZGVmaW5lZCwgdHJ1ZSkudG8uZXF1YWwodW5kZWZpbmVkKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0RlZmluZWQodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgbm90IGB1bmRlZmluZWRgLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYSA9ICdjdXAgb2YgY2hhaSc7XG4gICAqICAgICBhc3NlcnQuaXNEZWZpbmVkKHRlYSwgJ3RlYSBoYXMgYmVlbiBkZWZpbmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzRGVmaW5lZFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNEZWZpbmVkID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzRGVmaW5lZCwgdHJ1ZSkudG8ubm90LmVxdWFsKHVuZGVmaW5lZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNGdW5jdGlvbih2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLlxuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gc2VydmVUZWEoKSB7IHJldHVybiAnY3VwIG9mIHRlYSc7IH07XG4gICAqICAgICBhc3NlcnQuaXNGdW5jdGlvbihzZXJ2ZVRlYSwgJ2dyZWF0LCB3ZSBjYW4gaGF2ZSB0ZWEgbm93Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzRnVuY3Rpb25cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNGdW5jdGlvbiwgdHJ1ZSkudG8uYmUuYSgnZnVuY3Rpb24nKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdEZ1bmN0aW9uKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIF9ub3RfIGEgZnVuY3Rpb24uXG4gICAqXG4gICAqICAgICB2YXIgc2VydmVUZWEgPSBbICdoZWF0JywgJ3BvdXInLCAnc2lwJyBdO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90RnVuY3Rpb24oc2VydmVUZWEsICdncmVhdCwgd2UgaGF2ZSBsaXN0ZWQgdGhlIHN0ZXBzJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90RnVuY3Rpb25cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90RnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNOb3RGdW5jdGlvbiwgdHJ1ZSkudG8ubm90LmJlLmEoJ2Z1bmN0aW9uJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNPYmplY3QodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYW4gb2JqZWN0IG9mIHR5cGUgJ09iamVjdCcgKGFzIHJldmVhbGVkIGJ5IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCkuXG4gICAqIF9UaGUgYXNzZXJ0aW9uIGRvZXMgbm90IG1hdGNoIHN1YmNsYXNzZWQgb2JqZWN0cy5fXG4gICAqXG4gICAqICAgICB2YXIgc2VsZWN0aW9uID0geyBuYW1lOiAnQ2hhaScsIHNlcnZlOiAnd2l0aCBzcGljZXMnIH07XG4gICAqICAgICBhc3NlcnQuaXNPYmplY3Qoc2VsZWN0aW9uLCAndGVhIHNlbGVjdGlvbiBpcyBhbiBvYmplY3QnKTtcbiAgICpcbiAgICogQG5hbWUgaXNPYmplY3RcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzT2JqZWN0ID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzT2JqZWN0LCB0cnVlKS50by5iZS5hKCdvYmplY3QnKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdE9iamVjdCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBfbm90XyBhbiBvYmplY3Qgb2YgdHlwZSAnT2JqZWN0JyAoYXMgcmV2ZWFsZWQgYnkgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgKS5cbiAgICpcbiAgICogICAgIHZhciBzZWxlY3Rpb24gPSAnY2hhaSdcbiAgICogICAgIGFzc2VydC5pc05vdE9iamVjdChzZWxlY3Rpb24sICd0ZWEgc2VsZWN0aW9uIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICogICAgIGFzc2VydC5pc05vdE9iamVjdChudWxsLCAnbnVsbCBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90T2JqZWN0XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdE9iamVjdCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc05vdE9iamVjdCwgdHJ1ZSkudG8ubm90LmJlLmEoJ29iamVjdCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzQXJyYXkodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYW4gYXJyYXkuXG4gICAqXG4gICAqICAgICB2YXIgbWVudSA9IFsgJ2dyZWVuJywgJ2NoYWknLCAnb29sb25nJyBdO1xuICAgKiAgICAgYXNzZXJ0LmlzQXJyYXkobWVudSwgJ3doYXQga2luZCBvZiB0ZWEgZG8gd2Ugd2FudD8nKTtcbiAgICpcbiAgICogQG5hbWUgaXNBcnJheVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNBcnJheSA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc0FycmF5LCB0cnVlKS50by5iZS5hbignYXJyYXknKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdEFycmF5KHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIF9ub3RfIGFuIGFycmF5LlxuICAgKlxuICAgKiAgICAgdmFyIG1lbnUgPSAnZ3JlZW58Y2hhaXxvb2xvbmcnO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90QXJyYXkobWVudSwgJ3doYXQga2luZCBvZiB0ZWEgZG8gd2Ugd2FudD8nKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RBcnJheVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RBcnJheSA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc05vdEFycmF5LCB0cnVlKS50by5ub3QuYmUuYW4oJ2FycmF5Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNTdHJpbmcodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYSBzdHJpbmcuXG4gICAqXG4gICAqICAgICB2YXIgdGVhT3JkZXIgPSAnY2hhaSc7XG4gICAqICAgICBhc3NlcnQuaXNTdHJpbmcodGVhT3JkZXIsICdvcmRlciBwbGFjZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNTdHJpbmdcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzU3RyaW5nID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzU3RyaW5nLCB0cnVlKS50by5iZS5hKCdzdHJpbmcnKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdFN0cmluZyh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBfbm90XyBhIHN0cmluZy5cbiAgICpcbiAgICogICAgIHZhciB0ZWFPcmRlciA9IDQ7XG4gICAqICAgICBhc3NlcnQuaXNOb3RTdHJpbmcodGVhT3JkZXIsICdvcmRlciBwbGFjZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RTdHJpbmdcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90U3RyaW5nID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTm90U3RyaW5nLCB0cnVlKS50by5ub3QuYmUuYSgnc3RyaW5nJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOdW1iZXIodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYSBudW1iZXIuXG4gICAqXG4gICAqICAgICB2YXIgY3VwcyA9IDI7XG4gICAqICAgICBhc3NlcnQuaXNOdW1iZXIoY3VwcywgJ2hvdyBtYW55IGN1cHMnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOdW1iZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc051bWJlciA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc051bWJlciwgdHJ1ZSkudG8uYmUuYSgnbnVtYmVyJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3ROdW1iZXIodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgX25vdF8gYSBudW1iZXIuXG4gICAqXG4gICAqICAgICB2YXIgY3VwcyA9ICcyIGN1cHMgcGxlYXNlJztcbiAgICogICAgIGFzc2VydC5pc05vdE51bWJlcihjdXBzLCAnaG93IG1hbnkgY3VwcycpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdE51bWJlclxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3ROdW1iZXIgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNOb3ROdW1iZXIsIHRydWUpLnRvLm5vdC5iZS5hKCdudW1iZXInKTtcbiAgfTtcblxuICAgLyoqXG4gICAqICMjIyAuaXNGaW5pdGUodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYSBmaW5pdGUgbnVtYmVyLiBVbmxpa2UgYC5pc051bWJlcmAsIHRoaXMgd2lsbCBmYWlsIGZvciBgTmFOYCBhbmQgYEluZmluaXR5YC5cbiAgICpcbiAgICogICAgIHZhciBjdXBzID0gMjtcbiAgICogICAgIGFzc2VydC5pc0Zpbml0ZShjdXBzLCAnaG93IG1hbnkgY3VwcycpO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzRmluaXRlKE5hTik7IC8vIHRocm93c1xuICAgKlxuICAgKiBAbmFtZSBpc0Zpbml0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzRmluaXRlID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzRmluaXRlLCB0cnVlKS50by5iZS5maW5pdGU7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNCb29sZWFuKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGEgYm9vbGVhbi5cbiAgICpcbiAgICogICAgIHZhciB0ZWFSZWFkeSA9IHRydWVcbiAgICogICAgICAgLCB0ZWFTZXJ2ZWQgPSBmYWxzZTtcbiAgICpcbiAgICogICAgIGFzc2VydC5pc0Jvb2xlYW4odGVhUmVhZHksICdpcyB0aGUgdGVhIHJlYWR5Jyk7XG4gICAqICAgICBhc3NlcnQuaXNCb29sZWFuKHRlYVNlcnZlZCwgJ2hhcyB0ZWEgYmVlbiBzZXJ2ZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNCb29sZWFuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0Jvb2xlYW4gPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQuaXNCb29sZWFuLCB0cnVlKS50by5iZS5hKCdib29sZWFuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RCb29sZWFuKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIF9ub3RfIGEgYm9vbGVhbi5cbiAgICpcbiAgICogICAgIHZhciB0ZWFSZWFkeSA9ICd5ZXAnXG4gICAqICAgICAgICwgdGVhU2VydmVkID0gJ25vcGUnO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzTm90Qm9vbGVhbih0ZWFSZWFkeSwgJ2lzIHRoZSB0ZWEgcmVhZHknKTtcbiAgICogICAgIGFzc2VydC5pc05vdEJvb2xlYW4odGVhU2VydmVkLCAnaGFzIHRlYSBiZWVuIHNlcnZlZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdEJvb2xlYW5cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90Qm9vbGVhbiA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc05vdEJvb2xlYW4sIHRydWUpLnRvLm5vdC5iZS5hKCdib29sZWFuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAudHlwZU9mKHZhbHVlLCBuYW1lLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgJ3MgdHlwZSBpcyBgbmFtZWAsIGFzIGRldGVybWluZWQgYnlcbiAgICogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnR5cGVPZih7IHRlYTogJ2NoYWknIH0sICdvYmplY3QnLCAnd2UgaGF2ZSBhbiBvYmplY3QnKTtcbiAgICogICAgIGFzc2VydC50eXBlT2YoWydjaGFpJywgJ2phc21pbmUnXSwgJ2FycmF5JywgJ3dlIGhhdmUgYW4gYXJyYXknKTtcbiAgICogICAgIGFzc2VydC50eXBlT2YoJ3RlYScsICdzdHJpbmcnLCAnd2UgaGF2ZSBhIHN0cmluZycpO1xuICAgKiAgICAgYXNzZXJ0LnR5cGVPZigvdGVhLywgJ3JlZ2V4cCcsICd3ZSBoYXZlIGEgcmVndWxhciBleHByZXNzaW9uJyk7XG4gICAqICAgICBhc3NlcnQudHlwZU9mKG51bGwsICdudWxsJywgJ3dlIGhhdmUgYSBudWxsJyk7XG4gICAqICAgICBhc3NlcnQudHlwZU9mKHVuZGVmaW5lZCwgJ3VuZGVmaW5lZCcsICd3ZSBoYXZlIGFuIHVuZGVmaW5lZCcpO1xuICAgKlxuICAgKiBAbmFtZSB0eXBlT2ZcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnR5cGVPZiA9IGZ1bmN0aW9uICh2YWwsIHR5cGUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC50eXBlT2YsIHRydWUpLnRvLmJlLmEodHlwZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90VHlwZU9mKHZhbHVlLCBuYW1lLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgJ3MgdHlwZSBpcyBfbm90XyBgbmFtZWAsIGFzIGRldGVybWluZWQgYnlcbiAgICogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdFR5cGVPZigndGVhJywgJ251bWJlcicsICdzdHJpbmdzIGFyZSBub3QgbnVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBub3RUeXBlT2ZcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVvZiBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RUeXBlT2YgPSBmdW5jdGlvbiAodmFsLCB0eXBlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnLCBhc3NlcnQubm90VHlwZU9mLCB0cnVlKS50by5ub3QuYmUuYSh0eXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pbnN0YW5jZU9mKG9iamVjdCwgY29uc3RydWN0b3IsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYW4gaW5zdGFuY2Ugb2YgYGNvbnN0cnVjdG9yYC5cbiAgICpcbiAgICogICAgIHZhciBUZWEgPSBmdW5jdGlvbiAobmFtZSkgeyB0aGlzLm5hbWUgPSBuYW1lOyB9XG4gICAqICAgICAgICwgY2hhaSA9IG5ldyBUZWEoJ2NoYWknKTtcbiAgICpcbiAgICogICAgIGFzc2VydC5pbnN0YW5jZU9mKGNoYWksIFRlYSwgJ2NoYWkgaXMgYW4gaW5zdGFuY2Ugb2YgdGVhJyk7XG4gICAqXG4gICAqIEBuYW1lIGluc3RhbmNlT2ZcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge0NvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaW5zdGFuY2VPZiA9IGZ1bmN0aW9uICh2YWwsIHR5cGUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pbnN0YW5jZU9mLCB0cnVlKS50by5iZS5pbnN0YW5jZU9mKHR5cGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdEluc3RhbmNlT2Yob2JqZWN0LCBjb25zdHJ1Y3RvciwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIGB2YWx1ZWAgaXMgbm90IGFuIGluc3RhbmNlIG9mIGBjb25zdHJ1Y3RvcmAuXG4gICAqXG4gICAqICAgICB2YXIgVGVhID0gZnVuY3Rpb24gKG5hbWUpIHsgdGhpcy5uYW1lID0gbmFtZTsgfVxuICAgKiAgICAgICAsIGNoYWkgPSBuZXcgU3RyaW5nKCdjaGFpJyk7XG4gICAqXG4gICAqICAgICBhc3NlcnQubm90SW5zdGFuY2VPZihjaGFpLCBUZWEsICdjaGFpIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiB0ZWEnKTtcbiAgICpcbiAgICogQG5hbWUgbm90SW5zdGFuY2VPZlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7Q29uc3RydWN0b3J9IGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RJbnN0YW5jZU9mID0gZnVuY3Rpb24gKHZhbCwgdHlwZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0Lm5vdEluc3RhbmNlT2YsIHRydWUpXG4gICAgICAudG8ubm90LmJlLmluc3RhbmNlT2YodHlwZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaW5jbHVkZShoYXlzdGFjaywgbmVlZGxlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgaGF5c3RhY2tgIGluY2x1ZGVzIGBuZWVkbGVgLiBDYW4gYmUgdXNlZCB0byBhc3NlcnQgdGhlXG4gICAqIGluY2x1c2lvbiBvZiBhIHZhbHVlIGluIGFuIGFycmF5LCBhIHN1YnN0cmluZyBpbiBhIHN0cmluZywgb3IgYSBzdWJzZXQgb2ZcbiAgICogcHJvcGVydGllcyBpbiBhbiBvYmplY3QuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaW5jbHVkZShbMSwyLDNdLCAyLCAnYXJyYXkgY29udGFpbnMgdmFsdWUnKTtcbiAgICogICAgIGFzc2VydC5pbmNsdWRlKCdmb29iYXInLCAnZm9vJywgJ3N0cmluZyBjb250YWlucyBzdWJzdHJpbmcnKTtcbiAgICogICAgIGFzc2VydC5pbmNsdWRlKHsgZm9vOiAnYmFyJywgaGVsbG86ICd1bml2ZXJzZScgfSwgeyBmb286ICdiYXInIH0sICdvYmplY3QgY29udGFpbnMgcHJvcGVydHknKTtcbiAgICpcbiAgICogU3RyaWN0IGVxdWFsaXR5ICg9PT0pIGlzIHVzZWQuIFdoZW4gYXNzZXJ0aW5nIHRoZSBpbmNsdXNpb24gb2YgYSB2YWx1ZSBpblxuICAgKiBhbiBhcnJheSwgdGhlIGFycmF5IGlzIHNlYXJjaGVkIGZvciBhbiBlbGVtZW50IHRoYXQncyBzdHJpY3RseSBlcXVhbCB0byB0aGVcbiAgICogZ2l2ZW4gdmFsdWUuIFdoZW4gYXNzZXJ0aW5nIGEgc3Vic2V0IG9mIHByb3BlcnRpZXMgaW4gYW4gb2JqZWN0LCB0aGUgb2JqZWN0XG4gICAqIGlzIHNlYXJjaGVkIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkga2V5cywgY2hlY2tpbmcgdGhhdCBlYWNoIG9uZSBpcyBwcmVzZW50XG4gICAqIGFuZCBzdHJpY3RseSBlcXVhbCB0byB0aGUgZ2l2ZW4gcHJvcGVydHkgdmFsdWUuIEZvciBpbnN0YW5jZTpcbiAgICpcbiAgICogICAgIHZhciBvYmoxID0ge2E6IDF9XG4gICAqICAgICAgICwgb2JqMiA9IHtiOiAyfTtcbiAgICogICAgIGFzc2VydC5pbmNsdWRlKFtvYmoxLCBvYmoyXSwgb2JqMSk7XG4gICAqICAgICBhc3NlcnQuaW5jbHVkZSh7Zm9vOiBvYmoxLCBiYXI6IG9iajJ9LCB7Zm9vOiBvYmoxfSk7XG4gICAqICAgICBhc3NlcnQuaW5jbHVkZSh7Zm9vOiBvYmoxLCBiYXI6IG9iajJ9LCB7Zm9vOiBvYmoxLCBiYXI6IG9iajJ9KTtcbiAgICpcbiAgICogQG5hbWUgaW5jbHVkZVxuICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gaGF5c3RhY2tcbiAgICogQHBhcmFtIHtNaXhlZH0gbmVlZGxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pbmNsdWRlID0gZnVuY3Rpb24gKGV4cCwgaW5jLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQuaW5jbHVkZSwgdHJ1ZSkuaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdEluY2x1ZGUoaGF5c3RhY2ssIG5lZWRsZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYGhheXN0YWNrYCBkb2VzIG5vdCBpbmNsdWRlIGBuZWVkbGVgLiBDYW4gYmUgdXNlZCB0byBhc3NlcnRcbiAgICogdGhlIGFic2VuY2Ugb2YgYSB2YWx1ZSBpbiBhbiBhcnJheSwgYSBzdWJzdHJpbmcgaW4gYSBzdHJpbmcsIG9yIGEgc3Vic2V0IG9mXG4gICAqIHByb3BlcnRpZXMgaW4gYW4gb2JqZWN0LlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdEluY2x1ZGUoWzEsMiwzXSwgNCwgXCJhcnJheSBkb2Vzbid0IGNvbnRhaW4gdmFsdWVcIik7XG4gICAqICAgICBhc3NlcnQubm90SW5jbHVkZSgnZm9vYmFyJywgJ2JheicsIFwic3RyaW5nIGRvZXNuJ3QgY29udGFpbiBzdWJzdHJpbmdcIik7XG4gICAqICAgICBhc3NlcnQubm90SW5jbHVkZSh7IGZvbzogJ2JhcicsIGhlbGxvOiAndW5pdmVyc2UnIH0sIHsgZm9vOiAnYmF6JyB9LCAnb2JqZWN0IGRvZXNuJ3QgY29udGFpbiBwcm9wZXJ0eScpO1xuICAgKlxuICAgKiBTdHJpY3QgZXF1YWxpdHkgKD09PSkgaXMgdXNlZC4gV2hlbiBhc3NlcnRpbmcgdGhlIGFic2VuY2Ugb2YgYSB2YWx1ZSBpbiBhblxuICAgKiBhcnJheSwgdGhlIGFycmF5IGlzIHNlYXJjaGVkIHRvIGNvbmZpcm0gdGhlIGFic2VuY2Ugb2YgYW4gZWxlbWVudCB0aGF0J3NcbiAgICogc3RyaWN0bHkgZXF1YWwgdG8gdGhlIGdpdmVuIHZhbHVlLiBXaGVuIGFzc2VydGluZyBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGluXG4gICAqIGFuIG9iamVjdCwgdGhlIG9iamVjdCBpcyBzZWFyY2hlZCB0byBjb25maXJtIHRoYXQgYXQgbGVhc3Qgb25lIG9mIHRoZSBnaXZlblxuICAgKiBwcm9wZXJ0eSBrZXlzIGlzIGVpdGhlciBub3QgcHJlc2VudCBvciBub3Qgc3RyaWN0bHkgZXF1YWwgdG8gdGhlIGdpdmVuXG4gICAqIHByb3BlcnR5IHZhbHVlLiBGb3IgaW5zdGFuY2U6XG4gICAqXG4gICAqICAgICB2YXIgb2JqMSA9IHthOiAxfVxuICAgKiAgICAgICAsIG9iajIgPSB7YjogMn07XG4gICAqICAgICBhc3NlcnQubm90SW5jbHVkZShbb2JqMSwgb2JqMl0sIHthOiAxfSk7XG4gICAqICAgICBhc3NlcnQubm90SW5jbHVkZSh7Zm9vOiBvYmoxLCBiYXI6IG9iajJ9LCB7Zm9vOiB7YTogMX19KTtcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlKHtmb286IG9iajEsIGJhcjogb2JqMn0sIHtmb286IG9iajEsIGJhcjoge2I6IDJ9fSk7XG4gICAqXG4gICAqIEBuYW1lIG5vdEluY2x1ZGVcbiAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGhheXN0YWNrXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90SW5jbHVkZSA9IGZ1bmN0aW9uIChleHAsIGluYywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0Lm5vdEluY2x1ZGUsIHRydWUpLm5vdC5pbmNsdWRlKGluYyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcEluY2x1ZGUoaGF5c3RhY2ssIG5lZWRsZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYGhheXN0YWNrYCBpbmNsdWRlcyBgbmVlZGxlYC4gQ2FuIGJlIHVzZWQgdG8gYXNzZXJ0IHRoZVxuICAgKiBpbmNsdXNpb24gb2YgYSB2YWx1ZSBpbiBhbiBhcnJheSBvciBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGluIGFuIG9iamVjdC5cbiAgICogRGVlcCBlcXVhbGl0eSBpcyB1c2VkLlxuICAgKlxuICAgKiAgICAgdmFyIG9iajEgPSB7YTogMX1cbiAgICogICAgICAgLCBvYmoyID0ge2I6IDJ9O1xuICAgKiAgICAgYXNzZXJ0LmRlZXBJbmNsdWRlKFtvYmoxLCBvYmoyXSwge2E6IDF9KTtcbiAgICogICAgIGFzc2VydC5kZWVwSW5jbHVkZSh7Zm9vOiBvYmoxLCBiYXI6IG9iajJ9LCB7Zm9vOiB7YTogMX19KTtcbiAgICogICAgIGFzc2VydC5kZWVwSW5jbHVkZSh7Zm9vOiBvYmoxLCBiYXI6IG9iajJ9LCB7Zm9vOiB7YTogMX0sIGJhcjoge2I6IDJ9fSk7XG4gICAqXG4gICAqIEBuYW1lIGRlZXBJbmNsdWRlXG4gICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBoYXlzdGFja1xuICAgKiBAcGFyYW0ge01peGVkfSBuZWVkbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlZXBJbmNsdWRlID0gZnVuY3Rpb24gKGV4cCwgaW5jLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQuZGVlcEluY2x1ZGUsIHRydWUpLmRlZXAuaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdERlZXBJbmNsdWRlKGhheXN0YWNrLCBuZWVkbGUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBoYXlzdGFja2AgZG9lcyBub3QgaW5jbHVkZSBgbmVlZGxlYC4gQ2FuIGJlIHVzZWQgdG8gYXNzZXJ0XG4gICAqIHRoZSBhYnNlbmNlIG9mIGEgdmFsdWUgaW4gYW4gYXJyYXkgb3IgYSBzdWJzZXQgb2YgcHJvcGVydGllcyBpbiBhbiBvYmplY3QuXG4gICAqIERlZXAgZXF1YWxpdHkgaXMgdXNlZC5cbiAgICpcbiAgICogICAgIHZhciBvYmoxID0ge2E6IDF9XG4gICAqICAgICAgICwgb2JqMiA9IHtiOiAyfTtcbiAgICogICAgIGFzc2VydC5ub3REZWVwSW5jbHVkZShbb2JqMSwgb2JqMl0sIHthOiA5fSk7XG4gICAqICAgICBhc3NlcnQubm90RGVlcEluY2x1ZGUoe2Zvbzogb2JqMSwgYmFyOiBvYmoyfSwge2Zvbzoge2E6IDl9fSk7XG4gICAqICAgICBhc3NlcnQubm90RGVlcEluY2x1ZGUoe2Zvbzogb2JqMSwgYmFyOiBvYmoyfSwge2Zvbzoge2E6IDF9LCBiYXI6IHtiOiA5fX0pO1xuICAgKlxuICAgKiBAbmFtZSBub3REZWVwSW5jbHVkZVxuICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gaGF5c3RhY2tcbiAgICogQHBhcmFtIHtNaXhlZH0gbmVlZGxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3REZWVwSW5jbHVkZSA9IGZ1bmN0aW9uIChleHAsIGluYywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0Lm5vdERlZXBJbmNsdWRlLCB0cnVlKS5ub3QuZGVlcC5pbmNsdWRlKGluYyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubmVzdGVkSW5jbHVkZShoYXlzdGFjaywgbmVlZGxlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCAnaGF5c3RhY2snIGluY2x1ZGVzICduZWVkbGUnLlxuICAgKiBDYW4gYmUgdXNlZCB0byBhc3NlcnQgdGhlIGluY2x1c2lvbiBvZiBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGluIGFuXG4gICAqIG9iamVjdC5cbiAgICogRW5hYmxlcyB0aGUgdXNlIG9mIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gZm9yIHJlZmVyZW5jaW5nIG5lc3RlZFxuICAgKiBwcm9wZXJ0aWVzLlxuICAgKiAnW10nIGFuZCAnLicgaW4gcHJvcGVydHkgbmFtZXMgY2FuIGJlIGVzY2FwZWQgdXNpbmcgZG91YmxlIGJhY2tzbGFzaGVzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5lc3RlZEluY2x1ZGUoeycuYSc6IHsnYic6ICd4J319LCB7J1xcXFwuYS5bYl0nOiAneCd9KTtcbiAgICogICAgIGFzc2VydC5uZXN0ZWRJbmNsdWRlKHsnYSc6IHsnW2JdJzogJ3gnfX0sIHsnYS5cXFxcW2JcXFxcXSc6ICd4J30pO1xuICAgKlxuICAgKiBAbmFtZSBuZXN0ZWRJbmNsdWRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYXlzdGFja1xuICAgKiBAcGFyYW0ge09iamVjdH0gbmVlZGxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5uZXN0ZWRJbmNsdWRlID0gZnVuY3Rpb24gKGV4cCwgaW5jLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQubmVzdGVkSW5jbHVkZSwgdHJ1ZSkubmVzdGVkLmluY2x1ZGUoaW5jKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3ROZXN0ZWRJbmNsdWRlKGhheXN0YWNrLCBuZWVkbGUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0ICdoYXlzdGFjaycgZG9lcyBub3QgaW5jbHVkZSAnbmVlZGxlJy5cbiAgICogQ2FuIGJlIHVzZWQgdG8gYXNzZXJ0IHRoZSBhYnNlbmNlIG9mIGEgc3Vic2V0IG9mIHByb3BlcnRpZXMgaW4gYW5cbiAgICogb2JqZWN0LlxuICAgKiBFbmFibGVzIHRoZSB1c2Ugb2YgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3IgcmVmZXJlbmNpbmcgbmVzdGVkXG4gICAqIHByb3BlcnRpZXMuXG4gICAqICdbXScgYW5kICcuJyBpbiBwcm9wZXJ0eSBuYW1lcyBjYW4gYmUgZXNjYXBlZCB1c2luZyBkb3VibGUgYmFja3NsYXNoZXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90TmVzdGVkSW5jbHVkZSh7Jy5hJzogeydiJzogJ3gnfX0sIHsnXFxcXC5hLmInOiAneSd9KTtcbiAgICogICAgIGFzc2VydC5ub3ROZXN0ZWRJbmNsdWRlKHsnYSc6IHsnW2JdJzogJ3gnfX0sIHsnYS5cXFxcW2JcXFxcXSc6ICd5J30pO1xuICAgKlxuICAgKiBAbmFtZSBub3ROZXN0ZWRJbmNsdWRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYXlzdGFja1xuICAgKiBAcGFyYW0ge09iamVjdH0gbmVlZGxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3ROZXN0ZWRJbmNsdWRlID0gZnVuY3Rpb24gKGV4cCwgaW5jLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQubm90TmVzdGVkSW5jbHVkZSwgdHJ1ZSlcbiAgICAgIC5ub3QubmVzdGVkLmluY2x1ZGUoaW5jKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwTmVzdGVkSW5jbHVkZShoYXlzdGFjaywgbmVlZGxlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCAnaGF5c3RhY2snIGluY2x1ZGVzICduZWVkbGUnLlxuICAgKiBDYW4gYmUgdXNlZCB0byBhc3NlcnQgdGhlIGluY2x1c2lvbiBvZiBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGluIGFuXG4gICAqIG9iamVjdCB3aGlsZSBjaGVja2luZyBmb3IgZGVlcCBlcXVhbGl0eS5cbiAgICogRW5hYmxlcyB0aGUgdXNlIG9mIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gZm9yIHJlZmVyZW5jaW5nIG5lc3RlZFxuICAgKiBwcm9wZXJ0aWVzLlxuICAgKiAnW10nIGFuZCAnLicgaW4gcHJvcGVydHkgbmFtZXMgY2FuIGJlIGVzY2FwZWQgdXNpbmcgZG91YmxlIGJhY2tzbGFzaGVzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRlZXBOZXN0ZWRJbmNsdWRlKHthOiB7YjogW3t4OiAxfV19fSwgeydhLmJbMF0nOiB7eDogMX19KTtcbiAgICogICAgIGFzc2VydC5kZWVwTmVzdGVkSW5jbHVkZSh7Jy5hJzogeydbYl0nOiB7eDogMX19fSwgeydcXFxcLmEuXFxcXFtiXFxcXF0nOiB7eDogMX19KTtcbiAgICpcbiAgICogQG5hbWUgZGVlcE5lc3RlZEluY2x1ZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGhheXN0YWNrXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuZWVkbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlZXBOZXN0ZWRJbmNsdWRlID0gZnVuY3Rpb24oZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5kZWVwTmVzdGVkSW5jbHVkZSwgdHJ1ZSlcbiAgICAgIC5kZWVwLm5lc3RlZC5pbmNsdWRlKGluYyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90RGVlcE5lc3RlZEluY2x1ZGUoaGF5c3RhY2ssIG5lZWRsZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgJ2hheXN0YWNrJyBkb2VzIG5vdCBpbmNsdWRlICduZWVkbGUnLlxuICAgKiBDYW4gYmUgdXNlZCB0byBhc3NlcnQgdGhlIGFic2VuY2Ugb2YgYSBzdWJzZXQgb2YgcHJvcGVydGllcyBpbiBhblxuICAgKiBvYmplY3Qgd2hpbGUgY2hlY2tpbmcgZm9yIGRlZXAgZXF1YWxpdHkuXG4gICAqIEVuYWJsZXMgdGhlIHVzZSBvZiBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvciByZWZlcmVuY2luZyBuZXN0ZWRcbiAgICogcHJvcGVydGllcy5cbiAgICogJ1tdJyBhbmQgJy4nIGluIHByb3BlcnR5IG5hbWVzIGNhbiBiZSBlc2NhcGVkIHVzaW5nIGRvdWJsZSBiYWNrc2xhc2hlcy5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3REZWVwTmVzdGVkSW5jbHVkZSh7YToge2I6IFt7eDogMX1dfX0sIHsnYS5iWzBdJzoge3k6IDF9fSlcbiAgICogICAgIGFzc2VydC5ub3REZWVwTmVzdGVkSW5jbHVkZSh7Jy5hJzogeydbYl0nOiB7eDogMX19fSwgeydcXFxcLmEuXFxcXFtiXFxcXF0nOiB7eTogMn19KTtcbiAgICpcbiAgICogQG5hbWUgbm90RGVlcE5lc3RlZEluY2x1ZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGhheXN0YWNrXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuZWVkbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdERlZXBOZXN0ZWRJbmNsdWRlID0gZnVuY3Rpb24oZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5ub3REZWVwTmVzdGVkSW5jbHVkZSwgdHJ1ZSlcbiAgICAgIC5ub3QuZGVlcC5uZXN0ZWQuaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm93bkluY2x1ZGUoaGF5c3RhY2ssIG5lZWRsZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgJ2hheXN0YWNrJyBpbmNsdWRlcyAnbmVlZGxlJy5cbiAgICogQ2FuIGJlIHVzZWQgdG8gYXNzZXJ0IHRoZSBpbmNsdXNpb24gb2YgYSBzdWJzZXQgb2YgcHJvcGVydGllcyBpbiBhblxuICAgKiBvYmplY3Qgd2hpbGUgaWdub3JpbmcgaW5oZXJpdGVkIHByb3BlcnRpZXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQub3duSW5jbHVkZSh7IGE6IDEgfSwgeyBhOiAxIH0pO1xuICAgKlxuICAgKiBAbmFtZSBvd25JbmNsdWRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYXlzdGFja1xuICAgKiBAcGFyYW0ge09iamVjdH0gbmVlZGxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5vd25JbmNsdWRlID0gZnVuY3Rpb24oZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5vd25JbmNsdWRlLCB0cnVlKS5vd24uaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdE93bkluY2x1ZGUoaGF5c3RhY2ssIG5lZWRsZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgJ2hheXN0YWNrJyBpbmNsdWRlcyAnbmVlZGxlJy5cbiAgICogQ2FuIGJlIHVzZWQgdG8gYXNzZXJ0IHRoZSBhYnNlbmNlIG9mIGEgc3Vic2V0IG9mIHByb3BlcnRpZXMgaW4gYW5cbiAgICogb2JqZWN0IHdoaWxlIGlnbm9yaW5nIGluaGVyaXRlZCBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiAgICAgT2JqZWN0LnByb3RvdHlwZS5iID0gMjtcbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RPd25JbmNsdWRlKHsgYTogMSB9LCB7IGI6IDIgfSk7XG4gICAqXG4gICAqIEBuYW1lIG5vdE93bkluY2x1ZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGhheXN0YWNrXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuZWVkbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdE93bkluY2x1ZGUgPSBmdW5jdGlvbihleHAsIGluYywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0Lm5vdE93bkluY2x1ZGUsIHRydWUpLm5vdC5vd24uaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmRlZXBPd25JbmNsdWRlKGhheXN0YWNrLCBuZWVkbGUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0ICdoYXlzdGFjaycgaW5jbHVkZXMgJ25lZWRsZScuXG4gICAqIENhbiBiZSB1c2VkIHRvIGFzc2VydCB0aGUgaW5jbHVzaW9uIG9mIGEgc3Vic2V0IG9mIHByb3BlcnRpZXMgaW4gYW5cbiAgICogb2JqZWN0IHdoaWxlIGlnbm9yaW5nIGluaGVyaXRlZCBwcm9wZXJ0aWVzIGFuZCBjaGVja2luZyBmb3IgZGVlcCBlcXVhbGl0eS5cbiAgICpcbiAgICogICAgICBhc3NlcnQuZGVlcE93bkluY2x1ZGUoe2E6IHtiOiAyfX0sIHthOiB7YjogMn19KTtcbiAgICpcbiAgICogQG5hbWUgZGVlcE93bkluY2x1ZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGhheXN0YWNrXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuZWVkbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlZXBPd25JbmNsdWRlID0gZnVuY3Rpb24oZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5kZWVwT3duSW5jbHVkZSwgdHJ1ZSlcbiAgICAgIC5kZWVwLm93bi5pbmNsdWRlKGluYyk7XG4gIH07XG5cbiAgIC8qKlxuICAgKiAjIyMgLm5vdERlZXBPd25JbmNsdWRlKGhheXN0YWNrLCBuZWVkbGUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0ICdoYXlzdGFjaycgaW5jbHVkZXMgJ25lZWRsZScuXG4gICAqIENhbiBiZSB1c2VkIHRvIGFzc2VydCB0aGUgYWJzZW5jZSBvZiBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGluIGFuXG4gICAqIG9iamVjdCB3aGlsZSBpZ25vcmluZyBpbmhlcml0ZWQgcHJvcGVydGllcyBhbmQgY2hlY2tpbmcgZm9yIGRlZXAgZXF1YWxpdHkuXG4gICAqXG4gICAqICAgICAgYXNzZXJ0Lm5vdERlZXBPd25JbmNsdWRlKHthOiB7YjogMn19LCB7YToge2M6IDN9fSk7XG4gICAqXG4gICAqIEBuYW1lIG5vdERlZXBPd25JbmNsdWRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYXlzdGFja1xuICAgKiBAcGFyYW0ge09iamVjdH0gbmVlZGxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3REZWVwT3duSW5jbHVkZSA9IGZ1bmN0aW9uKGV4cCwgaW5jLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQubm90RGVlcE93bkluY2x1ZGUsIHRydWUpXG4gICAgICAubm90LmRlZXAub3duLmluY2x1ZGUoaW5jKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5tYXRjaCh2YWx1ZSwgcmVnZXhwLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIG1hdGNoZXMgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBgcmVnZXhwYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5tYXRjaCgnZm9vYmFyJywgL15mb28vLCAncmVnZXhwIG1hdGNoZXMnKTtcbiAgICpcbiAgICogQG5hbWUgbWF0Y2hcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubWF0Y2ggPSBmdW5jdGlvbiAoZXhwLCByZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0Lm1hdGNoLCB0cnVlKS50by5tYXRjaChyZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90TWF0Y2godmFsdWUsIHJlZ2V4cCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBkb2VzIG5vdCBtYXRjaCB0aGUgcmVndWxhciBleHByZXNzaW9uIGByZWdleHBgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdE1hdGNoKCdmb29iYXInLCAvXmZvby8sICdyZWdleHAgZG9lcyBub3QgbWF0Y2gnKTtcbiAgICpcbiAgICogQG5hbWUgbm90TWF0Y2hcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90TWF0Y2ggPSBmdW5jdGlvbiAoZXhwLCByZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0Lm5vdE1hdGNoLCB0cnVlKS50by5ub3QubWF0Y2gocmUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLnByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZWQgYnlcbiAgICogYHByb3BlcnR5YC5cbiAgICpcbiAgICogICAgIGFzc2VydC5wcm9wZXJ0eSh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICd0ZWEnKTtcbiAgICogICAgIGFzc2VydC5wcm9wZXJ0eSh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICd0b1N0cmluZycpO1xuICAgKlxuICAgKiBAbmFtZSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQucHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQucHJvcGVydHksIHRydWUpLnRvLmhhdmUucHJvcGVydHkocHJvcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90UHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgZG9lcyBfbm90XyBoYXZlIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lZFxuICAgKiBieSBgcHJvcGVydHlgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdFByb3BlcnR5KHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ2NvZmZlZScpO1xuICAgKlxuICAgKiBAbmFtZSBub3RQcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90UHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQubm90UHJvcGVydHksIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUucHJvcGVydHkocHJvcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAucHJvcGVydHlWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZWQgYnlcbiAgICogYHByb3BlcnR5YCB3aXRoIGEgdmFsdWUgZ2l2ZW4gYnkgYHZhbHVlYC4gVXNlcyBhIHN0cmljdCBlcXVhbGl0eSBjaGVja1xuICAgKiAoPT09KS5cbiAgICpcbiAgICogICAgIGFzc2VydC5wcm9wZXJ0eVZhbCh7IHRlYTogJ2lzIGdvb2QnIH0sICd0ZWEnLCAnaXMgZ29vZCcpO1xuICAgKlxuICAgKiBAbmFtZSBwcm9wZXJ0eVZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQucHJvcGVydHlWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5wcm9wZXJ0eVZhbCwgdHJ1ZSlcbiAgICAgIC50by5oYXZlLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90UHJvcGVydHlWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGRvZXMgX25vdF8gaGF2ZSBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZWRcbiAgICogYnkgYHByb3BlcnR5YCB3aXRoIHZhbHVlIGdpdmVuIGJ5IGB2YWx1ZWAuIFVzZXMgYSBzdHJpY3QgZXF1YWxpdHkgY2hlY2tcbiAgICogKD09PSkuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90UHJvcGVydHlWYWwoeyB0ZWE6ICdpcyBnb29kJyB9LCAndGVhJywgJ2lzIGJhZCcpO1xuICAgKiAgICAgYXNzZXJ0Lm5vdFByb3BlcnR5VmFsKHsgdGVhOiAnaXMgZ29vZCcgfSwgJ2NvZmZlZScsICdpcyBnb29kJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFByb3BlcnR5VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RQcm9wZXJ0eVZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0Lm5vdFByb3BlcnR5VmFsLCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcFByb3BlcnR5VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVkIGJ5XG4gICAqIGBwcm9wZXJ0eWAgd2l0aCBhIHZhbHVlIGdpdmVuIGJ5IGB2YWx1ZWAuIFVzZXMgYSBkZWVwIGVxdWFsaXR5IGNoZWNrLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRlZXBQcm9wZXJ0eVZhbCh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfSB9LCAndGVhJywgeyBncmVlbjogJ21hdGNoYScgfSk7XG4gICAqXG4gICAqIEBuYW1lIGRlZXBQcm9wZXJ0eVZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVlcFByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuZGVlcFByb3BlcnR5VmFsLCB0cnVlKVxuICAgICAgLnRvLmhhdmUuZGVlcC5wcm9wZXJ0eShwcm9wLCB2YWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdERlZXBQcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgZG9lcyBfbm90XyBoYXZlIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lZFxuICAgKiBieSBgcHJvcGVydHlgIHdpdGggdmFsdWUgZ2l2ZW4gYnkgYHZhbHVlYC4gVXNlcyBhIGRlZXAgZXF1YWxpdHkgY2hlY2suXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90RGVlcFByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9IH0sICd0ZWEnLCB7IGJsYWNrOiAnbWF0Y2hhJyB9KTtcbiAgICogICAgIGFzc2VydC5ub3REZWVwUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH0gfSwgJ3RlYScsIHsgZ3JlZW46ICdvb2xvbmcnIH0pO1xuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBQcm9wZXJ0eVZhbCh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfSB9LCAnY29mZmVlJywgeyBncmVlbjogJ21hdGNoYScgfSk7XG4gICAqXG4gICAqIEBuYW1lIG5vdERlZXBQcm9wZXJ0eVZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90RGVlcFByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQubm90RGVlcFByb3BlcnR5VmFsLCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLmRlZXAucHJvcGVydHkocHJvcCwgdmFsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5vd25Qcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBkaXJlY3QgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YC4gSW5oZXJpdGVkXG4gICAqIHByb3BlcnRpZXMgYXJlbid0IGNoZWNrZWQuXG4gICAqXG4gICAqICAgICBhc3NlcnQub3duUHJvcGVydHkoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAndGVhJyk7XG4gICAqXG4gICAqIEBuYW1lIG93blByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5vd25Qcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5vd25Qcm9wZXJ0eSwgdHJ1ZSlcbiAgICAgIC50by5oYXZlLm93bi5wcm9wZXJ0eShwcm9wKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RPd25Qcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBkb2VzIF9ub3RfIGhhdmUgYSBkaXJlY3QgcHJvcGVydHkgbmFtZWQgYnlcbiAgICogYHByb3BlcnR5YC4gSW5oZXJpdGVkIHByb3BlcnRpZXMgYXJlbid0IGNoZWNrZWQuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90T3duUHJvcGVydHkoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAnY29mZmVlJyk7XG4gICAqICAgICBhc3NlcnQubm90T3duUHJvcGVydHkoe30sICd0b1N0cmluZycpO1xuICAgKlxuICAgKiBAbmFtZSBub3RPd25Qcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90T3duUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQubm90T3duUHJvcGVydHksIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUub3duLnByb3BlcnR5KHByb3ApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm93blByb3BlcnR5VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBkaXJlY3QgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCBhbmQgYSB2YWx1ZVxuICAgKiBlcXVhbCB0byB0aGUgcHJvdmlkZWQgYHZhbHVlYC4gVXNlcyBhIHN0cmljdCBlcXVhbGl0eSBjaGVjayAoPT09KS5cbiAgICogSW5oZXJpdGVkIHByb3BlcnRpZXMgYXJlbid0IGNoZWNrZWQuXG4gICAqXG4gICAqICAgICBhc3NlcnQub3duUHJvcGVydHlWYWwoeyBjb2ZmZWU6ICdpcyBnb29kJ30sICdjb2ZmZWUnLCAnaXMgZ29vZCcpO1xuICAgKlxuICAgKiBAbmFtZSBvd25Qcm9wZXJ0eVZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQub3duUHJvcGVydHlWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWx1ZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0Lm93blByb3BlcnR5VmFsLCB0cnVlKVxuICAgICAgLnRvLmhhdmUub3duLnByb3BlcnR5KHByb3AsIHZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RPd25Qcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgZG9lcyBfbm90XyBoYXZlIGEgZGlyZWN0IHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWBcbiAgICogd2l0aCBhIHZhbHVlIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBgdmFsdWVgLiBVc2VzIGEgc3RyaWN0IGVxdWFsaXR5IGNoZWNrXG4gICAqICg9PT0pLiBJbmhlcml0ZWQgcHJvcGVydGllcyBhcmVuJ3QgY2hlY2tlZC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RPd25Qcm9wZXJ0eVZhbCh7IHRlYTogJ2lzIGJldHRlcid9LCAndGVhJywgJ2lzIHdvcnNlJyk7XG4gICAqICAgICBhc3NlcnQubm90T3duUHJvcGVydHlWYWwoe30sICd0b1N0cmluZycsIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xuICAgKlxuICAgKiBAbmFtZSBub3RPd25Qcm9wZXJ0eVZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90T3duUHJvcGVydHlWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWx1ZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0Lm5vdE93blByb3BlcnR5VmFsLCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLm93bi5wcm9wZXJ0eShwcm9wLCB2YWx1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcE93blByb3BlcnR5VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBkaXJlY3QgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCBhbmQgYSB2YWx1ZVxuICAgKiBlcXVhbCB0byB0aGUgcHJvdmlkZWQgYHZhbHVlYC4gVXNlcyBhIGRlZXAgZXF1YWxpdHkgY2hlY2suIEluaGVyaXRlZFxuICAgKiBwcm9wZXJ0aWVzIGFyZW4ndCBjaGVja2VkLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRlZXBPd25Qcm9wZXJ0eVZhbCh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfSB9LCAndGVhJywgeyBncmVlbjogJ21hdGNoYScgfSk7XG4gICAqXG4gICAqIEBuYW1lIGRlZXBPd25Qcm9wZXJ0eVZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVlcE93blByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsdWUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5kZWVwT3duUHJvcGVydHlWYWwsIHRydWUpXG4gICAgICAudG8uaGF2ZS5kZWVwLm93bi5wcm9wZXJ0eShwcm9wLCB2YWx1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90RGVlcE93blByb3BlcnR5VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBkb2VzIF9ub3RfIGhhdmUgYSBkaXJlY3QgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YFxuICAgKiB3aXRoIGEgdmFsdWUgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIGB2YWx1ZWAuIFVzZXMgYSBkZWVwIGVxdWFsaXR5IGNoZWNrLlxuICAgKiBJbmhlcml0ZWQgcHJvcGVydGllcyBhcmVuJ3QgY2hlY2tlZC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3REZWVwT3duUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH0gfSwgJ3RlYScsIHsgYmxhY2s6ICdtYXRjaGEnIH0pO1xuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBPd25Qcm9wZXJ0eVZhbCh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfSB9LCAndGVhJywgeyBncmVlbjogJ29vbG9uZycgfSk7XG4gICAqICAgICBhc3NlcnQubm90RGVlcE93blByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9IH0sICdjb2ZmZWUnLCB7IGdyZWVuOiAnbWF0Y2hhJyB9KTtcbiAgICogICAgIGFzc2VydC5ub3REZWVwT3duUHJvcGVydHlWYWwoe30sICd0b1N0cmluZycsIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xuICAgKlxuICAgKiBAbmFtZSBub3REZWVwT3duUHJvcGVydHlWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdERlZXBPd25Qcm9wZXJ0eVZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbHVlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQubm90RGVlcE93blByb3BlcnR5VmFsLCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLmRlZXAub3duLnByb3BlcnR5KHByb3AsIHZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5uZXN0ZWRQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVkIGJ5XG4gICAqIGBwcm9wZXJ0eWAsIHdoaWNoIGNhbiBiZSBhIHN0cmluZyB1c2luZyBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvclxuICAgKiBuZXN0ZWQgcmVmZXJlbmNlLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5lc3RlZFByb3BlcnR5KHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYS5ncmVlbicpO1xuICAgKlxuICAgKiBAbmFtZSBuZXN0ZWRQcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubmVzdGVkUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQubmVzdGVkUHJvcGVydHksIHRydWUpXG4gICAgICAudG8uaGF2ZS5uZXN0ZWQucHJvcGVydHkocHJvcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90TmVzdGVkUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgZG9lcyBfbm90XyBoYXZlIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCwgd2hpY2hcbiAgICogY2FuIGJlIGEgc3RyaW5nIHVzaW5nIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gZm9yIG5lc3RlZCByZWZlcmVuY2UuIFRoZVxuICAgKiBwcm9wZXJ0eSBjYW5ub3QgZXhpc3Qgb24gdGhlIG9iamVjdCBub3IgYW55d2hlcmUgaW4gaXRzIHByb3RvdHlwZSBjaGFpbi5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3ROZXN0ZWRQcm9wZXJ0eSh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICd0ZWEub29sb25nJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdE5lc3RlZFByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3ROZXN0ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5ub3ROZXN0ZWRQcm9wZXJ0eSwgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5uZXN0ZWQucHJvcGVydHkocHJvcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubmVzdGVkUHJvcGVydHlWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAgd2l0aCB2YWx1ZSBnaXZlblxuICAgKiBieSBgdmFsdWVgLiBgcHJvcGVydHlgIGNhbiB1c2UgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3IgbmVzdGVkXG4gICAqIHJlZmVyZW5jZS4gVXNlcyBhIHN0cmljdCBlcXVhbGl0eSBjaGVjayAoPT09KS5cbiAgICpcbiAgICogICAgIGFzc2VydC5uZXN0ZWRQcm9wZXJ0eVZhbCh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICd0ZWEuZ3JlZW4nLCAnbWF0Y2hhJyk7XG4gICAqXG4gICAqIEBuYW1lIG5lc3RlZFByb3BlcnR5VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5uZXN0ZWRQcm9wZXJ0eVZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0Lm5lc3RlZFByb3BlcnR5VmFsLCB0cnVlKVxuICAgICAgLnRvLmhhdmUubmVzdGVkLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90TmVzdGVkUHJvcGVydHlWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGRvZXMgX25vdF8gaGF2ZSBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAgd2l0aFxuICAgKiB2YWx1ZSBnaXZlbiBieSBgdmFsdWVgLiBgcHJvcGVydHlgIGNhbiB1c2UgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3JcbiAgICogbmVzdGVkIHJlZmVyZW5jZS4gVXNlcyBhIHN0cmljdCBlcXVhbGl0eSBjaGVjayAoPT09KS5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3ROZXN0ZWRQcm9wZXJ0eVZhbCh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICd0ZWEuZ3JlZW4nLCAna29uYWNoYScpO1xuICAgKiAgICAgYXNzZXJ0Lm5vdE5lc3RlZFByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ2NvZmZlZS5ncmVlbicsICdtYXRjaGEnKTtcbiAgICpcbiAgICogQG5hbWUgbm90TmVzdGVkUHJvcGVydHlWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdE5lc3RlZFByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQubm90TmVzdGVkUHJvcGVydHlWYWwsIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUubmVzdGVkLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcE5lc3RlZFByb3BlcnR5VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgIHdpdGggYSB2YWx1ZSBnaXZlblxuICAgKiBieSBgdmFsdWVgLiBgcHJvcGVydHlgIGNhbiB1c2UgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3IgbmVzdGVkXG4gICAqIHJlZmVyZW5jZS4gVXNlcyBhIGRlZXAgZXF1YWxpdHkgY2hlY2suXG4gICAqXG4gICAqICAgICBhc3NlcnQuZGVlcE5lc3RlZFByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiB7IG1hdGNoYTogJ3l1bScgfSB9IH0sICd0ZWEuZ3JlZW4nLCB7IG1hdGNoYTogJ3l1bScgfSk7XG4gICAqXG4gICAqIEBuYW1lIGRlZXBOZXN0ZWRQcm9wZXJ0eVZhbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVlcE5lc3RlZFByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuZGVlcE5lc3RlZFByb3BlcnR5VmFsLCB0cnVlKVxuICAgICAgLnRvLmhhdmUuZGVlcC5uZXN0ZWQucHJvcGVydHkocHJvcCwgdmFsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3REZWVwTmVzdGVkUHJvcGVydHlWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGRvZXMgX25vdF8gaGF2ZSBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAgd2l0aFxuICAgKiB2YWx1ZSBnaXZlbiBieSBgdmFsdWVgLiBgcHJvcGVydHlgIGNhbiB1c2UgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3JcbiAgICogbmVzdGVkIHJlZmVyZW5jZS4gVXNlcyBhIGRlZXAgZXF1YWxpdHkgY2hlY2suXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90RGVlcE5lc3RlZFByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiB7IG1hdGNoYTogJ3l1bScgfSB9IH0sICd0ZWEuZ3JlZW4nLCB7IG9vbG9uZzogJ3l1bScgfSk7XG4gICAqICAgICBhc3NlcnQubm90RGVlcE5lc3RlZFByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiB7IG1hdGNoYTogJ3l1bScgfSB9IH0sICd0ZWEuZ3JlZW4nLCB7IG1hdGNoYTogJ3l1Y2snIH0pO1xuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBOZXN0ZWRQcm9wZXJ0eVZhbCh7IHRlYTogeyBncmVlbjogeyBtYXRjaGE6ICd5dW0nIH0gfSB9LCAndGVhLmJsYWNrJywgeyBtYXRjaGE6ICd5dW0nIH0pO1xuICAgKlxuICAgKiBAbmFtZSBub3REZWVwTmVzdGVkUHJvcGVydHlWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdERlZXBOZXN0ZWRQcm9wZXJ0eVZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0Lm5vdERlZXBOZXN0ZWRQcm9wZXJ0eVZhbCwgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5kZWVwLm5lc3RlZC5wcm9wZXJ0eShwcm9wLCB2YWwpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAubGVuZ3RoT2Yob2JqZWN0LCBsZW5ndGgsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIGBsZW5ndGhgIG9yIGBzaXplYCB3aXRoIHRoZSBleHBlY3RlZCB2YWx1ZS5cbiAgICpcbiAgICogICAgIGFzc2VydC5sZW5ndGhPZihbMSwyLDNdLCAzLCAnYXJyYXkgaGFzIGxlbmd0aCBvZiAzJyk7XG4gICAqICAgICBhc3NlcnQubGVuZ3RoT2YoJ2Zvb2JhcicsIDYsICdzdHJpbmcgaGFzIGxlbmd0aCBvZiA2Jyk7XG4gICAqICAgICBhc3NlcnQubGVuZ3RoT2YobmV3IFNldChbMSwyLDNdKSwgMywgJ3NldCBoYXMgc2l6ZSBvZiAzJyk7XG4gICAqICAgICBhc3NlcnQubGVuZ3RoT2YobmV3IE1hcChbWydhJywxXSxbJ2InLDJdLFsnYycsM11dKSwgMywgJ21hcCBoYXMgc2l6ZSBvZiAzJyk7XG4gICAqXG4gICAqIEBuYW1lIGxlbmd0aE9mXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5sZW5ndGhPZiA9IGZ1bmN0aW9uIChleHAsIGxlbiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0Lmxlbmd0aE9mLCB0cnVlKS50by5oYXZlLmxlbmd0aE9mKGxlbik7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaGFzQW55S2V5cyhvYmplY3QsIFtrZXlzXSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGF0IGxlYXN0IG9uZSBvZiB0aGUgYGtleXNgIHByb3ZpZGVkLlxuICAgKiBZb3UgY2FuIGFsc28gcHJvdmlkZSBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCBvZiBhIGBrZXlzYCBhcnJheSBhbmQgaXRzIGtleXNcbiAgICogd2lsbCBiZSB1c2VkIGFzIHRoZSBleHBlY3RlZCBzZXQgb2Yga2V5cy5cbiAgICpcbiAgICogICAgIGFzc2VydC5oYXNBbnlLZXlzKHtmb286IDEsIGJhcjogMiwgYmF6OiAzfSwgWydmb28nLCAnaURvbnRFeGlzdCcsICdiYXonXSk7XG4gICAqICAgICBhc3NlcnQuaGFzQW55S2V5cyh7Zm9vOiAxLCBiYXI6IDIsIGJhejogM30sIHtmb286IDMwLCBpRG9udEV4aXN0OiA5OSwgYmF6OiAxMzM3fSk7XG4gICAqICAgICBhc3NlcnQuaGFzQW55S2V5cyhuZXcgTWFwKFtbe2ZvbzogMX0sICdiYXInXSwgWydrZXknLCAndmFsdWUnXV0pLCBbe2ZvbzogMX0sICdrZXknXSk7XG4gICAqICAgICBhc3NlcnQuaGFzQW55S2V5cyhuZXcgU2V0KFt7Zm9vOiAnYmFyJ30sICdhbm90aGVyS2V5J10pLCBbe2ZvbzogJ2Jhcid9LCAnYW5vdGhlcktleSddKTtcbiAgICpcbiAgICogQG5hbWUgaGFzQW55S2V5c1xuICAgKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGtleXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lmhhc0FueUtleXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuaGFzQW55S2V5cywgdHJ1ZSkudG8uaGF2ZS5hbnkua2V5cyhrZXlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmhhc0FsbEtleXMob2JqZWN0LCBba2V5c10sIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhbGwgYW5kIG9ubHkgYWxsIG9mIHRoZSBga2V5c2AgcHJvdmlkZWQuXG4gICAqIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGEgYGtleXNgIGFycmF5IGFuZCBpdHMga2V5c1xuICAgKiB3aWxsIGJlIHVzZWQgYXMgdGhlIGV4cGVjdGVkIHNldCBvZiBrZXlzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lmhhc0FsbEtleXMoe2ZvbzogMSwgYmFyOiAyLCBiYXo6IDN9LCBbJ2ZvbycsICdiYXInLCAnYmF6J10pO1xuICAgKiAgICAgYXNzZXJ0Lmhhc0FsbEtleXMoe2ZvbzogMSwgYmFyOiAyLCBiYXo6IDN9LCB7Zm9vOiAzMCwgYmFyOiA5OSwgYmF6OiAxMzM3XSk7XG4gICAqICAgICBhc3NlcnQuaGFzQWxsS2V5cyhuZXcgTWFwKFtbe2ZvbzogMX0sICdiYXInXSwgWydrZXknLCAndmFsdWUnXV0pLCBbe2ZvbzogMX0sICdrZXknXSk7XG4gICAqICAgICBhc3NlcnQuaGFzQWxsS2V5cyhuZXcgU2V0KFt7Zm9vOiAnYmFyJ30sICdhbm90aGVyS2V5J10sIFt7Zm9vOiAnYmFyJ30sICdhbm90aGVyS2V5J10pO1xuICAgKlxuICAgKiBAbmFtZSBoYXNBbGxLZXlzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBrZXlzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5oYXNBbGxLZXlzID0gZnVuY3Rpb24gKG9iaiwga2V5cywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0Lmhhc0FsbEtleXMsIHRydWUpLnRvLmhhdmUuYWxsLmtleXMoa2V5cyk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5jb250YWluc0FsbEtleXMob2JqZWN0LCBba2V5c10sIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhbGwgb2YgdGhlIGBrZXlzYCBwcm92aWRlZCBidXQgbWF5IGhhdmUgbW9yZSBrZXlzIG5vdCBsaXN0ZWQuXG4gICAqIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGEgYGtleXNgIGFycmF5IGFuZCBpdHMga2V5c1xuICAgKiB3aWxsIGJlIHVzZWQgYXMgdGhlIGV4cGVjdGVkIHNldCBvZiBrZXlzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmNvbnRhaW5zQWxsS2V5cyh7Zm9vOiAxLCBiYXI6IDIsIGJhejogM30sIFsnZm9vJywgJ2JheiddKTtcbiAgICogICAgIGFzc2VydC5jb250YWluc0FsbEtleXMoe2ZvbzogMSwgYmFyOiAyLCBiYXo6IDN9LCBbJ2ZvbycsICdiYXInLCAnYmF6J10pO1xuICAgKiAgICAgYXNzZXJ0LmNvbnRhaW5zQWxsS2V5cyh7Zm9vOiAxLCBiYXI6IDIsIGJhejogM30sIHtmb286IDMwLCBiYXo6IDEzMzd9KTtcbiAgICogICAgIGFzc2VydC5jb250YWluc0FsbEtleXMoe2ZvbzogMSwgYmFyOiAyLCBiYXo6IDN9LCB7Zm9vOiAzMCwgYmFyOiA5OSwgYmF6OiAxMzM3fSk7XG4gICAqICAgICBhc3NlcnQuY29udGFpbnNBbGxLZXlzKG5ldyBNYXAoW1t7Zm9vOiAxfSwgJ2JhciddLCBbJ2tleScsICd2YWx1ZSddXSksIFt7Zm9vOiAxfV0pO1xuICAgKiAgICAgYXNzZXJ0LmNvbnRhaW5zQWxsS2V5cyhuZXcgTWFwKFtbe2ZvbzogMX0sICdiYXInXSwgWydrZXknLCAndmFsdWUnXV0pLCBbe2ZvbzogMX0sICdrZXknXSk7XG4gICAqICAgICBhc3NlcnQuY29udGFpbnNBbGxLZXlzKG5ldyBTZXQoW3tmb286ICdiYXInfSwgJ2Fub3RoZXJLZXknXSwgW3tmb286ICdiYXInfV0pO1xuICAgKiAgICAgYXNzZXJ0LmNvbnRhaW5zQWxsS2V5cyhuZXcgU2V0KFt7Zm9vOiAnYmFyJ30sICdhbm90aGVyS2V5J10sIFt7Zm9vOiAnYmFyJ30sICdhbm90aGVyS2V5J10pO1xuICAgKlxuICAgKiBAbmFtZSBjb250YWluc0FsbEtleXNcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nW119IGtleXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmNvbnRhaW5zQWxsS2V5cyA9IGZ1bmN0aW9uIChvYmosIGtleXMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5jb250YWluc0FsbEtleXMsIHRydWUpXG4gICAgICAudG8uY29udGFpbi5hbGwua2V5cyhrZXlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmRvZXNOb3RIYXZlQW55S2V5cyhvYmplY3QsIFtrZXlzXSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIG5vbmUgb2YgdGhlIGBrZXlzYCBwcm92aWRlZC5cbiAgICogWW91IGNhbiBhbHNvIHByb3ZpZGUgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQgb2YgYSBga2V5c2AgYXJyYXkgYW5kIGl0cyBrZXlzXG4gICAqIHdpbGwgYmUgdXNlZCBhcyB0aGUgZXhwZWN0ZWQgc2V0IG9mIGtleXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZG9lc05vdEhhdmVBbnlLZXlzKHtmb286IDEsIGJhcjogMiwgYmF6OiAzfSwgWydvbmUnLCAndHdvJywgJ2V4YW1wbGUnXSk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdEhhdmVBbnlLZXlzKHtmb286IDEsIGJhcjogMiwgYmF6OiAzfSwge29uZTogMSwgdHdvOiAyLCBleGFtcGxlOiAnZm9vJ30pO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQW55S2V5cyhuZXcgTWFwKFtbe2ZvbzogMX0sICdiYXInXSwgWydrZXknLCAndmFsdWUnXV0pLCBbe29uZTogJ3R3byd9LCAnZXhhbXBsZSddKTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFueUtleXMobmV3IFNldChbe2ZvbzogJ2Jhcid9LCAnYW5vdGhlcktleSddLCBbe29uZTogJ3R3byd9LCAnZXhhbXBsZSddKTtcbiAgICpcbiAgICogQG5hbWUgZG9lc05vdEhhdmVBbnlLZXlzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBrZXlzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kb2VzTm90SGF2ZUFueUtleXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuZG9lc05vdEhhdmVBbnlLZXlzLCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLmFueS5rZXlzKGtleXMpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuZG9lc05vdEhhdmVBbGxLZXlzKG9iamVjdCwgW2tleXNdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBkb2VzIG5vdCBoYXZlIGF0IGxlYXN0IG9uZSBvZiB0aGUgYGtleXNgIHByb3ZpZGVkLlxuICAgKiBZb3UgY2FuIGFsc28gcHJvdmlkZSBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCBvZiBhIGBrZXlzYCBhcnJheSBhbmQgaXRzIGtleXNcbiAgICogd2lsbCBiZSB1c2VkIGFzIHRoZSBleHBlY3RlZCBzZXQgb2Yga2V5cy5cbiAgICpcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFsbEtleXMoe2ZvbzogMSwgYmFyOiAyLCBiYXo6IDN9LCBbJ29uZScsICd0d28nLCAnZXhhbXBsZSddKTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFsbEtleXMoe2ZvbzogMSwgYmFyOiAyLCBiYXo6IDN9LCB7b25lOiAxLCB0d286IDIsIGV4YW1wbGU6ICdmb28nfSk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdEhhdmVBbGxLZXlzKG5ldyBNYXAoW1t7Zm9vOiAxfSwgJ2JhciddLCBbJ2tleScsICd2YWx1ZSddXSksIFt7b25lOiAndHdvJ30sICdleGFtcGxlJ10pO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQWxsS2V5cyhuZXcgU2V0KFt7Zm9vOiAnYmFyJ30sICdhbm90aGVyS2V5J10sIFt7b25lOiAndHdvJ30sICdleGFtcGxlJ10pO1xuICAgKlxuICAgKiBAbmFtZSBkb2VzTm90SGF2ZUFsbEtleXNcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nW119IGtleXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRvZXNOb3RIYXZlQWxsS2V5cyA9IGZ1bmN0aW9uIChvYmosIGtleXMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5kb2VzTm90SGF2ZUFsbEtleXMsIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUuYWxsLmtleXMoa2V5cyk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5oYXNBbnlEZWVwS2V5cyhvYmplY3QsIFtrZXlzXSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGF0IGxlYXN0IG9uZSBvZiB0aGUgYGtleXNgIHByb3ZpZGVkLlxuICAgKiBTaW5jZSBTZXRzIGFuZCBNYXBzIGNhbiBoYXZlIG9iamVjdHMgYXMga2V5cyB5b3UgY2FuIHVzZSB0aGlzIGFzc2VydGlvbiB0byBwZXJmb3JtXG4gICAqIGEgZGVlcCBjb21wYXJpc29uLlxuICAgKiBZb3UgY2FuIGFsc28gcHJvdmlkZSBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCBvZiBhIGBrZXlzYCBhcnJheSBhbmQgaXRzIGtleXNcbiAgICogd2lsbCBiZSB1c2VkIGFzIHRoZSBleHBlY3RlZCBzZXQgb2Yga2V5cy5cbiAgICpcbiAgICogICAgIGFzc2VydC5oYXNBbnlEZWVwS2V5cyhuZXcgTWFwKFtbe29uZTogJ29uZSd9LCAndmFsdWVPbmUnXSwgWzEsIDJdXSksIHtvbmU6ICdvbmUnfSk7XG4gICAqICAgICBhc3NlcnQuaGFzQW55RGVlcEtleXMobmV3IE1hcChbW3tvbmU6ICdvbmUnfSwgJ3ZhbHVlT25lJ10sIFsxLCAyXV0pLCBbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKTtcbiAgICogICAgIGFzc2VydC5oYXNBbnlEZWVwS2V5cyhuZXcgTWFwKFtbe29uZTogJ29uZSd9LCAndmFsdWVPbmUnXSwgW3t0d286ICd0d28nfSwgJ3ZhbHVlVHdvJ11dKSwgW3tvbmU6ICdvbmUnfSwge3R3bzogJ3R3byd9XSk7XG4gICAqICAgICBhc3NlcnQuaGFzQW55RGVlcEtleXMobmV3IFNldChbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKSwge29uZTogJ29uZSd9KTtcbiAgICogICAgIGFzc2VydC5oYXNBbnlEZWVwS2V5cyhuZXcgU2V0KFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pLCBbe29uZTogJ29uZSd9LCB7dGhyZWU6ICd0aHJlZSd9XSk7XG4gICAqICAgICBhc3NlcnQuaGFzQW55RGVlcEtleXMobmV3IFNldChbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKSwgW3tvbmU6ICdvbmUnfSwge3R3bzogJ3R3byd9XSk7XG4gICAqXG4gICAqIEBuYW1lIGRvZXNOb3RIYXZlQWxsS2V5c1xuICAgKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGtleXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lmhhc0FueURlZXBLZXlzID0gZnVuY3Rpb24gKG9iaiwga2V5cywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0Lmhhc0FueURlZXBLZXlzLCB0cnVlKVxuICAgICAgLnRvLmhhdmUuYW55LmRlZXAua2V5cyhrZXlzKTtcbiAgfVxuXG4gLyoqXG4gICAqICMjIyAuaGFzQWxsRGVlcEtleXMob2JqZWN0LCBba2V5c10sIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhbGwgYW5kIG9ubHkgYWxsIG9mIHRoZSBga2V5c2AgcHJvdmlkZWQuXG4gICAqIFNpbmNlIFNldHMgYW5kIE1hcHMgY2FuIGhhdmUgb2JqZWN0cyBhcyBrZXlzIHlvdSBjYW4gdXNlIHRoaXMgYXNzZXJ0aW9uIHRvIHBlcmZvcm1cbiAgICogYSBkZWVwIGNvbXBhcmlzb24uXG4gICAqIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGEgYGtleXNgIGFycmF5IGFuZCBpdHMga2V5c1xuICAgKiB3aWxsIGJlIHVzZWQgYXMgdGhlIGV4cGVjdGVkIHNldCBvZiBrZXlzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lmhhc0FsbERlZXBLZXlzKG5ldyBNYXAoW1t7b25lOiAnb25lJ30sICd2YWx1ZU9uZSddXSksIHtvbmU6ICdvbmUnfSk7XG4gICAqICAgICBhc3NlcnQuaGFzQWxsRGVlcEtleXMobmV3IE1hcChbW3tvbmU6ICdvbmUnfSwgJ3ZhbHVlT25lJ10sIFt7dHdvOiAndHdvJ30sICd2YWx1ZVR3byddXSksIFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pO1xuICAgKiAgICAgYXNzZXJ0Lmhhc0FsbERlZXBLZXlzKG5ldyBTZXQoW3tvbmU6ICdvbmUnfV0pLCB7b25lOiAnb25lJ30pO1xuICAgKiAgICAgYXNzZXJ0Lmhhc0FsbERlZXBLZXlzKG5ldyBTZXQoW3tvbmU6ICdvbmUnfSwge3R3bzogJ3R3byd9XSksIFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pO1xuICAgKlxuICAgKiBAbmFtZSBoYXNBbGxEZWVwS2V5c1xuICAgKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGtleXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lmhhc0FsbERlZXBLZXlzID0gZnVuY3Rpb24gKG9iaiwga2V5cywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0Lmhhc0FsbERlZXBLZXlzLCB0cnVlKVxuICAgICAgLnRvLmhhdmUuYWxsLmRlZXAua2V5cyhrZXlzKTtcbiAgfVxuXG4gLyoqXG4gICAqICMjIyAuY29udGFpbnNBbGxEZWVwS2V5cyhvYmplY3QsIFtrZXlzXSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgY29udGFpbnMgYWxsIG9mIHRoZSBga2V5c2AgcHJvdmlkZWQuXG4gICAqIFNpbmNlIFNldHMgYW5kIE1hcHMgY2FuIGhhdmUgb2JqZWN0cyBhcyBrZXlzIHlvdSBjYW4gdXNlIHRoaXMgYXNzZXJ0aW9uIHRvIHBlcmZvcm1cbiAgICogYSBkZWVwIGNvbXBhcmlzb24uXG4gICAqIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGEgYGtleXNgIGFycmF5IGFuZCBpdHMga2V5c1xuICAgKiB3aWxsIGJlIHVzZWQgYXMgdGhlIGV4cGVjdGVkIHNldCBvZiBrZXlzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmNvbnRhaW5zQWxsRGVlcEtleXMobmV3IE1hcChbW3tvbmU6ICdvbmUnfSwgJ3ZhbHVlT25lJ10sIFsxLCAyXV0pLCB7b25lOiAnb25lJ30pO1xuICAgKiAgICAgYXNzZXJ0LmNvbnRhaW5zQWxsRGVlcEtleXMobmV3IE1hcChbW3tvbmU6ICdvbmUnfSwgJ3ZhbHVlT25lJ10sIFt7dHdvOiAndHdvJ30sICd2YWx1ZVR3byddXSksIFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pO1xuICAgKiAgICAgYXNzZXJ0LmNvbnRhaW5zQWxsRGVlcEtleXMobmV3IFNldChbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKSwge29uZTogJ29uZSd9KTtcbiAgICogICAgIGFzc2VydC5jb250YWluc0FsbERlZXBLZXlzKG5ldyBTZXQoW3tvbmU6ICdvbmUnfSwge3R3bzogJ3R3byd9XSksIFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pO1xuICAgKlxuICAgKiBAbmFtZSBjb250YWluc0FsbERlZXBLZXlzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0ga2V5c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuY29udGFpbnNBbGxEZWVwS2V5cyA9IGZ1bmN0aW9uIChvYmosIGtleXMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5jb250YWluc0FsbERlZXBLZXlzLCB0cnVlKVxuICAgICAgLnRvLmNvbnRhaW4uYWxsLmRlZXAua2V5cyhrZXlzKTtcbiAgfVxuXG4gLyoqXG4gICAqICMjIyAuZG9lc05vdEhhdmVBbnlEZWVwS2V5cyhvYmplY3QsIFtrZXlzXSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIG5vbmUgb2YgdGhlIGBrZXlzYCBwcm92aWRlZC5cbiAgICogU2luY2UgU2V0cyBhbmQgTWFwcyBjYW4gaGF2ZSBvYmplY3RzIGFzIGtleXMgeW91IGNhbiB1c2UgdGhpcyBhc3NlcnRpb24gdG8gcGVyZm9ybVxuICAgKiBhIGRlZXAgY29tcGFyaXNvbi5cbiAgICogWW91IGNhbiBhbHNvIHByb3ZpZGUgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQgb2YgYSBga2V5c2AgYXJyYXkgYW5kIGl0cyBrZXlzXG4gICAqIHdpbGwgYmUgdXNlZCBhcyB0aGUgZXhwZWN0ZWQgc2V0IG9mIGtleXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZG9lc05vdEhhdmVBbnlEZWVwS2V5cyhuZXcgTWFwKFtbe29uZTogJ29uZSd9LCAndmFsdWVPbmUnXSwgWzEsIDJdXSksIHt0aGlzRG9lc05vdDogJ2V4aXN0J30pO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQW55RGVlcEtleXMobmV3IE1hcChbW3tvbmU6ICdvbmUnfSwgJ3ZhbHVlT25lJ10sIFt7dHdvOiAndHdvJ30sICd2YWx1ZVR3byddXSksIFt7dHdlbnR5OiAndHdlbnR5J30sIHtmaWZ0eTogJ2ZpZnR5J31dKTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFueURlZXBLZXlzKG5ldyBTZXQoW3tvbmU6ICdvbmUnfSwge3R3bzogJ3R3byd9XSksIHt0d2VudHk6ICd0d2VudHknfSk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdEhhdmVBbnlEZWVwS2V5cyhuZXcgU2V0KFt7b25lOiAnb25lJ30sIHt0d286ICd0d28nfV0pLCBbe3R3ZW50eTogJ3R3ZW50eSd9LCB7ZmlmdHk6ICdmaWZ0eSd9XSk7XG4gICAqXG4gICAqIEBuYW1lIGRvZXNOb3RIYXZlQW55RGVlcEtleXNcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBrZXlzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kb2VzTm90SGF2ZUFueURlZXBLZXlzID0gZnVuY3Rpb24gKG9iaiwga2V5cywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LmRvZXNOb3RIYXZlQW55RGVlcEtleXMsIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUuYW55LmRlZXAua2V5cyhrZXlzKTtcbiAgfVxuXG4gLyoqXG4gICAqICMjIyAuZG9lc05vdEhhdmVBbGxEZWVwS2V5cyhvYmplY3QsIFtrZXlzXSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgZG9lcyBub3QgaGF2ZSBhdCBsZWFzdCBvbmUgb2YgdGhlIGBrZXlzYCBwcm92aWRlZC5cbiAgICogU2luY2UgU2V0cyBhbmQgTWFwcyBjYW4gaGF2ZSBvYmplY3RzIGFzIGtleXMgeW91IGNhbiB1c2UgdGhpcyBhc3NlcnRpb24gdG8gcGVyZm9ybVxuICAgKiBhIGRlZXAgY29tcGFyaXNvbi5cbiAgICogWW91IGNhbiBhbHNvIHByb3ZpZGUgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQgb2YgYSBga2V5c2AgYXJyYXkgYW5kIGl0cyBrZXlzXG4gICAqIHdpbGwgYmUgdXNlZCBhcyB0aGUgZXhwZWN0ZWQgc2V0IG9mIGtleXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZG9lc05vdEhhdmVBbGxEZWVwS2V5cyhuZXcgTWFwKFtbe29uZTogJ29uZSd9LCAndmFsdWVPbmUnXSwgWzEsIDJdXSksIHt0aGlzRG9lc05vdDogJ2V4aXN0J30pO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQWxsRGVlcEtleXMobmV3IE1hcChbW3tvbmU6ICdvbmUnfSwgJ3ZhbHVlT25lJ10sIFt7dHdvOiAndHdvJ30sICd2YWx1ZVR3byddXSksIFt7dHdlbnR5OiAndHdlbnR5J30sIHtvbmU6ICdvbmUnfV0pO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RIYXZlQWxsRGVlcEtleXMobmV3IFNldChbe29uZTogJ29uZSd9LCB7dHdvOiAndHdvJ31dKSwge3R3ZW50eTogJ3R3ZW50eSd9KTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90SGF2ZUFsbERlZXBLZXlzKG5ldyBTZXQoW3tvbmU6ICdvbmUnfSwge3R3bzogJ3R3byd9XSksIFt7b25lOiAnb25lJ30sIHtmaWZ0eTogJ2ZpZnR5J31dKTtcbiAgICpcbiAgICogQG5hbWUgZG9lc05vdEhhdmVBbGxEZWVwS2V5c1xuICAgKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGtleXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRvZXNOb3RIYXZlQWxsRGVlcEtleXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuZG9lc05vdEhhdmVBbGxEZWVwS2V5cywgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5hbGwuZGVlcC5rZXlzKGtleXMpO1xuICB9XG5cbiAvKipcbiAgICogIyMjIC50aHJvd3MoZm4sIFtlcnJvckxpa2Uvc3RyaW5nL3JlZ2V4cF0sIFtzdHJpbmcvcmVnZXhwXSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBJZiBgZXJyb3JMaWtlYCBpcyBhbiBgRXJyb3JgIGNvbnN0cnVjdG9yLCBhc3NlcnRzIHRoYXQgYGZuYCB3aWxsIHRocm93IGFuIGVycm9yIHRoYXQgaXMgYW5cbiAgICogaW5zdGFuY2Ugb2YgYGVycm9yTGlrZWAuXG4gICAqIElmIGBlcnJvckxpa2VgIGlzIGFuIGBFcnJvcmAgaW5zdGFuY2UsIGFzc2VydHMgdGhhdCB0aGUgZXJyb3IgdGhyb3duIGlzIHRoZSBzYW1lXG4gICAqIGluc3RhbmNlIGFzIGBlcnJvckxpa2VgLlxuICAgKiBJZiBgZXJyTXNnTWF0Y2hlcmAgaXMgcHJvdmlkZWQsIGl0IGFsc28gYXNzZXJ0cyB0aGF0IHRoZSBlcnJvciB0aHJvd24gd2lsbCBoYXZlIGFcbiAgICogbWVzc2FnZSBtYXRjaGluZyBgZXJyTXNnTWF0Y2hlcmAuXG4gICAqXG4gICAqICAgICBhc3NlcnQudGhyb3dzKGZuLCAnRXJyb3IgdGhyb3duIG11c3QgaGF2ZSB0aGlzIG1zZycpO1xuICAgKiAgICAgYXNzZXJ0LnRocm93cyhmbiwgL0Vycm9yIHRocm93biBtdXN0IGhhdmUgYSBtc2cgdGhhdCBtYXRjaGVzIHRoaXMvKTtcbiAgICogICAgIGFzc2VydC50aHJvd3MoZm4sIFJlZmVyZW5jZUVycm9yKTtcbiAgICogICAgIGFzc2VydC50aHJvd3MoZm4sIGVycm9ySW5zdGFuY2UpO1xuICAgKiAgICAgYXNzZXJ0LnRocm93cyhmbiwgUmVmZXJlbmNlRXJyb3IsICdFcnJvciB0aHJvd24gbXVzdCBiZSBhIFJlZmVyZW5jZUVycm9yIGFuZCBoYXZlIHRoaXMgbXNnJyk7XG4gICAqICAgICBhc3NlcnQudGhyb3dzKGZuLCBlcnJvckluc3RhbmNlLCAnRXJyb3IgdGhyb3duIG11c3QgYmUgdGhlIHNhbWUgZXJyb3JJbnN0YW5jZSBhbmQgaGF2ZSB0aGlzIG1zZycpO1xuICAgKiAgICAgYXNzZXJ0LnRocm93cyhmbiwgUmVmZXJlbmNlRXJyb3IsIC9FcnJvciB0aHJvd24gbXVzdCBiZSBhIFJlZmVyZW5jZUVycm9yIGFuZCBtYXRjaCB0aGlzLyk7XG4gICAqICAgICBhc3NlcnQudGhyb3dzKGZuLCBlcnJvckluc3RhbmNlLCAvRXJyb3IgdGhyb3duIG11c3QgYmUgdGhlIHNhbWUgZXJyb3JJbnN0YW5jZSBhbmQgbWF0Y2ggdGhpcy8pO1xuICAgKlxuICAgKiBAbmFtZSB0aHJvd3NcbiAgICogQGFsaWFzIHRocm93XG4gICAqIEBhbGlhcyBUaHJvd1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKiBAcGFyYW0ge0Vycm9yQ29uc3RydWN0b3J8RXJyb3J9IGVycm9yTGlrZVxuICAgKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IGVyck1zZ01hdGNoZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvciNFcnJvcl90eXBlc1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQudGhyb3dzID0gZnVuY3Rpb24gKGZuLCBlcnJvckxpa2UsIGVyck1zZ01hdGNoZXIsIG1zZykge1xuICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIGVycm9yTGlrZSB8fCBlcnJvckxpa2UgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIGVyck1zZ01hdGNoZXIgPSBlcnJvckxpa2U7XG4gICAgICBlcnJvckxpa2UgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBhc3NlcnRFcnIgPSBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC50aHJvd3MsIHRydWUpXG4gICAgICAudG8udGhyb3coZXJyb3JMaWtlLCBlcnJNc2dNYXRjaGVyKTtcbiAgICByZXR1cm4gZmxhZyhhc3NlcnRFcnIsICdvYmplY3QnKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kb2VzTm90VGhyb3coZm4sIFtlcnJvckxpa2Uvc3RyaW5nL3JlZ2V4cF0sIFtzdHJpbmcvcmVnZXhwXSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBJZiBgZXJyb3JMaWtlYCBpcyBhbiBgRXJyb3JgIGNvbnN0cnVjdG9yLCBhc3NlcnRzIHRoYXQgYGZuYCB3aWxsIF9ub3RfIHRocm93IGFuIGVycm9yIHRoYXQgaXMgYW5cbiAgICogaW5zdGFuY2Ugb2YgYGVycm9yTGlrZWAuXG4gICAqIElmIGBlcnJvckxpa2VgIGlzIGFuIGBFcnJvcmAgaW5zdGFuY2UsIGFzc2VydHMgdGhhdCB0aGUgZXJyb3IgdGhyb3duIGlzIF9ub3RfIHRoZSBzYW1lXG4gICAqIGluc3RhbmNlIGFzIGBlcnJvckxpa2VgLlxuICAgKiBJZiBgZXJyTXNnTWF0Y2hlcmAgaXMgcHJvdmlkZWQsIGl0IGFsc28gYXNzZXJ0cyB0aGF0IHRoZSBlcnJvciB0aHJvd24gd2lsbCBfbm90XyBoYXZlIGFcbiAgICogbWVzc2FnZSBtYXRjaGluZyBgZXJyTXNnTWF0Y2hlcmAuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZG9lc05vdFRocm93KGZuLCAnQW55IEVycm9yIHRocm93biBtdXN0IG5vdCBoYXZlIHRoaXMgbWVzc2FnZScpO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RUaHJvdyhmbiwgL0FueSBFcnJvciB0aHJvd24gbXVzdCBub3QgbWF0Y2ggdGhpcy8pO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RUaHJvdyhmbiwgRXJyb3IpO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RUaHJvdyhmbiwgZXJyb3JJbnN0YW5jZSk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdFRocm93KGZuLCBFcnJvciwgJ0Vycm9yIG11c3Qgbm90IGhhdmUgdGhpcyBtZXNzYWdlJyk7XG4gICAqICAgICBhc3NlcnQuZG9lc05vdFRocm93KGZuLCBlcnJvckluc3RhbmNlLCAnRXJyb3IgbXVzdCBub3QgaGF2ZSB0aGlzIG1lc3NhZ2UnKTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90VGhyb3coZm4sIEVycm9yLCAvRXJyb3IgbXVzdCBub3QgbWF0Y2ggdGhpcy8pO1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3RUaHJvdyhmbiwgZXJyb3JJbnN0YW5jZSwgL0Vycm9yIG11c3Qgbm90IG1hdGNoIHRoaXMvKTtcbiAgICpcbiAgICogQG5hbWUgZG9lc05vdFRocm93XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqIEBwYXJhbSB7RXJyb3JDb25zdHJ1Y3Rvcn0gZXJyb3JMaWtlXG4gICAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gZXJyTXNnTWF0Y2hlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yI0Vycm9yX3R5cGVzXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbiAoZm4sIGVycm9yTGlrZSwgZXJyTXNnTWF0Y2hlciwgbXNnKSB7XG4gICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgZXJyb3JMaWtlIHx8IGVycm9yTGlrZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgZXJyTXNnTWF0Y2hlciA9IGVycm9yTGlrZTtcbiAgICAgIGVycm9yTGlrZSA9IG51bGw7XG4gICAgfVxuXG4gICAgbmV3IEFzc2VydGlvbihmbiwgbXNnLCBhc3NlcnQuZG9lc05vdFRocm93LCB0cnVlKVxuICAgICAgLnRvLm5vdC50aHJvdyhlcnJvckxpa2UsIGVyck1zZ01hdGNoZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm9wZXJhdG9yKHZhbDEsIG9wZXJhdG9yLCB2YWwyLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIENvbXBhcmVzIHR3byB2YWx1ZXMgdXNpbmcgYG9wZXJhdG9yYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5vcGVyYXRvcigxLCAnPCcsIDIsICdldmVyeXRoaW5nIGlzIG9rJyk7XG4gICAqICAgICBhc3NlcnQub3BlcmF0b3IoMSwgJz4nLCAyLCAndGhpcyB3aWxsIGZhaWwnKTtcbiAgICpcbiAgICogQG5hbWUgb3BlcmF0b3JcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsMVxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3BlcmF0b3JcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsMlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQub3BlcmF0b3IgPSBmdW5jdGlvbiAodmFsLCBvcGVyYXRvciwgdmFsMiwgbXNnKSB7XG4gICAgdmFyIG9rO1xuICAgIHN3aXRjaChvcGVyYXRvcikge1xuICAgICAgY2FzZSAnPT0nOlxuICAgICAgICBvayA9IHZhbCA9PSB2YWwyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJz09PSc6XG4gICAgICAgIG9rID0gdmFsID09PSB2YWwyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJz4nOlxuICAgICAgICBvayA9IHZhbCA+IHZhbDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnPj0nOlxuICAgICAgICBvayA9IHZhbCA+PSB2YWwyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzwnOlxuICAgICAgICBvayA9IHZhbCA8IHZhbDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnPD0nOlxuICAgICAgICBvayA9IHZhbCA8PSB2YWwyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJyE9JzpcbiAgICAgICAgb2sgPSB2YWwgIT0gdmFsMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICchPT0nOlxuICAgICAgICBvayA9IHZhbCAhPT0gdmFsMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBtc2cgPSBtc2cgPyBtc2cgKyAnOiAnIDogbXNnO1xuICAgICAgICB0aHJvdyBuZXcgY2hhaS5Bc3NlcnRpb25FcnJvcihcbiAgICAgICAgICBtc2cgKyAnSW52YWxpZCBvcGVyYXRvciBcIicgKyBvcGVyYXRvciArICdcIicsXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIGFzc2VydC5vcGVyYXRvclxuICAgICAgICApO1xuICAgIH1cbiAgICB2YXIgdGVzdCA9IG5ldyBBc3NlcnRpb24ob2ssIG1zZywgYXNzZXJ0Lm9wZXJhdG9yLCB0cnVlKTtcbiAgICB0ZXN0LmFzc2VydChcbiAgICAgICAgdHJ1ZSA9PT0gZmxhZyh0ZXN0LCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICcgKyB1dGlsLmluc3BlY3QodmFsKSArICcgdG8gYmUgJyArIG9wZXJhdG9yICsgJyAnICsgdXRpbC5pbnNwZWN0KHZhbDIpXG4gICAgICAsICdleHBlY3RlZCAnICsgdXRpbC5pbnNwZWN0KHZhbCkgKyAnIHRvIG5vdCBiZSAnICsgb3BlcmF0b3IgKyAnICcgKyB1dGlsLmluc3BlY3QodmFsMikgKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5jbG9zZVRvKGFjdHVhbCwgZXhwZWN0ZWQsIGRlbHRhLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGVxdWFsIGBleHBlY3RlZGAsIHRvIHdpdGhpbiBhICsvLSBgZGVsdGFgIHJhbmdlLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmNsb3NlVG8oMS41LCAxLCAwLjUsICdudW1iZXJzIGFyZSBjbG9zZScpO1xuICAgKlxuICAgKiBAbmFtZSBjbG9zZVRvXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhY3R1YWxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuY2xvc2VUbyA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgZGVsdGEsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oYWN0LCBtc2csIGFzc2VydC5jbG9zZVRvLCB0cnVlKS50by5iZS5jbG9zZVRvKGV4cCwgZGVsdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmFwcHJveGltYXRlbHkoYWN0dWFsLCBleHBlY3RlZCwgZGVsdGEsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgYGV4cGVjdGVkYCwgdG8gd2l0aGluIGEgKy8tIGBkZWx0YWAgcmFuZ2UuXG4gICAqXG4gICAqICAgICBhc3NlcnQuYXBwcm94aW1hdGVseSgxLjUsIDEsIDAuNSwgJ251bWJlcnMgYXJlIGNsb3NlJyk7XG4gICAqXG4gICAqIEBuYW1lIGFwcHJveGltYXRlbHlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFjdHVhbFxuICAgKiBAcGFyYW0ge051bWJlcn0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5hcHByb3hpbWF0ZWx5ID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBkZWx0YSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihhY3QsIG1zZywgYXNzZXJ0LmFwcHJveGltYXRlbHksIHRydWUpXG4gICAgICAudG8uYmUuYXBwcm94aW1hdGVseShleHAsIGRlbHRhKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5zYW1lTWVtYmVycyhzZXQxLCBzZXQyLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc2V0MWAgYW5kIGBzZXQyYCBoYXZlIHRoZSBzYW1lIG1lbWJlcnMgaW4gYW55IG9yZGVyLiBVc2VzIGFcbiAgICogc3RyaWN0IGVxdWFsaXR5IGNoZWNrICg9PT0pLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnNhbWVNZW1iZXJzKFsgMSwgMiwgMyBdLCBbIDIsIDEsIDMgXSwgJ3NhbWUgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBzYW1lTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQxXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnNhbWVNZW1iZXJzID0gZnVuY3Rpb24gKHNldDEsIHNldDIsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc2V0MSwgbXNnLCBhc3NlcnQuc2FtZU1lbWJlcnMsIHRydWUpXG4gICAgICAudG8uaGF2ZS5zYW1lLm1lbWJlcnMoc2V0Mik7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5ub3RTYW1lTWVtYmVycyhzZXQxLCBzZXQyLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc2V0MWAgYW5kIGBzZXQyYCBkb24ndCBoYXZlIHRoZSBzYW1lIG1lbWJlcnMgaW4gYW55IG9yZGVyLlxuICAgKiBVc2VzIGEgc3RyaWN0IGVxdWFsaXR5IGNoZWNrICg9PT0pLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdFNhbWVNZW1iZXJzKFsgMSwgMiwgMyBdLCBbIDUsIDEsIDMgXSwgJ25vdCBzYW1lIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgbm90U2FtZU1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MVxuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RTYW1lTWVtYmVycyA9IGZ1bmN0aW9uIChzZXQxLCBzZXQyLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHNldDEsIG1zZywgYXNzZXJ0Lm5vdFNhbWVNZW1iZXJzLCB0cnVlKVxuICAgICAgLnRvLm5vdC5oYXZlLnNhbWUubWVtYmVycyhzZXQyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLnNhbWVEZWVwTWVtYmVycyhzZXQxLCBzZXQyLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc2V0MWAgYW5kIGBzZXQyYCBoYXZlIHRoZSBzYW1lIG1lbWJlcnMgaW4gYW55IG9yZGVyLiBVc2VzIGFcbiAgICogZGVlcCBlcXVhbGl0eSBjaGVjay5cbiAgICpcbiAgICogICAgIGFzc2VydC5zYW1lRGVlcE1lbWJlcnMoWyB7IGE6IDEgfSwgeyBiOiAyIH0sIHsgYzogMyB9IF0sIFt7IGI6IDIgfSwgeyBhOiAxIH0sIHsgYzogMyB9XSwgJ3NhbWUgZGVlcCBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIHNhbWVEZWVwTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQxXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnNhbWVEZWVwTWVtYmVycyA9IGZ1bmN0aW9uIChzZXQxLCBzZXQyLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHNldDEsIG1zZywgYXNzZXJ0LnNhbWVEZWVwTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5oYXZlLnNhbWUuZGVlcC5tZW1iZXJzKHNldDIpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAubm90U2FtZURlZXBNZW1iZXJzKHNldDEsIHNldDIsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzZXQxYCBhbmQgYHNldDJgIGRvbid0IGhhdmUgdGhlIHNhbWUgbWVtYmVycyBpbiBhbnkgb3JkZXIuXG4gICAqIFVzZXMgYSBkZWVwIGVxdWFsaXR5IGNoZWNrLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdFNhbWVEZWVwTWVtYmVycyhbIHsgYTogMSB9LCB7IGI6IDIgfSwgeyBjOiAzIH0gXSwgW3sgYjogMiB9LCB7IGE6IDEgfSwgeyBmOiA1IH1dLCAnbm90IHNhbWUgZGVlcCBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFNhbWVEZWVwTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQxXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdFNhbWVEZWVwTWVtYmVycyA9IGZ1bmN0aW9uIChzZXQxLCBzZXQyLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHNldDEsIG1zZywgYXNzZXJ0Lm5vdFNhbWVEZWVwTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5zYW1lLmRlZXAubWVtYmVycyhzZXQyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLnNhbWVPcmRlcmVkTWVtYmVycyhzZXQxLCBzZXQyLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc2V0MWAgYW5kIGBzZXQyYCBoYXZlIHRoZSBzYW1lIG1lbWJlcnMgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAqIFVzZXMgYSBzdHJpY3QgZXF1YWxpdHkgY2hlY2sgKD09PSkuXG4gICAqXG4gICAqICAgICBhc3NlcnQuc2FtZU9yZGVyZWRNZW1iZXJzKFsgMSwgMiwgMyBdLCBbIDEsIDIsIDMgXSwgJ3NhbWUgb3JkZXJlZCBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIHNhbWVPcmRlcmVkTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQxXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnNhbWVPcmRlcmVkTWVtYmVycyA9IGZ1bmN0aW9uIChzZXQxLCBzZXQyLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHNldDEsIG1zZywgYXNzZXJ0LnNhbWVPcmRlcmVkTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5oYXZlLnNhbWUub3JkZXJlZC5tZW1iZXJzKHNldDIpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAubm90U2FtZU9yZGVyZWRNZW1iZXJzKHNldDEsIHNldDIsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzZXQxYCBhbmQgYHNldDJgIGRvbid0IGhhdmUgdGhlIHNhbWUgbWVtYmVycyBpbiB0aGUgc2FtZVxuICAgKiBvcmRlci4gVXNlcyBhIHN0cmljdCBlcXVhbGl0eSBjaGVjayAoPT09KS5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RTYW1lT3JkZXJlZE1lbWJlcnMoWyAxLCAyLCAzIF0sIFsgMiwgMSwgMyBdLCAnbm90IHNhbWUgb3JkZXJlZCBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFNhbWVPcmRlcmVkTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzZXQxXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdFNhbWVPcmRlcmVkTWVtYmVycyA9IGZ1bmN0aW9uIChzZXQxLCBzZXQyLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHNldDEsIG1zZywgYXNzZXJ0Lm5vdFNhbWVPcmRlcmVkTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5ub3QuaGF2ZS5zYW1lLm9yZGVyZWQubWVtYmVycyhzZXQyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLnNhbWVEZWVwT3JkZXJlZE1lbWJlcnMoc2V0MSwgc2V0MiwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHNldDFgIGFuZCBgc2V0MmAgaGF2ZSB0aGUgc2FtZSBtZW1iZXJzIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgKiBVc2VzIGEgZGVlcCBlcXVhbGl0eSBjaGVjay5cbiAgICpcbiAgICogYXNzZXJ0LnNhbWVEZWVwT3JkZXJlZE1lbWJlcnMoWyB7IGE6IDEgfSwgeyBiOiAyIH0sIHsgYzogMyB9IF0sIFsgeyBhOiAxIH0sIHsgYjogMiB9LCB7IGM6IDMgfSBdLCAnc2FtZSBkZWVwIG9yZGVyZWQgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBzYW1lRGVlcE9yZGVyZWRNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDFcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuc2FtZURlZXBPcmRlcmVkTWVtYmVycyA9IGZ1bmN0aW9uIChzZXQxLCBzZXQyLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHNldDEsIG1zZywgYXNzZXJ0LnNhbWVEZWVwT3JkZXJlZE1lbWJlcnMsIHRydWUpXG4gICAgICAudG8uaGF2ZS5zYW1lLmRlZXAub3JkZXJlZC5tZW1iZXJzKHNldDIpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAubm90U2FtZURlZXBPcmRlcmVkTWVtYmVycyhzZXQxLCBzZXQyLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc2V0MWAgYW5kIGBzZXQyYCBkb24ndCBoYXZlIHRoZSBzYW1lIG1lbWJlcnMgaW4gdGhlIHNhbWVcbiAgICogb3JkZXIuIFVzZXMgYSBkZWVwIGVxdWFsaXR5IGNoZWNrLlxuICAgKlxuICAgKiBhc3NlcnQubm90U2FtZURlZXBPcmRlcmVkTWVtYmVycyhbIHsgYTogMSB9LCB7IGI6IDIgfSwgeyBjOiAzIH0gXSwgWyB7IGE6IDEgfSwgeyBiOiAyIH0sIHsgejogNSB9IF0sICdub3Qgc2FtZSBkZWVwIG9yZGVyZWQgbWVtYmVycycpO1xuICAgKiBhc3NlcnQubm90U2FtZURlZXBPcmRlcmVkTWVtYmVycyhbIHsgYTogMSB9LCB7IGI6IDIgfSwgeyBjOiAzIH0gXSwgWyB7IGI6IDIgfSwgeyBhOiAxIH0sIHsgYzogMyB9IF0sICdub3Qgc2FtZSBkZWVwIG9yZGVyZWQgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBub3RTYW1lRGVlcE9yZGVyZWRNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDFcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90U2FtZURlZXBPcmRlcmVkTWVtYmVycyA9IGZ1bmN0aW9uIChzZXQxLCBzZXQyLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHNldDEsIG1zZywgYXNzZXJ0Lm5vdFNhbWVEZWVwT3JkZXJlZE1lbWJlcnMsIHRydWUpXG4gICAgICAudG8ubm90LmhhdmUuc2FtZS5kZWVwLm9yZGVyZWQubWVtYmVycyhzZXQyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmluY2x1ZGVNZW1iZXJzKHN1cGVyc2V0LCBzdWJzZXQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzdWJzZXRgIGlzIGluY2x1ZGVkIGluIGBzdXBlcnNldGAgaW4gYW55IG9yZGVyLiBVc2VzIGFcbiAgICogc3RyaWN0IGVxdWFsaXR5IGNoZWNrICg9PT0pLiBEdXBsaWNhdGVzIGFyZSBpZ25vcmVkLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGVNZW1iZXJzKFsgMSwgMiwgMyBdLCBbIDIsIDEsIDIgXSwgJ2luY2x1ZGUgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBpbmNsdWRlTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzdXBlcnNldFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdWJzZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmluY2x1ZGVNZW1iZXJzID0gZnVuY3Rpb24gKHN1cGVyc2V0LCBzdWJzZXQsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc3VwZXJzZXQsIG1zZywgYXNzZXJ0LmluY2x1ZGVNZW1iZXJzLCB0cnVlKVxuICAgICAgLnRvLmluY2x1ZGUubWVtYmVycyhzdWJzZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAubm90SW5jbHVkZU1lbWJlcnMoc3VwZXJzZXQsIHN1YnNldCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHN1YnNldGAgaXNuJ3QgaW5jbHVkZWQgaW4gYHN1cGVyc2V0YCBpbiBhbnkgb3JkZXIuIFVzZXMgYVxuICAgKiBzdHJpY3QgZXF1YWxpdHkgY2hlY2sgKD09PSkuIER1cGxpY2F0ZXMgYXJlIGlnbm9yZWQuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90SW5jbHVkZU1lbWJlcnMoWyAxLCAyLCAzIF0sIFsgNSwgMSBdLCAnbm90IGluY2x1ZGUgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBub3RJbmNsdWRlTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzdXBlcnNldFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdWJzZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdEluY2x1ZGVNZW1iZXJzID0gZnVuY3Rpb24gKHN1cGVyc2V0LCBzdWJzZXQsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc3VwZXJzZXQsIG1zZywgYXNzZXJ0Lm5vdEluY2x1ZGVNZW1iZXJzLCB0cnVlKVxuICAgICAgLnRvLm5vdC5pbmNsdWRlLm1lbWJlcnMoc3Vic2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmluY2x1ZGVEZWVwTWVtYmVycyhzdXBlcnNldCwgc3Vic2V0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc3Vic2V0YCBpcyBpbmNsdWRlZCBpbiBgc3VwZXJzZXRgIGluIGFueSBvcmRlci4gVXNlcyBhIGRlZXBcbiAgICogZXF1YWxpdHkgY2hlY2suIER1cGxpY2F0ZXMgYXJlIGlnbm9yZWQuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaW5jbHVkZURlZXBNZW1iZXJzKFsgeyBhOiAxIH0sIHsgYjogMiB9LCB7IGM6IDMgfSBdLCBbIHsgYjogMiB9LCB7IGE6IDEgfSwgeyBiOiAyIH0gXSwgJ2luY2x1ZGUgZGVlcCBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIGluY2x1ZGVEZWVwTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzdXBlcnNldFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdWJzZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmluY2x1ZGVEZWVwTWVtYmVycyA9IGZ1bmN0aW9uIChzdXBlcnNldCwgc3Vic2V0LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHN1cGVyc2V0LCBtc2csIGFzc2VydC5pbmNsdWRlRGVlcE1lbWJlcnMsIHRydWUpXG4gICAgICAudG8uaW5jbHVkZS5kZWVwLm1lbWJlcnMoc3Vic2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLm5vdEluY2x1ZGVEZWVwTWVtYmVycyhzdXBlcnNldCwgc3Vic2V0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc3Vic2V0YCBpc24ndCBpbmNsdWRlZCBpbiBgc3VwZXJzZXRgIGluIGFueSBvcmRlci4gVXNlcyBhXG4gICAqIGRlZXAgZXF1YWxpdHkgY2hlY2suIER1cGxpY2F0ZXMgYXJlIGlnbm9yZWQuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90SW5jbHVkZURlZXBNZW1iZXJzKFsgeyBhOiAxIH0sIHsgYjogMiB9LCB7IGM6IDMgfSBdLCBbIHsgYjogMiB9LCB7IGY6IDUgfSBdLCAnbm90IGluY2x1ZGUgZGVlcCBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdEluY2x1ZGVEZWVwTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzdXBlcnNldFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdWJzZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdEluY2x1ZGVEZWVwTWVtYmVycyA9IGZ1bmN0aW9uIChzdXBlcnNldCwgc3Vic2V0LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHN1cGVyc2V0LCBtc2csIGFzc2VydC5ub3RJbmNsdWRlRGVlcE1lbWJlcnMsIHRydWUpXG4gICAgICAudG8ubm90LmluY2x1ZGUuZGVlcC5tZW1iZXJzKHN1YnNldCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5pbmNsdWRlT3JkZXJlZE1lbWJlcnMoc3VwZXJzZXQsIHN1YnNldCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHN1YnNldGAgaXMgaW5jbHVkZWQgaW4gYHN1cGVyc2V0YCBpbiB0aGUgc2FtZSBvcmRlclxuICAgKiBiZWdpbm5pbmcgd2l0aCB0aGUgZmlyc3QgZWxlbWVudCBpbiBgc3VwZXJzZXRgLiBVc2VzIGEgc3RyaWN0IGVxdWFsaXR5XG4gICAqIGNoZWNrICg9PT0pLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGVPcmRlcmVkTWVtYmVycyhbIDEsIDIsIDMgXSwgWyAxLCAyIF0sICdpbmNsdWRlIG9yZGVyZWQgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBpbmNsdWRlT3JkZXJlZE1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc3VwZXJzZXRcbiAgICogQHBhcmFtIHtBcnJheX0gc3Vic2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pbmNsdWRlT3JkZXJlZE1lbWJlcnMgPSBmdW5jdGlvbiAoc3VwZXJzZXQsIHN1YnNldCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzdXBlcnNldCwgbXNnLCBhc3NlcnQuaW5jbHVkZU9yZGVyZWRNZW1iZXJzLCB0cnVlKVxuICAgICAgLnRvLmluY2x1ZGUub3JkZXJlZC5tZW1iZXJzKHN1YnNldCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5ub3RJbmNsdWRlT3JkZXJlZE1lbWJlcnMoc3VwZXJzZXQsIHN1YnNldCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHN1YnNldGAgaXNuJ3QgaW5jbHVkZWQgaW4gYHN1cGVyc2V0YCBpbiB0aGUgc2FtZSBvcmRlclxuICAgKiBiZWdpbm5pbmcgd2l0aCB0aGUgZmlyc3QgZWxlbWVudCBpbiBgc3VwZXJzZXRgLiBVc2VzIGEgc3RyaWN0IGVxdWFsaXR5XG4gICAqIGNoZWNrICg9PT0pLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdEluY2x1ZGVPcmRlcmVkTWVtYmVycyhbIDEsIDIsIDMgXSwgWyAyLCAxIF0sICdub3QgaW5jbHVkZSBvcmRlcmVkIG1lbWJlcnMnKTtcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlT3JkZXJlZE1lbWJlcnMoWyAxLCAyLCAzIF0sIFsgMiwgMyBdLCAnbm90IGluY2x1ZGUgb3JkZXJlZCBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdEluY2x1ZGVPcmRlcmVkTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzdXBlcnNldFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdWJzZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdEluY2x1ZGVPcmRlcmVkTWVtYmVycyA9IGZ1bmN0aW9uIChzdXBlcnNldCwgc3Vic2V0LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHN1cGVyc2V0LCBtc2csIGFzc2VydC5ub3RJbmNsdWRlT3JkZXJlZE1lbWJlcnMsIHRydWUpXG4gICAgICAudG8ubm90LmluY2x1ZGUub3JkZXJlZC5tZW1iZXJzKHN1YnNldCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5pbmNsdWRlRGVlcE9yZGVyZWRNZW1iZXJzKHN1cGVyc2V0LCBzdWJzZXQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzdWJzZXRgIGlzIGluY2x1ZGVkIGluIGBzdXBlcnNldGAgaW4gdGhlIHNhbWUgb3JkZXJcbiAgICogYmVnaW5uaW5nIHdpdGggdGhlIGZpcnN0IGVsZW1lbnQgaW4gYHN1cGVyc2V0YC4gVXNlcyBhIGRlZXAgZXF1YWxpdHlcbiAgICogY2hlY2suXG4gICAqXG4gICAqICAgICBhc3NlcnQuaW5jbHVkZURlZXBPcmRlcmVkTWVtYmVycyhbIHsgYTogMSB9LCB7IGI6IDIgfSwgeyBjOiAzIH0gXSwgWyB7IGE6IDEgfSwgeyBiOiAyIH0gXSwgJ2luY2x1ZGUgZGVlcCBvcmRlcmVkIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgaW5jbHVkZURlZXBPcmRlcmVkTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzdXBlcnNldFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdWJzZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmluY2x1ZGVEZWVwT3JkZXJlZE1lbWJlcnMgPSBmdW5jdGlvbiAoc3VwZXJzZXQsIHN1YnNldCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzdXBlcnNldCwgbXNnLCBhc3NlcnQuaW5jbHVkZURlZXBPcmRlcmVkTWVtYmVycywgdHJ1ZSlcbiAgICAgIC50by5pbmNsdWRlLmRlZXAub3JkZXJlZC5tZW1iZXJzKHN1YnNldCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5ub3RJbmNsdWRlRGVlcE9yZGVyZWRNZW1iZXJzKHN1cGVyc2V0LCBzdWJzZXQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzdWJzZXRgIGlzbid0IGluY2x1ZGVkIGluIGBzdXBlcnNldGAgaW4gdGhlIHNhbWUgb3JkZXJcbiAgICogYmVnaW5uaW5nIHdpdGggdGhlIGZpcnN0IGVsZW1lbnQgaW4gYHN1cGVyc2V0YC4gVXNlcyBhIGRlZXAgZXF1YWxpdHlcbiAgICogY2hlY2suXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90SW5jbHVkZURlZXBPcmRlcmVkTWVtYmVycyhbIHsgYTogMSB9LCB7IGI6IDIgfSwgeyBjOiAzIH0gXSwgWyB7IGE6IDEgfSwgeyBmOiA1IH0gXSwgJ25vdCBpbmNsdWRlIGRlZXAgb3JkZXJlZCBtZW1iZXJzJyk7XG4gICAqICAgICBhc3NlcnQubm90SW5jbHVkZURlZXBPcmRlcmVkTWVtYmVycyhbIHsgYTogMSB9LCB7IGI6IDIgfSwgeyBjOiAzIH0gXSwgWyB7IGI6IDIgfSwgeyBhOiAxIH0gXSwgJ25vdCBpbmNsdWRlIGRlZXAgb3JkZXJlZCBtZW1iZXJzJyk7XG4gICAqICAgICBhc3NlcnQubm90SW5jbHVkZURlZXBPcmRlcmVkTWVtYmVycyhbIHsgYTogMSB9LCB7IGI6IDIgfSwgeyBjOiAzIH0gXSwgWyB7IGI6IDIgfSwgeyBjOiAzIH0gXSwgJ25vdCBpbmNsdWRlIGRlZXAgb3JkZXJlZCBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdEluY2x1ZGVEZWVwT3JkZXJlZE1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc3VwZXJzZXRcbiAgICogQHBhcmFtIHtBcnJheX0gc3Vic2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RJbmNsdWRlRGVlcE9yZGVyZWRNZW1iZXJzID0gZnVuY3Rpb24gKHN1cGVyc2V0LCBzdWJzZXQsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc3VwZXJzZXQsIG1zZywgYXNzZXJ0Lm5vdEluY2x1ZGVEZWVwT3JkZXJlZE1lbWJlcnMsIHRydWUpXG4gICAgICAudG8ubm90LmluY2x1ZGUuZGVlcC5vcmRlcmVkLm1lbWJlcnMoc3Vic2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLm9uZU9mKGluTGlzdCwgbGlzdCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgbm9uLW9iamVjdCwgbm9uLWFycmF5IHZhbHVlIGBpbkxpc3RgIGFwcGVhcnMgaW4gdGhlIGZsYXQgYXJyYXkgYGxpc3RgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm9uZU9mKDEsIFsgMiwgMSBdLCAnTm90IGZvdW5kIGluIGxpc3QnKTtcbiAgICpcbiAgICogQG5hbWUgb25lT2ZcbiAgICogQHBhcmFtIHsqfSBpbkxpc3RcbiAgICogQHBhcmFtIHtBcnJheTwqPn0gbGlzdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQub25lT2YgPSBmdW5jdGlvbiAoaW5MaXN0LCBsaXN0LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGluTGlzdCwgbXNnLCBhc3NlcnQub25lT2YsIHRydWUpLnRvLmJlLm9uZU9mKGxpc3QpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuY2hhbmdlcyhmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBjaGFuZ2VzIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5LlxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgPSAyMiB9O1xuICAgKiAgICAgYXNzZXJ0LmNoYW5nZXMoZm4sIG9iaiwgJ3ZhbCcpO1xuICAgKlxuICAgKiBAbmFtZSBjaGFuZ2VzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3Qgb3IgZ2V0dGVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuY2hhbmdlcyA9IGZ1bmN0aW9uIChmbiwgb2JqLCBwcm9wLCBtc2cpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBtc2cgPSBwcm9wO1xuICAgICAgcHJvcCA9IG51bGw7XG4gICAgfVxuXG4gICAgbmV3IEFzc2VydGlvbihmbiwgbXNnLCBhc3NlcnQuY2hhbmdlcywgdHJ1ZSkudG8uY2hhbmdlKG9iaiwgcHJvcCk7XG4gIH1cblxuICAgLyoqXG4gICAqICMjIyAuY2hhbmdlc0J5KGZ1bmN0aW9uLCBvYmplY3QsIHByb3BlcnR5LCBkZWx0YSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBjaGFuZ2VzIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGJ5IGFuIGFtb3VudCAoZGVsdGEpLlxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgKz0gMiB9O1xuICAgKiAgICAgYXNzZXJ0LmNoYW5nZXNCeShmbiwgb2JqLCAndmFsJywgMik7XG4gICAqXG4gICAqIEBuYW1lIGNoYW5nZXNCeVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RpZmllciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IG9yIGdldHRlciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZSBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFuZ2UgYW1vdW50IChkZWx0YSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuY2hhbmdlc0J5ID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3AsIGRlbHRhLCBtc2cpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCAmJiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgdG1wTXNnID0gZGVsdGE7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBtc2cgPSB0bXBNc2c7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBkZWx0YSA9IHByb3A7XG4gICAgICBwcm9wID0gbnVsbDtcbiAgICB9XG5cbiAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC5jaGFuZ2VzQnksIHRydWUpXG4gICAgICAudG8uY2hhbmdlKG9iaiwgcHJvcCkuYnkoZGVsdGEpO1xuICB9XG5cbiAgIC8qKlxuICAgKiAjIyMgLmRvZXNOb3RDaGFuZ2UoZnVuY3Rpb24sIG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gZG9lcyBub3QgY2hhbmdlIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5LlxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IGNvbnNvbGUubG9nKCdmb28nKTsgfTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90Q2hhbmdlKGZuLCBvYmosICd2YWwnKTtcbiAgICpcbiAgICogQG5hbWUgZG9lc05vdENoYW5nZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RpZmllciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IG9yIGdldHRlciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZSBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRvZXNOb3RDaGFuZ2UgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbXNnID0gcHJvcDtcbiAgICAgIHByb3AgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC5kb2VzTm90Q2hhbmdlLCB0cnVlKVxuICAgICAgLnRvLm5vdC5jaGFuZ2Uob2JqLCBwcm9wKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmNoYW5nZXNCdXROb3RCeShmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSwgZGVsdGEsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gZG9lcyBub3QgY2hhbmdlIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IG9yIG9mIGEgZnVuY3Rpb24ncyByZXR1cm4gdmFsdWUgYnkgYW4gYW1vdW50IChkZWx0YSlcbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBvYmoudmFsICs9IDEwIH07XG4gICAqICAgICBhc3NlcnQuY2hhbmdlc0J1dE5vdEJ5KGZuLCBvYmosICd2YWwnLCA1KTtcbiAgICpcbiAgICogQG5hbWUgY2hhbmdlc0J1dE5vdEJ5XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3Qgb3IgZ2V0dGVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYW5nZSBhbW91bnQgKGRlbHRhKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5jaGFuZ2VzQnV0Tm90QnkgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCwgZGVsdGEsIG1zZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0ICYmIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciB0bXBNc2cgPSBkZWx0YTtcbiAgICAgIGRlbHRhID0gcHJvcDtcbiAgICAgIG1zZyA9IHRtcE1zZztcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGRlbHRhID0gcHJvcDtcbiAgICAgIHByb3AgPSBudWxsO1xuICAgIH1cblxuICAgIG5ldyBBc3NlcnRpb24oZm4sIG1zZywgYXNzZXJ0LmNoYW5nZXNCdXROb3RCeSwgdHJ1ZSlcbiAgICAgIC50by5jaGFuZ2Uob2JqLCBwcm9wKS5idXQubm90LmJ5KGRlbHRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmluY3JlYXNlcyhmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBpbmNyZWFzZXMgYSBudW1lcmljIG9iamVjdCBwcm9wZXJ0eS5cbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBvYmoudmFsID0gMTMgfTtcbiAgICogICAgIGFzc2VydC5pbmNyZWFzZXMoZm4sIG9iaiwgJ3ZhbCcpO1xuICAgKlxuICAgKiBAbmFtZSBpbmNyZWFzZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvciBnZXR0ZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pbmNyZWFzZXMgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbXNnID0gcHJvcDtcbiAgICAgIHByb3AgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC5pbmNyZWFzZXMsIHRydWUpXG4gICAgICAudG8uaW5jcmVhc2Uob2JqLCBwcm9wKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmluY3JlYXNlc0J5KGZ1bmN0aW9uLCBvYmplY3QsIHByb3BlcnR5LCBkZWx0YSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBpbmNyZWFzZXMgYSBudW1lcmljIG9iamVjdCBwcm9wZXJ0eSBvciBhIGZ1bmN0aW9uJ3MgcmV0dXJuIHZhbHVlIGJ5IGFuIGFtb3VudCAoZGVsdGEpLlxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgKz0gMTAgfTtcbiAgICogICAgIGFzc2VydC5pbmNyZWFzZXNCeShmbiwgb2JqLCAndmFsJywgMTApO1xuICAgKlxuICAgKiBAbmFtZSBpbmNyZWFzZXNCeVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RpZmllciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IG9yIGdldHRlciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZSBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFuZ2UgYW1vdW50IChkZWx0YSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaW5jcmVhc2VzQnkgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCwgZGVsdGEsIG1zZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0ICYmIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciB0bXBNc2cgPSBkZWx0YTtcbiAgICAgIGRlbHRhID0gcHJvcDtcbiAgICAgIG1zZyA9IHRtcE1zZztcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGRlbHRhID0gcHJvcDtcbiAgICAgIHByb3AgPSBudWxsO1xuICAgIH1cblxuICAgIG5ldyBBc3NlcnRpb24oZm4sIG1zZywgYXNzZXJ0LmluY3JlYXNlc0J5LCB0cnVlKVxuICAgICAgLnRvLmluY3JlYXNlKG9iaiwgcHJvcCkuYnkoZGVsdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuZG9lc05vdEluY3JlYXNlKGZ1bmN0aW9uLCBvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGRvZXMgbm90IGluY3JlYXNlIGEgbnVtZXJpYyBvYmplY3QgcHJvcGVydHkuXG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgb2JqLnZhbCA9IDggfTtcbiAgICogICAgIGFzc2VydC5kb2VzTm90SW5jcmVhc2UoZm4sIG9iaiwgJ3ZhbCcpO1xuICAgKlxuICAgKiBAbmFtZSBkb2VzTm90SW5jcmVhc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kaWZpZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvciBnZXR0ZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IG5hbWUgX29wdGlvbmFsX1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kb2VzTm90SW5jcmVhc2UgPSBmdW5jdGlvbiAoZm4sIG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbXNnID0gcHJvcDtcbiAgICAgIHByb3AgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKGZuLCBtc2csIGFzc2VydC5kb2VzTm90SW5jcmVhc2UsIHRydWUpXG4gICAgICAudG8ubm90LmluY3JlYXNlKG9iaiwgcHJvcCk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5pbmNyZWFzZXNCdXROb3RCeShmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBkb2VzIG5vdCBpbmNyZWFzZSBhIG51bWVyaWMgb2JqZWN0IHByb3BlcnR5IG9yIGZ1bmN0aW9uJ3MgcmV0dXJuIHZhbHVlIGJ5IGFuIGFtb3VudCAoZGVsdGEpLlxuICAgKlxuICAgKiAgICAgdmFyIG9iaiA9IHsgdmFsOiAxMCB9O1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7IG9iai52YWwgPSAxNSB9O1xuICAgKiAgICAgYXNzZXJ0LmluY3JlYXNlc0J1dE5vdEJ5KGZuLCBvYmosICd2YWwnLCAxMCk7XG4gICAqXG4gICAqIEBuYW1lIGluY3JlYXNlc0J1dE5vdEJ5XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3Qgb3IgZ2V0dGVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYW5nZSBhbW91bnQgKGRlbHRhKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pbmNyZWFzZXNCdXROb3RCeSA9IGZ1bmN0aW9uIChmbiwgb2JqLCBwcm9wLCBkZWx0YSwgbXNnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQgJiYgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHRtcE1zZyA9IGRlbHRhO1xuICAgICAgZGVsdGEgPSBwcm9wO1xuICAgICAgbXNnID0gdG1wTXNnO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgZGVsdGEgPSBwcm9wO1xuICAgICAgcHJvcCA9IG51bGw7XG4gICAgfVxuXG4gICAgbmV3IEFzc2VydGlvbihmbiwgbXNnLCBhc3NlcnQuaW5jcmVhc2VzQnV0Tm90QnksIHRydWUpXG4gICAgICAudG8uaW5jcmVhc2Uob2JqLCBwcm9wKS5idXQubm90LmJ5KGRlbHRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmRlY3JlYXNlcyhmdW5jdGlvbiwgb2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBkZWNyZWFzZXMgYSBudW1lcmljIG9iamVjdCBwcm9wZXJ0eS5cbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBvYmoudmFsID0gNSB9O1xuICAgKiAgICAgYXNzZXJ0LmRlY3JlYXNlcyhmbiwgb2JqLCAndmFsJyk7XG4gICAqXG4gICAqIEBuYW1lIGRlY3JlYXNlc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RpZmllciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IG9yIGdldHRlciBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgbmFtZSBfb3B0aW9uYWxfXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlY3JlYXNlcyA9IGZ1bmN0aW9uIChmbiwgb2JqLCBwcm9wLCBtc2cpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBtc2cgPSBwcm9wO1xuICAgICAgcHJvcCA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBBc3NlcnRpb24oZm4sIG1zZywgYXNzZXJ0LmRlY3JlYXNlcywgdHJ1ZSlcbiAgICAgIC50by5kZWNyZWFzZShvYmosIHByb3ApO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuZGVjcmVhc2VzQnkoZnVuY3Rpb24sIG9iamVjdCwgcHJvcGVydHksIGRlbHRhLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGRlY3JlYXNlcyBhIG51bWVyaWMgb2JqZWN0IHByb3BlcnR5IG9yIGEgZnVuY3Rpb24ncyByZXR1cm4gdmFsdWUgYnkgYW4gYW1vdW50IChkZWx0YSlcbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBvYmoudmFsIC09IDUgfTtcbiAgICogICAgIGFzc2VydC5kZWNyZWFzZXNCeShmbiwgb2JqLCAndmFsJywgNSk7XG4gICAqXG4gICAqIEBuYW1lIGRlY3JlYXNlc0J5XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3Qgb3IgZ2V0dGVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYW5nZSBhbW91bnQgKGRlbHRhKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kZWNyZWFzZXNCeSA9IGZ1bmN0aW9uIChmbiwgb2JqLCBwcm9wLCBkZWx0YSwgbXNnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQgJiYgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHRtcE1zZyA9IGRlbHRhO1xuICAgICAgZGVsdGEgPSBwcm9wO1xuICAgICAgbXNnID0gdG1wTXNnO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgZGVsdGEgPSBwcm9wO1xuICAgICAgcHJvcCA9IG51bGw7XG4gICAgfVxuXG4gICAgbmV3IEFzc2VydGlvbihmbiwgbXNnLCBhc3NlcnQuZGVjcmVhc2VzQnksIHRydWUpXG4gICAgICAudG8uZGVjcmVhc2Uob2JqLCBwcm9wKS5ieShkZWx0YSk7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5kb2VzTm90RGVjcmVhc2UoZnVuY3Rpb24sIG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGEgZnVuY3Rpb24gZG9lcyBub3QgZGVjcmVhc2VzIGEgbnVtZXJpYyBvYmplY3QgcHJvcGVydHkuXG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgb2JqLnZhbCA9IDE1IH07XG4gICAqICAgICBhc3NlcnQuZG9lc05vdERlY3JlYXNlKGZuLCBvYmosICd2YWwnKTtcbiAgICpcbiAgICogQG5hbWUgZG9lc05vdERlY3JlYXNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3Qgb3IgZ2V0dGVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZG9lc05vdERlY3JlYXNlID0gZnVuY3Rpb24gKGZuLCBvYmosIHByb3AsIG1zZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzICYmIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1zZyA9IHByb3A7XG4gICAgICBwcm9wID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEFzc2VydGlvbihmbiwgbXNnLCBhc3NlcnQuZG9lc05vdERlY3JlYXNlLCB0cnVlKVxuICAgICAgLnRvLm5vdC5kZWNyZWFzZShvYmosIHByb3ApO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuZG9lc05vdERlY3JlYXNlQnkoZnVuY3Rpb24sIG9iamVjdCwgcHJvcGVydHksIGRlbHRhLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBhIGZ1bmN0aW9uIGRvZXMgbm90IGRlY3JlYXNlcyBhIG51bWVyaWMgb2JqZWN0IHByb3BlcnR5IG9yIGEgZnVuY3Rpb24ncyByZXR1cm4gdmFsdWUgYnkgYW4gYW1vdW50IChkZWx0YSlcbiAgICpcbiAgICogICAgIHZhciBvYmogPSB7IHZhbDogMTAgfTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uKCkgeyBvYmoudmFsID0gNSB9O1xuICAgKiAgICAgYXNzZXJ0LmRvZXNOb3REZWNyZWFzZUJ5KGZuLCBvYmosICd2YWwnLCAxKTtcbiAgICpcbiAgICogQG5hbWUgZG9lc05vdERlY3JlYXNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3Qgb3IgZ2V0dGVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYW5nZSBhbW91bnQgKGRlbHRhKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kb2VzTm90RGVjcmVhc2VCeSA9IGZ1bmN0aW9uIChmbiwgb2JqLCBwcm9wLCBkZWx0YSwgbXNnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQgJiYgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHRtcE1zZyA9IGRlbHRhO1xuICAgICAgZGVsdGEgPSBwcm9wO1xuICAgICAgbXNnID0gdG1wTXNnO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgZGVsdGEgPSBwcm9wO1xuICAgICAgcHJvcCA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBBc3NlcnRpb24oZm4sIG1zZywgYXNzZXJ0LmRvZXNOb3REZWNyZWFzZUJ5LCB0cnVlKVxuICAgICAgLnRvLm5vdC5kZWNyZWFzZShvYmosIHByb3ApLmJ5KGRlbHRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLmRlY3JlYXNlc0J1dE5vdEJ5KGZ1bmN0aW9uLCBvYmplY3QsIHByb3BlcnR5LCBkZWx0YSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYSBmdW5jdGlvbiBkb2VzIG5vdCBkZWNyZWFzZXMgYSBudW1lcmljIG9iamVjdCBwcm9wZXJ0eSBvciBhIGZ1bmN0aW9uJ3MgcmV0dXJuIHZhbHVlIGJ5IGFuIGFtb3VudCAoZGVsdGEpXG4gICAqXG4gICAqICAgICB2YXIgb2JqID0geyB2YWw6IDEwIH07XG4gICAqICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgb2JqLnZhbCA9IDUgfTtcbiAgICogICAgIGFzc2VydC5kZWNyZWFzZXNCdXROb3RCeShmbiwgb2JqLCAndmFsJywgMSk7XG4gICAqXG4gICAqIEBuYW1lIGRlY3JlYXNlc0J1dE5vdEJ5XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGlmaWVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3Qgb3IgZ2V0dGVyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBuYW1lIF9vcHRpb25hbF9cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYW5nZSBhbW91bnQgKGRlbHRhKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBuYW1lc3BhY2UgQXNzZXJ0XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kZWNyZWFzZXNCdXROb3RCeSA9IGZ1bmN0aW9uIChmbiwgb2JqLCBwcm9wLCBkZWx0YSwgbXNnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQgJiYgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHRtcE1zZyA9IGRlbHRhO1xuICAgICAgZGVsdGEgPSBwcm9wO1xuICAgICAgbXNnID0gdG1wTXNnO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgZGVsdGEgPSBwcm9wO1xuICAgICAgcHJvcCA9IG51bGw7XG4gICAgfVxuXG4gICAgbmV3IEFzc2VydGlvbihmbiwgbXNnLCBhc3NlcnQuZGVjcmVhc2VzQnV0Tm90QnksIHRydWUpXG4gICAgICAudG8uZGVjcmVhc2Uob2JqLCBwcm9wKS5idXQubm90LmJ5KGRlbHRhKTtcbiAgfVxuXG4gIC8qIVxuICAgKiAjIyMgLmlmRXJyb3Iob2JqZWN0KVxuICAgKlxuICAgKiBBc3NlcnRzIGlmIHZhbHVlIGlzIG5vdCBhIGZhbHNlIHZhbHVlLCBhbmQgdGhyb3dzIGlmIGl0IGlzIGEgdHJ1ZSB2YWx1ZS5cbiAgICogVGhpcyBpcyBhZGRlZCB0byBhbGxvdyBmb3IgY2hhaSB0byBiZSBhIGRyb3AtaW4gcmVwbGFjZW1lbnQgZm9yIE5vZGUnc1xuICAgKiBhc3NlcnQgY2xhc3MuXG4gICAqXG4gICAqICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdJIGFtIGEgY3VzdG9tIGVycm9yJyk7XG4gICAqICAgICBhc3NlcnQuaWZFcnJvcihlcnIpOyAvLyBSZXRocm93cyBlcnIhXG4gICAqXG4gICAqIEBuYW1lIGlmRXJyb3JcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICBpZiAodmFsKSB7XG4gICAgICB0aHJvdyh2YWwpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0V4dGVuc2libGUob2JqZWN0KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaXMgZXh0ZW5zaWJsZSAoY2FuIGhhdmUgbmV3IHByb3BlcnRpZXMgYWRkZWQgdG8gaXQpLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzRXh0ZW5zaWJsZSh7fSk7XG4gICAqXG4gICAqIEBuYW1lIGlzRXh0ZW5zaWJsZVxuICAgKiBAYWxpYXMgZXh0ZW5zaWJsZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzRXh0ZW5zaWJsZSA9IGZ1bmN0aW9uIChvYmosIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2csIGFzc2VydC5pc0V4dGVuc2libGUsIHRydWUpLnRvLmJlLmV4dGVuc2libGU7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RFeHRlbnNpYmxlKG9iamVjdClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIF9ub3RfIGV4dGVuc2libGUuXG4gICAqXG4gICAqICAgICB2YXIgbm9uRXh0ZW5zaWJsZU9iamVjdCA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSk7XG4gICAqICAgICB2YXIgc2VhbGVkT2JqZWN0ID0gT2JqZWN0LnNlYWwoe30pO1xuICAgKiAgICAgdmFyIGZyb3plbk9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzTm90RXh0ZW5zaWJsZShub25FeHRlbnNpYmxlT2JqZWN0KTtcbiAgICogICAgIGFzc2VydC5pc05vdEV4dGVuc2libGUoc2VhbGVkT2JqZWN0KTtcbiAgICogICAgIGFzc2VydC5pc05vdEV4dGVuc2libGUoZnJvemVuT2JqZWN0KTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RFeHRlbnNpYmxlXG4gICAqIEBhbGlhcyBub3RFeHRlbnNpYmxlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RFeHRlbnNpYmxlID0gZnVuY3Rpb24gKG9iaiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LmlzTm90RXh0ZW5zaWJsZSwgdHJ1ZSkudG8ubm90LmJlLmV4dGVuc2libGU7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNTZWFsZWQob2JqZWN0KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaXMgc2VhbGVkIChjYW5ub3QgaGF2ZSBuZXcgcHJvcGVydGllcyBhZGRlZCB0byBpdFxuICAgKiBhbmQgaXRzIGV4aXN0aW5nIHByb3BlcnRpZXMgY2Fubm90IGJlIHJlbW92ZWQpLlxuICAgKlxuICAgKiAgICAgdmFyIHNlYWxlZE9iamVjdCA9IE9iamVjdC5zZWFsKHt9KTtcbiAgICogICAgIHZhciBmcm96ZW5PYmplY3QgPSBPYmplY3Quc2VhbCh7fSk7XG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNTZWFsZWQoc2VhbGVkT2JqZWN0KTtcbiAgICogICAgIGFzc2VydC5pc1NlYWxlZChmcm96ZW5PYmplY3QpO1xuICAgKlxuICAgKiBAbmFtZSBpc1NlYWxlZFxuICAgKiBAYWxpYXMgc2VhbGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNTZWFsZWQgPSBmdW5jdGlvbiAob2JqLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuaXNTZWFsZWQsIHRydWUpLnRvLmJlLnNlYWxlZDtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdFNlYWxlZChvYmplY3QpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBpcyBfbm90XyBzZWFsZWQuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNOb3RTZWFsZWQoe30pO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdFNlYWxlZFxuICAgKiBAYWxpYXMgbm90U2VhbGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RTZWFsZWQgPSBmdW5jdGlvbiAob2JqLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnLCBhc3NlcnQuaXNOb3RTZWFsZWQsIHRydWUpLnRvLm5vdC5iZS5zZWFsZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNGcm96ZW4ob2JqZWN0KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaXMgZnJvemVuIChjYW5ub3QgaGF2ZSBuZXcgcHJvcGVydGllcyBhZGRlZCB0byBpdFxuICAgKiBhbmQgaXRzIGV4aXN0aW5nIHByb3BlcnRpZXMgY2Fubm90IGJlIG1vZGlmaWVkKS5cbiAgICpcbiAgICogICAgIHZhciBmcm96ZW5PYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcbiAgICogICAgIGFzc2VydC5mcm96ZW4oZnJvemVuT2JqZWN0KTtcbiAgICpcbiAgICogQG5hbWUgaXNGcm96ZW5cbiAgICogQGFsaWFzIGZyb3plblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzRnJvemVuID0gZnVuY3Rpb24gKG9iaiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LmlzRnJvemVuLCB0cnVlKS50by5iZS5mcm96ZW47XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RGcm96ZW4ob2JqZWN0KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaXMgX25vdF8gZnJvemVuLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzTm90RnJvemVuKHt9KTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RGcm96ZW5cbiAgICogQGFsaWFzIG5vdEZyb3plblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90RnJvemVuID0gZnVuY3Rpb24gKG9iaiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZywgYXNzZXJ0LmlzTm90RnJvemVuLCB0cnVlKS50by5ub3QuYmUuZnJvemVuO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzRW1wdHkodGFyZ2V0KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBkb2VzIG5vdCBjb250YWluIGFueSB2YWx1ZXMuXG4gICAqIEZvciBhcnJheXMgYW5kIHN0cmluZ3MsIGl0IGNoZWNrcyB0aGUgYGxlbmd0aGAgcHJvcGVydHkuXG4gICAqIEZvciBgTWFwYCBhbmQgYFNldGAgaW5zdGFuY2VzLCBpdCBjaGVja3MgdGhlIGBzaXplYCBwcm9wZXJ0eS5cbiAgICogRm9yIG5vbi1mdW5jdGlvbiBvYmplY3RzLCBpdCBnZXRzIHRoZSBjb3VudCBvZiBvd25cbiAgICogZW51bWVyYWJsZSBzdHJpbmcga2V5cy5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc0VtcHR5KFtdKTtcbiAgICogICAgIGFzc2VydC5pc0VtcHR5KCcnKTtcbiAgICogICAgIGFzc2VydC5pc0VtcHR5KG5ldyBNYXApO1xuICAgKiAgICAgYXNzZXJ0LmlzRW1wdHkoe30pO1xuICAgKlxuICAgKiBAbmFtZSBpc0VtcHR5XG4gICAqIEBhbGlhcyBlbXB0eVxuICAgKiBAcGFyYW0ge09iamVjdHxBcnJheXxTdHJpbmd8TWFwfFNldH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQG5hbWVzcGFjZSBBc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzRW1wdHkgPSBmdW5jdGlvbih2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2csIGFzc2VydC5pc0VtcHR5LCB0cnVlKS50by5iZS5lbXB0eTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdEVtcHR5KHRhcmdldClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgY29udGFpbnMgdmFsdWVzLlxuICAgKiBGb3IgYXJyYXlzIGFuZCBzdHJpbmdzLCBpdCBjaGVja3MgdGhlIGBsZW5ndGhgIHByb3BlcnR5LlxuICAgKiBGb3IgYE1hcGAgYW5kIGBTZXRgIGluc3RhbmNlcywgaXQgY2hlY2tzIHRoZSBgc2l6ZWAgcHJvcGVydHkuXG4gICAqIEZvciBub24tZnVuY3Rpb24gb2JqZWN0cywgaXQgZ2V0cyB0aGUgY291bnQgb2Ygb3duXG4gICAqIGVudW1lcmFibGUgc3RyaW5nIGtleXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNOb3RFbXB0eShbMSwgMl0pO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90RW1wdHkoJzM0Jyk7XG4gICAqICAgICBhc3NlcnQuaXNOb3RFbXB0eShuZXcgU2V0KFs1LCA2XSkpO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90RW1wdHkoeyBrZXk6IDcgfSk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90RW1wdHlcbiAgICogQGFsaWFzIG5vdEVtcHR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fFN0cmluZ3xNYXB8U2V0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAbmFtZXNwYWNlIEFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RFbXB0eSA9IGZ1bmN0aW9uKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZywgYXNzZXJ0LmlzTm90RW1wdHksIHRydWUpLnRvLm5vdC5iZS5lbXB0eTtcbiAgfTtcblxuICAvKiFcbiAgICogQWxpYXNlcy5cbiAgICovXG5cbiAgKGZ1bmN0aW9uIGFsaWFzKG5hbWUsIGFzKXtcbiAgICBhc3NlcnRbYXNdID0gYXNzZXJ0W25hbWVdO1xuICAgIHJldHVybiBhbGlhcztcbiAgfSlcbiAgKCdpc09rJywgJ29rJylcbiAgKCdpc05vdE9rJywgJ25vdE9rJylcbiAgKCd0aHJvd3MnLCAndGhyb3cnKVxuICAoJ3Rocm93cycsICdUaHJvdycpXG4gICgnaXNFeHRlbnNpYmxlJywgJ2V4dGVuc2libGUnKVxuICAoJ2lzTm90RXh0ZW5zaWJsZScsICdub3RFeHRlbnNpYmxlJylcbiAgKCdpc1NlYWxlZCcsICdzZWFsZWQnKVxuICAoJ2lzTm90U2VhbGVkJywgJ25vdFNlYWxlZCcpXG4gICgnaXNGcm96ZW4nLCAnZnJvemVuJylcbiAgKCdpc05vdEZyb3plbicsICdub3RGcm96ZW4nKVxuICAoJ2lzRW1wdHknLCAnZW1wdHknKVxuICAoJ2lzTm90RW1wdHknLCAnbm90RW1wdHknKTtcbn07XG4iLCIvKiFcbiAqIGNoYWlcbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgdXNlZCA9IFtdO1xuXG4vKiFcbiAqIENoYWkgdmVyc2lvblxuICovXG5cbmV4cG9ydHMudmVyc2lvbiA9ICc0LjIuMCc7XG5cbi8qIVxuICogQXNzZXJ0aW9uIEVycm9yXG4gKi9cblxuZXhwb3J0cy5Bc3NlcnRpb25FcnJvciA9IHJlcXVpcmUoJ2Fzc2VydGlvbi1lcnJvcicpO1xuXG4vKiFcbiAqIFV0aWxzIGZvciBwbHVnaW5zIChub3QgZXhwb3J0ZWQpXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL2NoYWkvdXRpbHMnKTtcblxuLyoqXG4gKiAjIC51c2UoZnVuY3Rpb24pXG4gKlxuICogUHJvdmlkZXMgYSB3YXkgdG8gZXh0ZW5kIHRoZSBpbnRlcm5hbHMgb2YgQ2hhaS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufVxuICogQHJldHVybnMge3RoaXN9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnVzZSA9IGZ1bmN0aW9uIChmbikge1xuICBpZiAoIX51c2VkLmluZGV4T2YoZm4pKSB7XG4gICAgZm4oZXhwb3J0cywgdXRpbCk7XG4gICAgdXNlZC5wdXNoKGZuKTtcbiAgfVxuXG4gIHJldHVybiBleHBvcnRzO1xufTtcblxuLyohXG4gKiBVdGlsaXR5IEZ1bmN0aW9uc1xuICovXG5cbmV4cG9ydHMudXRpbCA9IHV0aWw7XG5cbi8qIVxuICogQ29uZmlndXJhdGlvblxuICovXG5cbnZhciBjb25maWcgPSByZXF1aXJlKCcuL2NoYWkvY29uZmlnJyk7XG5leHBvcnRzLmNvbmZpZyA9IGNvbmZpZztcblxuLyohXG4gKiBQcmltYXJ5IGBBc3NlcnRpb25gIHByb3RvdHlwZVxuICovXG5cbnZhciBhc3NlcnRpb24gPSByZXF1aXJlKCcuL2NoYWkvYXNzZXJ0aW9uJyk7XG5leHBvcnRzLnVzZShhc3NlcnRpb24pO1xuXG4vKiFcbiAqIENvcmUgQXNzZXJ0aW9uc1xuICovXG5cbnZhciBjb3JlID0gcmVxdWlyZSgnLi9jaGFpL2NvcmUvYXNzZXJ0aW9ucycpO1xuZXhwb3J0cy51c2UoY29yZSk7XG5cbi8qIVxuICogRXhwZWN0IGludGVyZmFjZVxuICovXG5cbnZhciBleHBlY3QgPSByZXF1aXJlKCcuL2NoYWkvaW50ZXJmYWNlL2V4cGVjdCcpO1xuZXhwb3J0cy51c2UoZXhwZWN0KTtcblxuLyohXG4gKiBTaG91bGQgaW50ZXJmYWNlXG4gKi9cblxudmFyIHNob3VsZCA9IHJlcXVpcmUoJy4vY2hhaS9pbnRlcmZhY2Uvc2hvdWxkJyk7XG5leHBvcnRzLnVzZShzaG91bGQpO1xuXG4vKiFcbiAqIEFzc2VydCBpbnRlcmZhY2VcbiAqL1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnLi9jaGFpL2ludGVyZmFjZS9hc3NlcnQnKTtcbmV4cG9ydHMudXNlKGFzc2VydCk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2NoYWknKTtcbiIsIihmdW5jdGlvbihjaGFpRG9tKSB7XG4gIGlmICh0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNoYWlEb21cbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY2hhaURvbVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgY2hhaS51c2UoY2hhaURvbSlcbiAgfVxufShmdW5jdGlvbihjaGFpLCB1dGlscykge1xuICB2YXIgZmxhZyA9IHV0aWxzLmZsYWcsXG5cbiAgZWxUb1N0cmluZyA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgdmFyIGRlc2NcbiAgICBpZiAoaXNOb2RlTGlzdChlbCkpIHtcbiAgICAgIGlmIChlbC5sZW5ndGggPT09IDApIHJldHVybiAnZW1wdHkgTm9kZUxpc3QnXG4gICAgICBkZXNjID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZWwsIDAsIDUpLm1hcChlbFRvU3RyaW5nKS5qb2luKCcsICcpXG4gICAgICByZXR1cm4gZWwubGVuZ3RoID4gNSA/IGRlc2MgKyAnLi4uICgrJyArIChlbC5sZW5ndGggLSA1KSArICcgbW9yZSknIDogZGVzY1xuICAgIH1cbiAgICBpZiAoIWlzSFRNTEVsZW1lbnQoZWwpKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGVsKVxuICAgIH1cblxuICAgIGRlc2MgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZWwuaWQpIHtcbiAgICAgIGRlc2MgKz0gJyMnICsgZWwuaWRcbiAgICB9XG4gICAgaWYgKGVsLmNsYXNzTmFtZSkge1xuICAgICAgZGVzYyArPSAnLicgKyBTdHJpbmcoZWwuY2xhc3NOYW1lKS5yZXBsYWNlKC9cXHMrL2csICcuJylcbiAgICB9XG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChlbC5hdHRyaWJ1dGVzLCBmdW5jdGlvbihhdHRyKSB7XG4gICAgICBpZiAoYXR0ci5uYW1lICE9PSAnY2xhc3MnICYmIGF0dHIubmFtZSAhPT0gJ2lkJykge1xuICAgICAgICBkZXNjICs9ICdbJyArIGF0dHIubmFtZSArIChhdHRyLnZhbHVlID8gJz1cIicgKyBhdHRyLnZhbHVlICsgJ1wiXScgOiAnXScpXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gZGVzY1xuICB9LFxuXG4gIGF0dHJBc3NlcnQgPSBmdW5jdGlvbihuYW1lLCB2YWwpIHtcbiAgICB2YXIgZWwgPSBmbGFnKHRoaXMsICdvYmplY3QnKSwgYWN0dWFsID0gZWwuZ2V0QXR0cmlidXRlKG5hbWUpXG5cbiAgICBpZiAoIWZsYWcodGhpcywgJ25lZ2F0ZScpIHx8IHVuZGVmaW5lZCA9PT0gdmFsKSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgISFlbC5hdHRyaWJ1dGVzW25hbWVdXG4gICAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKGVsKSArICcgdG8gaGF2ZSBhbiBhdHRyaWJ1dGUgI3tleHB9J1xuICAgICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhlbCkgKyAnIG5vdCB0byBoYXZlIGFuIGF0dHJpYnV0ZSAje2V4cH0nXG4gICAgICAgICwgbmFtZVxuICAgICAgKVxuICAgIH1cblxuICAgIGlmICh1bmRlZmluZWQgIT09IHZhbCkge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHZhbCA9PT0gYWN0dWFsXG4gICAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKGVsKSArICcgdG8gaGF2ZSBhbiBhdHRyaWJ1dGUgJyArIHV0aWxzLmluc3BlY3QobmFtZSkgKyAnIHdpdGggdGhlIHZhbHVlICN7ZXhwfSwgYnV0IHRoZSB2YWx1ZSB3YXMgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhlbCkgKyAnIG5vdCB0byBoYXZlIGFuIGF0dHJpYnV0ZSAnICsgdXRpbHMuaW5zcGVjdChuYW1lKSArICcgd2l0aCB0aGUgdmFsdWUgI3thY3R9J1xuICAgICAgICAsIHZhbFxuICAgICAgICAsIGFjdHVhbFxuICAgICAgKVxuICAgIH1cblxuICAgIGZsYWcodGhpcywgJ29iamVjdCcsIGFjdHVhbClcbiAgfSxcblxuICBpc0hUTUxFbGVtZW50ID0gZnVuY3Rpb24oZWwpIHtcbiAgICByZXR1cm4gZWwubm9kZVR5cGUgPT09IDEgLy8gd2luZG93Lk5vZGUuRUxFTUVOVF9OT0RFXG4gIH0sXG5cbiAgaXNOb2RlTGlzdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgTm9kZUxpc3RdJ1xuICB9XG5cbiAgdXRpbHMuZWxUb1N0cmluZyA9IGVsVG9TdHJpbmdcbiAgY2hhaS5Bc3NlcnRpb24uYWRkTWV0aG9kKCdhdHRyJywgYXR0ckFzc2VydClcbiAgY2hhaS5Bc3NlcnRpb24uYWRkTWV0aG9kKCdhdHRyaWJ1dGUnLCBhdHRyQXNzZXJ0KVxuXG4gIGNoYWkuQXNzZXJ0aW9uLmFkZE1ldGhvZCgnY2xhc3MnLCBmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgICB2YXIgZWwgPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSlcbiAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKGVsKSArICcgdG8gaGF2ZSBjbGFzcyAje2V4cH0nXG4gICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhlbCkgKyAnIG5vdCB0byBoYXZlIGNsYXNzICN7ZXhwfSdcbiAgICAgICwgY2xhc3NOYW1lXG4gICAgKVxuICB9KVxuXG4gIGNoYWkuQXNzZXJ0aW9uLmFkZE1ldGhvZCgnaWQnLCBmdW5jdGlvbihpZCkge1xuICAgIHZhciBlbCA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBlbC5pZCA9PSBpZFxuICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcoZWwpICsgJyB0byBoYXZlIGlkICN7ZXhwfSdcbiAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKGVsKSArICcgbm90IHRvIGhhdmUgaWQgI3tleHB9J1xuICAgICAgLCBpZFxuICAgIClcbiAgfSlcblxuICBjaGFpLkFzc2VydGlvbi5hZGRNZXRob2QoJ2h0bWwnLCBmdW5jdGlvbihodG1sKSB7XG4gICAgdmFyIGVsID0gZmxhZyh0aGlzLCAnb2JqZWN0JyksIGFjdHVhbCA9IGZsYWcodGhpcywgJ29iamVjdCcpLmlubmVySFRNTFxuXG4gICAgaWYgKGZsYWcodGhpcywgJ2NvbnRhaW5zJykpIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBhY3R1YWwuaW5kZXhPZihodG1sKSA+PSAwXG4gICAgICAgICwgJ2V4cGVjdGVkICN7YWN0fSB0byBjb250YWluIEhUTUwgI3tleHB9J1xuICAgICAgICAsICdleHBlY3RlZCAje2FjdH0gbm90IHRvIGNvbnRhaW4gSFRNTCAje2V4cH0nXG4gICAgICAgICwgaHRtbFxuICAgICAgICAsIGFjdHVhbFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgYWN0dWFsID09PSBodG1sXG4gICAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKGVsKSArICcgdG8gaGF2ZSBIVE1MICN7ZXhwfSwgYnV0IHRoZSBIVE1MIHdhcyAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKGVsKSArICcgbm90IHRvIGhhdmUgSFRNTCAje2V4cH0nXG4gICAgICAgICwgaHRtbFxuICAgICAgICAsIGFjdHVhbFxuICAgICAgKVxuICAgIH1cbiAgfSlcblxuICBjaGFpLkFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ3RyaW1tZWQnLCBudWxsLCBmdW5jdGlvbigpIHtcbiAgICBmbGFnKHRoaXMsICd0cmltLXRleHQnLCB0cnVlKVxuICB9KVxuXG4gIGNoYWkuQXNzZXJ0aW9uLmFkZE1ldGhvZCgndGV4dCcsIGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JyksIGNvbnRhaW5zID0gZmxhZyh0aGlzLCAnY29udGFpbnMnKSxcbiAgICAgICAgdHJpbSA9IGZsYWcodGhpcywgJ3RyaW0tdGV4dCcpLCBhY3R1YWwsIHJlc3VsdFxuXG4gICAgaWYgKGlzTm9kZUxpc3Qob2JqKSkge1xuICAgICAgYWN0dWFsID0gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKG9iaiwgZnVuY3Rpb24oZWwpIHsgcmV0dXJuIHRyaW0gPyBlbC50ZXh0Q29udGVudC50cmltKCkgOiBlbC50ZXh0Q29udGVudCB9KVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGV4dCkpIHtcbiAgICAgICAgcmVzdWx0ID0gY29udGFpbnMgP1xuICAgICAgICAgIHRleHRbZmxhZyh0aGlzLCAnbmVnYXRlJykgPyAnc29tZScgOiAnZXZlcnknXShmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNvbWUuY2FsbChvYmosIGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgIHJldHVybiAodHJpbSA/IGVsLnRleHRDb250ZW50LnRyaW0oKSA6IGVsLnRleHRDb250ZW50KSA9PT0gdFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIDpcbiAgICAgICAgICB1dGlscy5lcWwoYWN0dWFsLCB0ZXh0KVxuXG4gICAgICAgIGFjdHVhbCA9IGFjdHVhbC5qb2luKClcbiAgICAgICAgdGV4dCA9IHRleHQuam9pbigpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3R1YWwgPSBhY3R1YWwuam9pbignJylcbiAgICAgICAgcmVzdWx0ID0gY29udGFpbnMgPyBhY3R1YWwuaW5kZXhPZih0ZXh0KSA+PSAwIDogYWN0dWFsID09PSB0ZXh0XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjdHVhbCA9IHRyaW0gPyBvYmoudGV4dENvbnRlbnQudHJpbSgpIDogb2JqLnRleHRDb250ZW50XG4gICAgICByZXN1bHQgPSBjb250YWlucyA/IGFjdHVhbC5pbmRleE9mKHRleHQpID49IDAgOiBhY3R1YWwgPT09IHRleHRcbiAgICB9XG5cbiAgICB2YXIgb2JqRGVzYyA9IGVsVG9TdHJpbmcob2JqKSwgdGV4dE1zZyA9IHRyaW0gPyAndHJpbW1lZCB0ZXh0JyA6ICd0ZXh0J1xuICAgIGlmIChjb250YWlucykge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHJlc3VsdFxuICAgICAgICAsICdleHBlY3RlZCAnICsgb2JqRGVzYyArICcgdG8gY29udGFpbiAje2V4cH0sIGJ1dCB0aGUgJyArIHRleHRNc2cgKyAnIHdhcyAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICcgKyBvYmpEZXNjICsgJyBub3QgdG8gY29udGFpbiAje2V4cH0sIGJ1dCB0aGUgJyArIHRleHRNc2cgKyAnIHdhcyAje2FjdH0nXG4gICAgICAgICwgdGV4dFxuICAgICAgICAsIGFjdHVhbFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgcmVzdWx0XG4gICAgICAgICwgJ2V4cGVjdGVkICcgKyBvYmpEZXNjICsgJyB0byBoYXZlICcgKyB0ZXh0TXNnICsgJyAje2V4cH0sIGJ1dCB0aGUgJyArIHRleHRNc2cgKyAnIHdhcyAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICcgKyBvYmpEZXNjICsgJyBub3QgdG8gaGF2ZSAnICsgdGV4dE1zZyArICcgI3tleHB9J1xuICAgICAgICAsIHRleHRcbiAgICAgICAgLCBhY3R1YWxcbiAgICAgIClcbiAgICB9XG4gIH0pXG5cbiAgY2hhaS5Bc3NlcnRpb24uYWRkTWV0aG9kKCd2YWx1ZScsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIGVsID0gZmxhZyh0aGlzLCAnb2JqZWN0JyksIGFjdHVhbCA9IGZsYWcodGhpcywgJ29iamVjdCcpLnZhbHVlXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBmbGFnKHRoaXMsICdvYmplY3QnKS52YWx1ZSA9PT0gdmFsdWVcbiAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKGVsKSArICcgdG8gaGF2ZSB2YWx1ZSAje2V4cH0sIGJ1dCB0aGUgdmFsdWUgd2FzICN7YWN0fSdcbiAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKGVsKSArICcgbm90IHRvIGhhdmUgdmFsdWUgI3tleHB9J1xuICAgICAgLCB2YWx1ZVxuICAgICAgLCBhY3R1YWxcbiAgICApXG4gIH0pXG5cbiAgY2hhaS5Bc3NlcnRpb24ub3ZlcndyaXRlUHJvcGVydHkoJ2V4aXN0JywgZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICBpZiAoaXNOb2RlTGlzdChvYmopKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iai5sZW5ndGggPiAwXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgYW4gZW1wdHkgTm9kZUxpc3QgdG8gaGF2ZSBub2RlcydcbiAgICAgICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhvYmopICsgJyB0byBub3QgZXhpc3QnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgY2hhaS5Bc3NlcnRpb24ub3ZlcndyaXRlUHJvcGVydHkoJ2VtcHR5JywgZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICBpZiAoaXNIVE1MRWxlbWVudChvYmopKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iai5jaGlsZHJlbi5sZW5ndGggPT09IDBcbiAgICAgICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhvYmopICsgJyB0byBiZSBlbXB0eSdcbiAgICAgICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhvYmopICsgJyB0byBub3QgYmUgZW1wdHknKVxuICAgICAgfSBlbHNlIGlmIChpc05vZGVMaXN0KG9iaikpIHtcbiAgICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgb2JqLmxlbmd0aCA9PT0gMFxuICAgICAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKG9iaikgKyAnIHRvIGJlIGVtcHR5J1xuICAgICAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKG9iaikgKyAnIHRvIG5vdCBiZSBlbXB0eScpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICBjaGFpLkFzc2VydGlvbi5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QoJ2xlbmd0aCcsXG4gICAgZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgICBpZiAoaXNOb2RlTGlzdChvYmopIHx8IGlzSFRNTEVsZW1lbnQob2JqKSkge1xuICAgICAgICAgIHZhciBhY3R1YWxMZW5ndGggPSBvYmouY2hpbGRyZW4gPyBvYmouY2hpbGRyZW4ubGVuZ3RoIDogb2JqLmxlbmd0aFxuICAgICAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgICAgICBhY3R1YWxMZW5ndGggPT09IGxlbmd0aFxuICAgICAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcob2JqKSArICcgdG8gaGF2ZSAje2V4cH0gY2hpbGRyZW4gYnV0IGl0IGhhZCAje2FjdH0gY2hpbGRyZW4nXG4gICAgICAgICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhvYmopICsgJyB0byBub3QgaGF2ZSAje2V4cH0gY2hpbGRyZW4nXG4gICAgICAgICAgICAsIGxlbmd0aFxuICAgICAgICAgICAgLCBhY3R1YWxMZW5ndGhcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpXG4gICAgICB9XG4gICAgfVxuICApXG5cblxuICBjaGFpLkFzc2VydGlvbi5vdmVyd3JpdGVNZXRob2QoJ21hdGNoJywgZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgIGlmIChpc0hUTUxFbGVtZW50KG9iaikpIHtcbiAgICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgb2JqLm1hdGNoZXMoc2VsZWN0b3IpXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcob2JqKSArICcgdG8gbWF0Y2ggI3tleHB9J1xuICAgICAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKG9iaikgKyAnIHRvIG5vdCBtYXRjaCAje2V4cH0nXG4gICAgICAgICAgLCBzZWxlY3RvclxuICAgICAgICApXG4gICAgICB9IGVsc2UgaWYgKGlzTm9kZUxpc3Qob2JqKSkge1xuICAgICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICAoISFvYmoubGVuZ3RoICYmIEFycmF5LnByb3RvdHlwZS5ldmVyeS5jYWxsKG9iaiwgZnVuY3Rpb24oZWwpIHsgcmV0dXJuIGVsLm1hdGNoZXMoc2VsZWN0b3IpIH0pKVxuICAgICAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKG9iaikgKyAnIHRvIG1hdGNoICN7ZXhwfSdcbiAgICAgICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhvYmopICsgJyB0byBub3QgbWF0Y2ggI3tleHB9J1xuICAgICAgICAgICwgc2VsZWN0b3JcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgY2hhaS5Bc3NlcnRpb24ub3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kKCdjb250YWluJyxcbiAgICBmdW5jdGlvbihfc3VwZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdWJpdGVtKSB7XG4gICAgICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgICBpZiAoaXNIVE1MRWxlbWVudChvYmopKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzdWJpdGVtID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgICAgICEhb2JqLnF1ZXJ5U2VsZWN0b3Ioc3ViaXRlbSlcbiAgICAgICAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcob2JqKSArICcgdG8gY29udGFpbiAje2V4cH0nXG4gICAgICAgICAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKG9iaikgKyAnIHRvIG5vdCBjb250YWluICN7ZXhwfSdcbiAgICAgICAgICAgICAgLCBzdWJpdGVtKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICAgICAgb2JqLmNvbnRhaW5zKHN1Yml0ZW0pXG4gICAgICAgICAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKG9iaikgKyAnIHRvIGNvbnRhaW4gJyArIGVsVG9TdHJpbmcoc3ViaXRlbSlcbiAgICAgICAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcob2JqKSArICcgdG8gbm90IGNvbnRhaW4gJyArIGVsVG9TdHJpbmcoc3ViaXRlbSkpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGZ1bmN0aW9uKF9zdXBlcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKVxuICAgICAgfVxuICAgIH1cbiAgKVxuXG4gIGNoYWkuQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZGVzY2VuZGFudCcsIGZ1bmN0aW9uKHN1Yml0ZW0pIHtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JyksIGFjdHVhbCA9IHN1Yml0ZW1cblxuICAgIGlmICh0eXBlb2Ygc3ViaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGFjdHVhbCA9IG9iai5xdWVyeVNlbGVjdG9yKHN1Yml0ZW0pXG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgISFhY3R1YWxcbiAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcob2JqKSArICcgdG8gaGF2ZSBkZXNjZW5kYW50ICN7ZXhwfSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcob2JqKSArICcgdG8gbm90IGhhdmUgZGVzY2VuZGFudCAje2V4cH0nXG4gICAgICAgICwgc3ViaXRlbSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIG9iai5jb250YWlucyhzdWJpdGVtKVxuICAgICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhvYmopICsgJyB0byBjb250YWluICcgKyBlbFRvU3RyaW5nKHN1Yml0ZW0pXG4gICAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKG9iaikgKyAnIHRvIG5vdCBjb250YWluICcgKyBlbFRvU3RyaW5nKHN1Yml0ZW0pKVxuICAgIH1cblxuICAgIGZsYWcodGhpcywgJ29iamVjdCcsIGFjdHVhbClcbiAgfSlcblxuICBjaGFpLkFzc2VydGlvbi5hZGRNZXRob2QoJ2Rlc2NlbmRhbnRzJywgZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JyksXG4gICAgICAgIGFjdHVhbCA9IG9iai5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKVxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgISFhY3R1YWwubGVuZ3RoXG4gICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhvYmopICsgJyB0byBoYXZlIGRlc2NlbmRhbnRzICN7ZXhwfSdcbiAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKG9iaikgKyAnIHRvIG5vdCBoYXZlIGRlc2NlbmRhbnRzICN7ZXhwfSdcbiAgICAgICwgc2VsZWN0b3IpXG4gICAgZmxhZyh0aGlzLCAnb2JqZWN0JywgYWN0dWFsKVxuICB9KVxuXG4gIGNoYWkuQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdkaXNwbGF5ZWQnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgZWwgPSBmbGFnKHRoaXMsICdvYmplY3QnKSxcbiAgICAgICAgYWN0dWFsID0gZG9jdW1lbnQuYm9keS5jb250YWlucyhlbCkgPyB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZGlzcGxheSA6IGVsLnN0eWxlLmRpc3BsYXlcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgYWN0dWFsICE9PSAnbm9uZSdcbiAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKGVsKSArICcgdG8gYmUgZGlzcGxheWVkLCBidXQgaXQgd2FzIG5vdCdcbiAgICAgICwgJ2V4cGVjdGVkICcgKyBlbFRvU3RyaW5nKGVsKSArICcgdG8gbm90IGJlIGRpc3BsYXllZCwgYnV0IGl0IHdhcyBhcyAnICsgYWN0dWFsXG4gICAgICAsIGFjdHVhbFxuICAgIClcbiAgfSlcblxuICBjaGFpLkFzc2VydGlvbi5hZGRQcm9wZXJ0eSgndmlzaWJsZScsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBlbCA9IGZsYWcodGhpcywgJ29iamVjdCcpLFxuICAgICAgICBhY3R1YWwgPSBkb2N1bWVudC5ib2R5LmNvbnRhaW5zKGVsKSA/IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKS52aXNpYmlsaXR5IDogZWwuc3R5bGUudmlzaWJpbGl0eVxuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICBhY3R1YWwgIT09ICdoaWRkZW4nICYmIGFjdHVhbCAhPT0gJ2NvbGxhcHNlJ1xuICAgICAgLCAnZXhwZWN0ZWQgJyArIGVsVG9TdHJpbmcoZWwpICsgJyB0byBiZSB2aXNpYmxlLCBidXQgaXQgd2FzICcgKyAoYWN0dWFsID09PSAnaGlkZGVuJyA/ICdoaWRkZW4nIDogJ2NvbGxhcHNlZCcpXG4gICAgICAsICdleHBlY3RlZCAnICsgZWxUb1N0cmluZyhlbCkgKyAnIHRvIG5vdCBiZSB2aXNpYmxlLCBidXQgaXQgd2FzJ1xuICAgICAgLCBhY3R1YWxcbiAgICApXG4gIH0pXG59KSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGNoYWlTdHlsZVxuXG5mdW5jdGlvbiBjaGFpU3R5bGUoY2hhaSwgdXRpbHMpIHtcbiAgY29uc3Qge0Fzc2VydGlvbn0gPSBjaGFpXG4gIGNvbnN0IHtmbGFnfSA9IHV0aWxzXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnc3R5bGUnLCBmdW5jdGlvbihwcm9wZXJ0eSwgdmFsdWUgPSAnJykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudClcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKVxuXG4gICAgY29uc3QgaXNOb25Db2xvcnMgPSBzdHlsZVtwcm9wZXJ0eV0gPT09ICdyZ2JhKDAsIDAsIDAsIDApJyAvLyB3ZWJraXRcbiAgICAgIHx8IHN0eWxlW3Byb3BlcnR5XSA9PT0gJ3RyYW5zcGFyZW50JyAvLyBmaXJlZm94XG5cbiAgICBjb25zdCBwcm9wZXJ0eVZhbHVlID0gaXNOb25Db2xvcnNcbiAgICAgID8gJydcbiAgICAgIDogc3R5bGVbcHJvcGVydHldXG5cbiAgICBjb25zdCBhc3NlcnRpb24gPSB2YWx1ZVxuICAgICAgPyBjb21wYXJlQ1NTVmFsdWUocHJvcGVydHlWYWx1ZSwgdmFsdWUpXG4gICAgICA6IEJvb2xlYW4ocHJvcGVydHlWYWx1ZSlcblxuICAgIGNvbnN0IGVsZW1lbnRUYWcgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKVxuXG4gICAgY29uc3QgdGhyb3dNZXNzYWdlID0gYGV4cGVjdCAke2VsZW1lbnRUYWd9IHRvIGhhdmUgeyR7cHJvcGVydHl9OiAke3ZhbHVlfX0sIGlzIHJlY2VpdmluZyB7JHtwcm9wZXJ0eX06ICR7cHJvcGVydHlWYWx1ZX19YFxuICAgIGNvbnN0IHRocm93TWVzc2FnZU5lZ2F0aXZlID0gYGV4cGVjdCAke2VsZW1lbnRUYWd9IHRvIG5vdCBoYXZlIHske3Byb3BlcnR5fTogJHt2YWx1ZX19LCBpcyByZWNlaXZpbmcgeyR7cHJvcGVydHl9OiAke3Byb3BlcnR5VmFsdWV9fWBcblxuICAgIHRoaXMuYXNzZXJ0KGFzc2VydGlvbiwgdGhyb3dNZXNzYWdlLCB0aHJvd01lc3NhZ2VOZWdhdGl2ZSwgdmFsdWUpXG5cbiAgICBmdW5jdGlvbiBjb21wYXJlQ1NTVmFsdWUoY29tcHV0ZWQsIGV4cGVjdGVkKSB7XG4gICAgICBjb25zdCBwcm9wZXJ0eUhpZmVuQ2FzZSA9IHByb3BlcnR5LnJlcGxhY2UoL1tBLVpdL2csIChtYXRjaCkgPT4gJy0nICsgbWF0Y2gudG9Mb3dlckNhc2UoKSlcbiAgICAgIGNvbnN0IGZha2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgZmFrZS5zdHlsZS5mb250U2l6ZSA9IHN0eWxlLmZvbnRTaXplXG4gICAgICBmYWtlLnN0eWxlLnNldFByb3BlcnR5KHByb3BlcnR5SGlmZW5DYXNlLCBleHBlY3RlZCwgJ2ltcG9ydGFudCcpXG4gICAgICBjb25zdCBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKVxuICAgICAgaWZyYW1lLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJ1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpXG4gICAgICBpZnJhbWUuYXBwZW5kQ2hpbGQoZmFrZSlcbiAgICAgIGNvbnN0IGZha2VTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGZha2UpXG4gICAgICBjb25zdCB2YWx1ZSA9IGZha2VTdHlsZVtwcm9wZXJ0eV1cblxuICAgICAgY29uc3QgaGFzQXV0b1ZhbHVlID0gdmFsdWUuaW5jbHVkZXMoJ2F1dG8nKVxuICAgICAgY29uc3QgcmVnID0gbmV3IFJlZ0V4cChlc2NhcGVSZWdFeHAodmFsdWUpLnJlcGxhY2UoL2F1dG8vZywgJyhcXFxcZCsoLlxcXFxkKyk/cHh8YXV0byknKSlcblxuICAgICAgY29uc3QgY29tcGFyaXNvblJlc3VsdCA9IGhhc0F1dG9WYWx1ZVxuICAgICAgICA/IHJlZy50ZXN0KGNvbXB1dGVkKVxuICAgICAgICA6IGNvbXB1dGVkID09PSB2YWx1ZVxuXG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSlcblxuICAgICAgcmV0dXJuIGNvbXBhcmlzb25SZXN1bHRcbiAgICB9XG4gIH0pXG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZW5qYW1pbmdyL1JlZ0V4cC5lc2NhcGUvYmxvYi9tYXN0ZXIvcG9seWZpbGwuanNcbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cCh2YWx1ZSkge1xuICAgIHJldHVybiBTdHJpbmcodmFsdWUpLnJlcGxhY2UoL1tcXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJylcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbi8qICFcbiAqIHR5cGUtZGV0ZWN0XG4gKiBDb3B5cmlnaHQoYykgMjAxMyBqYWtlIGx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG52YXIgZ2V0UHJvdG90eXBlT2ZFeGlzdHMgPSB0eXBlb2YgT2JqZWN0LmdldFByb3RvdHlwZU9mID09PSAnZnVuY3Rpb24nO1xudmFyIHByb21pc2VFeGlzdHMgPSB0eXBlb2YgUHJvbWlzZSA9PT0gJ2Z1bmN0aW9uJztcbnZhciBnbG9iYWxPYmplY3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogc2VsZjsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxudmFyIGlzRG9tID0gJ2xvY2F0aW9uJyBpbiBnbG9iYWxPYmplY3QgJiYgJ2RvY3VtZW50JyBpbiBnbG9iYWxPYmplY3Q7XG52YXIgaHRtbEVsZW1lbnRFeGlzdHMgPSB0eXBlb2YgSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xudmFyIGlzQXJyYXlFeGlzdHMgPSB0eXBlb2YgQXJyYXkuaXNBcnJheSA9PT0gJ2Z1bmN0aW9uJztcbnZhciBzeW1ib2xFeGlzdHMgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJztcbnZhciBtYXBFeGlzdHMgPSB0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJztcbnZhciBzZXRFeGlzdHMgPSB0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJztcbnZhciB3ZWFrTWFwRXhpc3RzID0gdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnO1xudmFyIHdlYWtTZXRFeGlzdHMgPSB0eXBlb2YgV2Vha1NldCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgZGF0YVZpZXdFeGlzdHMgPSB0eXBlb2YgRGF0YVZpZXcgIT09ICd1bmRlZmluZWQnO1xudmFyIHN5bWJvbEl0ZXJhdG9yRXhpc3RzID0gc3ltYm9sRXhpc3RzICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgIT09ICd1bmRlZmluZWQnO1xudmFyIHN5bWJvbFRvU3RyaW5nVGFnRXhpc3RzID0gc3ltYm9sRXhpc3RzICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgIT09ICd1bmRlZmluZWQnO1xudmFyIHNldEVudHJpZXNFeGlzdHMgPSBzZXRFeGlzdHMgJiYgdHlwZW9mIFNldC5wcm90b3R5cGUuZW50cmllcyA9PT0gJ2Z1bmN0aW9uJztcbnZhciBtYXBFbnRyaWVzRXhpc3RzID0gbWFwRXhpc3RzICYmIHR5cGVvZiBNYXAucHJvdG90eXBlLmVudHJpZXMgPT09ICdmdW5jdGlvbic7XG52YXIgc2V0SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZkV4aXN0cyAmJiBzZXRFbnRyaWVzRXhpc3RzICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgU2V0KCkuZW50cmllcygpKTtcbnZhciBtYXBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mRXhpc3RzICYmIG1hcEVudHJpZXNFeGlzdHMgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBNYXAoKS5lbnRyaWVzKCkpO1xudmFyIGFycmF5SXRlcmF0b3JFeGlzdHMgPSBzeW1ib2xJdGVyYXRvckV4aXN0cyAmJiB0eXBlb2YgQXJyYXkucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG52YXIgYXJyYXlJdGVyYXRvclByb3RvdHlwZSA9IGFycmF5SXRlcmF0b3JFeGlzdHMgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSk7XG52YXIgc3RyaW5nSXRlcmF0b3JFeGlzdHMgPSBzeW1ib2xJdGVyYXRvckV4aXN0cyAmJiB0eXBlb2YgQXJyYXkucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG52YXIgc3RyaW5nSXRlcmF0b3JQcm90b3R5cGUgPSBzdHJpbmdJdGVyYXRvckV4aXN0cyAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoJydbU3ltYm9sLml0ZXJhdG9yXSgpKTtcbnZhciB0b1N0cmluZ0xlZnRTbGljZUxlbmd0aCA9IDg7XG52YXIgdG9TdHJpbmdSaWdodFNsaWNlTGVuZ3RoID0gLTE7XG4vKipcbiAqICMjIyB0eXBlT2YgKG9iailcbiAqXG4gKiBVc2VzIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCB0byBkZXRlcm1pbmUgdGhlIHR5cGUgb2YgYW4gb2JqZWN0LFxuICogbm9ybWFsaXNpbmcgYmVoYXZpb3VyIGFjcm9zcyBlbmdpbmUgdmVyc2lvbnMgJiB3ZWxsIG9wdGltaXNlZC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAqIEByZXR1cm4ge1N0cmluZ30gb2JqZWN0IHR5cGVcbiAqIEBhcGkgcHVibGljXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHlwZURldGVjdChvYmopIHtcbiAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgICogUHJlOlxuICAgKiAgIHN0cmluZyBsaXRlcmFsICAgICB4IDMsMDM5LDAzNSBvcHMvc2VjIMKxMS42MiUgKDc4IHJ1bnMgc2FtcGxlZClcbiAgICogICBib29sZWFuIGxpdGVyYWwgICAgeCAxLDQyNCwxMzggb3BzL3NlYyDCsTQuNTQlICg3NSBydW5zIHNhbXBsZWQpXG4gICAqICAgbnVtYmVyIGxpdGVyYWwgICAgIHggMSw2NTMsMTUzIG9wcy9zZWMgwrExLjkxJSAoODIgcnVucyBzYW1wbGVkKVxuICAgKiAgIHVuZGVmaW5lZCAgICAgICAgICB4IDksOTc4LDY2MCBvcHMvc2VjIMKxMS45MiUgKDc1IHJ1bnMgc2FtcGxlZClcbiAgICogICBmdW5jdGlvbiAgICAgICAgICAgeCAyLDU1Niw3Njkgb3BzL3NlYyDCsTEuNzMlICg3NyBydW5zIHNhbXBsZWQpXG4gICAqIFBvc3Q6XG4gICAqICAgc3RyaW5nIGxpdGVyYWwgICAgIHggMzgsNTY0LDc5NiBvcHMvc2VjIMKxMS4xNSUgKDc5IHJ1bnMgc2FtcGxlZClcbiAgICogICBib29sZWFuIGxpdGVyYWwgICAgeCAzMSwxNDgsOTQwIG9wcy9zZWMgwrExLjEwJSAoNzkgcnVucyBzYW1wbGVkKVxuICAgKiAgIG51bWJlciBsaXRlcmFsICAgICB4IDMyLDY3OSwzMzAgb3BzL3NlYyDCsTEuOTAlICg3OCBydW5zIHNhbXBsZWQpXG4gICAqICAgdW5kZWZpbmVkICAgICAgICAgIHggMzIsMzYzLDM2OCBvcHMvc2VjIMKxMS4wNyUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgICogICBmdW5jdGlvbiAgICAgICAgICAgeCAzMSwyOTYsODcwIG9wcy9zZWMgwrEwLjk2JSAoODMgcnVucyBzYW1wbGVkKVxuICAgKi9cbiAgdmFyIHR5cGVvZk9iaiA9IHR5cGVvZiBvYmo7XG4gIGlmICh0eXBlb2ZPYmogIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHR5cGVvZk9iajtcbiAgfVxuXG4gIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICAqIFByZTpcbiAgICogICBudWxsICAgICAgICAgICAgICAgeCAyOCw2NDUsNzY1IG9wcy9zZWMgwrExLjE3JSAoODIgcnVucyBzYW1wbGVkKVxuICAgKiBQb3N0OlxuICAgKiAgIG51bGwgICAgICAgICAgICAgICB4IDM2LDQyOCw5NjIgb3BzL3NlYyDCsTEuMzclICg4NCBydW5zIHNhbXBsZWQpXG4gICAqL1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgcmV0dXJuICdudWxsJztcbiAgfVxuXG4gIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHdpbmRvdylgYFxuICAgKiAgLSBOb2RlID09PSBcIltvYmplY3QgZ2xvYmFsXVwiXG4gICAqICAtIENocm9tZSA9PT0gXCJbb2JqZWN0IGdsb2JhbF1cIlxuICAgKiAgLSBGaXJlZm94ID09PSBcIltvYmplY3QgV2luZG93XVwiXG4gICAqICAtIFBoYW50b21KUyA9PT0gXCJbb2JqZWN0IFdpbmRvd11cIlxuICAgKiAgLSBTYWZhcmkgPT09IFwiW29iamVjdCBXaW5kb3ddXCJcbiAgICogIC0gSUUgMTEgPT09IFwiW29iamVjdCBXaW5kb3ddXCJcbiAgICogIC0gSUUgRWRnZSA9PT0gXCJbb2JqZWN0IFdpbmRvd11cIlxuICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMpYGBcbiAgICogIC0gQ2hyb21lIFdvcmtlciA9PT0gXCJbb2JqZWN0IGdsb2JhbF1cIlxuICAgKiAgLSBGaXJlZm94IFdvcmtlciA9PT0gXCJbb2JqZWN0IERlZGljYXRlZFdvcmtlckdsb2JhbFNjb3BlXVwiXG4gICAqICAtIFNhZmFyaSBXb3JrZXIgPT09IFwiW29iamVjdCBEZWRpY2F0ZWRXb3JrZXJHbG9iYWxTY29wZV1cIlxuICAgKiAgLSBJRSAxMSBXb3JrZXIgPT09IFwiW29iamVjdCBXb3JrZXJHbG9iYWxTY29wZV1cIlxuICAgKiAgLSBJRSBFZGdlIFdvcmtlciA9PT0gXCJbb2JqZWN0IFdvcmtlckdsb2JhbFNjb3BlXVwiXG4gICAqL1xuICBpZiAob2JqID09PSBnbG9iYWxPYmplY3QpIHtcbiAgICByZXR1cm4gJ2dsb2JhbCc7XG4gIH1cblxuICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAgKiBQcmU6XG4gICAqICAgYXJyYXkgbGl0ZXJhbCAgICAgIHggMiw4ODgsMzUyIG9wcy9zZWMgwrEwLjY3JSAoODIgcnVucyBzYW1wbGVkKVxuICAgKiBQb3N0OlxuICAgKiAgIGFycmF5IGxpdGVyYWwgICAgICB4IDIyLDQ3OSw2NTAgb3BzL3NlYyDCsTAuOTYlICg4MSBydW5zIHNhbXBsZWQpXG4gICAqL1xuICBpZiAoaXNBcnJheUV4aXN0cyAmJiBBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gJ0FycmF5JztcbiAgfVxuXG4gIGlmIChpc0RvbSkge1xuICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAqIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9icm93c2Vycy5odG1sI2xvY2F0aW9uKVxuICAgICAqIFdoYXRXRyBIVE1MJDcuNy4zIC0gVGhlIGBMb2NhdGlvbmAgaW50ZXJmYWNlXG4gICAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3cubG9jYXRpb24pYGBcbiAgICAgKiAgLSBJRSA8PTExID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAgICogIC0gSUUgRWRnZSA8PTEzID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAgICovXG4gICAgaWYgKG9iaiA9PT0gZ2xvYmFsT2JqZWN0LmxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gJ0xvY2F0aW9uJztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jZG9jdW1lbnQpXG4gICAgICogV2hhdFdHIEhUTUwkMy4xLjEgLSBUaGUgYERvY3VtZW50YCBvYmplY3RcbiAgICAgKiBOb3RlOiBNb3N0IGJyb3dzZXJzIGN1cnJlbnRseSBhZGhlciB0byB0aGUgVzNDIERPTSBMZXZlbCAyIHNwZWNcbiAgICAgKiAgICAgICAoaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUhUTUwvaHRtbC5odG1sI0lELTI2ODA5MjY4KVxuICAgICAqICAgICAgIHdoaWNoIHN1Z2dlc3RzIHRoYXQgYnJvd3NlcnMgc2hvdWxkIHVzZSBIVE1MVGFibGVDZWxsRWxlbWVudCBmb3JcbiAgICAgKiAgICAgICBib3RoIFREIGFuZCBUSCBlbGVtZW50cy4gV2hhdFdHIHNlcGFyYXRlcyB0aGVzZS5cbiAgICAgKiAgICAgICBXaGF0V0cgSFRNTCBzdGF0ZXM6XG4gICAgICogICAgICAgICA+IEZvciBoaXN0b3JpY2FsIHJlYXNvbnMsIFdpbmRvdyBvYmplY3RzIG11c3QgYWxzbyBoYXZlIGFcbiAgICAgKiAgICAgICAgID4gd3JpdGFibGUsIGNvbmZpZ3VyYWJsZSwgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgbmFtZWRcbiAgICAgKiAgICAgICAgID4gSFRNTERvY3VtZW50IHdob3NlIHZhbHVlIGlzIHRoZSBEb2N1bWVudCBpbnRlcmZhY2Ugb2JqZWN0LlxuICAgICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9jdW1lbnQpYGBcbiAgICAgKiAgLSBDaHJvbWUgPT09IFwiW29iamVjdCBIVE1MRG9jdW1lbnRdXCJcbiAgICAgKiAgLSBGaXJlZm94ID09PSBcIltvYmplY3QgSFRNTERvY3VtZW50XVwiXG4gICAgICogIC0gU2FmYXJpID09PSBcIltvYmplY3QgSFRNTERvY3VtZW50XVwiXG4gICAgICogIC0gSUUgPD0xMCA9PT0gXCJbb2JqZWN0IERvY3VtZW50XVwiXG4gICAgICogIC0gSUUgMTEgPT09IFwiW29iamVjdCBIVE1MRG9jdW1lbnRdXCJcbiAgICAgKiAgLSBJRSBFZGdlIDw9MTMgPT09IFwiW29iamVjdCBIVE1MRG9jdW1lbnRdXCJcbiAgICAgKi9cbiAgICBpZiAob2JqID09PSBnbG9iYWxPYmplY3QuZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiAnRG9jdW1lbnQnO1xuICAgIH1cblxuICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAqIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS93ZWJhcHBhcGlzLmh0bWwjbWltZXR5cGVhcnJheSlcbiAgICAgKiBXaGF0V0cgSFRNTCQ4LjYuMS41IC0gUGx1Z2lucyAtIEludGVyZmFjZSBNaW1lVHlwZUFycmF5XG4gICAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuYXZpZ2F0b3IubWltZVR5cGVzKWBgXG4gICAgICogIC0gSUUgPD0xMCA9PT0gXCJbb2JqZWN0IE1TTWltZVR5cGVzQ29sbGVjdGlvbl1cIlxuICAgICAqL1xuICAgIGlmIChvYmogPT09IChnbG9iYWxPYmplY3QubmF2aWdhdG9yIHx8IHt9KS5taW1lVHlwZXMpIHtcbiAgICAgIHJldHVybiAnTWltZVR5cGVBcnJheSc7XG4gICAgfVxuXG4gICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICogKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3dlYmFwcGFwaXMuaHRtbCNwbHVnaW5hcnJheSlcbiAgICAgKiBXaGF0V0cgSFRNTCQ4LjYuMS41IC0gUGx1Z2lucyAtIEludGVyZmFjZSBQbHVnaW5BcnJheVxuICAgICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmF2aWdhdG9yLnBsdWdpbnMpYGBcbiAgICAgKiAgLSBJRSA8PTEwID09PSBcIltvYmplY3QgTVNQbHVnaW5zQ29sbGVjdGlvbl1cIlxuICAgICAqL1xuICAgIGlmIChvYmogPT09IChnbG9iYWxPYmplY3QubmF2aWdhdG9yIHx8IHt9KS5wbHVnaW5zKSB7XG4gICAgICByZXR1cm4gJ1BsdWdpbkFycmF5JztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvd2ViYXBwYXBpcy5odG1sI3BsdWdpbmFycmF5KVxuICAgICAqIFdoYXRXRyBIVE1MJDQuNC40IC0gVGhlIGBibG9ja3F1b3RlYCBlbGVtZW50IC0gSW50ZXJmYWNlIGBIVE1MUXVvdGVFbGVtZW50YFxuICAgICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYmxvY2txdW90ZScpKWBgXG4gICAgICogIC0gSUUgPD0xMCA9PT0gXCJbb2JqZWN0IEhUTUxCbG9ja0VsZW1lbnRdXCJcbiAgICAgKi9cbiAgICBpZiAoaHRtbEVsZW1lbnRFeGlzdHMgJiYgb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgb2JqLnRhZ05hbWUgPT09ICdCTE9DS1FVT1RFJykge1xuICAgICAgcmV0dXJuICdIVE1MUXVvdGVFbGVtZW50JztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jaHRtbHRhYmxlZGF0YWNlbGxlbGVtZW50KVxuICAgICAqIFdoYXRXRyBIVE1MJDQuOS45IC0gVGhlIGB0ZGAgZWxlbWVudCAtIEludGVyZmFjZSBgSFRNTFRhYmxlRGF0YUNlbGxFbGVtZW50YFxuICAgICAqIE5vdGU6IE1vc3QgYnJvd3NlcnMgY3VycmVudGx5IGFkaGVyIHRvIHRoZSBXM0MgRE9NIExldmVsIDIgc3BlY1xuICAgICAqICAgICAgIChodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTItSFRNTC9odG1sLmh0bWwjSUQtODI5MTUwNzUpXG4gICAgICogICAgICAgd2hpY2ggc3VnZ2VzdHMgdGhhdCBicm93c2VycyBzaG91bGQgdXNlIEhUTUxUYWJsZUNlbGxFbGVtZW50IGZvclxuICAgICAqICAgICAgIGJvdGggVEQgYW5kIFRIIGVsZW1lbnRzLiBXaGF0V0cgc2VwYXJhdGVzIHRoZXNlLlxuICAgICAqIFRlc3Q6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpKVxuICAgICAqICAtIENocm9tZSA9PT0gXCJbb2JqZWN0IEhUTUxUYWJsZUNlbGxFbGVtZW50XVwiXG4gICAgICogIC0gRmlyZWZveCA9PT0gXCJbb2JqZWN0IEhUTUxUYWJsZUNlbGxFbGVtZW50XVwiXG4gICAgICogIC0gU2FmYXJpID09PSBcIltvYmplY3QgSFRNTFRhYmxlQ2VsbEVsZW1lbnRdXCJcbiAgICAgKi9cbiAgICBpZiAoaHRtbEVsZW1lbnRFeGlzdHMgJiYgb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgb2JqLnRhZ05hbWUgPT09ICdURCcpIHtcbiAgICAgIHJldHVybiAnSFRNTFRhYmxlRGF0YUNlbGxFbGVtZW50JztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jaHRtbHRhYmxlaGVhZGVyY2VsbGVsZW1lbnQpXG4gICAgICogV2hhdFdHIEhUTUwkNC45LjkgLSBUaGUgYHRkYCBlbGVtZW50IC0gSW50ZXJmYWNlIGBIVE1MVGFibGVIZWFkZXJDZWxsRWxlbWVudGBcbiAgICAgKiBOb3RlOiBNb3N0IGJyb3dzZXJzIGN1cnJlbnRseSBhZGhlciB0byB0aGUgVzNDIERPTSBMZXZlbCAyIHNwZWNcbiAgICAgKiAgICAgICAoaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUhUTUwvaHRtbC5odG1sI0lELTgyOTE1MDc1KVxuICAgICAqICAgICAgIHdoaWNoIHN1Z2dlc3RzIHRoYXQgYnJvd3NlcnMgc2hvdWxkIHVzZSBIVE1MVGFibGVDZWxsRWxlbWVudCBmb3JcbiAgICAgKiAgICAgICBib3RoIFREIGFuZCBUSCBlbGVtZW50cy4gV2hhdFdHIHNlcGFyYXRlcyB0aGVzZS5cbiAgICAgKiBUZXN0OiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGgnKSlcbiAgICAgKiAgLSBDaHJvbWUgPT09IFwiW29iamVjdCBIVE1MVGFibGVDZWxsRWxlbWVudF1cIlxuICAgICAqICAtIEZpcmVmb3ggPT09IFwiW29iamVjdCBIVE1MVGFibGVDZWxsRWxlbWVudF1cIlxuICAgICAqICAtIFNhZmFyaSA9PT0gXCJbb2JqZWN0IEhUTUxUYWJsZUNlbGxFbGVtZW50XVwiXG4gICAgICovXG4gICAgaWYgKGh0bWxFbGVtZW50RXhpc3RzICYmIG9iaiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIG9iai50YWdOYW1lID09PSAnVEgnKSB7XG4gICAgICByZXR1cm4gJ0hUTUxUYWJsZUhlYWRlckNlbGxFbGVtZW50JztcbiAgICB9XG4gIH1cblxuICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAqIFByZTpcbiAgKiAgIEZsb2F0NjRBcnJheSAgICAgICB4IDYyNSw2NDQgb3BzL3NlYyDCsTEuNTglICg4MCBydW5zIHNhbXBsZWQpXG4gICogICBGbG9hdDMyQXJyYXkgICAgICAgeCAxLDI3OSw4NTIgb3BzL3NlYyDCsTIuOTElICg3NyBydW5zIHNhbXBsZWQpXG4gICogICBVaW50MzJBcnJheSAgICAgICAgeCAxLDE3OCwxODUgb3BzL3NlYyDCsTEuOTUlICg4MyBydW5zIHNhbXBsZWQpXG4gICogICBVaW50MTZBcnJheSAgICAgICAgeCAxLDAwOCwzODAgb3BzL3NlYyDCsTIuMjUlICg4MCBydW5zIHNhbXBsZWQpXG4gICogICBVaW50OEFycmF5ICAgICAgICAgeCAxLDEyOCwwNDAgb3BzL3NlYyDCsTIuMTElICg4MSBydW5zIHNhbXBsZWQpXG4gICogICBJbnQzMkFycmF5ICAgICAgICAgeCAxLDE3MCwxMTkgb3BzL3NlYyDCsTIuODglICg4MCBydW5zIHNhbXBsZWQpXG4gICogICBJbnQxNkFycmF5ICAgICAgICAgeCAxLDE3NiwzNDggb3BzL3NlYyDCsTUuNzklICg4NiBydW5zIHNhbXBsZWQpXG4gICogICBJbnQ4QXJyYXkgICAgICAgICAgeCAxLDA1OCw3MDcgb3BzL3NlYyDCsTQuOTQlICg3NyBydW5zIHNhbXBsZWQpXG4gICogICBVaW50OENsYW1wZWRBcnJheSAgeCAxLDExMCw2MzMgb3BzL3NlYyDCsTQuMjAlICg4MCBydW5zIHNhbXBsZWQpXG4gICogUG9zdDpcbiAgKiAgIEZsb2F0NjRBcnJheSAgICAgICB4IDcsMTA1LDY3MSBvcHMvc2VjIMKxMTMuNDclICg2NCBydW5zIHNhbXBsZWQpXG4gICogICBGbG9hdDMyQXJyYXkgICAgICAgeCA1LDg4Nyw5MTIgb3BzL3NlYyDCsTEuNDYlICg4MiBydW5zIHNhbXBsZWQpXG4gICogICBVaW50MzJBcnJheSAgICAgICAgeCA2LDQ5MSw2NjEgb3BzL3NlYyDCsTEuNzYlICg3OSBydW5zIHNhbXBsZWQpXG4gICogICBVaW50MTZBcnJheSAgICAgICAgeCA2LDU1OSw3OTUgb3BzL3NlYyDCsTEuNjclICg4MiBydW5zIHNhbXBsZWQpXG4gICogICBVaW50OEFycmF5ICAgICAgICAgeCA2LDQ2Myw5NjYgb3BzL3NlYyDCsTEuNDMlICg4NSBydW5zIHNhbXBsZWQpXG4gICogICBJbnQzMkFycmF5ICAgICAgICAgeCA1LDY0MSw4NDEgb3BzL3NlYyDCsTMuNDklICg4MSBydW5zIHNhbXBsZWQpXG4gICogICBJbnQxNkFycmF5ICAgICAgICAgeCA2LDU4Myw1MTEgb3BzL3NlYyDCsTEuOTglICg4MCBydW5zIHNhbXBsZWQpXG4gICogICBJbnQ4QXJyYXkgICAgICAgICAgeCA2LDYwNiwwNzggb3BzL3NlYyDCsTEuNzQlICg4MSBydW5zIHNhbXBsZWQpXG4gICogICBVaW50OENsYW1wZWRBcnJheSAgeCA2LDYwMiwyMjQgb3BzL3NlYyDCsTEuNzclICg4MyBydW5zIHNhbXBsZWQpXG4gICovXG4gIHZhciBzdHJpbmdUYWcgPSAoc3ltYm9sVG9TdHJpbmdUYWdFeGlzdHMgJiYgb2JqW1N5bWJvbC50b1N0cmluZ1RhZ10pO1xuICBpZiAodHlwZW9mIHN0cmluZ1RhZyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc3RyaW5nVGFnO1xuICB9XG5cbiAgaWYgKGdldFByb3RvdHlwZU9mRXhpc3RzKSB7XG4gICAgdmFyIG9ialByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuICAgIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICAgKiBQcmU6XG4gICAgKiAgIHJlZ2V4IGxpdGVyYWwgICAgICB4IDEsNzcyLDM4NSBvcHMvc2VjIMKxMS44NSUgKDc3IHJ1bnMgc2FtcGxlZClcbiAgICAqICAgcmVnZXggY29uc3RydWN0b3IgIHggMiwxNDMsNjM0IG9wcy9zZWMgwrEyLjQ2JSAoNzggcnVucyBzYW1wbGVkKVxuICAgICogUG9zdDpcbiAgICAqICAgcmVnZXggbGl0ZXJhbCAgICAgIHggMyw5MjgsMDA5IG9wcy9zZWMgwrEwLjY1JSAoNzggcnVucyBzYW1wbGVkKVxuICAgICogICByZWdleCBjb25zdHJ1Y3RvciAgeCAzLDkzMSwxMDggb3BzL3NlYyDCsTAuNTglICg4NCBydW5zIHNhbXBsZWQpXG4gICAgKi9cbiAgICBpZiAob2JqUHJvdG90eXBlID09PSBSZWdFeHAucHJvdG90eXBlKSB7XG4gICAgICByZXR1cm4gJ1JlZ0V4cCc7XG4gICAgfVxuXG4gICAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgICAqIFByZTpcbiAgICAqICAgZGF0ZSAgICAgICAgICAgICAgIHggMiwxMzAsMDc0IG9wcy9zZWMgwrE0LjQyJSAoNjggcnVucyBzYW1wbGVkKVxuICAgICogUG9zdDpcbiAgICAqICAgZGF0ZSAgICAgICAgICAgICAgIHggMyw5NTMsNzc5IG9wcy9zZWMgwrExLjM1JSAoNzcgcnVucyBzYW1wbGVkKVxuICAgICovXG4gICAgaWYgKG9ialByb3RvdHlwZSA9PT0gRGF0ZS5wcm90b3R5cGUpIHtcbiAgICAgIHJldHVybiAnRGF0ZSc7XG4gICAgfVxuXG4gICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICogKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvaW5kZXguaHRtbCNzZWMtcHJvbWlzZS5wcm90b3R5cGUtQEB0b3N0cmluZ3RhZylcbiAgICAgKiBFUzYkMjUuNC41LjQgLSBQcm9taXNlLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSBzaG91bGQgYmUgXCJQcm9taXNlXCI6XG4gICAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChQcm9taXNlLnJlc29sdmUoKSlgYFxuICAgICAqICAtIENocm9tZSA8PTQ3ID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAgICogIC0gRWRnZSA8PTIwID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAgICogIC0gRmlyZWZveCAyOS1MYXRlc3QgPT09IFwiW29iamVjdCBQcm9taXNlXVwiXG4gICAgICogIC0gU2FmYXJpIDcuMS1MYXRlc3QgPT09IFwiW29iamVjdCBQcm9taXNlXVwiXG4gICAgICovXG4gICAgaWYgKHByb21pc2VFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBQcm9taXNlLnByb3RvdHlwZSkge1xuICAgICAgcmV0dXJuICdQcm9taXNlJztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAgICogUHJlOlxuICAgICogICBzZXQgICAgICAgICAgICAgICAgeCAyLDIyMiwxODYgb3BzL3NlYyDCsTEuMzElICg4MiBydW5zIHNhbXBsZWQpXG4gICAgKiBQb3N0OlxuICAgICogICBzZXQgICAgICAgICAgICAgICAgeCA0LDU0NSw4Nzkgb3BzL3NlYyDCsTEuMTMlICg4MyBydW5zIHNhbXBsZWQpXG4gICAgKi9cbiAgICBpZiAoc2V0RXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gU2V0LnByb3RvdHlwZSkge1xuICAgICAgcmV0dXJuICdTZXQnO1xuICAgIH1cblxuICAgIC8qICEgU3BlZWQgb3B0aW1pc2F0aW9uXG4gICAgKiBQcmU6XG4gICAgKiAgIG1hcCAgICAgICAgICAgICAgICB4IDIsMzk2LDg0MiBvcHMvc2VjIMKxMS41OSUgKDgxIHJ1bnMgc2FtcGxlZClcbiAgICAqIFBvc3Q6XG4gICAgKiAgIG1hcCAgICAgICAgICAgICAgICB4IDQsMTgzLDk0NSBvcHMvc2VjIMKxNi41OSUgKDgyIHJ1bnMgc2FtcGxlZClcbiAgICAqL1xuICAgIGlmIChtYXBFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBNYXAucHJvdG90eXBlKSB7XG4gICAgICByZXR1cm4gJ01hcCc7XG4gICAgfVxuXG4gICAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgICAqIFByZTpcbiAgICAqICAgd2Vha3NldCAgICAgICAgICAgIHggMSwzMjMsMjIwIG9wcy9zZWMgwrEyLjE3JSAoNzYgcnVucyBzYW1wbGVkKVxuICAgICogUG9zdDpcbiAgICAqICAgd2Vha3NldCAgICAgICAgICAgIHggNCwyMzcsNTEwIG9wcy9zZWMgwrEyLjAxJSAoNzcgcnVucyBzYW1wbGVkKVxuICAgICovXG4gICAgaWYgKHdlYWtTZXRFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBXZWFrU2V0LnByb3RvdHlwZSkge1xuICAgICAgcmV0dXJuICdXZWFrU2V0JztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWVkIG9wdGltaXNhdGlvblxuICAgICogUHJlOlxuICAgICogICB3ZWFrbWFwICAgICAgICAgICAgeCAxLDUwMCwyNjAgb3BzL3NlYyDCsTIuMDIlICg3OCBydW5zIHNhbXBsZWQpXG4gICAgKiBQb3N0OlxuICAgICogICB3ZWFrbWFwICAgICAgICAgICAgeCAzLDg4MSwzODQgb3BzL3NlYyDCsTEuNDUlICg4MiBydW5zIHNhbXBsZWQpXG4gICAgKi9cbiAgICBpZiAod2Vha01hcEV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IFdlYWtNYXAucHJvdG90eXBlKSB7XG4gICAgICByZXR1cm4gJ1dlYWtNYXAnO1xuICAgIH1cblxuICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAqIChodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wL2luZGV4Lmh0bWwjc2VjLWRhdGF2aWV3LnByb3RvdHlwZS1AQHRvc3RyaW5ndGFnKVxuICAgICAqIEVTNiQyNC4yLjQuMjEgLSBEYXRhVmlldy5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gc2hvdWxkIGJlIFwiRGF0YVZpZXdcIjpcbiAgICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKWBgXG4gICAgICogIC0gRWRnZSA8PTEzID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAgICovXG4gICAgaWYgKGRhdGFWaWV3RXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gRGF0YVZpZXcucHJvdG90eXBlKSB7XG4gICAgICByZXR1cm4gJ0RhdGFWaWV3JztcbiAgICB9XG5cbiAgICAvKiAhIFNwZWMgQ29uZm9ybWFuY2VcbiAgICAgKiAoaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC9pbmRleC5odG1sI3NlYy0lbWFwaXRlcmF0b3Jwcm90b3R5cGUlLUBAdG9zdHJpbmd0YWcpXG4gICAgICogRVM2JDIzLjEuNS4yLjIgLSAlTWFwSXRlcmF0b3JQcm90b3R5cGUlW0BAdG9TdHJpbmdUYWddIHNob3VsZCBiZSBcIk1hcCBJdGVyYXRvclwiOlxuICAgICAqIFRlc3Q6IGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3IE1hcCgpLmVudHJpZXMoKSlgYFxuICAgICAqICAtIEVkZ2UgPD0xMyA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIlxuICAgICAqL1xuICAgIGlmIChtYXBFeGlzdHMgJiYgb2JqUHJvdG90eXBlID09PSBtYXBJdGVyYXRvclByb3RvdHlwZSkge1xuICAgICAgcmV0dXJuICdNYXAgSXRlcmF0b3InO1xuICAgIH1cblxuICAgIC8qICEgU3BlYyBDb25mb3JtYW5jZVxuICAgICAqIChodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wL2luZGV4Lmh0bWwjc2VjLSVzZXRpdGVyYXRvcnByb3RvdHlwZSUtQEB0b3N0cmluZ3RhZylcbiAgICAgKiBFUzYkMjMuMi41LjIuMiAtICVTZXRJdGVyYXRvclByb3RvdHlwZSVbQEB0b1N0cmluZ1RhZ10gc2hvdWxkIGJlIFwiU2V0IEl0ZXJhdG9yXCI6XG4gICAgICogVGVzdDogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXcgU2V0KCkuZW50cmllcygpKWBgXG4gICAgICogIC0gRWRnZSA8PTEzID09PSBcIltvYmplY3QgT2JqZWN0XVwiXG4gICAgICovXG4gICAgaWYgKHNldEV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IHNldEl0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgICByZXR1cm4gJ1NldCBJdGVyYXRvcic7XG4gICAgfVxuXG4gICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICogKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvaW5kZXguaHRtbCNzZWMtJWFycmF5aXRlcmF0b3Jwcm90b3R5cGUlLUBAdG9zdHJpbmd0YWcpXG4gICAgICogRVM2JDIyLjEuNS4yLjIgLSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSVbQEB0b1N0cmluZ1RhZ10gc2hvdWxkIGJlIFwiQXJyYXkgSXRlcmF0b3JcIjpcbiAgICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSlgYFxuICAgICAqICAtIEVkZ2UgPD0xMyA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIlxuICAgICAqL1xuICAgIGlmIChhcnJheUl0ZXJhdG9yRXhpc3RzICYmIG9ialByb3RvdHlwZSA9PT0gYXJyYXlJdGVyYXRvclByb3RvdHlwZSkge1xuICAgICAgcmV0dXJuICdBcnJheSBJdGVyYXRvcic7XG4gICAgfVxuXG4gICAgLyogISBTcGVjIENvbmZvcm1hbmNlXG4gICAgICogKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvaW5kZXguaHRtbCNzZWMtJXN0cmluZ2l0ZXJhdG9ycHJvdG90eXBlJS1AQHRvc3RyaW5ndGFnKVxuICAgICAqIEVTNiQyMS4xLjUuMi4yIC0gJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJVtAQHRvU3RyaW5nVGFnXSBzaG91bGQgYmUgXCJTdHJpbmcgSXRlcmF0b3JcIjpcbiAgICAgKiBUZXN0OiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKCcnW1N5bWJvbC5pdGVyYXRvcl0oKSlgYFxuICAgICAqICAtIEVkZ2UgPD0xMyA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIlxuICAgICAqL1xuICAgIGlmIChzdHJpbmdJdGVyYXRvckV4aXN0cyAmJiBvYmpQcm90b3R5cGUgPT09IHN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgICByZXR1cm4gJ1N0cmluZyBJdGVyYXRvcic7XG4gICAgfVxuXG4gICAgLyogISBTcGVlZCBvcHRpbWlzYXRpb25cbiAgICAqIFByZTpcbiAgICAqICAgb2JqZWN0IGZyb20gbnVsbCAgIHggMiw0MjQsMzIwIG9wcy9zZWMgwrExLjY3JSAoNzYgcnVucyBzYW1wbGVkKVxuICAgICogUG9zdDpcbiAgICAqICAgb2JqZWN0IGZyb20gbnVsbCAgIHggNSw4MzgsMDAwIG9wcy9zZWMgwrEwLjk5JSAoODQgcnVucyBzYW1wbGVkKVxuICAgICovXG4gICAgaWYgKG9ialByb3RvdHlwZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICdPYmplY3QnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBPYmplY3RcbiAgICAucHJvdG90eXBlXG4gICAgLnRvU3RyaW5nXG4gICAgLmNhbGwob2JqKVxuICAgIC5zbGljZSh0b1N0cmluZ0xlZnRTbGljZUxlbmd0aCwgdG9TdHJpbmdSaWdodFNsaWNlTGVuZ3RoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLnR5cGVEZXRlY3QgPSBtb2R1bGUuZXhwb3J0cztcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGdsb2JhbHMgU3ltYm9sOiB0cnVlLCBVaW50OEFycmF5OiB0cnVlLCBXZWFrTWFwOiB0cnVlICovXG4vKiFcbiAqIGRlZXAtZXFsXG4gKiBDb3B5cmlnaHQoYykgMjAxMyBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciB0eXBlID0gcmVxdWlyZSgndHlwZS1kZXRlY3QnKTtcbmZ1bmN0aW9uIEZha2VNYXAoKSB7XG4gIHRoaXMuY2xlYXIoKTtcbn1cbkZha2VNYXAucHJvdG90eXBlID0ge1xuICBjbGVhcjogZnVuY3Rpb24gY2xlYXJNYXAoKSB7XG4gICAgdGhpcy5rZXlzID0gW107XG4gICAgdGhpcy52YWx1ZXMgPSBbXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXRNYXAoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBpbmRleCA9IHRoaXMua2V5cy5pbmRleE9mKGtleSk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRoaXMudmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmtleXMucHVzaChrZXkpO1xuICAgICAgdGhpcy52YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBnZXQ6IGZ1bmN0aW9uIGdldE1hcChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXNbdGhpcy5rZXlzLmluZGV4T2Yoa2V5KV07XG4gIH0sXG4gIGRlbGV0ZTogZnVuY3Rpb24gZGVsZXRlTWFwKGtleSkge1xuICAgIHZhciBpbmRleCA9IHRoaXMua2V5cy5pbmRleE9mKGtleSk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRoaXMudmFsdWVzID0gdGhpcy52YWx1ZXMuc2xpY2UoMCwgaW5kZXgpLmNvbmNhdCh0aGlzLnZhbHVlcy5zbGljZShpbmRleCArIDEpKTtcbiAgICAgIHRoaXMua2V5cyA9IHRoaXMua2V5cy5zbGljZSgwLCBpbmRleCkuY29uY2F0KHRoaXMua2V5cy5zbGljZShpbmRleCArIDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG59O1xuXG52YXIgTWVtb2l6ZU1hcCA9IG51bGw7XG5pZiAodHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicpIHtcbiAgTWVtb2l6ZU1hcCA9IFdlYWtNYXA7XG59IGVsc2Uge1xuICBNZW1vaXplTWFwID0gRmFrZU1hcDtcbn1cblxuLyohXG4gKiBDaGVjayB0byBzZWUgaWYgdGhlIE1lbW9pemVNYXAgaGFzIHJlY29yZGVkIGEgcmVzdWx0IG9mIHRoZSB0d28gb3BlcmFuZHNcbiAqXG4gKiBAcGFyYW0ge01peGVkfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWl4ZWR9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWVtb2l6ZU1hcH0gbWVtb2l6ZU1hcFxuICogQHJldHVybnMge0Jvb2xlYW58bnVsbH0gcmVzdWx0XG4qL1xuZnVuY3Rpb24gbWVtb2l6ZUNvbXBhcmUobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBtZW1vaXplTWFwKSB7XG4gIC8vIFRlY2huaWNhbGx5LCBXZWFrTWFwIGtleXMgY2FuICpvbmx5KiBiZSBvYmplY3RzLCBub3QgcHJpbWl0aXZlcy5cbiAgaWYgKCFtZW1vaXplTWFwIHx8IGlzUHJpbWl0aXZlKGxlZnRIYW5kT3BlcmFuZCkgfHwgaXNQcmltaXRpdmUocmlnaHRIYW5kT3BlcmFuZCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbGVmdEhhbmRNYXAgPSBtZW1vaXplTWFwLmdldChsZWZ0SGFuZE9wZXJhbmQpO1xuICBpZiAobGVmdEhhbmRNYXApIHtcbiAgICB2YXIgcmVzdWx0ID0gbGVmdEhhbmRNYXAuZ2V0KHJpZ2h0SGFuZE9wZXJhbmQpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKiFcbiAqIFNldCB0aGUgcmVzdWx0IG9mIHRoZSBlcXVhbGl0eSBpbnRvIHRoZSBNZW1vaXplTWFwXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01peGVkfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01lbW9pemVNYXB9IG1lbW9pemVNYXBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVzdWx0XG4qL1xuZnVuY3Rpb24gbWVtb2l6ZVNldChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG1lbW9pemVNYXAsIHJlc3VsdCkge1xuICAvLyBUZWNobmljYWxseSwgV2Vha01hcCBrZXlzIGNhbiAqb25seSogYmUgb2JqZWN0cywgbm90IHByaW1pdGl2ZXMuXG4gIGlmICghbWVtb2l6ZU1hcCB8fCBpc1ByaW1pdGl2ZShsZWZ0SGFuZE9wZXJhbmQpIHx8IGlzUHJpbWl0aXZlKHJpZ2h0SGFuZE9wZXJhbmQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBsZWZ0SGFuZE1hcCA9IG1lbW9pemVNYXAuZ2V0KGxlZnRIYW5kT3BlcmFuZCk7XG4gIGlmIChsZWZ0SGFuZE1hcCkge1xuICAgIGxlZnRIYW5kTWFwLnNldChyaWdodEhhbmRPcGVyYW5kLCByZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIGxlZnRIYW5kTWFwID0gbmV3IE1lbW9pemVNYXAoKTtcbiAgICBsZWZ0SGFuZE1hcC5zZXQocmlnaHRIYW5kT3BlcmFuZCwgcmVzdWx0KTtcbiAgICBtZW1vaXplTWFwLnNldChsZWZ0SGFuZE9wZXJhbmQsIGxlZnRIYW5kTWFwKTtcbiAgfVxufVxuXG4vKiFcbiAqIFByaW1hcnkgRXhwb3J0XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZWVwRXF1YWw7XG5tb2R1bGUuZXhwb3J0cy5NZW1vaXplTWFwID0gTWVtb2l6ZU1hcDtcblxuLyoqXG4gKiBBc3NlcnQgZGVlcGx5IG5lc3RlZCBzYW1lVmFsdWUgZXF1YWxpdHkgYmV0d2VlbiB0d28gb2JqZWN0cyBvZiBhbnkgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWl4ZWR9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gKG9wdGlvbmFsKSBBZGRpdGlvbmFsIG9wdGlvbnNcbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmNvbXBhcmF0b3JdIChvcHRpb25hbCkgT3ZlcnJpZGUgZGVmYXVsdCBhbGdvcml0aG0sIGRldGVybWluaW5nIGN1c3RvbSBlcXVhbGl0eS5cbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLm1lbW9pemVdIChvcHRpb25hbCkgUHJvdmlkZSBhIGN1c3RvbSBtZW1vaXphdGlvbiBvYmplY3Qgd2hpY2ggd2lsbCBjYWNoZSB0aGUgcmVzdWx0cyBvZlxuICAgIGNvbXBsZXggb2JqZWN0cyBmb3IgYSBzcGVlZCBib29zdC4gQnkgcGFzc2luZyBgZmFsc2VgIHlvdSBjYW4gZGlzYWJsZSBtZW1vaXphdGlvbiwgYnV0IHRoaXMgd2lsbCBjYXVzZSBjaXJjdWxhclxuICAgIHJlZmVyZW5jZXMgdG8gYmxvdyB0aGUgc3RhY2suXG4gKiBAcmV0dXJuIHtCb29sZWFufSBlcXVhbCBtYXRjaFxuICovXG5mdW5jdGlvbiBkZWVwRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKSB7XG4gIC8vIElmIHdlIGhhdmUgYSBjb21wYXJhdG9yLCB3ZSBjYW4ndCBhc3N1bWUgYW55dGhpbmc7IHNvIGJhaWwgdG8gaXRzIGNoZWNrIGZpcnN0LlxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNvbXBhcmF0b3IpIHtcbiAgICByZXR1cm4gZXh0ZW5zaXZlRGVlcEVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucyk7XG4gIH1cblxuICB2YXIgc2ltcGxlUmVzdWx0ID0gc2ltcGxlRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kKTtcbiAgaWYgKHNpbXBsZVJlc3VsdCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBzaW1wbGVSZXN1bHQ7XG4gIH1cblxuICAvLyBEZWVwZXIgY29tcGFyaXNvbnMgYXJlIHB1c2hlZCB0aHJvdWdoIHRvIGEgbGFyZ2VyIGZ1bmN0aW9uXG4gIHJldHVybiBleHRlbnNpdmVEZWVwRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBNYW55IGNvbXBhcmlzb25zIGNhbiBiZSBjYW5jZWxlZCBvdXQgZWFybHkgdmlhIHNpbXBsZSBlcXVhbGl0eSBvciBwcmltaXRpdmUgY2hlY2tzLlxuICogQHBhcmFtIHtNaXhlZH0gbGVmdEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge01peGVkfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcmV0dXJuIHtCb29sZWFufG51bGx9IGVxdWFsIG1hdGNoXG4gKi9cbmZ1bmN0aW9uIHNpbXBsZUVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCkge1xuICAvLyBFcXVhbCByZWZlcmVuY2VzIChleGNlcHQgZm9yIE51bWJlcnMpIGNhbiBiZSByZXR1cm5lZCBlYXJseVxuICBpZiAobGVmdEhhbmRPcGVyYW5kID09PSByaWdodEhhbmRPcGVyYW5kKSB7XG4gICAgLy8gSGFuZGxlICstMCBjYXNlc1xuICAgIHJldHVybiBsZWZ0SGFuZE9wZXJhbmQgIT09IDAgfHwgMSAvIGxlZnRIYW5kT3BlcmFuZCA9PT0gMSAvIHJpZ2h0SGFuZE9wZXJhbmQ7XG4gIH1cblxuICAvLyBoYW5kbGUgTmFOIGNhc2VzXG4gIGlmIChcbiAgICBsZWZ0SGFuZE9wZXJhbmQgIT09IGxlZnRIYW5kT3BlcmFuZCAmJiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIHJpZ2h0SGFuZE9wZXJhbmQgIT09IHJpZ2h0SGFuZE9wZXJhbmQgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBBbnl0aGluZyB0aGF0IGlzIG5vdCBhbiAnb2JqZWN0JywgaS5lLiBzeW1ib2xzLCBmdW5jdGlvbnMsIGJvb2xlYW5zLCBudW1iZXJzLFxuICAvLyBzdHJpbmdzLCBhbmQgdW5kZWZpbmVkLCBjYW4gYmUgY29tcGFyZWQgYnkgcmVmZXJlbmNlLlxuICBpZiAoaXNQcmltaXRpdmUobGVmdEhhbmRPcGVyYW5kKSB8fCBpc1ByaW1pdGl2ZShyaWdodEhhbmRPcGVyYW5kKSkge1xuICAgIC8vIEVhc3kgb3V0IGIvYyBpdCB3b3VsZCBoYXZlIHBhc3NlZCB0aGUgZmlyc3QgZXF1YWxpdHkgY2hlY2tcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qIVxuICogVGhlIG1haW4gbG9naWMgb2YgdGhlIGBkZWVwRXF1YWxgIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtNaXhlZH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAob3B0aW9uYWwpIEFkZGl0aW9uYWwgb3B0aW9uc1xuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMuY29tcGFyYXRvcl0gKG9wdGlvbmFsKSBPdmVycmlkZSBkZWZhdWx0IGFsZ29yaXRobSwgZGV0ZXJtaW5pbmcgY3VzdG9tIGVxdWFsaXR5LlxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMubWVtb2l6ZV0gKG9wdGlvbmFsKSBQcm92aWRlIGEgY3VzdG9tIG1lbW9pemF0aW9uIG9iamVjdCB3aGljaCB3aWxsIGNhY2hlIHRoZSByZXN1bHRzIG9mXG4gICAgY29tcGxleCBvYmplY3RzIGZvciBhIHNwZWVkIGJvb3N0LiBCeSBwYXNzaW5nIGBmYWxzZWAgeW91IGNhbiBkaXNhYmxlIG1lbW9pemF0aW9uLCBidXQgdGhpcyB3aWxsIGNhdXNlIGNpcmN1bGFyXG4gICAgcmVmZXJlbmNlcyB0byBibG93IHRoZSBzdGFjay5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGVxdWFsIG1hdGNoXG4qL1xuZnVuY3Rpb24gZXh0ZW5zaXZlRGVlcEVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5tZW1vaXplID0gb3B0aW9ucy5tZW1vaXplID09PSBmYWxzZSA/IGZhbHNlIDogb3B0aW9ucy5tZW1vaXplIHx8IG5ldyBNZW1vaXplTWFwKCk7XG4gIHZhciBjb21wYXJhdG9yID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvbXBhcmF0b3I7XG5cbiAgLy8gQ2hlY2sgaWYgYSBtZW1vaXplZCByZXN1bHQgZXhpc3RzLlxuICB2YXIgbWVtb2l6ZVJlc3VsdExlZnQgPSBtZW1vaXplQ29tcGFyZShsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMubWVtb2l6ZSk7XG4gIGlmIChtZW1vaXplUmVzdWx0TGVmdCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBtZW1vaXplUmVzdWx0TGVmdDtcbiAgfVxuICB2YXIgbWVtb2l6ZVJlc3VsdFJpZ2h0ID0gbWVtb2l6ZUNvbXBhcmUocmlnaHRIYW5kT3BlcmFuZCwgbGVmdEhhbmRPcGVyYW5kLCBvcHRpb25zLm1lbW9pemUpO1xuICBpZiAobWVtb2l6ZVJlc3VsdFJpZ2h0ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIG1lbW9pemVSZXN1bHRSaWdodDtcbiAgfVxuXG4gIC8vIElmIGEgY29tcGFyYXRvciBpcyBwcmVzZW50LCB1c2UgaXQuXG4gIGlmIChjb21wYXJhdG9yKSB7XG4gICAgdmFyIGNvbXBhcmF0b3JSZXN1bHQgPSBjb21wYXJhdG9yKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCk7XG4gICAgLy8gQ29tcGFyYXRvcnMgbWF5IHJldHVybiBudWxsLCBpbiB3aGljaCBjYXNlIHdlIHdhbnQgdG8gZ28gYmFjayB0byBkZWZhdWx0IGJlaGF2aW9yLlxuICAgIGlmIChjb21wYXJhdG9yUmVzdWx0ID09PSBmYWxzZSB8fCBjb21wYXJhdG9yUmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICBtZW1vaXplU2V0KGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucy5tZW1vaXplLCBjb21wYXJhdG9yUmVzdWx0KTtcbiAgICAgIHJldHVybiBjb21wYXJhdG9yUmVzdWx0O1xuICAgIH1cbiAgICAvLyBUbyBhbGxvdyBjb21wYXJhdG9ycyB0byBvdmVycmlkZSAqYW55KiBiZWhhdmlvciwgd2UgcmFuIHRoZW0gZmlyc3QuIFNpbmNlIGl0IGRpZG4ndCBkZWNpZGVcbiAgICAvLyB3aGF0IHRvIGRvLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0byByZXR1cm4gdGhlIGJhc2ljIHRlc3RzIGZpcnN0IGJlZm9yZSB3ZSBtb3ZlIG9uLlxuICAgIHZhciBzaW1wbGVSZXN1bHQgPSBzaW1wbGVFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQpO1xuICAgIGlmIChzaW1wbGVSZXN1bHQgIT09IG51bGwpIHtcbiAgICAgIC8vIERvbid0IG1lbW9pemUgdGhpcywgaXQgdGFrZXMgbG9uZ2VyIHRvIHNldC9yZXRyaWV2ZSB0aGFuIHRvIGp1c3QgY29tcGFyZS5cbiAgICAgIHJldHVybiBzaW1wbGVSZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxlZnRIYW5kVHlwZSA9IHR5cGUobGVmdEhhbmRPcGVyYW5kKTtcbiAgaWYgKGxlZnRIYW5kVHlwZSAhPT0gdHlwZShyaWdodEhhbmRPcGVyYW5kKSkge1xuICAgIG1lbW9pemVTZXQobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zLm1lbW9pemUsIGZhbHNlKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZW1wb3JhcmlseSBzZXQgdGhlIG9wZXJhbmRzIGluIHRoZSBtZW1vaXplIG9iamVjdCB0byBwcmV2ZW50IGJsb3dpbmcgdGhlIHN0YWNrXG4gIG1lbW9pemVTZXQobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zLm1lbW9pemUsIHRydWUpO1xuXG4gIHZhciByZXN1bHQgPSBleHRlbnNpdmVEZWVwRXF1YWxCeVR5cGUobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBsZWZ0SGFuZFR5cGUsIG9wdGlvbnMpO1xuICBtZW1vaXplU2V0KGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucy5tZW1vaXplLCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBleHRlbnNpdmVEZWVwRXF1YWxCeVR5cGUobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBsZWZ0SGFuZFR5cGUsIG9wdGlvbnMpIHtcbiAgc3dpdGNoIChsZWZ0SGFuZFR5cGUpIHtcbiAgICBjYXNlICdTdHJpbmcnOlxuICAgIGNhc2UgJ051bWJlcic6XG4gICAgY2FzZSAnQm9vbGVhbic6XG4gICAgY2FzZSAnRGF0ZSc6XG4gICAgICAvLyBJZiB0aGVzZSB0eXBlcyBhcmUgdGhlaXIgaW5zdGFuY2UgdHlwZXMgKGUuZy4gYG5ldyBOdW1iZXJgKSB0aGVuIHJlLWRlZXBFcXVhbCBhZ2FpbnN0IHRoZWlyIHZhbHVlc1xuICAgICAgcmV0dXJuIGRlZXBFcXVhbChsZWZ0SGFuZE9wZXJhbmQudmFsdWVPZigpLCByaWdodEhhbmRPcGVyYW5kLnZhbHVlT2YoKSk7XG4gICAgY2FzZSAnUHJvbWlzZSc6XG4gICAgY2FzZSAnU3ltYm9sJzpcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgY2FzZSAnV2Vha01hcCc6XG4gICAgY2FzZSAnV2Vha1NldCc6XG4gICAgY2FzZSAnRXJyb3InOlxuICAgICAgcmV0dXJuIGxlZnRIYW5kT3BlcmFuZCA9PT0gcmlnaHRIYW5kT3BlcmFuZDtcbiAgICBjYXNlICdBcmd1bWVudHMnOlxuICAgIGNhc2UgJ0ludDhBcnJheSc6XG4gICAgY2FzZSAnVWludDhBcnJheSc6XG4gICAgY2FzZSAnVWludDhDbGFtcGVkQXJyYXknOlxuICAgIGNhc2UgJ0ludDE2QXJyYXknOlxuICAgIGNhc2UgJ1VpbnQxNkFycmF5JzpcbiAgICBjYXNlICdJbnQzMkFycmF5JzpcbiAgICBjYXNlICdVaW50MzJBcnJheSc6XG4gICAgY2FzZSAnRmxvYXQzMkFycmF5JzpcbiAgICBjYXNlICdGbG9hdDY0QXJyYXknOlxuICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgIHJldHVybiBpdGVyYWJsZUVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucyk7XG4gICAgY2FzZSAnUmVnRXhwJzpcbiAgICAgIHJldHVybiByZWdleHBFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQpO1xuICAgIGNhc2UgJ0dlbmVyYXRvcic6XG4gICAgICByZXR1cm4gZ2VuZXJhdG9yRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKTtcbiAgICBjYXNlICdEYXRhVmlldyc6XG4gICAgICByZXR1cm4gaXRlcmFibGVFcXVhbChuZXcgVWludDhBcnJheShsZWZ0SGFuZE9wZXJhbmQuYnVmZmVyKSwgbmV3IFVpbnQ4QXJyYXkocmlnaHRIYW5kT3BlcmFuZC5idWZmZXIpLCBvcHRpb25zKTtcbiAgICBjYXNlICdBcnJheUJ1ZmZlcic6XG4gICAgICByZXR1cm4gaXRlcmFibGVFcXVhbChuZXcgVWludDhBcnJheShsZWZ0SGFuZE9wZXJhbmQpLCBuZXcgVWludDhBcnJheShyaWdodEhhbmRPcGVyYW5kKSwgb3B0aW9ucyk7XG4gICAgY2FzZSAnU2V0JzpcbiAgICAgIHJldHVybiBlbnRyaWVzRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKTtcbiAgICBjYXNlICdNYXAnOlxuICAgICAgcmV0dXJuIGVudHJpZXNFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gb2JqZWN0RXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKTtcbiAgfVxufVxuXG4vKiFcbiAqIENvbXBhcmUgdHdvIFJlZ3VsYXIgRXhwcmVzc2lvbnMgZm9yIGVxdWFsaXR5LlxuICpcbiAqIEBwYXJhbSB7UmVnRXhwfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7UmVnRXhwfSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiByZWdleHBFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQpIHtcbiAgcmV0dXJuIGxlZnRIYW5kT3BlcmFuZC50b1N0cmluZygpID09PSByaWdodEhhbmRPcGVyYW5kLnRvU3RyaW5nKCk7XG59XG5cbi8qIVxuICogQ29tcGFyZSB0d28gU2V0cy9NYXBzIGZvciBlcXVhbGl0eS4gRmFzdGVyIHRoYW4gb3RoZXIgZXF1YWxpdHkgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7U2V0fSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7U2V0fSByaWdodEhhbmRPcGVyYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIChPcHRpb25hbClcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIGVudHJpZXNFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIG9wdGlvbnMpIHtcbiAgLy8gSUUxMSBkb2Vzbid0IHN1cHBvcnQgU2V0I2VudHJpZXMgb3IgU2V0I0BAaXRlcmF0b3IsIHNvIHdlIG5lZWQgbWFudWFsbHkgcG9wdWxhdGUgdXNpbmcgU2V0I2ZvckVhY2hcbiAgaWYgKGxlZnRIYW5kT3BlcmFuZC5zaXplICE9PSByaWdodEhhbmRPcGVyYW5kLnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGxlZnRIYW5kT3BlcmFuZC5zaXplID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIGxlZnRIYW5kSXRlbXMgPSBbXTtcbiAgdmFyIHJpZ2h0SGFuZEl0ZW1zID0gW107XG4gIGxlZnRIYW5kT3BlcmFuZC5mb3JFYWNoKGZ1bmN0aW9uIGdhdGhlckVudHJpZXMoa2V5LCB2YWx1ZSkge1xuICAgIGxlZnRIYW5kSXRlbXMucHVzaChbIGtleSwgdmFsdWUgXSk7XG4gIH0pO1xuICByaWdodEhhbmRPcGVyYW5kLmZvckVhY2goZnVuY3Rpb24gZ2F0aGVyRW50cmllcyhrZXksIHZhbHVlKSB7XG4gICAgcmlnaHRIYW5kSXRlbXMucHVzaChbIGtleSwgdmFsdWUgXSk7XG4gIH0pO1xuICByZXR1cm4gaXRlcmFibGVFcXVhbChsZWZ0SGFuZEl0ZW1zLnNvcnQoKSwgcmlnaHRIYW5kSXRlbXMuc29ydCgpLCBvcHRpb25zKTtcbn1cblxuLyohXG4gKiBTaW1wbGUgZXF1YWxpdHkgZm9yIGZsYXQgaXRlcmFibGUgb2JqZWN0cyBzdWNoIGFzIEFycmF5cywgVHlwZWRBcnJheXMgb3IgTm9kZS5qcyBidWZmZXJzLlxuICpcbiAqIEBwYXJhbSB7SXRlcmFibGV9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtJdGVyYWJsZX0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAoT3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBpdGVyYWJsZUVxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwgb3B0aW9ucykge1xuICB2YXIgbGVuZ3RoID0gbGVmdEhhbmRPcGVyYW5kLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCAhPT0gcmlnaHRIYW5kT3BlcmFuZC5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBpbmRleCA9IC0xO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChkZWVwRXF1YWwobGVmdEhhbmRPcGVyYW5kW2luZGV4XSwgcmlnaHRIYW5kT3BlcmFuZFtpbmRleF0sIG9wdGlvbnMpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyohXG4gKiBTaW1wbGUgZXF1YWxpdHkgZm9yIGdlbmVyYXRvciBvYmplY3RzIHN1Y2ggYXMgdGhvc2UgcmV0dXJuZWQgYnkgZ2VuZXJhdG9yIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7SXRlcmFibGV9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gKE9wdGlvbmFsKVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gZ2VuZXJhdG9yRXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKSB7XG4gIHJldHVybiBpdGVyYWJsZUVxdWFsKGdldEdlbmVyYXRvckVudHJpZXMobGVmdEhhbmRPcGVyYW5kKSwgZ2V0R2VuZXJhdG9yRW50cmllcyhyaWdodEhhbmRPcGVyYW5kKSwgb3B0aW9ucyk7XG59XG5cbi8qIVxuICogRGV0ZXJtaW5lIGlmIHRoZSBnaXZlbiBvYmplY3QgaGFzIGFuIEBAaXRlcmF0b3IgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBvYmplY3QgaGFzIGFuIEBAaXRlcmF0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGhhc0l0ZXJhdG9yRnVuY3Rpb24odGFyZ2V0KSB7XG4gIHJldHVybiB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgdGFyZ2V0W1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG59XG5cbi8qIVxuICogR2V0cyBhbGwgaXRlcmF0b3IgZW50cmllcyBmcm9tIHRoZSBnaXZlbiBPYmplY3QuIElmIHRoZSBPYmplY3QgaGFzIG5vIEBAaXRlcmF0b3IgZnVuY3Rpb24sIHJldHVybnMgYW4gZW1wdHkgYXJyYXkuXG4gKiBUaGlzIHdpbGwgY29uc3VtZSB0aGUgaXRlcmF0b3IgLSB3aGljaCBjb3VsZCBoYXZlIHNpZGUgZWZmZWN0cyBkZXBlbmRpbmcgb24gdGhlIEBAaXRlcmF0b3IgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHJldHVybnMge0FycmF5fSBhbiBhcnJheSBvZiBlbnRyaWVzIGZyb20gdGhlIEBAaXRlcmF0b3IgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JFbnRyaWVzKHRhcmdldCkge1xuICBpZiAoaGFzSXRlcmF0b3JGdW5jdGlvbih0YXJnZXQpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnZXRHZW5lcmF0b3JFbnRyaWVzKHRhcmdldFtTeW1ib2wuaXRlcmF0b3JdKCkpO1xuICAgIH0gY2F0Y2ggKGl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtdO1xufVxuXG4vKiFcbiAqIEdldHMgYWxsIGVudHJpZXMgZnJvbSBhIEdlbmVyYXRvci4gVGhpcyB3aWxsIGNvbnN1bWUgdGhlIGdlbmVyYXRvciAtIHdoaWNoIGNvdWxkIGhhdmUgc2lkZSBlZmZlY3RzLlxuICpcbiAqIEBwYXJhbSB7R2VuZXJhdG9yfSB0YXJnZXRcbiAqIEByZXR1cm5zIHtBcnJheX0gYW4gYXJyYXkgb2YgZW50cmllcyBmcm9tIHRoZSBHZW5lcmF0b3IuXG4gKi9cbmZ1bmN0aW9uIGdldEdlbmVyYXRvckVudHJpZXMoZ2VuZXJhdG9yKSB7XG4gIHZhciBnZW5lcmF0b3JSZXN1bHQgPSBnZW5lcmF0b3IubmV4dCgpO1xuICB2YXIgYWNjdW11bGF0b3IgPSBbIGdlbmVyYXRvclJlc3VsdC52YWx1ZSBdO1xuICB3aGlsZSAoZ2VuZXJhdG9yUmVzdWx0LmRvbmUgPT09IGZhbHNlKSB7XG4gICAgZ2VuZXJhdG9yUmVzdWx0ID0gZ2VuZXJhdG9yLm5leHQoKTtcbiAgICBhY2N1bXVsYXRvci5wdXNoKGdlbmVyYXRvclJlc3VsdC52YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG4vKiFcbiAqIEdldHMgYWxsIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUga2V5cyBmcm9tIGEgdGFyZ2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEByZXR1cm5zIHtBcnJheX0gYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBrZXlzIGZyb20gdGhlIHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gZ2V0RW51bWVyYWJsZUtleXModGFyZ2V0KSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiB0YXJnZXQpIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cblxuLyohXG4gKiBEZXRlcm1pbmVzIGlmIHR3byBvYmplY3RzIGhhdmUgbWF0Y2hpbmcgdmFsdWVzLCBnaXZlbiBhIHNldCBvZiBrZXlzLiBEZWZlcnMgdG8gZGVlcEVxdWFsIGZvciB0aGUgZXF1YWxpdHkgY2hlY2sgb2ZcbiAqIGVhY2gga2V5LiBJZiBhbnkgdmFsdWUgb2YgdGhlIGdpdmVuIGtleSBpcyBub3QgZXF1YWwsIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBmYWxzZSAoZWFybHkpLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGxlZnRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtNaXhlZH0gcmlnaHRIYW5kT3BlcmFuZFxuICogQHBhcmFtIHtBcnJheX0ga2V5cyBBbiBhcnJheSBvZiBrZXlzIHRvIGNvbXBhcmUgdGhlIHZhbHVlcyBvZiBsZWZ0SGFuZE9wZXJhbmQgYW5kIHJpZ2h0SGFuZE9wZXJhbmQgYWdhaW5zdFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAoT3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuZnVuY3Rpb24ga2V5c0VxdWFsKGxlZnRIYW5kT3BlcmFuZCwgcmlnaHRIYW5kT3BlcmFuZCwga2V5cywgb3B0aW9ucykge1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGRlZXBFcXVhbChsZWZ0SGFuZE9wZXJhbmRba2V5c1tpXV0sIHJpZ2h0SGFuZE9wZXJhbmRba2V5c1tpXV0sIG9wdGlvbnMpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyohXG4gKiBSZWN1cnNpdmVseSBjaGVjayB0aGUgZXF1YWxpdHkgb2YgdHdvIE9iamVjdHMuIE9uY2UgYmFzaWMgc2FtZW5lc3MgaGFzIGJlZW4gZXN0YWJsaXNoZWQgaXQgd2lsbCBkZWZlciB0byBgZGVlcEVxdWFsYFxuICogZm9yIGVhY2ggZW51bWVyYWJsZSBrZXkgaW4gdGhlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBsZWZ0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7TWl4ZWR9IHJpZ2h0SGFuZE9wZXJhbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gKE9wdGlvbmFsKVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gb2JqZWN0RXF1YWwobGVmdEhhbmRPcGVyYW5kLCByaWdodEhhbmRPcGVyYW5kLCBvcHRpb25zKSB7XG4gIHZhciBsZWZ0SGFuZEtleXMgPSBnZXRFbnVtZXJhYmxlS2V5cyhsZWZ0SGFuZE9wZXJhbmQpO1xuICB2YXIgcmlnaHRIYW5kS2V5cyA9IGdldEVudW1lcmFibGVLZXlzKHJpZ2h0SGFuZE9wZXJhbmQpO1xuICBpZiAobGVmdEhhbmRLZXlzLmxlbmd0aCAmJiBsZWZ0SGFuZEtleXMubGVuZ3RoID09PSByaWdodEhhbmRLZXlzLmxlbmd0aCkge1xuICAgIGxlZnRIYW5kS2V5cy5zb3J0KCk7XG4gICAgcmlnaHRIYW5kS2V5cy5zb3J0KCk7XG4gICAgaWYgKGl0ZXJhYmxlRXF1YWwobGVmdEhhbmRLZXlzLCByaWdodEhhbmRLZXlzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGtleXNFcXVhbChsZWZ0SGFuZE9wZXJhbmQsIHJpZ2h0SGFuZE9wZXJhbmQsIGxlZnRIYW5kS2V5cywgb3B0aW9ucyk7XG4gIH1cblxuICB2YXIgbGVmdEhhbmRFbnRyaWVzID0gZ2V0SXRlcmF0b3JFbnRyaWVzKGxlZnRIYW5kT3BlcmFuZCk7XG4gIHZhciByaWdodEhhbmRFbnRyaWVzID0gZ2V0SXRlcmF0b3JFbnRyaWVzKHJpZ2h0SGFuZE9wZXJhbmQpO1xuICBpZiAobGVmdEhhbmRFbnRyaWVzLmxlbmd0aCAmJiBsZWZ0SGFuZEVudHJpZXMubGVuZ3RoID09PSByaWdodEhhbmRFbnRyaWVzLmxlbmd0aCkge1xuICAgIGxlZnRIYW5kRW50cmllcy5zb3J0KCk7XG4gICAgcmlnaHRIYW5kRW50cmllcy5zb3J0KCk7XG4gICAgcmV0dXJuIGl0ZXJhYmxlRXF1YWwobGVmdEhhbmRFbnRyaWVzLCByaWdodEhhbmRFbnRyaWVzLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChsZWZ0SGFuZEtleXMubGVuZ3RoID09PSAwICYmXG4gICAgICBsZWZ0SGFuZEVudHJpZXMubGVuZ3RoID09PSAwICYmXG4gICAgICByaWdodEhhbmRLZXlzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgcmlnaHRIYW5kRW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyohXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGFyZ3VtZW50IGlzIGEgcHJpbWl0aXZlLlxuICpcbiAqIFRoaXMgaW50ZW50aW9uYWxseSByZXR1cm5zIHRydWUgZm9yIGFsbCBvYmplY3RzIHRoYXQgY2FuIGJlIGNvbXBhcmVkIGJ5IHJlZmVyZW5jZSxcbiAqIGluY2x1ZGluZyBmdW5jdGlvbnMgYW5kIHN5bWJvbHMuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jztcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgZGVlcEVxdWFsID0gcmVxdWlyZSgnZGVlcC1lcWwnKVxudmFyIHR5cGUgPSByZXF1aXJlKCd0eXBlLWRldGVjdCcpXG5cbnZhciBERUZBVUxUX1RPTEVSQU5DRSA9IDFlLTZcblxuLyoqXG4gKiBzbWFsbCB1dGlsaXR5IGZ1bmN0aW9uc1xuICovXG5mdW5jdGlvbiBpc051bWJlciAodmFsKSB7XG4gIHJldHVybiB0eXBlKHZhbCkgPT09ICdudW1iZXInXG59XG5cbmZ1bmN0aW9uIGJvdGhOdW1iZXJzIChsZWZ0LCByaWdodCkge1xuICByZXR1cm4gaXNOdW1iZXIocmlnaHQpICYmIGlzTnVtYmVyKGxlZnQpXG59XG5cbmZ1bmN0aW9uIGFsbW9zdEVxdWFsIChsZWZ0LCByaWdodCwgdG9sKSB7XG4gIHJldHVybiBNYXRoLmFicyhsZWZ0IC0gcmlnaHQpIDw9IHRvbFxufVxuXG4vKipcbiAqIE1ha2VzIGEgY29tcGFyYXRvciBmdW5jdGlvbiB0byBiZSBwYXNzZWQgdG8gZGVlcEVxdWFsLlxuICogVGhlIHJldHVybmVkIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIG51bGwgaWYgYm90aCBhcmd1bWVudHMgYXJlIG5vdCBudW1iZXJzLFxuICogaW5kaWNhdGluZyB0aGF0IGRlZXBFcXVhbCBzaG91bGQgcHJvY2VlZCB3aXRoIG90aGVyIGVxdWFsaXR5IGNoZWNrc1xuICovXG5mdW5jdGlvbiBjb21wYXJhdG9yICh0b2xlcmFuY2UpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgIGlmIChib3RoTnVtYmVycyhsZWZ0LCByaWdodCkpIHtcbiAgICAgIHJldHVybiBhbG1vc3RFcXVhbChsZWZ0LCByaWdodCwgdG9sZXJhbmNlKVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbi8qKlxuICogU2V0cyBnbG9iYWwgdG9sZXJhbmNlIGFuZCByZXR1cm5zIGEgZnVuY3Rpb24gdG8gYmUgcGFzc2VkIHRvIGNoYWkudXNlXG4gKiBAc2VlIGh0dHA6Ly9jaGFpanMuY29tL2d1aWRlL3BsdWdpbnMvXG4gKi9cbmZ1bmN0aW9uIGNoYWlBbG1vc3QgKGN1c3RvbVRvbGVyYW5jZSkge1xuICB2YXIgc3RhbmRhcmRUb2xlcmFuY2UgPSBjdXN0b21Ub2xlcmFuY2UgfHwgREVGQVVMVF9UT0xFUkFOQ0VcblxuICByZXR1cm4gZnVuY3Rpb24gKGNoYWksIHV0aWxzKSB7XG4gICAgdmFyIEFzc2VydGlvbiA9IGNoYWkuQXNzZXJ0aW9uXG4gICAgdmFyIGZsYWcgPSB1dGlscy5mbGFnXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHNoYWxsb3cgZXF1YWxpdHkgZnVuY3Rpb24gdG8gb3ZlcnJpZGVcbiAgICAgKiAuZXF1YWwsIC5lcXVhbHMsIC5lcSB0aGF0IHRlc3RzICdhbG1vc3QnIGVxdWFsaXR5XG4gICAgICogaWYgYm90aCB2YWx1ZXMgYXJlIG51bWJlcnMgYW5kIGEgJ3RvbGVyYW5jZScgZmxhZyBpcyBzZXQuXG4gICAgICogU2VuZHMgdG8gZGVlcCBlcXVhbGl0eSBjaGVjayBpZiBkZWVwIGZsYWcgaXMgc2V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gb3ZlcnJpZGVBc3NlcnRFcXVhbCAoX3N1cGVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gYXNzZXJ0RXF1YWwgKHZhbCwgbXNnKSB7XG4gICAgICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpXG5cbiAgICAgICAgdmFyIGRlZXAgPSBmbGFnKHRoaXMsICdkZWVwJylcbiAgICAgICAgdmFyIHRvbGVyYW5jZSA9IGZsYWcodGhpcywgJ3RvbGVyYW5jZScpXG5cbiAgICAgICAgaWYgKGRlZXApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lcWwodmFsKVxuICAgICAgICB9IGVsc2UgaWYgKHRvbGVyYW5jZSAmJiBib3RoTnVtYmVycyh2YWwsIHRoaXMuX29iaikpIHtcbiAgICAgICAgICB0aGlzLmFzc2VydChhbG1vc3RFcXVhbCh2YWwsIHRoaXMuX29iaiwgdG9sZXJhbmNlKSxcbiAgICAgICAgICAgICdleHBlY3RlZCAje3RoaXN9IHRvIGFsbW9zdCBlcXVhbCAje2V4cH0nLFxuICAgICAgICAgICAgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGFsbW9zdCBlcXVhbCAje2V4cH0nLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgdGhpcy5fb2JqLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgZGVlcCBlcXVhbGl0eSBmdW5jdGlvbiB0byBvdmVycmlkZVxuICAgICAqIC5lcWwsIC5lcWxzIHRoYXQgdGVzdHMgJ2FsbW9zdCcgZXF1YWxpdHkgaWYgYm90aCBjb3JyZXNwb25kaW5nXG4gICAgICogdmFsdWVzIGFyZSBudW1iZXJzIGFuZCB0b2xlcmFuY2UgZmxhZyBpcyBzZXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvdmVycmlkZUFzc2VydEVxbCAoX3N1cGVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gYXNzZXJ0RXFsICh2YWwsIG1zZykge1xuICAgICAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKVxuXG4gICAgICAgIHZhciB0b2xlcmFuY2UgPSBmbGFnKHRoaXMsICd0b2xlcmFuY2UnKVxuXG4gICAgICAgIGlmICh0b2xlcmFuY2UpIHtcbiAgICAgICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICAgIGRlZXBFcXVhbCh2YWwsIHRoaXMuX29iaiwgeyBjb21wYXJhdG9yOiBjb21wYXJhdG9yKHRvbGVyYW5jZSkgfSksXG4gICAgICAgICAgICAnZXhwZWN0ZWQgI3t0aGlzfSB0byBkZWVwbHkgYWxtb3N0IGVxdWFsICN7ZXhwfScsXG4gICAgICAgICAgICAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgZGVlcGx5IGFsbW9zdCBlcXVhbCAje2V4cH0nLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgdGhpcy5fb2JqLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIC5hbG1vc3QoKSBtZXRob2QuIFRvIGJlIHVzZWQgYXQgdGhlIGVuZCBvZiB0aGUgY2hhaW4gbGlrZTpcbiAgICAgKiBleHBlY3QoNCkudG8ubm90LmJlLmFsbW9zdCg1LCAxLjUpLiBTaW1wbHkgYWRkcyB0b2xlcmFuY2UgZmxhZyB0aGVuIGNhbGxzXG4gICAgICogLmVxdWFsLiBUaGlzIHdpbGwgcmVkaXJlY3QgdG8gLmVxbCBpZiBkZWVwIGZsYWcgc2V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWV0aG9kICh2YWwsIHRvbGVyYW5jZU92ZXJyaWRlKSB7XG4gICAgICB2YXIgdG9sZXJhbmNlID0gdG9sZXJhbmNlT3ZlcnJpZGUgfHwgc3RhbmRhcmRUb2xlcmFuY2VcblxuICAgICAgZmxhZyh0aGlzLCAndG9sZXJhbmNlJywgdG9sZXJhbmNlKVxuXG4gICAgICByZXR1cm4gdGhpcy5lcXVhbCh2YWwpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogLmFsbW9zdCBjaGFpbmFibGUgcHJvcGVydHkgdG8gYmUgdXNlZCBsaWtlOlxuICAgICAqIGV4cGVjdCgzLjk5OTk5OTk5KS50by5hbG1vc3QuZXF1YWwoNCkuIFNpbXBseSBhZGRzXG4gICAgICogdG9sZXJhbmNlIGZsYWcgdG8gYmUgcmVhZCBieSBlcXVhbGl0eSBjaGVja2luZyBtZXRob2RzXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hhaW5pbmdCZWhhdmlvciAoKSB7XG4gICAgICBmbGFnKHRoaXMsICd0b2xlcmFuY2UnLCBzdGFuZGFyZFRvbGVyYW5jZSlcbiAgICB9XG5cbiAgICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdhbG1vc3QnLCBtZXRob2QsIGNoYWluaW5nQmVoYXZpb3IpXG5cbiAgICBBc3NlcnRpb24ub3ZlcndyaXRlTWV0aG9kKCdlcXVhbCcsIG92ZXJyaWRlQXNzZXJ0RXF1YWwpXG4gICAgQXNzZXJ0aW9uLm92ZXJ3cml0ZU1ldGhvZCgnZXF1YWxzJywgb3ZlcnJpZGVBc3NlcnRFcXVhbClcbiAgICBBc3NlcnRpb24ub3ZlcndyaXRlTWV0aG9kKCdlcScsIG92ZXJyaWRlQXNzZXJ0RXF1YWwpXG5cbiAgICBBc3NlcnRpb24ub3ZlcndyaXRlTWV0aG9kKCdlcWwnLCBvdmVycmlkZUFzc2VydEVxbClcbiAgICBBc3NlcnRpb24ub3ZlcndyaXRlTWV0aG9kKCdlcWxzJywgb3ZlcnJpZGVBc3NlcnRFcWwpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGFpQWxtb3N0XG4iLCIvKmdsb2JhbHMgZGVmaW5lLCBtb2R1bGUsIFN5bWJvbCAqL1xuLypqc2hpbnQgLVcwNTYgKi9cblxuKGZ1bmN0aW9uIChnbG9iYWxzKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgc3RyaW5ncywgbWVzc2FnZXMsIHByZWRpY2F0ZXMsIGZ1bmN0aW9ucywgYXNzZXJ0LCBub3QsIG1heWJlLFxuICAgICAgY29sbGVjdGlvbnMsIHNsaWNlLCBuZWdpbmYsIHBvc2luZiwgaXNBcnJheSwgaGF2ZVN5bWJvbHM7XG5cbiAgc3RyaW5ncyA9IHtcbiAgICB2OiAndmFsdWUnLFxuICAgIG46ICdudW1iZXInLFxuICAgIHM6ICdzdHJpbmcnLFxuICAgIGI6ICdib29sZWFuJyxcbiAgICBvOiAnb2JqZWN0JyxcbiAgICB0OiAndHlwZScsXG4gICAgYTogJ2FycmF5JyxcbiAgICBhbDogJ2FycmF5LWxpa2UnLFxuICAgIGk6ICdpdGVyYWJsZScsXG4gICAgZDogJ2RhdGUnLFxuICAgIGY6ICdmdW5jdGlvbicsXG4gICAgbDogJ2xlbmd0aCdcbiAgfTtcblxuICBtZXNzYWdlcyA9IHt9O1xuICBwcmVkaWNhdGVzID0ge307XG5cbiAgW1xuICAgIHsgbjogJ2VxdWFsJywgZjogZXF1YWwsIHM6ICd2JyB9LFxuICAgIHsgbjogJ3VuZGVmaW5lZCcsIGY6IGlzVW5kZWZpbmVkLCBzOiAndicgfSxcbiAgICB7IG46ICdudWxsJywgZjogaXNOdWxsLCBzOiAndicgfSxcbiAgICB7IG46ICdhc3NpZ25lZCcsIGY6IGFzc2lnbmVkLCBzOiAndicgfSxcbiAgICB7IG46ICdwcmltaXRpdmUnLCBmOiBwcmltaXRpdmUsIHM6ICd2JyB9LFxuICAgIHsgbjogJ2luY2x1ZGVzJywgZjogaW5jbHVkZXMsIHM6ICd2JyB9LFxuICAgIHsgbjogJ3plcm8nLCBmOiB6ZXJvIH0sXG4gICAgeyBuOiAnaW5maW5pdHknLCBmOiBpbmZpbml0eSB9LFxuICAgIHsgbjogJ251bWJlcicsIGY6IG51bWJlciB9LFxuICAgIHsgbjogJ2ludGVnZXInLCBmOiBpbnRlZ2VyIH0sXG4gICAgeyBuOiAnZXZlbicsIGY6IGV2ZW4gfSxcbiAgICB7IG46ICdvZGQnLCBmOiBvZGQgfSxcbiAgICB7IG46ICdncmVhdGVyJywgZjogZ3JlYXRlciB9LFxuICAgIHsgbjogJ2xlc3MnLCBmOiBsZXNzIH0sXG4gICAgeyBuOiAnYmV0d2VlbicsIGY6IGJldHdlZW4gfSxcbiAgICB7IG46ICdncmVhdGVyT3JFcXVhbCcsIGY6IGdyZWF0ZXJPckVxdWFsIH0sXG4gICAgeyBuOiAnbGVzc09yRXF1YWwnLCBmOiBsZXNzT3JFcXVhbCB9LFxuICAgIHsgbjogJ2luUmFuZ2UnLCBmOiBpblJhbmdlIH0sXG4gICAgeyBuOiAncG9zaXRpdmUnLCBmOiBwb3NpdGl2ZSB9LFxuICAgIHsgbjogJ25lZ2F0aXZlJywgZjogbmVnYXRpdmUgfSxcbiAgICB7IG46ICdzdHJpbmcnLCBmOiBzdHJpbmcsIHM6ICdzJyB9LFxuICAgIHsgbjogJ2VtcHR5U3RyaW5nJywgZjogZW1wdHlTdHJpbmcsIHM6ICdzJyB9LFxuICAgIHsgbjogJ25vbkVtcHR5U3RyaW5nJywgZjogbm9uRW1wdHlTdHJpbmcsIHM6ICdzJyB9LFxuICAgIHsgbjogJ2NvbnRhaW5zJywgZjogY29udGFpbnMsIHM6ICdzJyB9LFxuICAgIHsgbjogJ21hdGNoJywgZjogbWF0Y2gsIHM6ICdzJyB9LFxuICAgIHsgbjogJ2Jvb2xlYW4nLCBmOiBib29sZWFuLCBzOiAnYicgfSxcbiAgICB7IG46ICdvYmplY3QnLCBmOiBvYmplY3QsIHM6ICdvJyB9LFxuICAgIHsgbjogJ2VtcHR5T2JqZWN0JywgZjogZW1wdHlPYmplY3QsIHM6ICdvJyB9LFxuICAgIHsgbjogJ25vbkVtcHR5T2JqZWN0JywgZjogbm9uRW1wdHlPYmplY3QsIHM6ICdvJyB9LFxuICAgIHsgbjogJ2luc3RhbmNlU3RyaWN0JywgZjogaW5zdGFuY2VTdHJpY3QsIHM6ICd0JyB9LFxuICAgIHsgbjogJ2luc3RhbmNlJywgZjogaW5zdGFuY2UsIHM6ICd0JyB9LFxuICAgIHsgbjogJ2xpa2UnLCBmOiBsaWtlLCBzOiAndCcgfSxcbiAgICB7IG46ICdhcnJheScsIGY6IGFycmF5LCBzOiAnYScgfSxcbiAgICB7IG46ICdlbXB0eUFycmF5JywgZjogZW1wdHlBcnJheSwgczogJ2EnIH0sXG4gICAgeyBuOiAnbm9uRW1wdHlBcnJheScsIGY6IG5vbkVtcHR5QXJyYXksIHM6ICdhJyB9LFxuICAgIHsgbjogJ2FycmF5TGlrZScsIGY6IGFycmF5TGlrZSwgczogJ2FsJyB9LFxuICAgIHsgbjogJ2l0ZXJhYmxlJywgZjogaXRlcmFibGUsIHM6ICdpJyB9LFxuICAgIHsgbjogJ2RhdGUnLCBmOiBkYXRlLCBzOiAnZCcgfSxcbiAgICB7IG46ICdmdW5jdGlvbicsIGY6IGlzRnVuY3Rpb24sIHM6ICdmJyB9LFxuICAgIHsgbjogJ2hhc0xlbmd0aCcsIGY6IGhhc0xlbmd0aCwgczogJ2wnIH0sXG4gIF0ubWFwKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIG4gPSBkYXRhLm47XG4gICAgbWVzc2FnZXNbbl0gPSAnSW52YWxpZCAnICsgc3RyaW5nc1tkYXRhLnMgfHwgJ24nXTtcbiAgICBwcmVkaWNhdGVzW25dID0gZGF0YS5mO1xuICB9KTtcblxuICBmdW5jdGlvbnMgPSB7XG4gICAgYXBwbHk6IGFwcGx5LFxuICAgIG1hcDogbWFwLFxuICAgIGFsbDogYWxsLFxuICAgIGFueTogYW55XG4gIH07XG5cbiAgY29sbGVjdGlvbnMgPSBbICdhcnJheScsICdhcnJheUxpa2UnLCAnaXRlcmFibGUnLCAnb2JqZWN0JyBdO1xuICBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbiAgbmVnaW5mID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICBwb3NpbmYgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuICBoYXZlU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbic7XG5cbiAgZnVuY3Rpb25zID0gbWl4aW4oZnVuY3Rpb25zLCBwcmVkaWNhdGVzKTtcbiAgYXNzZXJ0ID0gY3JlYXRlTW9kaWZpZWRQcmVkaWNhdGVzKGFzc2VydE1vZGlmaWVyLCBhc3NlcnRJbXBsKTtcbiAgbm90ID0gY3JlYXRlTW9kaWZpZWRQcmVkaWNhdGVzKG5vdE1vZGlmaWVyLCBub3RJbXBsKTtcbiAgbWF5YmUgPSBjcmVhdGVNb2RpZmllZFByZWRpY2F0ZXMobWF5YmVNb2RpZmllciwgbWF5YmVJbXBsKTtcbiAgYXNzZXJ0Lm5vdCA9IGNyZWF0ZU1vZGlmaWVkTW9kaWZpZXIoYXNzZXJ0TW9kaWZpZXIsIG5vdCk7XG4gIGFzc2VydC5tYXliZSA9IGNyZWF0ZU1vZGlmaWVkTW9kaWZpZXIoYXNzZXJ0TW9kaWZpZXIsIG1heWJlKTtcblxuICBjb2xsZWN0aW9ucy5mb3JFYWNoKGNyZWF0ZU9mUHJlZGljYXRlcyk7XG4gIGNyZWF0ZU9mTW9kaWZpZXJzKGFzc2VydCwgYXNzZXJ0TW9kaWZpZXIpO1xuICBjcmVhdGVPZk1vZGlmaWVycyhub3QsIG5vdE1vZGlmaWVyKTtcbiAgY29sbGVjdGlvbnMuZm9yRWFjaChjcmVhdGVNYXliZU9mTW9kaWZpZXJzKTtcblxuICBleHBvcnRGdW5jdGlvbnMobWl4aW4oZnVuY3Rpb25zLCB7XG4gICAgYXNzZXJ0OiBhc3NlcnQsXG4gICAgbm90OiBub3QsXG4gICAgbWF5YmU6IG1heWJlXG4gIH0pKTtcblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBlcXVhbGAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgbGhzYCBhbmQgYHJoc2AgYXJlIHN0cmljdGx5IGVxdWFsLCB3aXRob3V0IGNvZXJjaW9uLlxuICAgKiBSZXR1cm5zIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGVxdWFsIChsaHMsIHJocykge1xuICAgIHJldHVybiBsaHMgPT09IHJocztcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgdW5kZWZpbmVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBpc1VuZGVmaW5lZCAoZGF0YSkge1xuICAgIHJldHVybiBkYXRhID09PSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBudWxsYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBudWxsLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBpc051bGwgKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YSA9PT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYGFzc2lnbmVkYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBub3QgbnVsbCBvciB1bmRlZmluZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGFzc2lnbmVkIChkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEgIT09IHVuZGVmaW5lZCAmJiBkYXRhICE9PSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgcHJpbWl0aXZlYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBhIHByaW1pdGl2ZSB0eXBlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBwcmltaXRpdmUgKGRhdGEpIHtcbiAgICB2YXIgdHlwZTtcblxuICAgIHN3aXRjaCAoZGF0YSkge1xuICAgICAgY2FzZSBudWxsOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICBjYXNlIGZhbHNlOlxuICAgICAgY2FzZSB0cnVlOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0eXBlID0gdHlwZW9mIGRhdGE7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInIHx8IChoYXZlU3ltYm9scyAmJiB0eXBlID09PSAnc3ltYm9sJyk7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGB6ZXJvYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyB6ZXJvLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiB6ZXJvIChkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEgPT09IDA7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBpbmZpbml0eWAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgcG9zaXRpdmUgb3IgbmVnYXRpdmUgaW5maW5pdHksIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGluZmluaXR5IChkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEgPT09IG5lZ2luZiB8fCBkYXRhID09PSBwb3NpbmY7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBudW1iZXJgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGEgbnVtYmVyLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBudW1iZXIgKGRhdGEpIHtcbiAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09ICdudW1iZXInICYmIGRhdGEgPiBuZWdpbmYgJiYgZGF0YSA8IHBvc2luZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYGludGVnZXJgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGFuIGludGVnZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGludGVnZXIgKGRhdGEpIHtcbiAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09ICdudW1iZXInICYmIGRhdGEgJSAxID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgZXZlbmAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYW4gZXZlbiBudW1iZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGV2ZW4gKGRhdGEpIHtcbiAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09ICdudW1iZXInICYmIGRhdGEgJSAyID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgb2RkYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBhbiBvZGQgbnVtYmVyLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBvZGQgKGRhdGEpIHtcbiAgICByZXR1cm4gaW50ZWdlcihkYXRhKSAmJiBkYXRhICUgMiAhPT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYGdyZWF0ZXJgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGxoc2AgaXMgYSBudW1iZXIgZ3JlYXRlciB0aGFuIGByaHNgLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBncmVhdGVyIChsaHMsIHJocykge1xuICAgIHJldHVybiBudW1iZXIobGhzKSAmJiBsaHMgPiByaHM7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBsZXNzYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBsaHNgIGlzIGEgbnVtYmVyIGxlc3MgdGhhbiBgcmhzYCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gbGVzcyAobGhzLCByaHMpIHtcbiAgICByZXR1cm4gbnVtYmVyKGxocykgJiYgbGhzIDwgcmhzO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgYmV0d2VlbmAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYSBudW1iZXIgYmV0d2VlbiBgeGAgYW5kIGB5YCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gYmV0d2VlbiAoZGF0YSwgeCwgeSkge1xuICAgIGlmICh4IDwgeSkge1xuICAgICAgcmV0dXJuIGdyZWF0ZXIoZGF0YSwgeCkgJiYgZGF0YSA8IHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlc3MoZGF0YSwgeCkgJiYgZGF0YSA+IHk7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBncmVhdGVyT3JFcXVhbGAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgbGhzYCBpcyBhIG51bWJlciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYHJoc2AsIGZhbHNlXG4gICAqIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGdyZWF0ZXJPckVxdWFsIChsaHMsIHJocykge1xuICAgIHJldHVybiBudW1iZXIobGhzKSAmJiBsaHMgPj0gcmhzO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgbGVzc09yRXF1YWxgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGxoc2AgaXMgYSBudW1iZXIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGByaHNgLCBmYWxzZVxuICAgKiBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBsZXNzT3JFcXVhbCAobGhzLCByaHMpIHtcbiAgICByZXR1cm4gbnVtYmVyKGxocykgJiYgbGhzIDw9IHJocztcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYGluUmFuZ2VgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGEgbnVtYmVyIGluIHRoZSByYW5nZSBgeC4ueWAsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGluUmFuZ2UgKGRhdGEsIHgsIHkpIHtcbiAgICBpZiAoeCA8IHkpIHtcbiAgICAgIHJldHVybiBncmVhdGVyT3JFcXVhbChkYXRhLCB4KSAmJiBkYXRhIDw9IHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlc3NPckVxdWFsKGRhdGEsIHgpICYmIGRhdGEgPj0geTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYHBvc2l0aXZlYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBhIHBvc2l0aXZlIG51bWJlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gcG9zaXRpdmUgKGRhdGEpIHtcbiAgICByZXR1cm4gZ3JlYXRlcihkYXRhLCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYG5lZ2F0aXZlYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBhIG5lZ2F0aXZlIG51bWJlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gbmVnYXRpdmUgKGRhdGEpIHtcbiAgICByZXR1cm4gbGVzcyhkYXRhLCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYHN0cmluZ2AuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYSBzdHJpbmcsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmluZyAoZGF0YSkge1xuICAgIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZyc7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBlbXB0eVN0cmluZ2AuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgdGhlIGVtcHR5IHN0cmluZywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gZW1wdHlTdHJpbmcgKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YSA9PT0gJyc7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBub25FbXB0eVN0cmluZ2AuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYSBub24tZW1wdHkgc3RyaW5nLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBub25FbXB0eVN0cmluZyAoZGF0YSkge1xuICAgIHJldHVybiBzdHJpbmcoZGF0YSkgJiYgZGF0YSAhPT0gJyc7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBjb250YWluc2AuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYSBzdHJpbmcgdGhhdCBjb250YWlucyBgc3Vic3RyaW5nYCwgZmFsc2VcbiAgICogb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gY29udGFpbnMgKGRhdGEsIHN1YnN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcoZGF0YSkgJiYgZGF0YS5pbmRleE9mKHN1YnN0cmluZykgIT09IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgbWF0Y2hgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGEgc3RyaW5nIHRoYXQgbWF0Y2hlcyBgcmVnZXhgLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBtYXRjaCAoZGF0YSwgcmVnZXgpIHtcbiAgICByZXR1cm4gc3RyaW5nKGRhdGEpICYmICEhIGRhdGEubWF0Y2gocmVnZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgYm9vbGVhbmAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYSBib29sZWFuIHZhbHVlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBib29sZWFuIChkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEgPT09IGZhbHNlIHx8IGRhdGEgPT09IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBvYmplY3RgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGEgcGxhaW4tb2xkIEpTIG9iamVjdCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gb2JqZWN0IChkYXRhKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBlbXB0eU9iamVjdGAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYW4gZW1wdHkgb2JqZWN0LCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBlbXB0eU9iamVjdCAoZGF0YSkge1xuICAgIHJldHVybiBvYmplY3QoZGF0YSkgJiYgT2JqZWN0LmtleXMoZGF0YSkubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgbm9uRW1wdHlPYmplY3RgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGEgbm9uLWVtcHR5IG9iamVjdCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gbm9uRW1wdHlPYmplY3QgKGRhdGEpIHtcbiAgICByZXR1cm4gb2JqZWN0KGRhdGEpICYmIE9iamVjdC5rZXlzKGRhdGEpLmxlbmd0aCA+IDA7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBpbnN0YW5jZVN0cmljdGAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYW4gaW5zdGFuY2Ugb2YgYHByb3RvdHlwZWAsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGluc3RhbmNlU3RyaWN0IChkYXRhLCBwcm90b3R5cGUpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBwcm90b3R5cGU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBpbnN0YW5jZWAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYW4gaW5zdGFuY2Ugb2YgYHByb3RvdHlwZWAsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogRmFsbHMgYmFjayB0byB0ZXN0aW5nIGNvbnN0cnVjdG9yLm5hbWUgYW5kIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgICogaWYgdGhlIGluaXRpYWwgaW5zdGFuY2VvZiB0ZXN0IGZhaWxzLlxuICAgKi9cbiAgZnVuY3Rpb24gaW5zdGFuY2UgKGRhdGEsIHByb3RvdHlwZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2VTdHJpY3QoZGF0YSwgcHJvdG90eXBlKSB8fFxuICAgICAgICBkYXRhLmNvbnN0cnVjdG9yLm5hbWUgPT09IHByb3RvdHlwZS5uYW1lIHx8XG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgJyArIHByb3RvdHlwZS5uYW1lICsgJ10nO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgbGlrZWAuXG4gICAqXG4gICAqIFRlc3RzIHdoZXRoZXIgYGRhdGFgICdxdWFja3MgbGlrZSBhIGR1Y2snLiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGhhcyBhbGxcbiAgICogb2YgdGhlIHByb3BlcnRpZXMgb2YgYGFyY2hldHlwZWAgKHRoZSAnZHVjaycpLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBsaWtlIChkYXRhLCBhcmNoZXR5cGUpIHtcbiAgICB2YXIgbmFtZTtcblxuICAgIGZvciAobmFtZSBpbiBhcmNoZXR5cGUpIHtcbiAgICAgIGlmIChhcmNoZXR5cGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkobmFtZSkgPT09IGZhbHNlIHx8IHR5cGVvZiBkYXRhW25hbWVdICE9PSB0eXBlb2YgYXJjaGV0eXBlW25hbWVdKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9iamVjdChkYXRhW25hbWVdKSAmJiBsaWtlKGRhdGFbbmFtZV0sIGFyY2hldHlwZVtuYW1lXSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBhcnJheWAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYW4gYXJyYXksIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5IChkYXRhKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkoZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBlbXB0eUFycmF5YC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBhbiBlbXB0eSBhcnJheSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gZW1wdHlBcnJheSAoZGF0YSkge1xuICAgIHJldHVybiBhcnJheShkYXRhKSAmJiBkYXRhLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYG5vbkVtcHR5QXJyYXlgLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGEgbm9uLWVtcHR5IGFycmF5LCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBub25FbXB0eUFycmF5IChkYXRhKSB7XG4gICAgcmV0dXJuIGFycmF5KGRhdGEpICYmIGdyZWF0ZXIoZGF0YS5sZW5ndGgsIDApO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgYXJyYXlMaWtlYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlMaWtlIChkYXRhKSB7XG4gICAgcmV0dXJuIGFzc2lnbmVkKGRhdGEpICYmIGdyZWF0ZXJPckVxdWFsKGRhdGEubGVuZ3RoLCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYGl0ZXJhYmxlYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBpcyBhbiBpdGVyYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gaXRlcmFibGUgKGRhdGEpIHtcbiAgICBpZiAoISBoYXZlU3ltYm9scykge1xuICAgICAgLy8gRmFsbCBiYWNrIHRvIGBhcnJheUxpa2VgIHByZWRpY2F0ZSBpbiBwcmUtRVM2IGVudmlyb25tZW50cy5cbiAgICAgIHJldHVybiBhcnJheUxpa2UoZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFzc2lnbmVkKGRhdGEpICYmIGlzRnVuY3Rpb24oZGF0YVtTeW1ib2wuaXRlcmF0b3JdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYGluY2x1ZGVzYC5cbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIGBkYXRhYCBjb250YWlucyBgdmFsdWVgLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBpbmNsdWRlcyAoZGF0YSwgdmFsdWUpIHtcbiAgICB2YXIgaXRlcmF0b3IsIGl0ZXJhdGlvbiwga2V5cywgbGVuZ3RoLCBpO1xuXG4gICAgaWYgKCEgYXNzaWduZWQoZGF0YSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaGF2ZVN5bWJvbHMgJiYgZGF0YVtTeW1ib2wuaXRlcmF0b3JdICYmIGlzRnVuY3Rpb24oZGF0YS52YWx1ZXMpKSB7XG4gICAgICBpdGVyYXRvciA9IGRhdGEudmFsdWVzKCk7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaXRlcmF0aW9uID0gaXRlcmF0b3IubmV4dCgpO1xuXG4gICAgICAgIGlmIChpdGVyYXRpb24udmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKCEgaXRlcmF0aW9uLmRvbmUpO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGRhdGFba2V5c1tpXV0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgZnVuY3Rpb24gYGhhc0xlbmd0aGAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaGFzIGEgbGVuZ3RoIHByb3BlcnR5IHRoYXQgZXF1YWxzIGBsZW5ndGhgLCBmYWxzZVxuICAgKiBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBoYXNMZW5ndGggKGRhdGEsIGxlbmd0aCkge1xuICAgIHJldHVybiBhc3NpZ25lZChkYXRhKSAmJiBkYXRhLmxlbmd0aCA9PT0gbGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgZGF0ZWAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgZGF0YWAgaXMgYSB2YWxpZCBkYXRlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBmdW5jdGlvbiBkYXRlIChkYXRhKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlU3RyaWN0KGRhdGEsIERhdGUpICYmIGludGVnZXIoZGF0YS5nZXRUaW1lKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgZnVuY3Rpb25gLlxuICAgKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYGRhdGFgIGlzIGEgZnVuY3Rpb24sIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGlzRnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBhcHBseWAuXG4gICAqXG4gICAqIE1hcHMgZWFjaCB2YWx1ZSBmcm9tIHRoZSBgZGF0YWAgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcHJlZGljYXRlIGFuZCByZXR1cm5zXG4gICAqIHRoZSByZXN1bHQgYXJyYXkuIElmIHRoZSBzYW1lIGZ1bmN0aW9uIGlzIHRvIGJlIGFwcGxpZWQgYWNyb3NzIGFsbCBvZiB0aGVcbiAgICogZGF0YSwgYSBzaW5nbGUgcHJlZGljYXRlIGZ1bmN0aW9uIG1heSBiZSBwYXNzZWQgaW4uXG4gICAqXG4gICAqL1xuICBmdW5jdGlvbiBhcHBseSAoZGF0YSwgcHJlZGljYXRlcykge1xuICAgIGFzc2VydC5hcnJheShkYXRhKTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKHByZWRpY2F0ZXMpKSB7XG4gICAgICByZXR1cm4gZGF0YS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGVzKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzc2VydC5hcnJheShwcmVkaWNhdGVzKTtcbiAgICBhc3NlcnQuaGFzTGVuZ3RoKGRhdGEsIHByZWRpY2F0ZXMubGVuZ3RoKTtcblxuICAgIHJldHVybiBkYXRhLm1hcChmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcHJlZGljYXRlc1tpbmRleF0odmFsdWUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBmdW5jdGlvbiBgbWFwYC5cbiAgICpcbiAgICogTWFwcyBlYWNoIHZhbHVlIGZyb20gdGhlIGBkYXRhYCB0byB0aGUgY29ycmVzcG9uZGluZyBwcmVkaWNhdGUgYW5kIHJldHVybnNcbiAgICogdGhlIHJlc3VsdCBvYmplY3QuIFN1cHBvcnRzIG5lc3RlZCBvYmplY3RzLiBJZiB0aGUgYGRhdGFgIGlzIG5vdCBuZXN0ZWQgYW5kXG4gICAqIHRoZSBzYW1lIGZ1bmN0aW9uIGlzIHRvIGJlIGFwcGxpZWQgYWNyb3NzIGFsbCBvZiBpdCwgYSBzaW5nbGUgcHJlZGljYXRlXG4gICAqIGZ1bmN0aW9uIG1heSBiZSBwYXNzZWQgaW4uXG4gICAqXG4gICAqL1xuICBmdW5jdGlvbiBtYXAgKGRhdGEsIHByZWRpY2F0ZXMpIHtcbiAgICBhc3NlcnQub2JqZWN0KGRhdGEpO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24ocHJlZGljYXRlcykpIHtcbiAgICAgIHJldHVybiBtYXBTaW1wbGUoZGF0YSwgcHJlZGljYXRlcyk7XG4gICAgfVxuXG4gICAgYXNzZXJ0Lm9iamVjdChwcmVkaWNhdGVzKTtcblxuICAgIHJldHVybiBtYXBDb21wbGV4KGRhdGEsIHByZWRpY2F0ZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwU2ltcGxlIChkYXRhLCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gcHJlZGljYXRlKGRhdGFba2V5XSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwQ29tcGxleCAoZGF0YSwgcHJlZGljYXRlcykge1xuICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgIE9iamVjdC5rZXlzKHByZWRpY2F0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIHByZWRpY2F0ZSA9IHByZWRpY2F0ZXNba2V5XTtcblxuICAgICAgaWYgKGlzRnVuY3Rpb24ocHJlZGljYXRlKSkge1xuICAgICAgICBpZiAobm90LmFzc2lnbmVkKGRhdGEpKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSAhIXByZWRpY2F0ZS5tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gcHJlZGljYXRlKGRhdGFba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob2JqZWN0KHByZWRpY2F0ZSkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBtYXBDb21wbGV4KGRhdGFba2V5XSwgcHJlZGljYXRlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBhbGxgXG4gICAqXG4gICAqIENoZWNrIHRoYXQgYWxsIGJvb2xlYW4gdmFsdWVzIGFyZSB0cnVlXG4gICAqIGluIGFuIGFycmF5IChyZXR1cm5lZCBmcm9tIGBhcHBseWApXG4gICAqIG9yIG9iamVjdCAocmV0dXJuZWQgZnJvbSBgbWFwYCkuXG4gICAqXG4gICAqL1xuICBmdW5jdGlvbiBhbGwgKGRhdGEpIHtcbiAgICBpZiAoYXJyYXkoZGF0YSkpIHtcbiAgICAgIHJldHVybiB0ZXN0QXJyYXkoZGF0YSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGFzc2VydC5vYmplY3QoZGF0YSk7XG5cbiAgICByZXR1cm4gdGVzdE9iamVjdChkYXRhLCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiB0ZXN0QXJyYXkgKGRhdGEsIHJlc3VsdCkge1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmIChkYXRhW2ldID09PSByZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gIXJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRlc3RPYmplY3QgKGRhdGEsIHJlc3VsdCkge1xuICAgIHZhciBrZXksIHZhbHVlO1xuXG4gICAgZm9yIChrZXkgaW4gZGF0YSkge1xuICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB2YWx1ZSA9IGRhdGFba2V5XTtcblxuICAgICAgICBpZiAob2JqZWN0KHZhbHVlKSAmJiB0ZXN0T2JqZWN0KHZhbHVlLCByZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSByZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICFyZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGZ1bmN0aW9uIGBhbnlgXG4gICAqXG4gICAqIENoZWNrIHRoYXQgYXQgbGVhc3Qgb25lIGJvb2xlYW4gdmFsdWUgaXMgdHJ1ZVxuICAgKiBpbiBhbiBhcnJheSAocmV0dXJuZWQgZnJvbSBgYXBwbHlgKVxuICAgKiBvciBvYmplY3QgKHJldHVybmVkIGZyb20gYG1hcGApLlxuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gYW55IChkYXRhKSB7XG4gICAgaWYgKGFycmF5KGRhdGEpKSB7XG4gICAgICByZXR1cm4gdGVzdEFycmF5KGRhdGEsIHRydWUpO1xuICAgIH1cblxuICAgIGFzc2VydC5vYmplY3QoZGF0YSk7XG5cbiAgICByZXR1cm4gdGVzdE9iamVjdChkYXRhLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1peGluICh0YXJnZXQsIHNvdXJjZSkge1xuICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgbW9kaWZpZXIgYGFzc2VydGAuXG4gICAqXG4gICAqIFRocm93cyBpZiBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNlLlxuICAgKi9cbiAgZnVuY3Rpb24gYXNzZXJ0TW9kaWZpZXIgKHByZWRpY2F0ZSwgZGVmYXVsdE1lc3NhZ2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFzc2VydFByZWRpY2F0ZShwcmVkaWNhdGUsIGFyZ3VtZW50cywgZGVmYXVsdE1lc3NhZ2UpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnRQcmVkaWNhdGUgKHByZWRpY2F0ZSwgYXJncywgZGVmYXVsdE1lc3NhZ2UpIHtcbiAgICB2YXIgYXJnQ291bnQgPSBwcmVkaWNhdGUubCB8fCBwcmVkaWNhdGUubGVuZ3RoO1xuICAgIHZhciBtZXNzYWdlID0gYXJnc1thcmdDb3VudF07XG4gICAgdmFyIEVycm9yVHlwZSA9IGFyZ3NbYXJnQ291bnQgKyAxXTtcbiAgICBhc3NlcnRJbXBsKFxuICAgICAgcHJlZGljYXRlLmFwcGx5KG51bGwsIGFyZ3MpLFxuICAgICAgbm9uRW1wdHlTdHJpbmcobWVzc2FnZSkgPyBtZXNzYWdlIDogZGVmYXVsdE1lc3NhZ2UsXG4gICAgICBpc0Z1bmN0aW9uKEVycm9yVHlwZSkgPyBFcnJvclR5cGUgOiBUeXBlRXJyb3JcbiAgICApO1xuICAgIHJldHVybiBhcmdzWzBdO1xuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0SW1wbCAodmFsdWUsIG1lc3NhZ2UsIEVycm9yVHlwZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgKEVycm9yVHlwZSB8fCBFcnJvcikobWVzc2FnZSB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBtb2RpZmllciBgbm90YC5cbiAgICpcbiAgICogTmVnYXRlcyBgcHJlZGljYXRlYC5cbiAgICovXG4gIGZ1bmN0aW9uIG5vdE1vZGlmaWVyIChwcmVkaWNhdGUpIHtcbiAgICB2YXIgbW9kaWZpZWRQcmVkaWNhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbm90SW1wbChwcmVkaWNhdGUuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICBtb2RpZmllZFByZWRpY2F0ZS5sID0gcHJlZGljYXRlLmxlbmd0aDtcbiAgICByZXR1cm4gbW9kaWZpZWRQcmVkaWNhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBub3RJbXBsICh2YWx1ZSkge1xuICAgIHJldHVybiAhdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIG1vZGlmaWVyIGBtYXliZWAuXG4gICAqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBwcmVkaWNhdGUgYXJndW1lbnQgaXMgIG51bGwgb3IgdW5kZWZpbmVkLFxuICAgKiBvdGhlcndpc2UgcHJvcGFnYXRlcyB0aGUgcmV0dXJuIHZhbHVlIGZyb20gYHByZWRpY2F0ZWAuXG4gICAqL1xuICBmdW5jdGlvbiBtYXliZU1vZGlmaWVyIChwcmVkaWNhdGUpIHtcbiAgICB2YXIgbW9kaWZpZWRQcmVkaWNhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobm90LmFzc2lnbmVkKGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmVkaWNhdGUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIG1vZGlmaWVkUHJlZGljYXRlLmwgPSBwcmVkaWNhdGUubGVuZ3RoO1xuXG4gICAgLy8gSGFja2lzaGx5IGluZGljYXRlIHRoYXQgdGhpcyBpcyBhIG1heWJlLnh4eCBwcmVkaWNhdGUuXG4gICAgLy8gV2l0aG91dCB0aGlzIGZsYWcsIHRoZSBhbHRlcm5hdGl2ZSB3b3VsZCBiZSB0byBpdGVyYXRlXG4gICAgLy8gdGhyb3VnaCB0aGUgbWF5YmUgcHJlZGljYXRlcyBvciB1c2UgaW5kZXhPZiB0byBjaGVjayxcbiAgICAvLyB3aGljaCB3b3VsZCBiZSB0aW1lLWNvbnN1bWluZy5cbiAgICBtb2RpZmllZFByZWRpY2F0ZS5tID0gdHJ1ZTtcblxuICAgIHJldHVybiBtb2RpZmllZFByZWRpY2F0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1heWJlSW1wbCAodmFsdWUpIHtcbiAgICBpZiAoYXNzaWduZWQodmFsdWUpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBtb2RpZmllciBgb2ZgLlxuICAgKlxuICAgKiBBcHBsaWVzIHRoZSBjaGFpbmVkIHByZWRpY2F0ZSB0byBtZW1iZXJzIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gb2ZNb2RpZmllciAodGFyZ2V0LCB0eXBlLCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgbW9kaWZpZWRQcmVkaWNhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29sbGVjdGlvbiwgYXJncztcblxuICAgICAgY29sbGVjdGlvbiA9IGFyZ3VtZW50c1swXTtcblxuICAgICAgaWYgKHRhcmdldCA9PT0gJ21heWJlJyAmJiBub3QuYXNzaWduZWQoY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghdHlwZShjb2xsZWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNvbGxlY3Rpb24gPSBjb2VyY2VDb2xsZWN0aW9uKHR5cGUsIGNvbGxlY3Rpb24pO1xuICAgICAgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29sbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHRhcmdldCAhPT0gJ21heWJlJyB8fCBhc3NpZ25lZChpdGVtKSkgJiZcbiAgICAgICAgICAgICFwcmVkaWNhdGUuYXBwbHkobnVsbCwgWyBpdGVtIF0uY29uY2F0KGFyZ3MpKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gVE9ETzogUmVwbGFjZSB3aXRoIGZvci4uLm9mIHdoZW4gRVM2IGlzIHJlcXVpcmVkLlxuICAgICAgICAgICAgdGhyb3cgMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoaWdub3JlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBtb2RpZmllZFByZWRpY2F0ZS5sID0gcHJlZGljYXRlLmxlbmd0aDtcbiAgICByZXR1cm4gbW9kaWZpZWRQcmVkaWNhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBjb2VyY2VDb2xsZWN0aW9uICh0eXBlLCBjb2xsZWN0aW9uKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIGFycmF5TGlrZTpcbiAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwoY29sbGVjdGlvbik7XG4gICAgICBjYXNlIG9iamVjdDpcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGNvbGxlY3Rpb24pLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25ba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVNb2RpZmllZFByZWRpY2F0ZXMgKG1vZGlmaWVyLCBvYmplY3QpIHtcbiAgICByZXR1cm4gY3JlYXRlTW9kaWZpZWRGdW5jdGlvbnMoWyBtb2RpZmllciwgcHJlZGljYXRlcywgb2JqZWN0IF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTW9kaWZpZWRGdW5jdGlvbnMgKGFyZ3MpIHtcbiAgICB2YXIgbW9kaWZpZXIsIG9iamVjdCwgZnVuY3Rpb25zLCByZXN1bHQ7XG5cbiAgICBtb2RpZmllciA9IGFyZ3Muc2hpZnQoKTtcbiAgICBvYmplY3QgPSBhcmdzLnBvcCgpO1xuICAgIGZ1bmN0aW9ucyA9IGFyZ3MucG9wKCk7XG5cbiAgICByZXN1bHQgPSBvYmplY3QgfHwge307XG5cbiAgICBPYmplY3Qua2V5cyhmdW5jdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwga2V5LCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IG1vZGlmaWVyLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KGZ1bmN0aW9uc1trZXldLCBtZXNzYWdlc1trZXldKSlcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU1vZGlmaWVkTW9kaWZpZXIgKG1vZGlmaWVyLCBtb2RpZmllZCkge1xuICAgIHJldHVybiBjcmVhdGVNb2RpZmllZEZ1bmN0aW9ucyhbIG1vZGlmaWVyLCBtb2RpZmllZCwgbnVsbCBdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9mUHJlZGljYXRlcyAoa2V5KSB7XG4gICAgcHJlZGljYXRlc1trZXldLm9mID0gY3JlYXRlTW9kaWZpZWRGdW5jdGlvbnMoXG4gICAgICBbIG9mTW9kaWZpZXIuYmluZChudWxsLCBudWxsKSwgcHJlZGljYXRlc1trZXldLCBwcmVkaWNhdGVzLCBudWxsIF1cbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2ZNb2RpZmllcnMgKGJhc2UsIG1vZGlmaWVyKSB7XG4gICAgY29sbGVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBiYXNlW2tleV0ub2YgPSBjcmVhdGVNb2RpZmllZE1vZGlmaWVyKG1vZGlmaWVyLCBwcmVkaWNhdGVzW2tleV0ub2YpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTWF5YmVPZk1vZGlmaWVycyAoa2V5KSB7XG4gICAgbWF5YmVba2V5XS5vZiA9IGNyZWF0ZU1vZGlmaWVkRnVuY3Rpb25zKFxuICAgICAgWyBvZk1vZGlmaWVyLmJpbmQobnVsbCwgJ21heWJlJyksIHByZWRpY2F0ZXNba2V5XSwgcHJlZGljYXRlcywgbnVsbCBdXG4gICAgKTtcbiAgICBhc3NlcnQubWF5YmVba2V5XS5vZiA9IGNyZWF0ZU1vZGlmaWVkTW9kaWZpZXIoYXNzZXJ0TW9kaWZpZXIsIG1heWJlW2tleV0ub2YpO1xuICAgIGFzc2VydC5ub3Rba2V5XS5vZiA9IGNyZWF0ZU1vZGlmaWVkTW9kaWZpZXIoYXNzZXJ0TW9kaWZpZXIsIG5vdFtrZXldLm9mKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4cG9ydEZ1bmN0aW9ucyAoZnVuY3Rpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9ucztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlICE9PSBudWxsICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9ucztcbiAgICB9IGVsc2Uge1xuICAgICAgZ2xvYmFscy5jaGVjayA9IGZ1bmN0aW9ucztcbiAgICB9XG4gIH1cbn0odGhpcykpO1xuIiwiY29uc3QgY2hlY2sgPSByZXF1aXJlKCdjaGVjay10eXBlcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChjaGFpKSA9PiB7XG5cbiAgY29uc3QgdHlwZXMgPSBbJ251bWJlcicsICdzdHJpbmcnLCAnYm9vbGVhbicsICdvYmplY3QnLCAnYXJyYXknLCAnZGF0ZScsICdmdW5jdGlvbiddO1xuXG4gIHR5cGVzLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICBjaGFpLkFzc2VydGlvbi5hZGRNZXRob2QodHlwZSwgZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgY2hlY2tbdHlwZV0odGhpcy5fb2JqKSxcbiAgICAgICAgYGV4cGVjdGVkICN7dGhpc30gdG8gYmUgJHt0eXBlfWAsXG4gICAgICAgIGBleHBlY3RlZCAje3RoaXN9IG5vdCB0byBiZSAke3R5cGV9YFxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbn07IiwiZnVuY3Rpb24gcGx1Z2luKGNoYWksIHV0aWxzKSB7XG5cbiAgdmFyIEFzc2VydGlvbiA9IGNoYWkuQXNzZXJ0aW9uO1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBnaXZlbiBlbnRyeSBpcyBhbiBldmVudCBlbWl0dGVyLlxuICAgKiBVc2VzIEV2ZW50RW1pdHRlciBvciBFdmVudFRhcmdldCBpZiBhdmFpbGFibGUgdG8gcXVpY2tseSBjaGVjayBgaW5zdGFuY2VvZmAuICBPdGhlcndpc2UsIGNoZWNrcyB0aGF0IGNvbW1vbiBtZXRob2RzXG4gICAqIHRvIGV2ZW50IGVtaXR0ZXJzIGFyZSBhdmFpbGFibGUuXG4gICAqXG4gICAqIEdyYWNlZnVsbHkgaGFuZGxlcyBjdXN0b20gaW1wbGVtZW50YXRpb25zIG9mIGV2ZW50IGVtaXR0ZXJzIGV2ZW4gaWYgRXZlbnRFbWl0dGVyIG9yIEV2ZW50VGFyZ2V0IGFyZSBhdmFpbGFibGUsXG4gICAqIGNoZWNraW5nIG1ldGhvZHMgaWYgdGhlIGVtaXR0ZXIgZG9lc24ndCBpbmhlcml0IGZyb20gdGhlIGdsb2JhbCBlbWl0dGVyLlxuICAqL1xuICBmdW5jdGlvbiBpc0VtaXR0ZXIoKSB7XG4gICAgLy8gRWFzeSBjaGVjazogaWYgTm9kZSdzIEV2ZW50RW1pdHRlciBvciB3aW5kb3cuRXZlbnRFbWl0dGVyIGV4aXN0LCBjaGVjayBpZiB0aGlzIGlzIGFuIGluc3RhbmNlIG9mIGl0LlxuICAgIGlmKHR5cGVvZiBFdmVudEVtaXR0ZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgRXZlbnRFbWl0dGVyICE9PSBudWxsICYmIHRoaXMuX29iaiBpbnN0YW5jZW9mIEV2ZW50RW1pdHRlcikge1xuICAgICAgcmV0dXJuIHRoaXMuYXNzZXJ0KHRydWUsIFwiXCIsIFwiZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgYW4gRXZlbnRFbWl0dGVyXCIpO1xuICAgIH1cblxuICAgIC8vIEVhc3kgY2hlY2s6IGlmIHRoZSBicm93c2VyJ3MgRXZlbnRUYXJnZXQgZXhpc3RzLCBjaGVjayBpZiB0aGlzIGlzIGFuIGluc3RhbmNlIG9mIGl0LlxuICAgIGlmKHR5cGVvZiBFdmVudFRhcmdldCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBFdmVudFRhcmdldCAhPT0gbnVsbCAmJiB0aGlzLl9vYmogaW5zdGFuY2VvZiBFdmVudFRhcmdldCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXNzZXJ0KHRydWUsIFwiXCIsIFwiZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgYW4gRXZlbnRUYXJnZXRcIik7XG4gICAgfVxuXG4gICAgdmFyIG9iaiA9IHRoaXMuX29iajtcblxuICAgIC8vIENoZWNrIGZvciBOb2RlLmpzIHN0eWxlIGV2ZW50IGVtaXR0ZXJzIHdpdGggXCJvblwiLCBcImVtaXRcIiwgZXRjLlxuICAgIHZhciBub2RlID0gW1wib25cIiwgXCJlbWl0XCJdLmV2ZXJ5KGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmpbbWV0aG9kXSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIH0pO1xuXG4gICAgaWYobm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXNzZXJ0KHRydWUsIFwiXCIsIFwiZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgYW4gRXZlbnRFbWl0dGVyXCIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBCcm93c2VyLWJhc2VkIGV2ZW50IGVtaXR0ZXJzIHdpdGggXCJhZGRFdmVudExpc3RlbmVyXCIsIGV0Yy5cbiAgICB2YXIgYnJvd3NlciA9IFtcImFkZEV2ZW50TGlzdGVuZXJcIiwgXCJkaXNwYXRjaEV2ZW50XCIsIFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiXS5ldmVyeShmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqW21ldGhvZF0gPT09IFwiZnVuY3Rpb25cIjtcbiAgICB9KTtcblxuICAgIGlmKGJyb3dzZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzc2VydCh0cnVlLCBcIlwiLCBcImV4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIGFuIEV2ZW50RW1pdHRlclwiKTtcbiAgICB9XG5cbiAgICB0aGlzLmFzc2VydChmYWxzZSwgXCJleHBlY3RlZCAje3RoaXN9IHRvIGJlIGFuIEV2ZW50RW1pdHRlclwiLCBcIlwiKTtcbiAgfTtcblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoXCJlbWl0dGVyXCIsIGlzRW1pdHRlcik7XG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eShcInRhcmdldFwiLCBpc0VtaXR0ZXIpO1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoXCJlbWl0XCIsIGZ1bmN0aW9uKG5hbWUsIGFyZ3MpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHRoaXMuX29iaikudG8uYmUuYW4uZW1pdHRlcjtcblxuICAgIG5ldyBBc3NlcnRpb24obmFtZSkudG8uYmUuYShcInN0cmluZ1wiKTtcbiAgICB2YXIgb2JqID0gdGhpcy5fb2JqO1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGFzc2VydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgX3RoaXMuYXNzZXJ0LmFwcGx5KF90aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHV0aWxzLmZsYWcodGhpcywgJ3RpbWVvdXQnKSB8fCAxNTAwO1xuXG4gICAgaWYodXRpbHMuZmxhZyh0aGlzLCAnbmVnYXRlJykpIHtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBldmVudCBkb2Vzbid0IGZpcmUgYmVmb3JlIHRpbWVvdXRcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgb2JqLm9uKG5hbWUsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmKGRvbmUpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcImV4cGVjdGVkICN7dGhpc30gdG8gbm90IGVtaXQgXCIrbmFtZStcIi5cIik7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZihkb25lKSB7IHJldHVybjsgfVxuICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgZXZlbnQgZmlyZXNcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgb2JqLm9uKG5hbWUsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmKGRvbmUpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZihkb25lKSB7IHJldHVybjsgfVxuICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgIGFzc2VydChmYWxzZSwgXCJleHBlY3RlZCAje3RoaXN9IHRvIGVtaXQgXCIrbmFtZStcIi5cIik7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbn1cblxuaWYgKHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIikge1xuICBtb2R1bGUuZXhwb3J0cyA9IHBsdWdpbjtcbn1cbmVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBsdWdpbjtcbiAgfSk7XG59XG5lbHNlIHtcbiAgLy8gT3RoZXIgZW52aXJvbm1lbnQgKHVzdWFsbHkgPHNjcmlwdD4gdGFnKTogcGx1ZyBpbiB0byBnbG9iYWwgY2hhaSBpbnN0YW5jZSBkaXJlY3RseS5cbiAgY2hhaS51c2UocGx1Z2luKTtcbn1cbiIsIiMgQFBvcHVwID0gd2luZG93LnF1aWNrcG9wdXBcbmltcG9ydCBQb3B1cCBmcm9tICcuLi9idWlsZC9xdWlja3BvcHVwLmVzbS5qcydcbmltcG9ydCBET00gZnJvbSAncXVpY2tkb20nXG5pbXBvcnQgKiBhcyBoZWxwZXJzIGZyb20gJy4vaGVscGVycydcbmltcG9ydCB7dmVyc2lvbiBhcyBwYWNrYWdlVmVyc2lvbn0gZnJvbSAnLi4vcGFja2FnZS5qc29uJ1xuaW1wb3J0IGNoYWkgZnJvbSAnY2hhaSdcbmltcG9ydCBjaGFpRG9tIGZyb20gJ2NoYWktZG9tJ1xuaW1wb3J0IGNoYWlTdHlsZSBmcm9tICdjaGFpLXN0eWxlJ1xuaW1wb3J0IGNoYWlBbG1vc3QgZnJvbSAnY2hhaS1hbG1vc3QnXG5pbXBvcnQgY2hhaUFzc2VydHR5cGUgZnJvbSAnY2hhaS1hc3NlcnR0eXBlJ1xuaW1wb3J0IGNoYWlFdmVudHMgZnJvbSAnY2hhaS1ldmVudHMnXG5jaGFpLnVzZShjaGFpRG9tKVxuY2hhaS51c2UoY2hhaVN0eWxlKVxuY2hhaS51c2UoY2hhaUFsbW9zdClcbmNoYWkudXNlKGNoYWlBc3NlcnR0eXBlKVxuY2hhaS51c2UoY2hhaUV2ZW50cylcbm1vY2hhLnNldHVwKCd0ZGQnKVxubW9jaGEuc2xvdyg0MDApXG5tb2NoYS50aW1lb3V0KDYwMDApXG5tb2NoYS5iYWlsKCkgdW5sZXNzIHdpbmRvdy5fX2thcm1hX19cbmV4cGVjdCA9IGNoYWkuZXhwZWN0XG5hc3NlcnQgPSBjaGFpLmFzc2VydFxud2luZG93LnNhbmRib3ggPSBudWxsXG5cblxuXG5zdWl0ZSBcIlF1aWNrUG9wdXBcIiwgKCktPlxuXHRzZXR1cChoZWxwZXJzLnJlc3RhcnRTYW5kYm94KVxuXHR0ZWFyZG93bihQb3B1cC5kZXN0cm95QWxsKVxuXG5cdHRlc3QgXCJWZXJzaW9uIFByb3BlcnR5XCIsICgpLT5cblx0XHRleHBlY3QoUG9wdXAudmVyc2lvbikudG8uZXF1YWwocGFja2FnZVZlcnNpb24pXG5cblxuXHRzdWl0ZSBcImluc3RhbmNlXCIsICgpLT5cblx0XHR0ZXN0IFwic2hvdWxkIGJlIGFuIGV2ZW50IGVtaXR0ZXJcIiwgKCktPlxuXHRcdFx0cG9wdXAgPSBQb3B1cCgpXG5cdFx0XHRhc3NlcnQuZXF1YWwgdHlwZW9mIHBvcHVwLm9uLCAnZnVuY3Rpb24nXG5cdFx0XHRhc3NlcnQuZXF1YWwgdHlwZW9mIHBvcHVwLm9mZiwgJ2Z1bmN0aW9uJ1xuXHRcdFx0YXNzZXJ0LmVxdWFsIHR5cGVvZiBwb3B1cC5lbWl0LCAnZnVuY3Rpb24nXG5cdFx0XHRQcm9taXNlLmRlbGF5KCkudGhlbiAoKS0+IHBvcHVwLmVtaXQgJ3NvbWVFdmVudCdcblx0XHRcdGV4cGVjdChwb3B1cCkudG8uZW1pdCAnc29tZUV2ZW50J1xuXG5cblx0XHRzdWl0ZSBcImFyZ3NcIiwgKCktPlxuXHRcdFx0dGVzdCBcInVzaW5nIG5vIGFyZ3NcIiwgKCktPlxuXHRcdFx0XHRwb3B1cCA9IFBvcHVwKClcblx0XHRcdFx0cG9wdXAgPSBuZXcgUG9wdXAoKVxuXHRcdFx0XHRhc3NlcnQgcG9wdXAgbm90IGluc3RhbmNlb2YgUG9wdXBcblx0XHRcdFx0YXNzZXJ0LmVxdWFsIHR5cGVvZiBwb3B1cCwgJ29iamVjdCdcblx0XHRcdFx0YXNzZXJ0LmVxdWFsIHR5cGVvZiBwb3B1cC5vcGVuLCAnZnVuY3Rpb24nXG5cdFx0XHRcdGFzc2VydC5lcXVhbCBwb3B1cC5lbC50ZXh0LCAnJ1xuXG5cblx0XHRcdHRlc3QgXCJ3aXRoIHN0cmluZyBhcmdcIiwgKCktPlxuXHRcdFx0XHRwb3B1cCA9IFBvcHVwKCdwcm92aWRlZCBzdHJpbmcnKVxuXHRcdFx0XHRhc3NlcnQuZXF1YWwgcG9wdXAuZWwudGV4dCwgJ3Byb3ZpZGVkIHN0cmluZydcblxuXG5cdFx0XHR0ZXN0IFwid2l0aCBodG1sIHN0cmluZyBhcmdcIiwgKCktPlxuXHRcdFx0XHRwb3B1cCA9IFBvcHVwKCc8YiBjbGFzcz1cInRoZUJvbGRPbmVcIj5wcm92aWRlZCBzdHJpbmc8L2I+PGkgY2xhc3M9XCJ0aGVTbGFudGVkT25lXCI+IGlzIHNsYW50ZWQ8L2I+Jylcblx0XHRcdFx0YXNzZXJ0LmVxdWFsIHBvcHVwLmVsLnRleHQsICdwcm92aWRlZCBzdHJpbmcgaXMgc2xhbnRlZCdcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnRlbnRzID0gcG9wdXAuZWwuY2hpbGQuY29udGVudC5sYXN0Q2hpbGQuY2hpbGRyZW5cblx0XHRcdFx0YXNzZXJ0LmVxdWFsIGNvbnRlbnRzLmxlbmd0aCwgMlxuXHRcdFx0XHRhc3NlcnQuZXF1YWwgY29udGVudHNbMF0udHlwZSwgJ2InXG5cdFx0XHRcdGFzc2VydC5lcXVhbCBjb250ZW50c1sxXS50eXBlLCAnaSdcblx0XHRcdFx0YXNzZXJ0LmVxdWFsIGNvbnRlbnRzWzBdLnJhdy5jbGFzc05hbWUsICd0aGVCb2xkT25lJ1xuXHRcdFx0XHRhc3NlcnQuZXF1YWwgY29udGVudHNbMV0ucmF3LmNsYXNzTmFtZSwgJ3RoZVNsYW50ZWRPbmUnXG5cblxuXHRcdFx0dGVzdCBcIndpdGggRE9NIGVsZW1lbnQgYXJnXCIsICgpLT5cblx0XHRcdFx0c3BhbiA9IERPTS5zcGFuKGNsYXNzOidhYmMxMjMtY2hpbGQnLCAncHJvdmlkZWQgZWwnKVxuXHRcdFx0XHRkaXYgPSBET00uZGl2KGNsYXNzOidhYmMxMjMnLCBzcGFuKVxuXHRcdFx0XHRwb3B1cCA9IFBvcHVwKGRpdi5yYXcpXG5cdFx0XHRcdGFzc2VydC5lcXVhbCBwb3B1cC5lbC50ZXh0LCAncHJvdmlkZWQgZWwnXG5cdFx0XHRcdFxuXHRcdFx0XHRjb250ZW50cyA9IHBvcHVwLmVsLmNoaWxkLmNvbnRlbnQuY2hpbGRyZW5cblx0XHRcdFx0YXNzZXJ0LmVxdWFsIGNvbnRlbnRzLmxlbmd0aCwgMVxuXHRcdFx0XHRhc3NlcnQuZXF1YWwgY29udGVudHNbMF0udHlwZSwgJ2Rpdidcblx0XHRcdFx0YXNzZXJ0LmVxdWFsIGNvbnRlbnRzWzBdLnJhdy5jbGFzc05hbWUsICdhYmMxMjMnXG5cdFx0XHRcdGFzc2VydC5lcXVhbCBjb250ZW50c1swXSwgZGl2XG5cdFx0XHRcdGFzc2VydC5lcXVhbCBjb250ZW50c1swXS5jaGlsZHJlblswXSwgc3BhblxuXG5cblx0XHRcdHRlc3QgXCJ3aXRoIFF1aWNrRE9NIGVsZW1lbnQgYXJnXCIsICgpLT5cblx0XHRcdFx0c3BhbiA9IERPTS5zcGFuKGNsYXNzOidhYmMxMjMtY2hpbGQnLCAncHJvdmlkZWQgZWwnKVxuXHRcdFx0XHRkaXYgPSBET00uZGl2KGNsYXNzOidhYmMxMjMnLCBzcGFuKVxuXHRcdFx0XHRwb3B1cCA9IFBvcHVwKGRpdilcblx0XHRcdFx0YXNzZXJ0LmVxdWFsIHBvcHVwLmVsLnRleHQsICdwcm92aWRlZCBlbCdcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnRlbnRzID0gcG9wdXAuZWwuY2hpbGQuY29udGVudC5jaGlsZHJlblxuXHRcdFx0XHRhc3NlcnQuZXF1YWwgY29udGVudHMubGVuZ3RoLCAxXG5cdFx0XHRcdGFzc2VydC5lcXVhbCBjb250ZW50c1swXS50eXBlLCAnZGl2J1xuXHRcdFx0XHRhc3NlcnQuZXF1YWwgY29udGVudHNbMF0ucmF3LmNsYXNzTmFtZSwgJ2FiYzEyMydcblx0XHRcdFx0YXNzZXJ0LmVxdWFsIGNvbnRlbnRzWzBdLCBkaXZcblx0XHRcdFx0YXNzZXJ0LmVxdWFsIGNvbnRlbnRzWzBdLmNoaWxkcmVuWzBdLCBzcGFuXG5cblxuXHRcdFx0dGVzdCBcIndpdGggc2V0dGluZ3MgYXJnXCIsICgpLT5cblx0XHRcdFx0cG9wdXBBID0gUG9wdXAoe30pXG5cdFx0XHRcdHBvcHVwQiA9IFBvcHVwKHtwbGFjZW1lbnQ6J2JvdHRvbSd9KVxuXHRcdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRhc3NlcnQuZXF1YWwgcG9wdXBBLnNldHRpbmdzLnBsYWNlbWVudCwgJ2NlbnRlcidcblx0XHRcdFx0YXNzZXJ0LmVxdWFsIHBvcHVwQi5zZXR0aW5ncy5wbGFjZW1lbnQsICdib3R0b20nXG5cblxuXHRzdWl0ZSBcImJlaGF2aW9yXCIsICgpLT5cblx0XHR0ZXN0IFwic2hvdWxkIGNyZWF0ZSBhIHdyYXBwZXIgZWxlbWVudCBhcm91bmQgYm9keSBjb250ZW50c1wiLCAoKS0+XG5cdFx0XHRhc3NlcnQuZXF1YWwgdHlwZW9mIERPTS5xdWVyeSgnI2JvZHlXcmFwcGVyJyksICd1bmRlZmluZWQnXG5cdFx0XHRib2R5Q2hpbGRyZW4gPSBET00oZG9jdW1lbnQuYm9keSkuY2hpbGRyZW4uc2xpY2UoKVxuXG5cdFx0XHRwb3B1cCA9IFBvcHVwKClcblx0XHRcdGFzc2VydC5lcXVhbCB0eXBlb2YgRE9NLnF1ZXJ5KCcjYm9keVdyYXBwZXInKSwgJ29iamVjdCdcblx0XHRcdGFzc2VydC5lcXVhbCBET00ucXVlcnkoJyNib2R5V3JhcHBlcicpLnBhcmVudCwgRE9NKGRvY3VtZW50LmJvZHkpXG5cdFx0XHRhc3NlcnQuZXF1YWwgRE9NKGRvY3VtZW50LmJvZHkpLmNoaWxkcmVuLmxlbmd0aCwgMlxuXHRcdFx0YXNzZXJ0LmVxdWFsIERPTS5xdWVyeSgnI2JvZHlXcmFwcGVyJykuY2hpbGRyZW4ubGVuZ3RoLCBib2R5Q2hpbGRyZW4ubGVuZ3RoXG5cdFx0XHRcblx0XHRcdFBvcHVwLnVud3JhcEJvZHkoKVxuXHRcdFx0YXNzZXJ0LmVxdWFsIHR5cGVvZiBET00ucXVlcnkoJyNib2R5V3JhcHBlcicpLCAndW5kZWZpbmVkJ1xuXHRcdFx0YXNzZXJ0LmVxdWFsIERPTShkb2N1bWVudC5ib2R5KS5jaGlsZHJlbi5sZW5ndGgsIGJvZHlDaGlsZHJlbi5sZW5ndGgrMVxuXG5cdFx0XHRwb3B1cC5kZXN0cm95KClcblx0XHRcdGFzc2VydC5lcXVhbCBET00oZG9jdW1lbnQuYm9keSkuY2hpbGRyZW4ubGVuZ3RoLCBib2R5Q2hpbGRyZW4ubGVuZ3RoXG5cdFx0XHRcblx0XHRcdHBvcHVwID0gUG9wdXAoKVxuXHRcdFx0YXNzZXJ0LmVxdWFsIERPTShkb2N1bWVudC5ib2R5KS5jaGlsZHJlbi5sZW5ndGgsIDJcblx0XHRcdGFzc2VydC5lcXVhbCBET00ucXVlcnkoJyNib2R5V3JhcHBlcicpLmNoaWxkcmVuLmxlbmd0aCwgYm9keUNoaWxkcmVuLmxlbmd0aFxuXG5cdFx0dGVzdCBcIlBvcHVwLmNvbmZpZygpIHdpbGwgcmV0dXJuIGEgbmV3IGNvbnN0cnVjdG9yIHdpdGggY3VzdG9taXplZCBzZXR0aW5nIGRlZmF1bHRzICYgdGVtcGxhdGVzXCIsICgpLT5cblx0XHRcdFBvcHVwMiA9IFBvcHVwLmNvbmZpZyh7YW5pbWF0aW9uOjEwMH0pXG5cdFx0XHRhc3NlcnQubm90RXF1YWwgUG9wdXAyLCBQb3B1cFxuXHRcdFx0YXNzZXJ0LmVxdWFsIFBvcHVwMi5kZWZhdWx0cy5hbmltYXRpb24sIDEwMFxuXHRcdFx0YXNzZXJ0Lm5vdEVxdWFsIFBvcHVwLmRlZmF1bHRzLmFuaW1hdGlvbiwgMTAwXG5cdFx0XHRQb3B1cCgpXG5cdFx0XHRQb3B1cDIoKVxuXG5cblx0c3VpdGUgXCJvcGVuL2Nsb3NlXCIsICgpLT5cblx0XHRzdWl0ZVNldHVwICgpLT4gQFBvcHVwID0gUG9wdXAuY29uZmlnKHthbmltYXRpb246NTB9KVxuXHRcdHRlc3QgXCJ3aWxsIHJldHVybiBwcm9taXNlcyB0aGF0IHJlc29sdmUgd2hlbiBhbmltYXRpb24gZW5kc1wiLCAoKS0+XG5cdFx0XHRjb250ZW50ID0gRE9NLmRpdihudWxsLCAnYWJjMTIzJylcblx0XHRcdHBvcHVwID0gQFBvcHVwKGNvbnRlbnQpXG5cdFx0XHRzdGFydFRpbWUgPSBEYXRlLm5vdygpXG5cdFx0XHRvcGVuVGltZSA9IG51bGxcblxuXHRcdFx0YXNzZXJ0LmVxdWFsIHBvcHVwLnN0YXRlLm9wZW4sIGZhbHNlXG5cblx0XHRcdG9wZW5Qcm9taXNlID0gcG9wdXAub3BlbigpXG5cdFx0XHRhc3NlcnQub2sgb3BlblByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlXG5cdFx0XHRhc3NlcnQub2sgb3BlblByb21pc2UuaXNQZW5kaW5nKClcblxuXHRcdFx0UHJvbWlzZS5iaW5kKEApXG5cdFx0XHRcdC50aGVuICgpLT4gb3BlblByb21pc2Vcblx0XHRcdFx0LnRoZW4gKCktPlxuXHRcdFx0XHRcdG9wZW5UaW1lID0gRGF0ZS5ub3coKVxuXHRcdFx0XHRcdGFzc2VydC5pc0F0TGVhc3Qgb3BlblRpbWUtc3RhcnRUaW1lLCBAUG9wdXAuZGVmYXVsdHMuYW5pbWF0aW9uLzJcblx0XHRcdFx0XHRhc3NlcnQuZXF1YWwgcG9wdXAuc3RhdGUub3BlbiwgdHJ1ZVxuXG5cdFx0XHRcdC50aGVuICgpLT4gcG9wdXAuY2xvc2UoKVxuXHRcdFx0XHQudGhlbiAoKS0+XG5cdFx0XHRcdFx0YXNzZXJ0LmlzQXRMZWFzdCBEYXRlLm5vdygpLW9wZW5UaW1lLCBAUG9wdXAuZGVmYXVsdHMuYW5pbWF0aW9uLzJcblx0XHRcdFx0XHRhc3NlcnQuZXF1YWwgcG9wdXAuc3RhdGUub3BlbiwgZmFsc2VcblxuXG5cdFx0dGVzdCBcIndpbGwgZW1pdCBldmVudHMgYmVmb3JlL3ByZXNlbnQvZmluaXNoIGZvciBvcGVuL2Nsb3NlXCIsICgpLT5cblx0XHRcdHBvcHVwID0gQFBvcHVwKClcblx0XHRcdGV2ZW50cyA9IFsnYmVmb3Jlb3BlbicsJ29wZW4nLCdmaW5pc2hvcGVuJywnYmVmb3JlY2xvc2UnLCdjbG9zZScsJ2ZpbmlzaGNsb3NlJ11cblx0XHRcdGNvdW50ID0ge31cblx0XHRcdGV2ZW50cy5mb3JFYWNoIChldmVudCktPlxuXHRcdFx0XHRjb3VudFtldmVudF0gPSAwXG5cdFx0XHRcdHBvcHVwLm9uIGV2ZW50LCAoKS0+IGNvdW50W2V2ZW50XSsrXG5cblx0XHRcdFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHRcdC50aGVuICgpLT4gYXNzZXJ0LmRlZXBFcXVhbCBjb3VudCwge2JlZm9yZW9wZW46MCwgb3BlbjowLCBmaW5pc2hvcGVuOjAsIGJlZm9yZWNsb3NlOjAsIGNsb3NlOjAsIGZpbmlzaGNsb3NlOjB9XG5cdFx0XHRcdC50aGVuICgpLT4gcG9wdXAub3BlbigpXG5cdFx0XHRcdC50aGVuICgpLT4gYXNzZXJ0LmRlZXBFcXVhbCBjb3VudCwge2JlZm9yZW9wZW46MSwgb3BlbjoxLCBmaW5pc2hvcGVuOjEsIGJlZm9yZWNsb3NlOjAsIGNsb3NlOjAsIGZpbmlzaGNsb3NlOjB9XG5cdFx0XHRcdC50aGVuICgpLT4gcG9wdXAuY2xvc2UoKVxuXHRcdFx0XHQudGhlbiAoKS0+IGFzc2VydC5kZWVwRXF1YWwgY291bnQsIHtiZWZvcmVvcGVuOjEsIG9wZW46MSwgZmluaXNob3BlbjoxLCBiZWZvcmVjbG9zZToxLCBjbG9zZToxLCBmaW5pc2hjbG9zZToxfVxuXG5cblx0XHR0ZXN0IFwid2lsbCBmYWlsIHRvIG9wZW4gaWYgYW5vdGhlciBwb3B1cCBpcyBvcGVuXCIsICgpLT5cblx0XHRcdHBvcHVwQSA9IEBQb3B1cCgpXG5cdFx0XHRwb3B1cEIgPSBAUG9wdXAoKVxuXG5cdFx0XHRQcm9taXNlLnJlc29sdmUoKVxuXHRcdFx0XHQudGhlbiAoKS0+XG5cdFx0XHRcdFx0YXNzZXJ0LmVxdWFsIHBvcHVwQS5zdGF0ZS5vcGVuLCBmYWxzZVxuXHRcdFx0XHRcdGFzc2VydC5lcXVhbCBwb3B1cEIuc3RhdGUub3BlbiwgZmFsc2Vcblx0XHRcdFx0XG5cdFx0XHRcdC50aGVuICgpLT4gcG9wdXBBLm9wZW4oKVxuXHRcdFx0XHQudGhlbiAoKS0+XG5cdFx0XHRcdFx0YXNzZXJ0LmVxdWFsIHBvcHVwQS5zdGF0ZS5vcGVuLCB0cnVlXG5cdFx0XHRcdFx0YXNzZXJ0LmVxdWFsIHBvcHVwQi5zdGF0ZS5vcGVuLCBmYWxzZVxuXG5cdFx0XHRcdC50aGVuICgpLT4gcG9wdXBCLm9wZW4oKVxuXHRcdFx0XHQudGhlbiAoKS0+XG5cdFx0XHRcdFx0YXNzZXJ0LmVxdWFsIHBvcHVwQS5zdGF0ZS5vcGVuLCB0cnVlXG5cdFx0XHRcdFx0YXNzZXJ0LmVxdWFsIHBvcHVwQi5zdGF0ZS5vcGVuLCBmYWxzZVxuXG5cblx0XHR0ZXN0IFwid2lsbCBjbG9zZSBhbGwgb3RoZXIgb3BlbiBwb3B1cHMgYW5kIHdpbGwgZm9yY2Ugb3BlbiB3aGVuIG9wdGlvbnMuZm9yY2VPcGVuXCIsICgpLT5cblx0XHRcdHBvcHVwQSA9IEBQb3B1cCgpXG5cdFx0XHRwb3B1cEIgPSBAUG9wdXAoZm9yY2VPcGVuOnRydWUpXG5cblx0XHRcdFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHRcdC50aGVuICgpLT5cblx0XHRcdFx0XHRhc3NlcnQuZXF1YWwgcG9wdXBBLnN0YXRlLm9wZW4sIGZhbHNlXG5cdFx0XHRcdFx0YXNzZXJ0LmVxdWFsIHBvcHVwQi5zdGF0ZS5vcGVuLCBmYWxzZVxuXHRcdFx0XHRcblx0XHRcdFx0LnRoZW4gKCktPiBwb3B1cEEub3BlbigpXG5cdFx0XHRcdC50aGVuICgpLT5cblx0XHRcdFx0XHRhc3NlcnQuZXF1YWwgcG9wdXBBLnN0YXRlLm9wZW4sIHRydWVcblx0XHRcdFx0XHRhc3NlcnQuZXF1YWwgcG9wdXBCLnN0YXRlLm9wZW4sIGZhbHNlXG5cblx0XHRcdFx0LnRoZW4gKCktPiBwb3B1cEIub3BlbigpXG5cdFx0XHRcdC50aGVuICgpLT5cblx0XHRcdFx0XHRhc3NlcnQuZXF1YWwgcG9wdXBBLnN0YXRlLm9wZW4sIGZhbHNlXG5cdFx0XHRcdFx0YXNzZXJ0LmVxdWFsIHBvcHVwQi5zdGF0ZS5vcGVuLCB0cnVlXG5cblx0XHRcdFx0LnRoZW4gKCktPiBwb3B1cEEub3BlbigpXG5cdFx0XHRcdC50aGVuICgpLT5cblx0XHRcdFx0XHRhc3NlcnQuZXF1YWwgcG9wdXBBLnN0YXRlLm9wZW4sIGZhbHNlXG5cdFx0XHRcdFx0YXNzZXJ0LmVxdWFsIHBvcHVwQi5zdGF0ZS5vcGVuLCB0cnVlXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4iXSwibmFtZXMiOlsiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJSRUdFWF9MRU5fVkFMIiwiUkVHRVhfRElHSVRTIiwiUkVHRVhfU1BBQ0UiLCJSRUdFWF9LRUJBQiIsIklNUE9SVEFOVCIsIlBPU1NJQkxFX1BSRUZJWEVTIiwiUkVRVUlSRVNfVU5JVF9WQUxVRSIsIlFVQURfU0hPUlRIQU5EUyIsIkRJUkVDVElPTlMiLCJmb3JFYWNoIiwicHJvcGVydHkiLCJkaXJlY3Rpb24iLCJpIiwibGVuIiwicHVzaCIsImxlbmd0aCIsIlNBTVBMRV9TVFlMRSIsInN0eWxlQ29uZmlnIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic3R5bGUiLCJpbmNsdWRlcyIsInRhcmdldCIsIml0ZW0iLCJpbmRleE9mIiwiaXNJdGVyYWJsZSIsIm5vZGVUeXBlIiwidG9LZWJhYkNhc2UiLCJzdHJpbmciLCJyZXBsYWNlIiwiZSIsImxldHRlciIsImNvbmNhdCIsInRvTG93ZXJDYXNlIiwiaXNQcm9wU3VwcG9ydGVkIiwiaXNWYWx1ZVN1cHBvcnRlZCIsInZhbHVlIiwid2luZG93IiwiQ1NTIiwic3VwcG9ydHMiLCJnZXRQcmVmaXgiLCJza2lwSW5pdGlhbENoZWNrIiwiaiIsImxlbjEiLCJwcmVmaXgiLCJub3JtYWxpemVQcm9wZXJ0eSIsIm5vcm1hbGl6ZVZhbHVlIiwidGVzdCIsInNvcnQiLCJhcnJheSIsImdyZWF0IiwibGVzcyIsInBpdm90IiwiaGFzaCIsImhzaCIsImNoYXJDb2RlQXQiLCJydWxlVG9TdHJpbmciLCJydWxlIiwiaW1wb3J0YW50Iiwib3V0cHV0IiwicHJvcCIsInByb3BzIiwiT2JqZWN0Iiwia2V5cyIsImlubGluZVN0eWxlQ29uZmlnIiwiY3JlYXRlIiwiaW5saW5lU3R5bGUiLCJ2YWx1ZVRvU3RvcmUiLCJsZXZlbCIsImNvbmZpZyIsInN0eWxlRWwiLCJpZCIsImhlYWQiLCJhcHBlbmRDaGlsZCIsImVsIiwiY29udGVudCIsImNhY2hlIiwidGV4dENvbnRlbnQiLCJjbGVhcklubGluZVN0eWxlIiwia2V5IiwidmVyc2lvbiIsIl9xdWlja2NzcyIsImluZGV4IiwicXVpY2tjc3MiLCJ0YXJnZXRFbCIsImNvbXB1dGVkU3R5bGUiLCJzdWJFbCIsInN1YlByb3BlcnR5Iiwic3ViVmFsdWUiLCJfY29tcHV0ZWRTdHlsZSIsImdldENvbXB1dGVkU3R5bGUiLCJzZXRQcm9wZXJ0eSIsImFuaW1hdGlvbiIsIm5hbWUkJDEiLCJmcmFtZXMiLCJmcmFtZSIsImdlbmVyYXRlZCIsInJ1bGVzIiwicmVnaXN0ZXIiLCJjbGFzc05hbWUiLCJyZWYiLCJjbGVhclJlZ2lzdGVyZWQiLCJVTlNFVCIsInN1cHBvcnRzUHJvcGVydHkiLCJfdHlwZW9mJDEiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydHkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfaXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlU3ByZWFkIiwiQXJyYXkiLCJpc0FycmF5IiwiYXJyMiIsIml0ZXIiLCJ0b1N0cmluZyIsImNhbGwiLCJmcm9tIiwiX3R5cGVvZiQyIiwiX2V4dGVuZCIsImlzT2JqZWN0IiwiX3Nob3VsZERlZXBFeHRlbmQiLCJzaG91bGREZWVwRXh0ZW5kIiwib3B0aW9ucyIsInBhcmVudEtleSIsImRlZXAiLCJub3REZWVwIiwiZGVlcE9ubHkiLCJleHRlbmQiLCJzb3VyY2VzIiwic291cmNlIiwic291cmNlVmFsdWUiLCJzdWJUYXJnZXQiLCJ0YXJnZXRWYWx1ZSIsImFsbG93TnVsbCIsIm51bGxEZWxldGVzIiwibm90S2V5cyIsIm93biIsImhhc093blByb3BlcnR5IiwiZ2xvYmFsRmlsdGVyIiwiZmlsdGVycyIsImdsb2JhbFRyYW5zZm9ybSIsInRyYW5zZm9ybXMiLCJ2ZXJzaW9uJDEiLCJtb2RpZmllcnMiLCJuZXdCdWlsZGVyIiwibm9ybWFsaXplS2V5cyIsInByaW1hcnlCdWlsZGVyIiwiaXNCYXNlIiwiX2J1aWxkZXIiLCJidWlsZGVyIiwidGhlVGFyZ2V0IiwiJF9sZW4iLCJhcmd1bWVudHMiLCIkX2kiLCJzaGlmdCIsImRlZmluZVByb3BlcnRpZXMiLCJnZXQiLCJfIiwidHJhbnNmb3JtIiwiZmlsdGVyIiwicHJpbWFyeUJ1aWxkZXIkMSIsInRlbXBsYXRlIiwiZWxlbWVudCIsIl90eXBlb2YkMyIsIl9jbGFzc0NhbGxDaGVjayQxIiwiX2RlZmluZVByb3BlcnRpZXMkMSIsIl9jcmVhdGVDbGFzcyQxIiwiZGVmaW5lZCIsInN1YmplY3QiLCJvYmplY3QiLCJvYmplY3RQbGFpbiIsIm51bWJlciIsImlzTmFOIiwibnVtYmVyTG9vc2UiLCJOdW1iZXIiLCJpdGVyYWJsZSIsImZ1bmN0aW9uXyIsIm5hdGl2ZXMiLCJmcmVlemUiLCJkb21Eb2MiLCJkb21FbCIsImRvbVRleHQiLCJkb21Ob2RlIiwiZG9tVGV4dGFyZWEiLCJub2RlTmFtZSIsImRvbUlucHV0IiwiZG9tU2VsZWN0IiwiZG9tRmllbGQiLCJkb20iLCJBVkFJTF9TRVRTIiwiQ2hlY2tzIiwiYXJncyIsInNsaWNlIiwic2V0cyIsInNldCIsImxvYWQiLCJpbmRleCQxIiwiSVMiLCJxdWlja0RvbUVsIiwibmFtZSIsIklTJDEiLCJRdWlja0VsZW1lbnQiLCJRdWlja1dpbmRvdyIsIl9xdWlja2RvbSIsInF1aWNrZG9tIiwiYXJnIiwicHJldkNvdW50IiwiY291bnQiLCJfcG9zdENyZWF0aW9uIiwiYXJnc0xlbmd0aCIsImNoaWxkIiwiY2hpbGRyZW4iLCJ0eXBlIiwiYXBwbHkiLCJzcGF3biIsInVwZGF0ZU9wdGlvbnMiLCJfcXVpY2tFbGVtZW50IiwiZXhpc3RpbmciLCJ0ZXh0IiwiYXBwZW5kIiwiaHRtbCIsImlubmVySFRNTCIsImNvbnRhaW5lciIsImNoaWxkTm9kZXMiLCJiYXRjaCIsImlzUXVpY2tFbCIsImlzRWwiLCJpbml0IiwiUXVpY2tFbGVtZW50XyIsIlF1aWNrV2luZG93XyIsImluY2x1ZGVzJDEiLCJyZW1vdmVJdGVtIiwiaXRlbUluZGV4Iiwic3BsaWNlIiwibm9ybWFsaXplRWxlbWVudEFyZyIsImlzU3RhdGVTdHlsZSIsInJlZ2lzdGVyU3R5bGUiLCJjYWNoZWQiLCJzdHlsZUNhY2hlIiwiZm5zIiwiX2NsYXNzIiwidmFsdWVzIiwiaW5kZXgkJDEiLCJSRUdFWF9XSElURVNQQUNFIiwib25fIiwiZXZlbnROYW1lcyIsImNhbGxiYWNrIiwidXNlQ2FwdHVyZSIsImlzUHJpdmF0ZSIsIl90aGlzIiwiY2FsbGJhY2tSZWYiLCJzcGxpdCIsIl9ldmVudENhbGxiYWNrcyIsIl9fcmVmcyIsImZ1bmN0aW9uIiwiX2luc2VydGVkIiwiX3BhcmVudCIsImV2ZW50TmFtZSIsImJhc2UiLCJfbGlzdGVuVG8iLCJldmVudCIsIl9pbnZva2VIYW5kbGVycyIsIm9uY2UiLCJfdGhpczIiLCJfb25jZUNhbGxiYWNrIiwib24iLCJvbmNlQ2FsbGJhY2siLCJvZmYiLCJvZmZfIiwiX3RoaXMzIiwiZW1pdCIsImJ1YmJsZXMiLCJ1bmRlZmluZWQiLCJjYW5jZWxhYmxlIiwiZGF0YSIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImVtaXRQcml2YXRlIiwiY2FsbGJhY2tzIiwiY2IiLCJldmVudE5hbWVUb0xpc3RlbkZvciIsImxpc3Rlbk1ldGhvZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudHMiLCJyZXN1bHQiLCJyZWxhdGVkIiwiY3VycmVudFN0YXRlU3R5bGUiLCJ0aGVuIiwiZm9yY2VTdHlsZSIsInN0eWxlU2FmZSIsInNraXBDb21wdXRlZCIsImNvbXB1dGVkIiwic2FtcGxlIiwic3R5bGVQYXJzZWQiLCJwYXJzZUZsb2F0IiwicmVjYWxjU3R5bGUiLCJyZWNhbGNDaGlsZHJlbiIsInRhcmdldFN0eWxlcyIsIl9yZXNvbHZlRm5TdHlsZXMiLCJfZ2V0QWN0aXZlU3RhdGVzIiwiX2NoaWxkcmVuIiwic3RhdGUiLCJzdGF0ZXMiLCJfc3RhdGUiLCJfc3RhdGVTaGFyZWQiLCJfc3RhdGVzIiwiX3N0eWxlcyIsImhpZGUiLCJzaG93IiwiZGlzcGxheSIsIm9yaWVudGF0aW9uR2V0dGVyIiwid2lkdGgiLCJoZWlnaHQiLCJhc3BlY3RSYXRpb0dldHRlciIsInN0eWxlJDEiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJRdWlja1dpbmRvdyQxIiwiUXVpY2tXaW5kb3ckMiIsInJhdyIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsIk1lZGlhUXVlcnkiLCJSVUxFX0RFSUxJTUlURVIiLCJNZWRpYVF1ZXJ5JDEiLCJ0ZXN0UnVsZSIsInBhcnNlUXVlcnkiLCJxdWVyeVN0cmluZyIsInF1ZXJ5U3BsaXQiLCJwYXJlbnQiLCJwYXJlbnRNYXRjaGluZyIsIm1hcCIsImdldHRlciIsImtleVByZWZpeCIsIm1heCIsIm1pbiIsIm9yaWVudGF0aW9uIiwiYXNwZWN0UmF0aW8iLCJwYXJzZWRWYWx1ZSIsInN0cmluZ1ZhbHVlIiwicXVlcnkiLCJjdXJyZW50VmFsdWUiLCJwYXNzZWQiLCJTdGF0ZUNoYWluIiwiU3RhdGVDaGFpbiQxIiwiam9pbiIsIndpdGhvdXQiLCJpc0FwcGxpY2FibGUiLCJvdGhlckFjdGl2ZSIsImFjdGl2ZSIsIkJBU0VfU1RBVEVfVFJJR0dFUlMiLCJDQUNIRURfRk5fSU5TRVJURUQiLCJfbm9ybWFsaXplT3B0aW9ucyIsImJhc2UxIiwiYmFzZTIiLCJiYXNlMyIsImJhc2U0IiwiYmFzZTUiLCJyZWxhdGVkSW5zdGFuY2UiLCJjbGFzcyIsInVybCIsImhyZWYiLCJ1bnBhc3NhYmxlU3RhdGVzIiwicGFzc1N0YXRlVG9DaGlsZHJlbiIsInBhc3NEYXRhVG9DaGlsZHJlbiIsInN0YXRlVHJpZ2dlcnMiLCJjbG9uZSIsIl9wYXJzZVRleHRzIiwiX3RleHRzIiwiX3BhcnNlU3R5bGVzIiwic3R5bGVzIiwic3RvcmUiLCJfbWVkaWFTdGF0ZXMiLCJfcHJvdmlkZWRTdGF0ZXMiLCJfcHJvdmlkZWRTdGF0ZXNTaGFyZWQiLCJfZmxhdHRlbk5lc3RlZFN0YXRlcyIsInNwZWNpYWxTdGF0ZXMiLCJzdGF0ZVN0eWxlcyIsInN0YXRlXyIsIiRiYXNlIiwiZmxhdHRlbk5lc3RlZFN0YXRlcyIsInN0eWxlT2JqZWN0IiwiY2hhaW4iLCJoYXNOb25TdGF0ZVByb3BzIiwic3RhdGVDaGFpbiIsInN0eWxlS2V5cyIsInRleHRzIiwiX2FwcGx5T3B0aW9ucyIsImhhbmRsZXIiLCJtZXRob2QiLCJyZWYxIiwicmVmMiIsImF0dHIiLCJzcmMiLCJzZWxlY3RlZCIsImNoZWNrZWQiLCJhdHRycyIsIl9hcHBseVJlZ2lzdGVyZWRTdHlsZSIsInN0eWxlQWZ0ZXJJbnNlcnQiLCJpbnZva2VDb21wdXRlcnNPbmNlIiwiX2ludm9rZWRDb21wdXRlcnMiLCJyZWNhbGNPblJlc2l6ZSIsIm1ldGhvZHMiLCJjb21wdXRlcnMiLCJhcHBseURhdGEiLCJfaW5pdCIsIl9ydW5Db21wdXRlciIsIl9hdHRhY2hTdGF0ZUV2ZW50cyIsImZvcmNlIiwiZGlzYWJsZXIiLCJlbmFibGVyIiwidHJpZ2dlciIsIl9wcm94eVBhcmVudCIsIm5ld1BhcmVudCIsImxhc3RQYXJlbnQiLCJwYXJlbnRzIiwiZG9jdW1lbnRFbGVtZW50IiwiX3VucHJveHlQYXJlbnQiLCJtZWRpYVN0YXRlcyIsInJlc3VsdHMiLCJpbml0JDEiLCJhbGlhc2VzIiwicGFyZW50c1VudGlsIiwiX2dldFBhcmVudHMiLCJpc1JlZiIsIm5leHRQYXJlbnQiLCJzZWxlY3RvciIsInF1ZXJ5U2VsZWN0b3IiLCJxdWVyeUFsbCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJfZ2V0Q2hpbGRSZWZzIiwiZnJlc2hDb3B5IiwiY2hpbGRSZWZzIiwicmVmcyIsIl9jaGlsZFJlZnMiLCJfZ2V0SW5kZXhCeVByb3AiLCJtYWluIiwiX2ZpbHRlckVsZW1lbnRzIiwidHJhdmVyc2luZyIsInBhcmVudE5vZGUiLCJuZXh0U2libGluZyIsIm5leHRFbGVtZW50U2libGluZyIsIm5leHRBbGwiLCJzaWJsaW5ncyIsIm5leHQiLCJwcmV2aW91c1NpYmxpbmciLCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwicHJldkFsbCIsInByZXZTaWJsaW5nIiwicHJldiIsInJldmVyc2UiLCJEVU1NWV9BUlJBWSIsInRhcmdldFN0YXRlIiwiYWN0aXZlU3RhdGVzIiwiZGVzaXJlZFZhbHVlIiwidG9nZ2xlIiwiX3N0YXRlUGlwZVRhcmdldCIsInRvZ2dsZVN0YXRlIiwicmVzZXRTdGF0ZSIsImFjdGl2ZVN0YXRlIiwicGlwZVN0YXRlIiwidGFyZ2V0U3R5bGUiLCJzdXBlcmlvclN0YXRlcyIsImluY2x1ZGVCYXNlIiwic2tpcEZucyIsImVudHJ5IiwiayIsInN1cGVyaW9yU3R5bGVzIiwiYWRkQ2xhc3MiLCJfcmVtb3ZlUmVnaXN0ZXJlZFN0eWxlIiwicmVzZXRWYWx1ZSIsInJlbW92ZUNsYXNzIiwiX3R1cm5TdHlsZU9OIiwic2hhcmVkU3RhdGVzIiwiX2dldFN1cGVyaW9yU3RhdGVzIiwiX2dldFNoYXJlZFN0YXRlcyIsIl90dXJuU3R5bGVPRkYiLCJhY3RpdmVTaGFyZWRTdGF0ZXMiLCJfdHVyblRleHRPTiIsInRhcmdldFRleHQiLCJfdHVyblRleHRPRkYiLCJzdGF0ZVRvRXhjbHVkZSIsImluY2x1ZGVTaGFyZWRTdGF0ZXMiLCJwbGFpblN0YXRlcyIsImNhbmRpZGF0ZSIsInN1cGVyaW9yIiwidGFyZ2V0U3RhdGVJbmRleCIsInN0YXRlJDEiLCJ0b1RlbXBsYXRlIiwiZWxDbG9uZSIsImxlbjIiLCJuZXdFbCIsImNsb25lTm9kZSIsInByZXZQYXJlbnQiLCJfcmVtb3ZlQ2hpbGQiLCJfcmVmcmVzaFBhcmVudCIsImFwcGVuZFRvIiwicHJlcGVuZCIsInVuc2hpZnQiLCJpbnNlcnRCZWZvcmUiLCJmaXJzdENoaWxkIiwicHJlcGVuZFRvIiwiYWZ0ZXIiLCJteUluZGV4IiwiaW5zZXJ0QWZ0ZXIiLCJiZWZvcmUiLCJkZXRhY2giLCJyZW1vdmUiLCJlbXB0eSIsIndyYXAiLCJjdXJyZW50UGFyZW50IiwidW53cmFwIiwiZ3JhbmRQYXJlbnQiLCJwYXJlbnRDaGlsZHJlbiIsInBhcmVudFNpYmxpbmciLCJoYXNDbGFzcyIsImNsYXNzTGlzdCIsInRhcmdldEluZGV4IiwidG9nZ2xlQ2xhc3MiLCJzZXRSZWYiLCJ0YXJnZXRDaGlsZCIsInJlcGxhY2VtZW50Q2hpbGQiLCJpbmRleE9mQ2hpbGQiLCJyZXBsYWNlQ2hpbGQiLCJyZW1vdmVDaGlsZCIsIm1hbmlwdWxhdGlvbiIsIm5ld1ZhbHVlIiwic3ZnIiwibGlzdCIsInBvcCIsInVwZGF0ZVN0YXRlU3R5bGVzIiwicGFyc2VkIiwidXBkYXRlZFN0YXRlcyIsInVwZGF0ZVN0YXRlVGV4dHMiLCJwYXNzVGhyb3VnaCIsImRlZmF1bHRzIiwiY29tcHV0ZXIiLCJhcHBsaWNhdGlvbiIsImdldEF0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsImF0dHJpYnV0ZXNBbmRQcm9wZXJ0aWVzIiwiUXVpY2tFbGVtZW50JDEiLCJzdmdOYW1lc3BhY2UiLCJRdWlja0VsZW1lbnQkMiIsImNyZWF0ZVRleHROb2RlIiwiY3JlYXRlRWxlbWVudE5TIiwidG9KU09OIiwic2NoZW1hIiwibWF0Y2hlc1NjaGVtYSIsIlBBUlNFX0VSUk9SX1BSRUZJWCIsInBhcnNlVHJlZSIsInBhcnNlVHJlZSQxIiwidHJlZSIsInBhcnNlQ2hpbGRyZW4iLCJFcnJvciIsIlN0cmluZyIsIk5PVF9ERUVQX0tFWVMiLCJOT1RfS0VZUyIsIl9leHRlbmRCeVJlZiIsImV4dGVuZFRlbXBsYXRlIiwiZXh0ZW5kVGVtcGxhdGUkMSIsImN1cnJlbnRPcHRzIiwibmV3T3B0cyIsImdsb2JhbE9wdHMiLCJjdXJyZW50Q2hpbGQiLCJjdXJyZW50Q2hpbGRyZW4iLCJnbG9iYWxPcHRzVHJhbnNmb3JtIiwibWF4TGVuZ3RoIiwibmVlZHNUZW1wbGF0ZVdyYXAiLCJuZXdDaGlsZCIsIm5ld0NoaWxkUHJvY2Vzc2VkIiwibmV3Q2hpbGRyZW4iLCJub0NoYW5nZXMiLCJyZW1haW5pbmdOZXdDaGlsZHJlbiIsIm9wdHMiLCJNYXRoIiwiUXVpY2tUZW1wbGF0ZSQxIiwiZXh0ZW5kQnlSZWYiLCJuZXdDaGlsZHJlblJlZnMiLCJRdWlja1RlbXBsYXRlIiwiaXNUcmVlIiwibmV3VmFsdWVzIiwiY2hpbGREYXRhIiwiX2V4dGVuZFRlbXBsYXRlIiwiaXNUZW1wbGF0ZSIsIlF1aWNrQmF0Y2giLCJRdWlja0JhdGNoJDEiLCJlbGVtZW50cyIsInJldHVyblJlc3VsdHMxIiwicmV0dXJuUmVzdWx0cyIsIl9yZXR1cm4iLCJyZXR1cm5OZXh0IiwibGFzdFJlc3VsdHMiLCJyZXN1bHRzMSIsIl9lbGVtZW50IiwidmVyc2lvbiQyIiwiU0hPUlRDVVRTIiwic2hvcnRjdXQiLCJwcm9taXNlIiwib25GaW5hbGx5IiwidmFsIiwiUHJvbWlzZSIsInJlc29sdmUiLCJlcnIiLCJUaW1lb3V0RXJyb3IiLCJtZXNzYWdlIiwibXMiLCJmYWxsYmFjayIsInJlamVjdCIsInRpbWVyIiwic2V0VGltZW91dCIsInBGaW5hbGx5IiwiY2xlYXJUaW1lb3V0IiwiZW1pdHRlciIsImNhbmNlbCIsInJldCIsImFzc2lnbiIsInJlamVjdGlvbkV2ZW50cyIsIm11bHRpQXJncyIsImFkZExpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYmluZCIsInJlc29sdmVIYW5kbGVyIiwicmVqZWN0SGFuZGxlciIsInJlYXNvbiIsInJlamVjdGlvbkV2ZW50IiwidGltZW91dCIsInBUaW1lb3V0IiwiY3JlYXRlRW5kQnJlYWsiLCJfX2lzRW5kQnJlYWsiLCJ0eXBlcyIsImVsZW0iLCJyZWR1Y2UiLCJ0cmFucyIsIkV2ZW50TGl0ZSIsIm1vZHVsZSIsIkxJU1RFTkVSUyIsIm1peGluIiwiZnVuYyIsImdldExpc3RlbmVycyIsInRoYXQiLCJvcmlnaW5hbExpc3RlbmVyIiwibGlzdG5lcnMiLCJuZSIsImxpc3RlbmVycyIsImFyZ2xlbiIsInplcm9hcmciLCJvbmVhcmciLCJtb3JlYXJncyIsInJlYWRvbmx5IiwiSVNfIiwiRE9NIiwicG9wdXAiLCJwb3NpdGlvbiIsInpJbmRleCIsInRvcCIsImxlZnQiLCJtaW5IZWlnaHQiLCJ2aXNpYmlsaXR5Iiwib3ZlcmZsb3ciLCJ0cmFuc2l0aW9uIiwic2V0dGluZ3MiLCIkb3BlbiIsIm92ZXJsYXkiLCJvcGFjaXR5IiwiYmFja2dyb3VuZENvbG9yIiwib3ZlcmxheUNvbG9yIiwiYm94U2l6aW5nIiwibWF4V2lkdGgiLCJtYXJnaW4iLCJwYWRkaW5nIiwiY29udGVudFBhZGRpbmciLCJkdXJhdGlvbiIsIiRjZW50ZXJQbGFjZW1lbnQiLCIkdG9wUGxhY2VtZW50IiwiJGJvdHRvbVBsYWNlbWVudCIsImJvdHRvbSIsInBsYWNlbWVudCIsInZpc2libGUiLCJhbGlnblRvQ2VudGVyIiwiY2xvc2UiLCJpbnNpZGUiLCJzaXplIiwicmlnaHQiLCJjb2xvciIsInZpZXdCb3giLCJkIiwiZmlsbCIsImJvZHlXcmFwcGVyIiwidGVtcGxhdGVzIiwiZXh0ZW5kU2V0dGluZ3MiLCJjb25kaXRpb24iLCJvcGVuIiwidHJpZ2dlcnMiLCJzY2hlZHVsZVNjcm9sbFJlc2V0Iiwic2NoZWR1bGVOZXh0Iiwic2Nyb2xsIiwidHJhbnNpdGlvbkVuZCIsImRldGVjdEFuaW1hdGlvbiIsInNjcm9sbE9mZnNldCIsInNjcm9sbFkiLCJkb2N1bWVudE9mZnNldCIsImJvZHkiLCJ2aXNpYmlsaXR5QXBpS2V5cyIsImhpZGRlbiIsInZpc2liaWxpdHljaGFuZ2UiLCJtc0hpZGRlbiIsIndlYmtpdEhpZGRlbiIsImlzSUUiLCJhbGwiLCJhdG9iIiwiaXNJRTExIiwibmF2aWdhdG9yIiwibXNQb2ludGVyRW5hYmxlZCIsImlzRWRnZSIsInVzZXJBZ2VudCIsIlBvcHVwIiwiRXZlbnRFbWl0dGVyIiwid3JhcEJvZHkiLCJib2R5Q2hpbGRyZW4iLCJ1bndyYXBCb2R5IiwiZGVzdHJveUFsbCIsImluc3RhbmNlcyIsImRlc3Ryb3kiLCJ0ZW1wbGF0ZTEiLCJyb3VuZCIsInJhbmRvbSIsImRlc3Ryb3llZCIsIm9mZnNldCIsIl9jcmVhdGVFbGVtZW50cyIsIl9hdHRhY2hCaW5kaW5ncyIsIl9hcHBseVRlbXBsYXRlIiwiY2xvc2UkJDEiLCJjb250ZW50JCQxIiwib3ZlcmxheSQkMSIsImN1c3RvbSIsImVzYyIsImtleUNvZGUiLCJzdG9wUHJvcGFnYXRpb24iLCJwcmV2ZW50RGVmYXVsdCIsImV4aXRJbnRlbnQiLCJ0aHJlc2hvbGQiLCJ5VGhyZXNob2xkIiwiY2xpZW50WSIsIm5hdmlnYXRpb24iLCJoaXN0b3J5IiwicHVzaFN0YXRlIiwicmVwbGFjZVN0YXRlIiwiYmFjayIsIl9kZXRhY2hCaW5kaW5ncyIsIl90aHJvd0Rlc3Ryb3llZCIsInNldENvbnRlbnQiLCJxdWlja0VsIiwicmVwbGFjZVdpdGgiLCJjb250ZW50SGVpZ2h0Iiwid2luZG93SGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwidHJpZ2dlck5hbWUiLCJoYXNPcGVuIiwiZm9yY2VPcGVuIiwib3BlbkxpbWl0IiwibWluV2lkdGgiLCJwcm9taXNlQnJlYWsiLCJvcGVuUG9wdXBzIiwicG9wdXAkJDEiLCJwcm9taXNlRXZlbnQiLCJjYXRjaCIsImVuZCIsInByZXZlbnRSZXNldCIsIlBvcHVwJDEiLCJxdWlja3BvcHVwIiwiZGVmYXVsdHMkJDEiLCJuZXdTZXR0aW5ncyIsIm5ld1RlbXBsYXRlcyIsIm91dHB1dFNldHRpbmdzIiwib3V0cHV0VGVtcGxhdGVzIiwicXVpY2twb3B1cCQxIiwicmVzdGFydFNhbmRib3giLCJzYW5kYm94IiwiZGl2IiwiYm9yZGVyIiwiZXhjbHVkZSIsImV4Y2x1ZGVzIiwiZXhjbHVkZVByb3BzIiwicmVzIiwiZXh0ZW5kRXhjbHVkZSIsIkFzc2VydGlvbkVycm9yIiwiX3Byb3BzIiwic3NmIiwic2hvd0RpZmYiLCJjYXB0dXJlU3RhY2tUcmFjZSIsInN0YWNrIiwiaGFzUHJvcGVydHkiLCJwYXJzZVBhdGgiLCJwYXRoIiwic3RyIiwicGFydHMiLCJtYXRjaCIsIm1hcE1hdGNoZXMiLCJyZWdleHAiLCJtQXJyIiwiZXhlYyIsInAiLCJpbnRlcm5hbEdldFBhdGhWYWx1ZSIsInBhdGhEZXB0aCIsInRlbXBvcmFyeVZhbHVlIiwicGFydCIsImludGVybmFsU2V0UGF0aFZhbHVlIiwidGVtcE9iaiIsInByb3BOYW1lIiwicHJvcFZhbCIsImdldFBhdGhJbmZvIiwibGFzdCIsImluZm8iLCJleGlzdHMiLCJnZXRQYXRoVmFsdWUiLCJzZXRQYXRoVmFsdWUiLCJmbGFnIiwiZmxhZ3MiLCJfX2ZsYWdzIiwibmVnYXRlIiwiZXhwciIsImdsb2JhbCIsImZhY3RvcnkiLCJ0aGlzIiwicHJvbWlzZUV4aXN0cyIsImdsb2JhbE9iamVjdCIsInNlbGYiLCJzeW1ib2xFeGlzdHMiLCJtYXBFeGlzdHMiLCJNYXAiLCJzZXRFeGlzdHMiLCJTZXQiLCJ3ZWFrTWFwRXhpc3RzIiwiV2Vha01hcCIsIndlYWtTZXRFeGlzdHMiLCJXZWFrU2V0IiwiZGF0YVZpZXdFeGlzdHMiLCJEYXRhVmlldyIsInN5bWJvbEl0ZXJhdG9yRXhpc3RzIiwic3ltYm9sVG9TdHJpbmdUYWdFeGlzdHMiLCJ0b1N0cmluZ1RhZyIsInNldEVudHJpZXNFeGlzdHMiLCJlbnRyaWVzIiwibWFwRW50cmllc0V4aXN0cyIsInNldEl0ZXJhdG9yUHJvdG90eXBlIiwiZ2V0UHJvdG90eXBlT2YiLCJtYXBJdGVyYXRvclByb3RvdHlwZSIsImFycmF5SXRlcmF0b3JFeGlzdHMiLCJhcnJheUl0ZXJhdG9yUHJvdG90eXBlIiwic3RyaW5nSXRlcmF0b3JFeGlzdHMiLCJzdHJpbmdJdGVyYXRvclByb3RvdHlwZSIsInRvU3RyaW5nTGVmdFNsaWNlTGVuZ3RoIiwidG9TdHJpbmdSaWdodFNsaWNlTGVuZ3RoIiwidHlwZURldGVjdCIsInR5cGVvZk9iaiIsImxvY2F0aW9uIiwibWltZVR5cGVzIiwicGx1Z2lucyIsIkhUTUxFbGVtZW50IiwidGFnTmFtZSIsInN0cmluZ1RhZyIsIm9ialByb3RvdHlwZSIsIlJlZ0V4cCIsIkRhdGUiLCJleHBlY3RUeXBlcyIsImZsYWdNc2ciLCJzc2ZpIiwidCIsImFydCIsImNoYXJBdCIsIm9yIiwib2JqVHlwZSIsInNvbWUiLCJleHBlY3RlZCIsImdldEFjdHVhbCIsIl9vYmoiLCJGdW5jdGlvbiIsImZ1bmN0aW9uTmFtZU1hdGNoIiwiZ2V0RnVuY05hbWUiLCJhRnVuYyIsImdldFByb3BlcnRpZXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiYWRkUHJvcGVydHkiLCJwcm90byIsImdldEVudW1lcmFibGVQcm9wZXJ0aWVzIiwiaW5jbHVkZVN0YWNrIiwidHJ1bmNhdGVUaHJlc2hvbGQiLCJ1c2VQcm94eSIsInByb3h5RXhjbHVkZWRLZXlzIiwiaW5zcGVjdCIsInNob3dIaWRkZW4iLCJkZXB0aCIsImNvbG9ycyIsImN0eCIsInNlZW4iLCJzdHlsaXplIiwiZm9ybWF0VmFsdWUiLCJpc0RPTUVsZW1lbnQiLCJyZWN1cnNlVGltZXMiLCJleHBvcnRzIiwicHJpbWl0aXZlIiwiZm9ybWF0UHJpbWl0aXZlIiwib3V0ZXJIVE1MIiwieG1sVmVyc2lvbiIsInhtbFNlcmlhbGl6ZXIiLCJYTUxTZXJpYWxpemVyIiwic2VyaWFsaXplVG9TdHJpbmciLCJucyIsInZpc2libGVLZXlzIiwibmFtZVN1ZmZpeCIsImlzRXJyb3IiLCJnZXROYW1lIiwiaXNSZWdFeHAiLCJpc0RhdGUiLCJ0b1VUQ1N0cmluZyIsImZvcm1hdEVycm9yIiwidHlwZWRBcnJheSIsImJyYWNlcyIsImlzVHlwZWRBcnJheSIsImZvcm1hdEFycmF5IiwiZm9ybWF0VHlwZWRBcnJheSIsImZvcm1hdFByb3BlcnR5IiwicmVkdWNlVG9TaW5nbGVTdHJpbmciLCJzaW1wbGUiLCJKU09OIiwic3RyaW5naWZ5IiwiSW5maW5pdHkiLCJsIiwicHJvcERlc2NyaXB0b3IiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJsaW5lIiwic3Vic3RyIiwiY3VyIiwiYXIiLCJvYmplY3RUb1N0cmluZyIsInJlIiwibyIsIm9iakRpc3BsYXkiLCJrc3RyIiwiZ2V0TWVzc2FnZSIsImFjdHVhbCIsIm1zZyIsInRyYW5zZmVyRmxhZ3MiLCJhc3NlcnRpb24iLCJpbmNsdWRlQWxsIiwiRmFrZU1hcCIsIl9rZXkiLCJub3ciLCJnZXRNYXAiLCJzZXRNYXAiLCJpc0V4dGVuc2libGUiLCJNZW1vaXplTWFwIiwibWVtb2l6ZUNvbXBhcmUiLCJsZWZ0SGFuZE9wZXJhbmQiLCJyaWdodEhhbmRPcGVyYW5kIiwibWVtb2l6ZU1hcCIsImlzUHJpbWl0aXZlIiwibGVmdEhhbmRNYXAiLCJtZW1vaXplU2V0IiwiZGVlcEVxdWFsIiwiY29tcGFyYXRvciIsImV4dGVuc2l2ZURlZXBFcXVhbCIsInNpbXBsZVJlc3VsdCIsInNpbXBsZUVxdWFsIiwibWVtb2l6ZSIsIm1lbW9pemVSZXN1bHRMZWZ0IiwibWVtb2l6ZVJlc3VsdFJpZ2h0IiwiY29tcGFyYXRvclJlc3VsdCIsImxlZnRIYW5kVHlwZSIsImV4dGVuc2l2ZURlZXBFcXVhbEJ5VHlwZSIsInZhbHVlT2YiLCJpdGVyYWJsZUVxdWFsIiwicmVnZXhwRXF1YWwiLCJnZW5lcmF0b3JFcXVhbCIsIlVpbnQ4QXJyYXkiLCJidWZmZXIiLCJlbnRyaWVzRXF1YWwiLCJvYmplY3RFcXVhbCIsImxlZnRIYW5kSXRlbXMiLCJyaWdodEhhbmRJdGVtcyIsImdhdGhlckVudHJpZXMiLCJnZXRHZW5lcmF0b3JFbnRyaWVzIiwiaGFzSXRlcmF0b3JGdW5jdGlvbiIsImdldEl0ZXJhdG9yRW50cmllcyIsIml0ZXJhdG9yRXJyb3IiLCJnZW5lcmF0b3IiLCJnZW5lcmF0b3JSZXN1bHQiLCJhY2N1bXVsYXRvciIsImRvbmUiLCJnZXRFbnVtZXJhYmxlS2V5cyIsImtleXNFcXVhbCIsImxlZnRIYW5kS2V5cyIsInJpZ2h0SGFuZEtleXMiLCJsZWZ0SGFuZEVudHJpZXMiLCJyaWdodEhhbmRFbnRyaWVzIiwiaXNQcm94eUVuYWJsZWQiLCJQcm94eSIsIlJlZmxlY3QiLCJwcm9wZXJ0eUdldHRlciIsIm5ld0Fzc2VydGlvbiIsImNoYWkiLCJBc3NlcnRpb24iLCJmbkxlbmd0aERlc2MiLCJhZGRMZW5ndGhHdWFyZCIsImZuIiwiYXNzZXJ0aW9uTmFtZSIsImlzQ2hhaW5hYmxlIiwiYnVpbHRpbnMiLCJwcm94aWZ5Iiwibm9uQ2hhaW5hYmxlTWV0aG9kTmFtZSIsInByb3h5R2V0dGVyIiwiaGFzIiwic3VnZ2VzdGlvbiIsInN1Z2dlc3Rpb25EaXN0YW5jZSIsImRpc3QiLCJzdHJpbmdEaXN0YW5jZUNhcHBlZCIsInN0ckEiLCJzdHJCIiwiY2FwIiwiYWJzIiwibWVtbyIsImNoIiwiYWRkTWV0aG9kIiwibWV0aG9kV3JhcHBlciIsIm92ZXJ3cml0ZVByb3BlcnR5IiwiX2dldCIsIl9zdXBlciIsIm92ZXJ3cml0aW5nUHJvcGVydHlHZXR0ZXIiLCJvcmlnTG9ja1NzZmkiLCJvdmVyd3JpdGVNZXRob2QiLCJfbWV0aG9kIiwib3ZlcndyaXRpbmdNZXRob2RXcmFwcGVyIiwiY2FuU2V0UHJvdG90eXBlIiwic2V0UHJvdG90eXBlT2YiLCJ0ZXN0Rm4iLCJleGNsdWRlTmFtZXMiLCJwcm9wRGVzYyIsImFkZENoYWluYWJsZU1ldGhvZCIsImNoYWluaW5nQmVoYXZpb3IiLCJjaGFpbmFibGVCZWhhdmlvciIsIl9fbWV0aG9kcyIsImNoYWluYWJsZU1ldGhvZEdldHRlciIsImNoYWluYWJsZU1ldGhvZFdyYXBwZXIiLCJhc3NlcnRlck5hbWVzIiwiYXNzZXJ0ZXJOYW1lIiwicGQiLCJvdmVyd3JpdGVDaGFpbmFibGVNZXRob2QiLCJfY2hhaW5pbmdCZWhhdmlvciIsIm92ZXJ3cml0aW5nQ2hhaW5hYmxlTWV0aG9kR2V0dGVyIiwib3ZlcndyaXRpbmdDaGFpbmFibGVNZXRob2RXcmFwcGVyIiwiY29tcGFyZUJ5SW5zcGVjdCIsImEiLCJiIiwiZ2V0T3duRW51bWVyYWJsZVByb3BlcnR5U3ltYm9scyIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bSIsImdldE93bkVudW1lcmFibGVQcm9wZXJ0aWVzIiwiY29tcGF0aWJsZUluc3RhbmNlIiwidGhyb3duIiwiZXJyb3JMaWtlIiwiY29tcGF0aWJsZUNvbnN0cnVjdG9yIiwiY29tcGF0aWJsZU1lc3NhZ2UiLCJlcnJNYXRjaGVyIiwiY29tcGFyaXNvblN0cmluZyIsImdldEZ1bmN0aW9uTmFtZSIsImNvbnN0cnVjdG9yRm4iLCJnZXRDb25zdHJ1Y3Rvck5hbWUiLCJjb25zdHJ1Y3Rvck5hbWUiLCJ0cmltIiwicmVxdWlyZSQkMCIsInJlcXVpcmUkJDEiLCJyZXF1aXJlJCQyIiwicmVxdWlyZSQkMyIsInJlcXVpcmUkJDQiLCJyZXF1aXJlJCQ1IiwicmVxdWlyZSQkNiIsInJlcXVpcmUkJDciLCJyZXF1aXJlJCQ4IiwicmVxdWlyZSQkOSIsInBhdGh2YWwiLCJyZXF1aXJlJCQxMCIsInJlcXVpcmUkJDExIiwicmVxdWlyZSQkMTIiLCJyZXF1aXJlJCQxMyIsInJlcXVpcmUkJDE0IiwicmVxdWlyZSQkMTUiLCJyZXF1aXJlJCQxNiIsInJlcXVpcmUkJDE3IiwicmVxdWlyZSQkMTgiLCJyZXF1aXJlJCQxOSIsInJlcXVpcmUkJDIwIiwicmVxdWlyZSQkMjEiLCJyZXF1aXJlJCQyMiIsInJlcXVpcmUkJDIzIiwicmVxdWlyZSQkMjQiLCJfY2hhaSIsInV0aWwiLCJsb2NrU3NmaSIsImNvbnNvbGUiLCJ3YXJuIiwiYXNzZXJ0IiwibmVnYXRlTXNnIiwiX2FjdHVhbCIsIm9rIiwiYW4iLCJhcnRpY2xlIiwiU2FtZVZhbHVlWmVybyIsImluY2x1ZGVDaGFpbmluZ0JlaGF2aW9yIiwiaW5jbHVkZSIsImlzRGVlcCIsImluY2x1ZGVkIiwiaXNFcWwiLCJlcWwiLCJmaXJzdEVyciIsIm51bUVycnMiLCJwcm9wQXNzZXJ0aW9uIiwiY2hlY2tFcnJvciIsIml0ZW1zQ291bnQiLCJjaGVja0FyZ3VtZW50cyIsImFzc2VydEVxdWFsIiwicHJldkxvY2tTc2ZpIiwiYXNzZXJ0RXFsIiwiYXNzZXJ0QWJvdmUiLCJuIiwiZG9MZW5ndGgiLCJtc2dQcmVmaXgiLCJuVHlwZSIsImVycm9yTWVzc2FnZSIsInNob3VsZFRocm93IiwidG8iLCJoYXZlIiwicHJpbnRPYmoiLCJhc3NlcnRMZWFzdCIsImFzc2VydEJlbG93IiwiYXNzZXJ0TW9zdCIsInN0YXJ0IiwiZmluaXNoIiwic3RhcnRUeXBlIiwiZmluaXNoVHlwZSIsInJhbmdlIiwiYXNzZXJ0SW5zdGFuY2VPZiIsImlzSW5zdGFuY2VPZiIsImFzc2VydFByb3BlcnR5IiwiaXNOZXN0ZWQiLCJpc093biIsIm5hbWVUeXBlIiwicGF0aEluZm8iLCJhc3NlcnRPd25Qcm9wZXJ0eSIsImFzc2VydE93blByb3BlcnR5RGVzY3JpcHRvciIsImFjdHVhbERlc2NyaXB0b3IiLCJhc3NlcnRMZW5ndGhDaGFpbiIsImFzc2VydExlbmd0aCIsImFzc2VydE1hdGNoIiwiaXMiLCJhc3NlcnRLZXlzIiwia2V5c1R5cGUiLCJkZWVwU3RyIiwibWl4ZWRBcmdzTXNnIiwiYW55IiwiZXhwZWN0ZWRLZXkiLCJhY3R1YWxLZXkiLCJldmVyeSIsImFzc2VydFRocm93cyIsImVyck1zZ01hdGNoZXIiLCJjYXVnaHRFcnIiLCJldmVyeUFyZ0lzVW5kZWZpbmVkIiwiZXZlcnlBcmdJc0RlZmluZWQiLCJCb29sZWFuIiwiZXJyb3JMaWtlRmFpbCIsImVyck1zZ01hdGNoZXJGYWlsIiwiZXJyb3JMaWtlU3RyaW5nIiwiaXNDb21wYXRpYmxlSW5zdGFuY2UiLCJpc0NvbXBhdGlibGVDb25zdHJ1Y3RvciIsInBsYWNlaG9sZGVyIiwiaXNDb21wYXRpYmxlTWVzc2FnZSIsInJlc3BvbmRUbyIsIml0c2VsZiIsImNvbnRleHQiLCJzYXRpc2Z5IiwibWF0Y2hlciIsImNsb3NlVG8iLCJkZWx0YSIsImlzU3Vic2V0T2YiLCJzdWJzZXQiLCJzdXBlcnNldCIsImNtcCIsImNvbnRhaW5zIiwib3JkZXJlZCIsImlkeCIsIm1hdGNoSWR4IiwiZWxlbTIiLCJiZSIsImZhaWxNc2ciLCJmYWlsTmVnYXRlTXNnIiwib25lT2YiLCJhc3NlcnRDaGFuZ2VzIiwiaW5pdGlhbCIsImZpbmFsIiwibXNnT2JqIiwiYXNzZXJ0SW5jcmVhc2VzIiwiYXNzZXJ0RGVjcmVhc2VzIiwiYXNzZXJ0RGVsdGEiLCJiZWhhdmlvciIsInJlYWxEZWx0YSIsImV4cHJlc3Npb24iLCJpc1NlYWxlZCIsImlzRnJvemVuIiwiaXNGaW5pdGUiLCJleHBlY3QiLCJmYWlsIiwib3BlcmF0b3IiLCJsb2FkU2hvdWxkIiwic2hvdWxkR2V0dGVyIiwic2hvdWxkU2V0dGVyIiwic2hvdWxkIiwiZXF1YWwiLCJ2YWwxIiwidmFsMiIsIlRocm93IiwiZXJydCIsImVycnMiLCJleGlzdCIsIm5vdCIsIlNob3VsZCIsImV4cHJlc3MiLCJlcnJtc2ciLCJpc09rIiwiaXNOb3RPayIsImFjdCIsImV4cCIsIm5vdEVxdWFsIiwic3RyaWN0RXF1YWwiLCJub3RTdHJpY3RFcXVhbCIsImRlZXBTdHJpY3RFcXVhbCIsIm5vdERlZXBFcXVhbCIsImlzQWJvdmUiLCJhYnYiLCJhYm92ZSIsImlzQXRMZWFzdCIsImF0bHN0IiwibGVhc3QiLCJpc0JlbG93IiwiYmx3IiwiYmVsb3ciLCJpc0F0TW9zdCIsImF0bXN0IiwibW9zdCIsImlzVHJ1ZSIsImlzTm90VHJ1ZSIsImlzRmFsc2UiLCJpc05vdEZhbHNlIiwiaXNOdWxsIiwiaXNOb3ROdWxsIiwiTmFOIiwiaXNOb3ROYU4iLCJub3RFeGlzdHMiLCJpc1VuZGVmaW5lZCIsImlzRGVmaW5lZCIsImlzRnVuY3Rpb24iLCJpc05vdEZ1bmN0aW9uIiwiaXNOb3RPYmplY3QiLCJpc05vdEFycmF5IiwiaXNTdHJpbmciLCJpc05vdFN0cmluZyIsImlzTnVtYmVyIiwiaXNOb3ROdW1iZXIiLCJmaW5pdGUiLCJpc0Jvb2xlYW4iLCJpc05vdEJvb2xlYW4iLCJ0eXBlT2YiLCJub3RUeXBlT2YiLCJpbnN0YW5jZU9mIiwibm90SW5zdGFuY2VPZiIsImluYyIsIm5vdEluY2x1ZGUiLCJkZWVwSW5jbHVkZSIsIm5vdERlZXBJbmNsdWRlIiwibmVzdGVkSW5jbHVkZSIsIm5lc3RlZCIsIm5vdE5lc3RlZEluY2x1ZGUiLCJkZWVwTmVzdGVkSW5jbHVkZSIsIm5vdERlZXBOZXN0ZWRJbmNsdWRlIiwib3duSW5jbHVkZSIsIm5vdE93bkluY2x1ZGUiLCJkZWVwT3duSW5jbHVkZSIsIm5vdERlZXBPd25JbmNsdWRlIiwibm90TWF0Y2giLCJub3RQcm9wZXJ0eSIsInByb3BlcnR5VmFsIiwibm90UHJvcGVydHlWYWwiLCJkZWVwUHJvcGVydHlWYWwiLCJub3REZWVwUHJvcGVydHlWYWwiLCJvd25Qcm9wZXJ0eSIsIm5vdE93blByb3BlcnR5Iiwib3duUHJvcGVydHlWYWwiLCJub3RPd25Qcm9wZXJ0eVZhbCIsImRlZXBPd25Qcm9wZXJ0eVZhbCIsIm5vdERlZXBPd25Qcm9wZXJ0eVZhbCIsIm5lc3RlZFByb3BlcnR5Iiwibm90TmVzdGVkUHJvcGVydHkiLCJuZXN0ZWRQcm9wZXJ0eVZhbCIsIm5vdE5lc3RlZFByb3BlcnR5VmFsIiwiZGVlcE5lc3RlZFByb3BlcnR5VmFsIiwibm90RGVlcE5lc3RlZFByb3BlcnR5VmFsIiwibGVuZ3RoT2YiLCJoYXNBbnlLZXlzIiwiaGFzQWxsS2V5cyIsImNvbnRhaW5zQWxsS2V5cyIsImNvbnRhaW4iLCJkb2VzTm90SGF2ZUFueUtleXMiLCJkb2VzTm90SGF2ZUFsbEtleXMiLCJoYXNBbnlEZWVwS2V5cyIsImhhc0FsbERlZXBLZXlzIiwiY29udGFpbnNBbGxEZWVwS2V5cyIsImRvZXNOb3RIYXZlQW55RGVlcEtleXMiLCJkb2VzTm90SGF2ZUFsbERlZXBLZXlzIiwidGhyb3dzIiwiYXNzZXJ0RXJyIiwidGhyb3ciLCJkb2VzTm90VGhyb3ciLCJhcHByb3hpbWF0ZWx5Iiwic2FtZU1lbWJlcnMiLCJzZXQxIiwic2V0MiIsInNhbWUiLCJtZW1iZXJzIiwibm90U2FtZU1lbWJlcnMiLCJzYW1lRGVlcE1lbWJlcnMiLCJub3RTYW1lRGVlcE1lbWJlcnMiLCJzYW1lT3JkZXJlZE1lbWJlcnMiLCJub3RTYW1lT3JkZXJlZE1lbWJlcnMiLCJzYW1lRGVlcE9yZGVyZWRNZW1iZXJzIiwibm90U2FtZURlZXBPcmRlcmVkTWVtYmVycyIsImluY2x1ZGVNZW1iZXJzIiwibm90SW5jbHVkZU1lbWJlcnMiLCJpbmNsdWRlRGVlcE1lbWJlcnMiLCJub3RJbmNsdWRlRGVlcE1lbWJlcnMiLCJpbmNsdWRlT3JkZXJlZE1lbWJlcnMiLCJub3RJbmNsdWRlT3JkZXJlZE1lbWJlcnMiLCJpbmNsdWRlRGVlcE9yZGVyZWRNZW1iZXJzIiwibm90SW5jbHVkZURlZXBPcmRlcmVkTWVtYmVycyIsImluTGlzdCIsImNoYW5nZXMiLCJjaGFuZ2UiLCJjaGFuZ2VzQnkiLCJ0bXBNc2ciLCJieSIsImRvZXNOb3RDaGFuZ2UiLCJjaGFuZ2VzQnV0Tm90QnkiLCJidXQiLCJpbmNyZWFzZXMiLCJpbmNyZWFzZSIsImluY3JlYXNlc0J5IiwiZG9lc05vdEluY3JlYXNlIiwiaW5jcmVhc2VzQnV0Tm90QnkiLCJkZWNyZWFzZXMiLCJkZWNyZWFzZSIsImRlY3JlYXNlc0J5IiwiZG9lc05vdERlY3JlYXNlIiwiZG9lc05vdERlY3JlYXNlQnkiLCJkZWNyZWFzZXNCdXROb3RCeSIsImlmRXJyb3IiLCJleHRlbnNpYmxlIiwiaXNOb3RFeHRlbnNpYmxlIiwic2VhbGVkIiwiaXNOb3RTZWFsZWQiLCJmcm96ZW4iLCJpc05vdEZyb3plbiIsImlzRW1wdHkiLCJpc05vdEVtcHR5IiwiYWxpYXMiLCJhcyIsInVzZWQiLCJ1c2UiLCJjb3JlIiwiY2hhaURvbSIsInJlcXVpcmUiLCJ1dGlscyIsImVsVG9TdHJpbmciLCJkZXNjIiwiaXNOb2RlTGlzdCIsImlzSFRNTEVsZW1lbnQiLCJhdHRyaWJ1dGVzIiwiYXR0ckFzc2VydCIsIm9iakRlc2MiLCJ0ZXh0TXNnIiwiYWN0dWFsTGVuZ3RoIiwibWF0Y2hlcyIsInN1Yml0ZW0iLCJjaGFpU3R5bGUiLCJpc05vbkNvbG9ycyIsInByb3BlcnR5VmFsdWUiLCJjb21wYXJlQ1NTVmFsdWUiLCJlbGVtZW50VGFnIiwidGhyb3dNZXNzYWdlIiwidGhyb3dNZXNzYWdlTmVnYXRpdmUiLCJwcm9wZXJ0eUhpZmVuQ2FzZSIsImZha2UiLCJmb250U2l6ZSIsImlmcmFtZSIsImZha2VTdHlsZSIsImhhc0F1dG9WYWx1ZSIsInJlZyIsImVzY2FwZVJlZ0V4cCIsImNvbXBhcmlzb25SZXN1bHQiLCJnZXRQcm90b3R5cGVPZkV4aXN0cyIsImlzRG9tIiwiaHRtbEVsZW1lbnRFeGlzdHMiLCJpc0FycmF5RXhpc3RzIiwiY2xlYXIiLCJjbGVhck1hcCIsImRlbGV0ZSIsImRlbGV0ZU1hcCIsIkRFRkFVTFRfVE9MRVJBTkNFIiwiYm90aE51bWJlcnMiLCJhbG1vc3RFcXVhbCIsInRvbCIsInRvbGVyYW5jZSIsImNoYWlBbG1vc3QiLCJjdXN0b21Ub2xlcmFuY2UiLCJzdGFuZGFyZFRvbGVyYW5jZSIsIm92ZXJyaWRlQXNzZXJ0RXF1YWwiLCJvdmVycmlkZUFzc2VydEVxbCIsInRvbGVyYW5jZU92ZXJyaWRlIiwiZ2xvYmFscyIsInN0cmluZ3MiLCJtZXNzYWdlcyIsInByZWRpY2F0ZXMiLCJmdW5jdGlvbnMiLCJtYXliZSIsImNvbGxlY3Rpb25zIiwibmVnaW5mIiwicG9zaW5mIiwiaGF2ZVN5bWJvbHMiLCJ2IiwicyIsImFsIiwiZiIsImFzc2lnbmVkIiwiemVybyIsImluZmluaXR5IiwiaW50ZWdlciIsImV2ZW4iLCJvZGQiLCJncmVhdGVyIiwiYmV0d2VlbiIsImdyZWF0ZXJPckVxdWFsIiwibGVzc09yRXF1YWwiLCJpblJhbmdlIiwicG9zaXRpdmUiLCJuZWdhdGl2ZSIsImVtcHR5U3RyaW5nIiwibm9uRW1wdHlTdHJpbmciLCJib29sZWFuIiwiZW1wdHlPYmplY3QiLCJub25FbXB0eU9iamVjdCIsImluc3RhbmNlU3RyaWN0IiwibGlrZSIsImVtcHR5QXJyYXkiLCJub25FbXB0eUFycmF5IiwiYXJyYXlMaWtlIiwiZGF0ZSIsImhhc0xlbmd0aCIsIk5FR0FUSVZFX0lORklOSVRZIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJjcmVhdGVNb2RpZmllZFByZWRpY2F0ZXMiLCJhc3NlcnRNb2RpZmllciIsImFzc2VydEltcGwiLCJub3RNb2RpZmllciIsIm5vdEltcGwiLCJtYXliZU1vZGlmaWVyIiwibWF5YmVJbXBsIiwiY3JlYXRlTW9kaWZpZWRNb2RpZmllciIsImNyZWF0ZU9mUHJlZGljYXRlcyIsImNyZWF0ZU9mTW9kaWZpZXJzIiwiY3JlYXRlTWF5YmVPZk1vZGlmaWVycyIsImV4cG9ydEZ1bmN0aW9ucyIsImxocyIsInJocyIsIngiLCJ5Iiwic3Vic3RyaW5nIiwicmVnZXgiLCJlcnJvciIsImFyY2hldHlwZSIsIml0ZXJhdGlvbiIsImdldFRpbWUiLCJtYXBTaW1wbGUiLCJtYXBDb21wbGV4IiwicHJlZGljYXRlIiwibSIsInRlc3RBcnJheSIsInRlc3RPYmplY3QiLCJkZWZhdWx0TWVzc2FnZSIsImFzc2VydFByZWRpY2F0ZSIsImFyZ0NvdW50IiwiRXJyb3JUeXBlIiwibW9kaWZpZWRQcmVkaWNhdGUiLCJvZk1vZGlmaWVyIiwiY29sbGVjdGlvbiIsImNvZXJjZUNvbGxlY3Rpb24iLCJpZ25vcmUiLCJtb2RpZmllciIsImNyZWF0ZU1vZGlmaWVkRnVuY3Rpb25zIiwibW9kaWZpZWQiLCJvZiIsImNoZWNrIiwicGx1Z2luIiwiaXNFbWl0dGVyIiwiRXZlbnRUYXJnZXQiLCJub2RlIiwiYnJvd3NlciIsImNoYWlBc3NlcnR0eXBlIiwiY2hhaUV2ZW50cyIsIm1vY2hhIiwic2V0dXAiLCJzbG93IiwiX19rYXJtYV9fIiwiYmFpbCIsInN1aXRlIiwiaGVscGVycyIsInRlYXJkb3duIiwicGFja2FnZVZlcnNpb24iLCJkZWxheSIsImNvbnRlbnRzIiwibGFzdENoaWxkIiwic3BhbiIsInBvcHVwQSIsInBvcHVwQiIsIlBvcHVwMiIsInN1aXRlU2V0dXAiLCJvcGVuUHJvbWlzZSIsIm9wZW5UaW1lIiwic3RhcnRUaW1lIiwiaXNQZW5kaW5nIiwiYmVmb3Jlb3BlbiIsImZpbmlzaG9wZW4iLCJiZWZvcmVjbG9zZSIsImZpbmlzaGNsb3NlIl0sIm1hcHBpbmdzIjoiNEZBQUEsU0FBU0EsT0FBVCxDQUFpQkMsR0FBakIsRUFBc0I7TUFDaEIsT0FBT0MsTUFBUCxLQUFrQixVQUFsQixJQUFnQyxPQUFPQSxNQUFNLENBQUNDLFFBQWQsS0FBMkIsUUFBL0QsRUFBeUU7SUFDdkVILE9BQU8sR0FBRyxVQUFVQyxHQUFWLEVBQWU7YUFDaEIsT0FBT0EsR0FBZDtLQURGO0dBREYsTUFJTztJQUNMRCxPQUFPLEdBQUcsVUFBVUMsR0FBVixFQUFlO2FBQ2hCQSxHQUFHLElBQUksT0FBT0MsTUFBUCxLQUFrQixVQUF6QixJQUF1Q0QsR0FBRyxDQUFDRyxXQUFKLEtBQW9CRixNQUEzRCxJQUFxRUQsR0FBRyxLQUFLQyxNQUFNLENBQUNHLFNBQXBGLEdBQWdHLFFBQWhHLEdBQTJHLE9BQU9KLEdBQXpIO0tBREY7OztTQUtLRCxPQUFPLENBQUNDLEdBQUQsQ0FBZDs7O0FBR0YsSUFBSUssYUFBYSxHQUFHLHFCQUFwQjtBQUNBLElBQUlDLFlBQVksR0FBRyxNQUFuQjtBQUNBLElBQUlDLFdBQVcsR0FBRyxJQUFsQjtBQUNBLElBQUlDLFdBQVcsR0FBRyxXQUFsQjtBQUNBLElBQUlDLFNBQVMsR0FBRyxXQUFoQjtBQUNBLElBQUlDLGlCQUFpQixHQUFHLENBQUMsUUFBRCxFQUFXLEtBQVgsRUFBa0IsSUFBbEIsRUFBd0IsR0FBeEIsQ0FBeEI7QUFDQSxJQUFJQyxtQkFBbUIsR0FBRyxDQUFDLHVCQUFELEVBQTBCLHVCQUExQixFQUFtRCxZQUFuRCxFQUFpRSxjQUFqRSxFQUFpRixrQkFBakYsRUFBcUcsSUFBckcsRUFBMkcsSUFBM0csRUFBaUgsV0FBakgsRUFBOEgsaUJBQTlILEVBQWlKLGNBQWpKLEVBQWlLLFFBQWpLLEVBQTJLLGFBQTNLLEVBQTBMLGFBQTFMLEVBQXlNLGVBQXpN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
